{*******************************************************}
{                                                       }
{       ObjectSight Visual Components                   }
{       TopGrid unbound grid component TtsGrid          }
{                                                       }
{       Copyright (c) 1997 - 2002, ObjectSight          }
{                                                       }
{*******************************************************}

unit TSGrid;

{$INCLUDE TSCmpVer}

interface
                         
uses
    Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,
    Dialogs, StdCtrls, Consts, Grids_ts, TSCommon, TSSetLib, TSGLib,
    TSMask, TSImageList, TSDateTimeDef, ExtCtrls, Registry, Menus
    {$IFDEF TSVER_V6}, Variants {$ENDIF};

type
    TtsGridStatus      = (grNormal, grColSelect, grRowSelect, grCellSelect);
    TtsMouseStatus     = (msNormal, msRowSelect, msColSelect, msCellSelect,
                          msAllRowSelect, msRowResize, msColResize, msHeadingResize,
                          msRowBarResize, msRowMove, msColMove, msButtonDown,
                          msHeadingDown);
    TtsEditMode        = (emNone, emEdit, emEditInsert, emBrowse);
    TtsGridMode        = (gmListBox, gmEdit, gmEditInsert, gmBrowse);
    TtsColSelectMode   = (csNone, csMulti);
    TtsRowSelectMode   = (rsNone, rsSingle, rsMulti);
    TtsCellSelectMode  = (cmNone, cmRange);
    TtsResizeRows      = (rrNone, rrSingle, rrAll);
    TtsResizeCols      = (rcNone, rcSingle, rcAll);
    TtsGridLines       = (glNone, glVertLines, glHorzLines, glBoth);
    TtsDrawOverlap     = (doDrawColOnTop, doDrawRowOnTop);
    TtsMoveDirection   = (mdLeft, mdRight, mdUp, mdDown);
    TtsViewPosition    = (vpNone, vpBottom, vpRight, vpBoth);
    TtsChangeTopLeft   = (ctlNone, ctlLeft, ctlTop, ctlBoth);
    TtsCellPosition    = (cpLeft, cpRight);
    TtsControlType     = (ctNone, ctText, ctCheck, ctPicture, ctDefault);
    TtsCheckBoxStyle   = (stFlat, stCheck, stCross);
    TtsScrollSpeed     = (spHigh, spLow, spVariable);
    TtsScrollMode      = (smWindow, smGridControl, smRowSelect);
    TtsInvert          = (ivNone, ivHead, ivData, ivBoth);
    TtsTextSelectMode  = (tsAll, tsCurrent, tsNone, tsDefault);
    TtsSelectType      = (stRowSelect, stColSelect, stCellSelect);
    TtsResetOrder      = (roCols, roRows, roBoth, roNone);
    TtsResetPosition   = (rpLeft, rpTop, rpTopLeft, rpNone);
    TtsProperty        = (prColor, prFont, prDisplayNumber, prWidth, prHeight,
                          prReadOnly, prAlign, prAlignment, prIs3D, prSelected,
                          prVisible, prChanged, prHeadingButton, prSortPicture,
                          prMaxLength, prWordWrap, prButtonType, prDropDownStyle,
                          prCellReadOnly, prAllowGrayed, prParentFont, prMask,
                          prCombo, prParentCombo, prPicture, prControlType,
                          prSpinOptions, prSpinIncrement, prHorzAlignment,
                          prVertAlignment, prDateTime, prTag, prData);
    TtsClickPosition   = (cpHeading, cpRowBar, cpUpperLeft, cpCell, cpNone);
    TtsGridAction      = (gacCheckTopLeft, gacTopLeftChanged);
    TtsPropKind        = (pkGrid, pkCols, pkRows, pkCells);
    TtsSpinButton      = (spbNone, spbIncrement, spbDecrement);
    TtsSpinOption      = (spoAutoRepeat, spoAutoIncrement, spoKeyEdit);

    TtsPaintCellState  = set of (psCurrent, psSelected, psFixed);
    TtsSelectChange    = array[TtsSelectType] of Boolean;
    TtsProperties      = set of TtsProperty;
    TtsGridStats       = set of TtsGridStatus;
    TtsGridActions     = set of TtsGridAction;
    TtsPropKinds       = set of TtsPropKind;
    TtsSpinButtons     = set of TtsSpinButton;
    TtsSpinOptions     = set of TtsSpinOption;

    TtsButtonType          = (btCombo, btNormal, btNone, btDefault, btVertSpin, btHorzSpin,
                              btDateTimeDropDown, btDateTimePopup);
    TtsButtonTypes         = set of TtsButtonType;
    TtsButtonMode          = (bmFlat, bmUp, bmDown);
    TtsInactiveButtonState = (ibsBackGround, ibsPicture, ibsNone);
    TtsGridCheckBoxStyle   = (cbFlat, cbWin95, cbWinNT);
    TtsDropDownStyle       = (ddDropDown, ddDropDownList);
    TtsComboCompareType    = (ctCaseSensitive, ctCaseInsensitive, ctOwn);
    TtsComboAutoSearchType = (asNone, asTop, asBottom, asCenter);
    TtsHeadingButton       = (hbCell, hbButton, hbNone);
    TtsColHeadingButton    = (cbCell, cbButton, cbGrid, cbNone);
    TtsSortPicture         = (spUp, spDown, spBullet, spNone);
    TtsWordWrap            = (wwOn, wwOff, wwDefault);
    TtsReadOnly            = (roOn, roOff, roDefault);
    TtsIndexType           = (itRow, itCol);
    TtsDrawOption          = (dopOn, dopOff, dopDefault);
    TtsFocusBorder         = (fbNone, fbDot, fbSingle, fbDouble, fbDash);
    TtsSelectionType       = (sltDefault, sltInvert, sltColor);
    TtsRowChangedIndicator = (riOn, riOff, riAutoReset);
    TtsColMatch            = (cmaFieldName, cmaNone);
    TtsConvertCase         = (afcOnEdit, afcOnExit, afcNone);
    TtsPrintMode           = (pmPortrait, pmLandscape);
    TtsPaperSize           = (psDefault, psLetter, psLetterSmall, psTabloid, psLedger, psLegal,
                psStatement, psExecutive, psA3, psA4, psA4Small, psA5, psB4, psB5, psFolio,
                psQuarto, psqr10X14, psqr11X17, psNote, psEnv9, psEnv10, psEnv11, psEnv12,
                psEnv14, psCSheet, psDSheet, psESheet, psCustom);


const
    tsAllGridStatus = [Low(TtsGridStatus)..High(TtsGridStatus)];
    tsAllProperties = [Low(TtsProperty)..High(TtsProperty)];
    tsAllPropKinds = [Low(TtsPropKind)..High(TtsPropKind)];
    tsMaxScrollRange = 32767;
    tsRangeSelectWidth = 3;
    {$IFDEF TSVER_V6} SRegCreateFailed = 'Registry Create Failed';  {$ENDIF}

type
    TtsGrid = class;
    TtsCol = class;
    TtsRow = class;
    TtsCurrentCell = class;
    TtsSelection = class;
    TtsBaseGrid = class;
    TtsCustomGrid = class;
    TtsCombo = class;
    TtsComboGrid = class;
    TtsGridEditBox = class;
    TtsGridStreamComponent = class;

    TtsBaseGridClass = class of TtsBaseGrid;

    TtsDrawInfo = record
        Font: TFont;
        Color: TColor;
        WordWrap: TtsWordWrap;
        TransparentColor: TColor;
        VertAlignment: TtsVertAlignment;
        case Boolean of
          True: (Alignment: TAlignment);
          False: (HorzAlignment: TtsHorzAlignment);
    end;

    TosXMLExport = class(TPersistent)
    private
      FEncoding : String;
      FVersion  : String;
      FDataPacketVersion : String;
      FStandAlone : Boolean;
    public
      constructor Create;
      procedure Assign(Source : TPersistent); override;
    published
      property Encoding : String read FEncoding write FEncoding;
      property Version : String read FVersion write FVersion;
      property DataPacketVersion : String read FDataPacketVersion write FDataPacketVersion;
      property StandAlone : Boolean read FStandAlone write FStandAlone default True;
    end;

    TtsRowLoadedEvent      = procedure (Sender: TObject; DataRow: Longint) of object;
    TtsCellLoadedEvent     = procedure (Sender: TObject; DataCol, DataRow: Longint;
                                        var Value: Variant) of object;
    TtsColMovedEvent       = procedure (Sender: TObject; ToDisplayCol, Count: Longint;
                                        ByUser: Boolean) of object;
    TtsRowMovedEvent       = procedure (Sender: TObject; ToDisplayRow, Count: Longint;
                                        ByUser: Boolean) of object;
    TtsCellEditEvent       = procedure (Sender: TObject; DataCol, DataRow: Longint; ByUser: Boolean) of object;
    TtsRowEditEvent        = procedure (Sender: TObject; DataRow: Longint; ByUser: Boolean) of object;
    TtsUndoCellEditEvent   = procedure (Sender: TObject; DataCol, DataRow: Longint; ByUser: Boolean; var Cancel: Boolean) of object;
    TtsUndoRowEditEvent    = procedure (Sender: TObject; DataRow: Longint; ByUser: Boolean; var Cancel: Boolean) of object;
    TtsCellEditingEvent    = procedure (Sender: TObject; DataCol, DataRow: Longint; var Cancel: Boolean) of object;
    TtsRowEditingEvent     = procedure (Sender: TObject; DataRow: Longint; var Cancel: Boolean) of object;
    TtsShowEditorEvent     = procedure (Sender: TObject; DataCol, DataRow: Longint; var Cancel: Boolean) of object;
    TtsTopLeftChangedEvent = procedure (Sender: TObject; OldCol, OldRow, NewCol, NewRow: Longint;
                                        ByUser: Boolean) of object;
    TtsCellChangedEvent    = procedure (Sender: TObject; OldCol, NewCol, OldRow, NewRow: Longint) of object;
    TtsRowChangedEvent     = procedure (Sender: TObject; OldRow, NewRow: Longint) of object;
    TtsColChangedEvent     = procedure (Sender: TObject; OldCol, NewCol: Longint) of object;
    TtsSelectChangedEvent  = procedure (Sender: TObject; SelectType: TtsSelectType; ByUser: Boolean) of object;
    TtsCountChangedEvent   = procedure (Sender: TObject; OldCount, NewCount: Longint) of object;
    TtsResizedEvent        = procedure (Sender: TObject; RowColnr: Longint) of object;
    TtsCanStartDragEvent   = procedure (Sender: TObject) of object;
    TtsPaintCellEvent      = procedure (Sender: TObject; DataCol, DataRow: Longint; ARect: TRect;
                                        State: TtsPaintCellState; var Cancel: Boolean) of object;
    TtsClickCellEvent      = procedure (Sender: TObject; DataColDown, DataRowDown, DataColUp, DataRowUp: Longint;
                                        DownPos, UpPos: TtsClickPosition) of object;
    TtsDblClickCellEvent   = procedure (Sender: TObject; DataCol, DataRow: Longint; Pos: TtsClickPosition) of object;
    TtsButtonEvent         = procedure (Sender: TObject; DataCol, DataRow: Longint) of object;
    TtsSpinButtonEvent     = procedure (Sender: TObject; DataCol, DataRow: Longint; SpinButton: TtsSpinButton) of object;
    TtsSpinRepeatEvent     = procedure (Sender: TObject; DataCol, DataRow: Longint; Count: Integer; SpinButton: TtsSpinButton) of object;
    TtsSpinIncrementEvent  = procedure (Sender: TObject; DataCol, DataRow: Longint; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean) of object;
    TtsHeadingClickEvent   = procedure (Sender: TObject; DataCol: Longint) of object;

    TtsMouseStatusChangedEvent = procedure(Sender: TObject; OldStatus, NewStatus: TtsMouseStatus) of object;
    TtsGridStatusChangedEvent  = procedure(Sender: TObject; OldStatus, NewStatus: TtsGridStatus) of object;
    TtsDeleteColEvent          = procedure(Sender: TObject; DataCol: Longint; ByUser: Boolean) of object;
    TtsInsertColEvent          = procedure(Sender: TObject; DataCol: Longint; ByUser: Boolean) of object;
    TtsDeleteRowEvent          = procedure(Sender: TObject; DataRow: Longint; ByUser: Boolean) of object;
    TtsInsertRowEvent          = procedure(Sender: TObject; DataRow: Longint; ByUser: Boolean) of object;
    TtsComboGetValueEvent      = procedure (Sender: TObject; Combo: TtsComboGrid; GridDataCol, GridDataRow,
                                            ComboDataRow: Longint; var Value: Variant) of object;
    TtsComboCellLoadedEvent    = procedure (Sender: TObject; Combo: TtsComboGrid; DataCol, DataRow: Longint;
                                            var Value: Variant) of object;
    TtsComboCellEvent          = procedure (Sender: TObject; Combo: TtsComboGrid; DataCol, DataRow: Longint) of object;
    TtsComboCompareValueEvent  = procedure (Sender: TObject; ComboString, CurrentCellString: string; var CompareRes: Integer) of object;
    TtsComboLCompareValueEvent = procedure (Sender: TObject; ComboString, CurrentCellString: string; Len: Integer; var CompareRes: Integer) of object;
    TtsGetDrawInfoEvent        = procedure (Sender: TObject; DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo) of object;
    TtsInvalidCellValueEvent   = procedure (Sender: TObject; DataCol, DataRow: Longint; var Accept: Boolean) of object;
    TtsInvalidCellKeysEvent    = procedure (Sender: TObject; Keys: string; DataCol, DataRow: Longint; var Accept: Boolean) of object;
    TtsDateTimeCellEvent       = procedure (Sender: TObject; DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint) of object;
    TtsDateTimeGetValueEvent   = procedure (Sender: TObject; DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint; var Value: Variant) of object;

    TtsNotifyChangedEvent   = procedure(Sender : TObject; DataChanged: Boolean) of object;
    TtsChangedEvent         = procedure(Sender : TObject; Edit, ByUser, TextAdded : Boolean) of object;
    TtsUndoChangedEvent     = procedure(Sender : TObject; ByUser : Boolean; var Cancel: Boolean) of object;
    TtsEditEvent            = procedure(Sender : TObject; var Cancel : Boolean) of object;
    TtsChangeEvent          = procedure(Sender : TObject; Edit: Boolean; var Cancel : Boolean) of object;
    TtsWantKeyEvent         = procedure(Sender: TObject; Key: Word; var WantKey: Boolean) of object;
    TtsCompareFunction      = function (Value1, Value2: string; Len: Integer): Integer of object;
    TtsInvalidEditEvent     = procedure(Sender: TObject; Keys: string; var Accept: Boolean) of object;
    TtsEditTextResizedEvent = procedure(Sender : TObject; ByUser : Boolean) of object;

    TtsPrintGridEvent       = procedure(Sender : TObject; var Cancel : Boolean; var Title, EndOfReportText : String; var Orientation : TtsPrintMode) of object;
    TtsPrintRowEvent        = procedure(Sender : TObject; DataRow : Longint; var Cancel : Boolean) of object;
    TtsPrintCellEvent       = procedure(Sender : TObject; DataCol, DataRow : Longint; var Cancel : Boolean) of object;

    {TosCustomGridReport}
    TosReportPageMargins = class(TPersistent)
    private
      FRightMargin  : Integer;
      FLeftMargin   : Integer;
      FBottomMargin : Integer;
      FTopMargin    : Integer;
    published
      property RightMargin  : Integer read FRightMargin write FRightMargin;
      property LeftMargin   : Integer read FLeftMargin write FLeftMargin;
      property BottomMargin : Integer read FBottomMargin write FBottomMargin;
      property TopMargin    : Integer read FTopMargin write FTopMargin;
    end;
    TosPrintLineMode = (lmNone, lmBanded, lmLine);

    {Base class for grid reporting options}
    TosCustomGridReport = class(TComponent)
    private
      FDateTimeLabel    : String;
      FPageLabel        : String;
      FEndOfReportLabel : String;
      FRecordCountLabel : String;
      FTitleFont        : TFont;
      FShowDateTime     : Boolean;
      FShowPageCount    : Boolean;
      FShowEndOfReport  : Boolean;
      FShowRecordCount  : Boolean;
      FProvideGridMenu  : Boolean;
      FShowTitleSection : Boolean;
      FTitleImage : TPicture;
      FMenuOptionsText : String;
      FPreviewMenuText : String;
      FPrintMenuText   : String;
      FExportMenuText  : String;
      FPaperSize : TtsPaperSize;
      FColumnSpacing : Integer;
      FMargins : TosReportPageMargins;
      FPrintLineMode : TosPrintLineMode;
      FPrintBandColor : TColor;
      FMinFontSize : Integer;

    protected
      procedure SetMargins(Value : TosReportPageMargins);
      procedure SetTitleFont(Value : TFont);
      procedure SetTitleImage(Value : TPicture);
      procedure SetMenuOptionsText(Value : String);
      procedure SetProvideGridMenu(Value : Boolean);
    public
      constructor Create(Owner : TComponent); override;
      destructor Destroy; override;

      procedure Print(forGrid : TtsBaseGrid); dynamic; 
      procedure PrintPreview(forGrid : TtsBaseGrid); dynamic;

      property PrintLineMode : TosPrintLineMode read FPrintLineMode write FPrintLineMode default lmNone;
      property PrintBandColor : TColor read FPrintBandColor write FPrintBandColor default clNone;
      property Margins : TosReportPageMargins read FMargins write SetMargins;
      property PaperSize : TtsPaperSize read FPaperSize write FPaperSize default psLetter;
      property MenuOptionsText : String read FMenuOptionsText write SetMenuOptionsText;
      property DateTimeLabel: String read FDateTimeLabel write FDateTimeLabel;
      property PageLabel: String read FPageLabel write FPageLabel;
      property EndOfReportLabel: String read FEndOfReportLabel write FEndOfReportLabel;
      property RecordCountLabel: String read FRecordCountLabel write FRecordCountLabel;
      property TitleFont : TFont read FTitleFont write SetTitleFont;
      property ShowDateTime : Boolean read FShowDateTime write FShowDateTime default True;
      property ShowPageCount: Boolean read FShowPageCount write FShowPageCount default True;
      property ShowEndOfReport: Boolean read FShowEndOfReport write FShowEndOfReport default True;
      property ShowRecordCount: Boolean read FShowRecordCount write FShowRecordCount default True;
      property ProvideGridMenu : Boolean read FProvideGridMenu write SetProvideGridMenu default False;
      property TitleImage : TPicture read FTitleImage write SetTitleImage;
      property ColumnSpacing : Integer read FColumnSpacing write FColumnSpacing default 2;
      property ShowTitleSection : Boolean read FShowTitleSection write FShowTitleSection default True;
      property MinFontSize : Integer read FMinFontSize write FMinFontSize default 0;
    end;

    {TtsGridControl}
    {Base class for controls used in the TtsBaseGrid}

    TtsGridControl = class(TCustomControl)
    protected
        FGrid: TWinControl;
        FOldMemoryPen: HPen;
        FOldMemoryBrush: HBrush;
        FOldMemoryFont: HFont;
        FLastLButtonTime : Cardinal;
        FDblClickPos : TPoint;
        FDoubleClickOk : Boolean;
        FAlignment : TAlignment;
        FVertAlignment : TtsVertAlignment;
        FWordWrap: TtsWordWrap;
        FLeftMargin : Integer;
        FClickOnMouseUp : Boolean;
        FMouseDownOccured: Boolean;
        FKeyEdit: Boolean;
        FCanDblClick: Boolean;
        FWantTabs: Boolean;
        FAlwaysShowFocus: Boolean;
        FDcPrepared: Boolean;
        FMouseSelect: Boolean;

        FOnEndKeyDown : TKeyEvent;
        FOnEndKeyUp : TKeyEvent;
        FOnEndKeyPress : TKeyPressEvent;
        FOnEdit : TtsEditEvent;
        FOnCanChange : TtsChangeEvent;
        FOnNotifyChanged : TtsNotifyChangedEvent;
        FOnChanged : TtsChangedEvent;
        FOnUndoChanged : TtsUndoChangedEvent;
        FOnKillFocus: TNotifyEvent;
        FOnWantKey: TtsWantKeyEvent;
        FOnInvalidMaskEdit: TtsInvalidEditEvent;
        FOnEditTextResized: TtsEditTextResizedEvent;

        procedure WMKillFocus(var Message : TMessage); message WM_KILLFOCUS;
        procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
        procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
        procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
        procedure CMShowingChanged(var Message: TMessage); message CM_SHOWINGCHANGED;
        procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
        procedure WMMove(var Message: TWMMove); message WM_MOVE;
        procedure WMEraseBkGnd(var Message: TWMEraseBkGnd); message WM_ERASEBKGND;
        procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
        procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;

        procedure WndProc(var Message: TMessage); override;
        procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure PaintWindow(DC : HDC); override;
        procedure SetControlDc(Dc: Hdc);
        procedure ResetControlDc;
        procedure SetAlignment(Align : TAlignment); virtual;
        procedure SetVertAlignment(Value : TtsVertAlignment); virtual;
        procedure SetWordWrap(Value: TtsWordWrap); virtual;
        function  CheckCanChange(Edit: Boolean): Boolean; virtual;
        function  CheckCanEdit(CheckKeyEdit: Boolean): Boolean; virtual;
        function  WantKey(Key: Word): Boolean;
        function  IsEditKey(Key: Char): Boolean; virtual;
        procedure ChangeScale(M, D: Integer); override;

    public
        constructor Create(AOwner : TComponent); override;
        destructor Destroy; override;
        procedure SetFocus; override;

        property OnEnter;
        property OnExit;
        property OnKeyDown;
        property OnKeyUp;
        property OnKeyPress;
        property OnClick;
        property OnDblClick;
        property OnDragDrop;
        property OnDragOver;
        property OnEndDrag;
        property OnMouseDown;
        property OnMouseMove;
        property OnMouseUp;
        property OnStartDrag;
        property MouseCapture;

        property OnEndKeyDown : TKeyEvent read FOnEndKeyDown write FOnEndKeyDown;
        property OnEndKeyUp : TKeyEvent read FOnEndKeyUp write FOnEndKeyUp;
        property OnEndKeyPress : TKeyPressEvent read FOnEndKeyPress write FOnEndKeyPress;
        property OnEdit : TtsEditEvent read FOnEdit write FOnEdit;
        property OnEditTextResized: TtsEditTextResizedEvent read FOnEditTextResized write FOnEditTextResized;
        property OnCanChange : TtsChangeEvent read FOnCanChange write FOnCanChange;
        property OnNotifyChanged : TtsNotifyChangedEvent read FOnNotifyChanged write FOnNotifyChanged;
        property OnChanged : TtsChangedEvent read FOnChanged write FOnChanged;
        property OnUndoChanged : TtsUndoChangedEvent read FOnUndoChanged write FOnUndoChanged;
        property OnKillFocus : TNotifyEvent read FOnKillFocus write FOnKillFocus;
        property OnWantKey : TtsWantKeyEvent read FOnWantKey write FOnWantKey;
        property OnInvalidMaskEdit: TtsInvalidEditEvent read FOnInvalidMaskEdit write FOnInvalidMaskEdit;

        property AlwaysShowFocus: Boolean read FAlwaysShowFocus write FAlwaysShowFocus;
        property Ctl3D;
        property LeftMargin : Integer read FLeftMargin write FLeftMargin;
        property Alignment : TAlignment read FAlignment write SetAlignment;
        property WordWrap: TtsWordWrap read FWordWrap write SetWordWrap;
        property KeyEdit: Boolean read FKeyEdit write FKeyEdit;
        property MouseSelect: Boolean read FMouseSelect write FMouseSelect;
        property VertAlignment: TtsVertAlignment read FVertAlignment write SetVertAlignment;
        property WantTabs: Boolean read FWantTabs write FWantTabs;

        property Grid: TWinControl read FGrid write FGrid;
    end;

    {TtsEditMaskLink}

    TtsEditMaskLink = class(TtsMaskLink)
    protected
        FEditBox: TtsGridEditBox;
        procedure MaskChanged(Mask: TtsMaskItem); override;
        procedure MaskDefsDeleted; override;
    public
        constructor Create(EditBox: TtsGridEditBox);
    end;

    {TtsGridEditBox}
    {Edit box control used in TtsBaseGrid}

    TtsGridEditBox = class(TtsGridControl)
    protected
        FText : string;
        FOldText : string;
        FOldTextSaved : Boolean;
        FSelStart : Integer;
        FSelLength : Integer;
        FSelByteStart : Integer;
        FSelByteLength : Integer;
        FTextPos : Integer;
        FStartDisplayChar : Integer;
        FFirstDisplayRow : Integer;
        FTextLines : TtsIntegerList;
        FOldLineCount : Integer;
        FTextRows : Integer;
        FCaretPos : TPoint;
        FCaretRow : Integer;
        FCaretOffset : Integer;
        FCaretBeforePos : Boolean;
        FHasCaret : Boolean;
        FCaretVisible : Boolean;
        FCanSetCaret: Boolean;
        FSetCaretVisible: Boolean;
        FMouseButtonDown : Boolean;
        FMouseStartPos : Integer;
        FMouseDownPos : TPoint;
        FCheckMouseDownPos : Boolean;
        FKeyRepeated : Boolean;
        FRightMargin : Integer;
        FCaretBitmap : TBitmap;
        FMaxLength: Integer;
        FLeadByte: Char;
        FEditMask: TtsMaskItem;
        FMaskLink: TtsEditMaskLink;
        FMaskName: string;

        procedure WMKillFocus(var Message : TMessage); message WM_KILLFOCUS;
        procedure WMSetFocus(var Message : TMessage); message WM_SETFOCUS;
        procedure WMSize(var Message : TWMSize); message WM_SIZE;
        procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
        procedure WMSetCursor(var Msg: TWMSetCursor); message WM_SETCURSOR;
        procedure WMPaste(var Msg: TWMPaste); message WM_PASTE;
        procedure WMCopy(var Msg: TWMCopy); message WM_COPY;
        procedure WMCut(var Msg: TWMCut); message WM_CUT;
        procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;

        procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
        procedure MouseDownSetPosition(X, Y: Integer);

        procedure CreateCaretBitmap;
        procedure DestroyCaretBitmap;
        function  GetDrawRect: TRect;
        procedure Paint; override;
        procedure DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                              Left, Top : Integer);
        procedure DisplayEditText;
        function  EditTextResized(ByUser: Boolean): Boolean;
        procedure SetTextValue(Value : string; Edit, ByUser: Boolean);
        procedure SetText(Value : string);
        procedure SetEditText(Value: string; ByUser: Boolean);
        procedure SetAlignment(Align : TAlignment); override;
        procedure SetVertAlignment(Value : TtsVertAlignment); override;
        procedure SetWordWrap(Value: TtsWordWrap); override;
        procedure SetSelByteStart(Value : Integer);
        procedure SetSelByteLength(Value : Integer);
        procedure SetSelStart(Value: Integer);
        procedure SetSelLength(Value: Integer);
        procedure ReplaceSelText(Value: string);
        procedure SetSelText(Value: string);
        procedure SetTextPosition(TextPos : Integer; CaretBeforePos : Boolean);
        procedure SetCaretRowAndOffset(TextPos : Integer; CaretBeforePos : Boolean);
        procedure SetCaretVisible(Value : Boolean);
        function  GetTextCaretPosLeft : TPoint;
        function  GetTextCaretPosRight : TPoint;
        function  GetTextCaretPos : TPoint;
        function  GetSelText: string;
        function  GetSelStart: Integer;
        function  GetSelLength: Integer;
        function  TextLineLength(Row : Integer) : Integer;
        function  GetPointCaretPos(WinPos : TPoint; var BeforeTextPos : Boolean) : Integer;
        function  TextStartOffset(PText : PChar; Chars : Integer) : Integer;
        function  LineCaretPosLeft(PText : PChar; Chars : Integer; XPos : Integer; var CaretPosX : Integer) : Integer;
        function  LineCaretPosRight(PText : PChar; Chars : Integer; XPos : Integer; var CaretPosX : Integer) : Integer;
        function  LineCaretPos(PText : PChar; Chars : Integer; XPos : Integer;
                               var CaretPosX : Integer) : Integer;
        procedure SetCaretPos;
        procedure HideCaret;
        procedure ShowCaret;
        function  GetTextHeight : Integer;
        function  IsMultiLine: Boolean;
        function  MoveCaretUpIntoView(Redraw : Boolean) : Boolean;
        function  MoveCaretDownIntoView(Redraw : Boolean) : Boolean;
        function  MoveCaretLeftIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
        function  MoveCaretRightIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
        function  MoveCaretIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
        procedure MoveSelectionRight(OldTextPos : Integer);
        procedure MoveSelectionLeft(OldTextPos : Integer);
        function  MoveRight(ShiftPressed : Boolean; MoveWord : Boolean; FKeyRepeated : Boolean) : Boolean;
        function  MoveRightSingleLine(Redraw : Boolean; MoveWord : Boolean; ScrollPerc : Double) : Boolean;
        function  MoveRightMultiLine(Redraw : Boolean; MoveWord : Boolean) : Boolean;
        function  MoveLeft(ShiftPressed : Boolean; MoveWord : Boolean; FKeyRepeated : Boolean) : Boolean;
        function  MoveLeftSingleLine(Redraw : Boolean; MoveWord : Boolean; ScrollPerc : Double) : Boolean;
        function  MoveLeftMultiLine(Redraw : Boolean; MoveWord : Boolean) : Boolean;
        function  MoveDown(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
        function  MoveUp(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
        function  MovePageDown(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
        function  MovePageUp(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
        function  CtrlMoveHome(ShiftPressed : Boolean; KeyPress : Boolean) : Boolean;
        function  CtrlMoveEnd(ShiftPressed : Boolean) : Boolean;
        function  MoveHome(ShiftPressed : Boolean) : Boolean;
        function  MoveEnd(ShiftPressed : Boolean) : Boolean;
        procedure MoveToStartOfText(ShiftPressed: Boolean);
        procedure MoveToEndOfText(ShiftPressed: Boolean);
        procedure SaveOldText;
        function  UndoEdit(var Key: Word): Boolean;
        function  RestoreOldText : Boolean;
        function  NewLengthOk(InsertText: string): Boolean;
        function  CanInsertText(var InsertChars: string): Boolean;
        procedure AddCharToText(Keys : string; var Changed : Boolean);
        procedure DeleteSelText(var Changed: Boolean);
        procedure DelSelectedText(var Changed : Boolean; CheckCancelEdit : Boolean);
        procedure DelNextCharFromText(var Changed : Boolean; CheckCancelEdit : Boolean);
        procedure DelPrevCharFromText(var Changed : Boolean; CheckCancelEdit : Boolean);
        function  AllSelected : Boolean;
        function  LineCount: Integer;
        procedure TextPosToSelStart;
        function  ClipboardPaste(ByUser: Boolean): Boolean;
        procedure ClipboardCut(ByUser: Boolean);
        procedure ClipboardCopy;
        procedure SetMaxLength(Value: Integer);
        function  GetEditMask: TtsMaskItem;
        procedure ResetEditMask;
        procedure SetMaskDefs(Value: TtsMaskDefsComponent);
        function  GetMaskDefs: TtsMaskDefsComponent;
        procedure SetMaskName(Value: string);
        function  GetMaskName: string;
        procedure KeyDown(var Key: Word; Shift: TShiftState); override;
        procedure KeyUp(var Key: Word; Shift: TShiftState); override;
        procedure KeyPress(var Key: Char); override;
        procedure Click; override;
        procedure DblClick; override;
        function  IsEditKey(Key: Char): Boolean; override;

        property EditMask: TtsMaskItem read GetEditMask;

    public
        constructor Create(AOwner : TComponent); override;
        destructor Destroy; override;

        procedure SelectAll;
        procedure CutToClipboard(ByUser: Boolean);
        procedure CopyToClipboard;
        procedure PasteFromClipboard(ByUser: Boolean);

        property MaskDefs: TtsMaskDefsComponent read GetMaskDefs write SetMaskDefs;
        property MaskName: string read GetMaskName write SetMaskName;
        property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
        property SelLength: Integer read GetSelLength write SetSelLength default 0;
        property SelStart: Integer read GetSelStart write SetSelStart default 0;
        property SelText: string read GetSelText write SetSelText;
        property Text : string read FText write SetText;
    end;

    {TtsGridCheckBox}
    {Check box control used in TtsBaseGrid}

    TtsGridCheckBox = class(TtsGridControl)
    protected
        FOldState : TCheckBoxState;
        FOldValue: Variant;
        FOldStateSaved : Boolean;
        FCustomCheckBoxBitmaps : TList;
        FCheckBoxOn : Integer;
        FCheckBoxOff : Integer;
        FCheckBoxGrayed : Integer;
        FCheckBoxState : TCheckBoxState;
        FCheckBoxValue : Variant;
        FCheckBoxMaskColor : TColor;
        FCheckBoxMaskToColor : TColor;
        FCheckBoxStyle : TtsGridCheckBoxStyle;
        FCheckBoxWin95Index : Integer;
        FCheckBoxWinNTIndex : Integer;
        FCheckBoxFlatIndex : Integer;
        FMouseMask : Boolean;
        FLButtonDown : Boolean;
        FSpaceKeyMask : Boolean;
        FMouseEditCanceled : Boolean;
        FKeyEditCanceled : Boolean;
        FAllowGrayed: Boolean;
        FCheckBoxValues: string;

        procedure WMSetCursor(var Msg: TWMSetCursor); message WM_SETCURSOR;
        procedure WMKillFocus(var Message : TMessage); message WM_KILLFOCUS;
        procedure WMSetFocus(var Message : TMessage); message WM_SETFOCUS;
        procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;

        procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
        procedure KeyDown(var Key: Word; Shift: TShiftState); override;
        procedure KeyUp(var Key: Word; Shift: TShiftState); override;
        procedure KeyPress(var Key: Char); override;
        procedure Click; override;
        procedure DblClick; override;
        procedure Paint; override;

        procedure CreateCheckBoxBitmaps;
        procedure DeleteCheckBoxBitmaps;
        procedure AddCheckBoxWinNTOn(Index: Integer);
        procedure AddCheckBoxWin95On(Index: Integer);
        procedure AddCheckBox3DOff(Index: Integer);
        procedure AddCheckBoxWinNTGrayed(Index: Integer);
        procedure AddCheckBoxWin95Grayed(Index: Integer);
        procedure AddCheckBoxFlatOn(Index: Integer);
        procedure AddCheckBoxFlatOff(Index: Integer);
        procedure AddCheckBoxFlatGrayed(Index: Integer);

        procedure DrawCheck(Canvas : TCanvas; ARect : TRect; DrawFocus: Boolean);
        function  CheckBoxMasked : Boolean;
        procedure ResetSelectState;
        procedure ToggleCheckBoxState;
        procedure SpaceKeyDown;
        function  UndoEdit(var Key: Word): Boolean;
        function  RestoreOldState : Boolean;
        procedure AddCheckBoxBitmapMasks;
        procedure AddBitmapMask(Bitmap: TBitmap; PictureCount, Index: Integer);
        procedure SetCheckBoxStyle(Value : TtsGridCheckBoxStyle);
        function  GetCheckBoxBitmap(State : TCheckBoxState; var CopyMode : TCopyMode; var ARect: TRect; Mask : Boolean) : TBitmap;
        procedure SetCheckBoxBitmap(State : TCheckBoxState; Bitmap : TBitmap);
        procedure SetCheckBoxValue(Value: Variant; Edit, ByUser: Boolean);
        procedure SetCheckBoxState(State : TCheckBoxState);
        procedure SetEditCheckBoxState(State: TCheckBoxState; ByUser: Boolean);
        procedure SetValue(Value : Variant);
        procedure SetEditValue(Value: Variant; ByUser: Boolean);
        function  IsEditKey(Key: Char): Boolean; override;

    public
        constructor Create(AOwner : TComponent); override;
        destructor Destroy; override;

        property CheckBoxState : TCheckBoxState read FCheckBoxState write SetCheckBoxState;
        property CheckBoxStyle : TtsGridCheckBoxStyle read FCheckBoxStyle write SetCheckBoxStyle;
        property CheckBoxMaskColor : TColor read FCheckBoxMaskColor write FCheckBoxMaskColor;
        property CheckBoxMaskToColor : TColor read FCheckBoxMaskToColor write FCheckBoxMaskToColor;
        property Value : Variant read FCheckBoxValue write SetValue;
        property CheckBoxValues: string read FCheckBoxValues write FCheckBoxValues;
        property AllowGrayed: Boolean read FAllowGrayed write FAllowGrayed;
    end;

    {TtsCustomGridControl}
    {Base class interface wrapper for controls used in TtsBaseGrid}

    TtsCustomGridControl = class(TObject)
    protected
        FControl : TtsGridControl;

        function  GetGrid: TWinControl; virtual; abstract;
        procedure SetGrid(Value: TWinControl); virtual; abstract;
        function  GetColor : TColor; virtual; abstract;
        procedure SetColor(Color : TColor); virtual; abstract;
        function  GetFont : TFont; virtual; abstract;
        procedure SetFont(Font : TFont); virtual; abstract;

        function  GetLeft: Integer;
        function  GetWidth: Integer;
        function  GetTop: Integer;
        function  GetHeight: Integer;
        procedure SetLeft(Value: Integer);
        procedure SetWidth(Value: Integer);
        procedure SetTop(Value: Integer);
        procedure SetHeight(Value: Integer);
        function  GetVisible: Boolean; virtual;
        procedure SetVisible(Value: Boolean); virtual;
        function  GetParent: TWinControl;
        procedure SetParent(Value: TWinControl);
        function  GetParentWindow: HWnd;
        procedure SetParentWindow(Value: HWnd);
        function  GetCtl3D : Boolean;
        procedure SetCtl3D(Ctl3D : Boolean);
        function  GetHandle: HWND;
        procedure SetMouseCapture(Value: Boolean); virtual;
        function  GetMouseCapture: Boolean; virtual;
        function  ComponentState : TComponentState;

        procedure SetEnter(EnterProc : TNotifyEvent); virtual;
        procedure SetExit(ExitProc : TNotifyEvent); virtual;
        procedure SetKillFocus(KillFocusProc : TNotifyEvent); virtual;
        procedure SetKeyDown(KeyDown : TKeyEvent); virtual;
        procedure SetKeyUp(KeyUp : TKeyEvent); virtual;
        procedure SetKeyPress(KeyPress : TKeyPressEvent); virtual;
        procedure SetClick(Click : TNotifyEvent); virtual;
        procedure SetDblClick(DblClick : TNotifyEvent); virtual;
        procedure SetDragDrop(DragDrop : TDragDropEvent); virtual;
        procedure SetDragOver(DragOver : TDragOverEvent); virtual;
        procedure SetEndDrag(EndDrag : TEndDragEvent); virtual;
        procedure SetMouseDown(MouseDown : TMouseEvent); virtual;
        procedure SetMouseMove(MouseMove : TMouseMoveEvent); virtual;
        procedure SetMouseUp(MouseUp : TMouseEvent); virtual;
        procedure SetStartDrag(StartDrag : TStartDragEvent); virtual;
        procedure SetEndKeyDown(EndKeyDown : TKeyEvent); virtual;
        procedure SetEndKeyUp(EndKeyUp : TKeyEvent); virtual;
        procedure SetEndKeyPress(EndKeyPress : TKeyPressEvent); virtual;
        procedure SetNotifyChanged(Changed : TtsNotifyChangedEvent); virtual;
        procedure SetChanged(Changed : TtsChangedEvent); virtual;
        procedure SetEdit(Edit : TtsEditEvent); virtual;
        procedure SetCanChange(CanChange : TtsChangeEvent); virtual;
        procedure SetUndoChanged(UndoChanged : TtsUndoChangedEvent); virtual;
        procedure SetWantKey(WantKey : TtsWantKeyEvent); virtual;
        procedure SetInvalidKeys(Value: TtsInvalidEditEvent); virtual;
        procedure SetEditTextResized(Value: TtsEditTextResizedEvent); virtual;

        procedure SetAlignment(Align : TAlignment);
        procedure SetVertAlignment(Value : TtsVertAlignment);
        procedure SetWordWrap(Value: TtsWordWrap);
        procedure SetLeftMargin(Margin : Integer);
        procedure SetSelStart(Value: Integer); virtual;
        procedure SetSelLength(Value: Integer); virtual;
        procedure SetSelText(Value: string); virtual;
        procedure SetValue(Value: Variant); virtual; abstract;
        procedure SetEditValue(Value: Variant; ByUser: Boolean); virtual; abstract;
        procedure SetKeyEdit(Value: Boolean); virtual;
        procedure SetMouseSelect(Value: Boolean); virtual;
        procedure SetCursor(Value: TCursor); virtual;
        procedure SetMaxLength(Value: Integer); virtual;
        procedure SetWantTabs(Value: Boolean); virtual;
        procedure SetMaskDefs(Value: TtsMaskDefsComponent); virtual;
        procedure SetMaskName(Value: string); virtual;
        procedure SetAlwaysShowFocus(Value: Boolean); virtual;

        function GetEnter : TNotifyEvent; virtual;
        function GetExit : TNotifyEvent; virtual;
        function GetKillFocus : TNotifyEvent; virtual;
        function GetKeyDown : TKeyEvent; virtual;
        function GetKeyUp : TKeyEvent; virtual;
        function GetKeyPress : TKeyPressEvent; virtual;
        function GetClick : TNotifyEvent; virtual;
        function GetDblClick : TNotifyEvent; virtual;
        function GetDragDrop : TDragDropEvent; virtual;
        function GetDragOver : TDragOverEvent; virtual;
        function GetEndDrag : TEndDragEvent; virtual;
        function GetMouseDown : TMouseEvent; virtual;
        function GetMouseMove : TMouseMoveEvent; virtual;
        function GetMouseUp : TMouseEvent; virtual;
        function GetStartDrag : TStartDragEvent; virtual;
        function GetEndKeyDown : TKeyEvent; virtual;
        function GetEndKeyUp : TKeyEvent; virtual;
        function GetEndKeyPress : TKeyPressEvent; virtual;
        function GetNotifyChanged : TtsNotifyChangedEvent; virtual;
        function GetChanged : TtsChangedEvent; virtual;
        function GetEdit : TtsEditEvent; virtual;
        function GetCanChange : TtsChangeEvent; virtual;
        function GetUndoChanged : TtsUndoChangedEvent; virtual;
        function GetWantKey : TtsWantKeyEvent; virtual;
        function GetInvalidKeys: TtsInvalidEditEvent; virtual;
        function GetEditTextResized: TtsEditTextResizedEvent; virtual;
        function GetAlignment : TAlignment;
        function GetVertAlignment : TtsVertAlignment;
        function GetWordWrap: TtsWordWrap;
        function GetLeftMargin : Integer;
        function GetValue: Variant; virtual; abstract;
        function GetSelStart: Integer; virtual;
        function GetSelLength: Integer; virtual;
        function GetSelText: string; virtual;
        function GetKeyEdit: Boolean; virtual;
        function GetMouseSelect: Boolean; virtual;
        function GetCursor: TCursor; virtual;
        function GetMaxLength: Integer; virtual;
        function GetWantTabs: Boolean; virtual;
        function GetMaskDefs: TtsMaskDefsComponent; virtual;
        function GetMaskName: string; virtual;
        function GetAlwaysShowFocus: Boolean; virtual;

    public
        constructor Create;
        destructor Destroy; override;

        procedure Hide; virtual;
        procedure Show; virtual;
        procedure Repaint; virtual;
        procedure Invalidate; virtual;
        procedure DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                              Left, Top : Integer; DrawFocus: Boolean); virtual; abstract;
        procedure SetFocus; virtual;
        function  CanFocus: Boolean; virtual;
        function  ScreenToClient(const Point: TPoint): TPoint; virtual;
        procedure SaveCurrentState; virtual;
        function  Focused : Boolean; virtual;
        function  IsEditControl : Boolean; virtual; abstract;
        function  IsEditKey(Key: Char): Boolean; virtual;
        function  MultiLine: Boolean; virtual;
        procedure CutToClipboard(ByUser: Boolean); virtual;
        procedure CopyToClipboard; virtual;
        procedure PasteFromClipboard(ByUser: Boolean); virtual;
        procedure SelectAll; virtual;
        procedure DblClick; virtual;

        property AlwaysShowFocus: Boolean read GetAlwaysShowFocus write SetAlwaysShowFocus;
        property MouseSelect: Boolean read GetMouseSelect write SetMouseSelect;
        property Handle: HWND read GetHandle;
        property Left: Integer read GetLeft write SetLeft;
        property Width: Integer read GetWidth write SetWidth;
        property Top: Integer read GetTop write SetTop;
        property Height: Integer read GetHeight write SetHeight;
        property Visible: Boolean read GetVisible write SetVisible;
        property Parent: TWinControl read GetParent write SetParent;
        property ParentWindow: HWnd read GetParentWindow write SetParentWindow;
        property Color : TColor read GetColor write SetColor;
        property Font : TFont read GetFont write SetFont;
        property Ctl3D : Boolean read GetCtl3D write SetCtl3D;
        property Alignment : TAlignment read GetAlignment write SetAlignment;
        property VertAlignment : TtsVertAlignment read GetVertAlignment write SetVertAlignment;
        property WordWrap: TtsWordWrap read GetWordWrap write SetWordWrap;
        property LeftMargin : Integer read GetLeftMargin write SetLeftMargin;
        property MouseCapture: Boolean read GetMouseCapture write SetMouseCapture;
        property Value: Variant read GetValue write SetValue;
        property SelLength : Integer read GetSelLength write SetSelLength;
        property SelStart : Integer read GetSelStart write SetSelStart;
        property SelText : string read GetSelText write SetSelText;
        property KeyEdit: Boolean read GetKeyEdit write SetKeyEdit;
        property Cursor: TCursor read GetCursor write SetCursor;
        property MaxLength: Integer read GetMaxLength write SetMaxLength;
        property WantTabs: Boolean read GetWantTabs write SetWantTabs;
        property MaskDefs: TtsMaskDefsComponent read GetMaskDefs write SetMaskDefs;
        property MaskName: string read GetMaskName write SetMaskName;

        property OnEnter: TNotifyEvent read GetEnter write SetEnter;
        property OnExit: TNotifyEvent read GetExit write SetExit;
        property OnKillFocus: TNotifyEvent read GetKillFocus write SetKillFocus;
        property OnKeyDown : TKeyEvent read GetKeyDown write SetKeyDown;
        property OnKeyUp : TKeyEvent read GetKeyUp write SetKeyUp;
        property OnKeyPress : TKeyPressEvent read GetKeyPress write SetKeyPress;
        property OnClick: TNotifyEvent read GetClick write SetClick;
        property OnDblClick: TNotifyEvent read GetDblClick write SetDblClick;
        property OnDragDrop: TDragDropEvent read GetDragDrop write SetDragDrop;
        property OnDragOver: TDragOverEvent read GetDragOver write SetDragOver;
        property OnEndDrag: TEndDragEvent read GetEndDrag write SetEndDrag;
        property OnMouseDown: TMouseEvent read GetMouseDown write SetMouseDown;
        property OnMouseMove: TMouseMoveEvent read GetMouseMove write SetMouseMove;
        property OnMouseUp: TMouseEvent read GetMouseUp write SetMouseUp;
        property OnStartDrag: TStartDragEvent read GetStartDrag write SetStartDrag;
        property OnEndKeyDown : TKeyEvent read GetEndKeyDown write SetEndKeyDown;
        property OnEndKeyUp : TKeyEvent read GetEndKeyUp write SetEndKeyUp;
        property OnEndKeyPress : TKeyPressEvent read GetEndKeyPress write SetEndKeyPress;
        property OnNotifyChanged : TtsNotifyChangedEvent read GetNotifyChanged write SetNotifyChanged;
        property OnChanged : TtsChangedEvent read GetChanged write SetChanged;
        property OnEdit : TtsEditEvent read GetEdit write SetEdit;
        property OnCanChange : TtsChangeEvent read GetCanChange write SetCanChange;
        property OnUndoChanged : TtsUndoChangedEvent read GetUndoChanged write SetUndoChanged;
        property OnWantKey : TtsWantKeyEvent read GetWantKey write SetWantKey;
        property OnInvalidMaskEdit: TtsInvalidEditEvent read GetInvalidKeys write SetInvalidKeys;
        property OnEditTextResized: TtsEditTextResizedEvent read GetEditTextResized write SetEditTextResized;
    end;

    {TtsDefaultGridControl}
    {Interface wrapper for default control used in TtsBaseGrid}

    TtsDefaultGridControl = class(TtsCustomGridControl)
    protected
        function  GetGrid: TWinControl; override;
        procedure SetGrid(Value: TWinControl); override;
        function  GetColor : TColor; override;
        procedure SetColor(Color : TColor); override;
        function  GetFont : TFont; override;
        procedure SetFont(Font : TFont);  override;
        procedure SetValue(Value: Variant); override;
        procedure SetEditValue(Value: Variant; ByUser: Boolean); override;
        function  GetValue: Variant; override;
    public
        constructor Create(AOwner: TComponent); virtual;
        procedure DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                              Left, Top : Integer; DrawFocus: Boolean); override;
        function  IsEditControl : Boolean; override;
    end;

    {TtsEditGridControl}
    {Interface wrapper for edit box control used in TtsBaseGrid}

    TtsEditGridControl = class(TtsCustomGridControl)
    protected
        function  GetValue: Variant; override;
        procedure SetValue(Value: Variant); override;
        procedure SetEditValue(Value: Variant; ByUser: Boolean); override;
        function  GetGrid: TWinControl; override;
        procedure SetGrid(Value: TWinControl); override;
        function  GetColor : TColor; override;
        procedure SetColor(Color : TColor); override;
        function  GetFont : TFont; override;
        procedure SetFont(Font : TFont); override;
        function  GetText : string;
        procedure SetText(Value: string);
        procedure SetEditText(Value: string; ByUser: Boolean);
        function  GetSelStart: Integer; override;
        procedure SetSelStart(Value: Integer); override;
        function  GetSelLength: Integer; override;
        procedure SetSelLength(Value: Integer); override;
        function  GetSelText: string; override;
        procedure SetSelText(Value: string); override;
        function  GetMaxLength: Integer; override;
        procedure SetMaxLength(Value: Integer); override;
        function  GetMaskDefs: TtsMaskDefsComponent; override;
        procedure SetMaskDefs(Value: TtsMaskDefsComponent); override;
        function  GetMaskName: string; override;
        procedure SetMaskName(Value: string); override;

    public
        constructor Create(AOwner: TComponent); virtual;

        procedure SaveCurrentState; override;
        function  IsEditControl : Boolean; override;
        function  MultiLine: Boolean; override;
        procedure CutToClipboard(ByUser: Boolean); override;
        procedure CopyToClipboard; override;
        procedure PasteFromClipboard(ByUser: Boolean); override;
        procedure SelectAll; override;
        procedure DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                              Left, Top : Integer; DrawFocus: Boolean); override;


        property Grid: TWinControl read GetGrid write SetGrid;
        property Text : string read GetText write SetText;
    end;

    {TtsCheckGridControl}
    {Interface wrapper for check box control used in TtsBaseGrid}

    TtsCheckGridControl = class(TtsCustomGridControl)
    protected
        function  GetValue: Variant; override;
        procedure SetValue(Value: Variant); override;
        procedure SetEditValue(Value: Variant; ByUser: Boolean); override;
        function  GetGrid: TWinControl; override;
        procedure SetGrid(Value: TWinControl); override;
        function  GetColor : TColor; override;
        procedure SetColor(Color : TColor); override;
        function  GetFont : TFont; override;
        procedure SetFont(Font : TFont); override;
        function  GetState : TCheckBoxState;
        procedure SetState(Value: TCheckBoxState);
        procedure SetEditState(Value: TCheckBoxState; ByUser: Boolean);
        function  GetCheckBoxStyle : TtsGridCheckBoxStyle;
        procedure SetCheckBoxStyle(Value : TtsGridCheckBoxStyle);
        function  GetCheckBoxMaskColor : TColor;
        procedure SetCheckBoxMaskColor(Value : TColor);
        function  GetCheckBoxMaskToColor : TColor;
        procedure SetCheckBoxMaskToColor(Value : TColor);
        function  GetAllowGrayed: Boolean;
        procedure SetAllowGrayed(Value: Boolean);
        function  GetCheckBoxValues: string;
        procedure SetCheckBoxValues(Value: string);
        procedure SetMouseCapture(Value: Boolean); override;

    public
        constructor Create(AOwner: TComponent); virtual;

        function  GetCheckBoxBitmap(State : TCheckBoxState; var CopyMode : TCopyMode; var ARect: TRect; Mask : Boolean) : TBitmap;
        procedure SetCheckBoxBitmap(State : TCheckBoxState; Bitmap : TBitmap);
        function  IsEditControl : Boolean; override;
        procedure DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                              Left, Top : Integer; DrawFocus: Boolean); override;

        property Grid: TWinControl read GetGrid write SetGrid;
        property State : TCheckBoxState read GetState write SetState;
        property CheckBoxStyle : TtsGridCheckBoxStyle read GetCheckBoxStyle write SetCheckBoxStyle;
        property CheckBoxMaskColor : TColor read GetCheckBoxMaskColor write SetCheckBoxMaskColor;
        property CheckBoxMaskToColor : TColor read GetCheckBoxMaskToColor write SetCheckBoxMaskToColor;
        property AllowGrayed: Boolean read GetAllowGrayed write SetAllowGrayed;
        property CheckBoxValues: string read GetCheckBoxValues write SetCheckBoxValues;
    end;

    {TtsDropDownForm}
    {Form used for displaying the TtsBaseGrid's combo box}

    {$IFDEF TSVER_V3}
    TtsDropDownForm = class(TCustomForm)
    {$ELSE TSVER_V3}
    TtsDropDownForm = class(TForm)
    {$ENDIF}
    protected
        FDropDownForm: Boolean;

        procedure WMEraseBkGnd(var Message: TWMEraseBkGnd); message WM_ERASEBKGND;
        procedure WMWindowPosChanged(var Message: TWMWindowPosChanged); message WM_WINDOWPOSCHANGED;
        procedure WMSize(var Message: TWMSize); message WM_SIZE;
        procedure WMMove(var Message: TWMMove); message WM_MOVE;

        function  SetChildStyleOff: Integer;
        function  SetChildStyleOn: Integer;
        procedure CreateParams(var Params: TCreateParams); override;
        procedure CreateWnd; override;
    public
        constructor Create(AOwner: TComponent); override;

        property DropDownForm: Boolean read FDropDownForm write FDropDownForm default True;
    end;

    {TtsCustomButton}
    {Base class for buttons used in TtsBaseGrid}

    TtsCustomButton = class(TObject)
    protected
        FGrid: TtsBaseGrid;
        FBitmap: TBitmap;
        FHeight: Integer;
        FWidth: Integer;
        FTransparentColor: TColor;

        function GetBitmap: TBitmap; virtual;
        function GetHeight: Integer; virtual;
        function GetWidth: Integer; virtual;
        function GetTransparentColor: TColor; virtual;

        procedure SetBitmap(Value: TBitmap); virtual;
        procedure SetHeight(Value: Integer); virtual;
        procedure SetWidth(Value: Integer); virtual;
        procedure SetTransparentColor(Value: TColor); virtual;

    public
        constructor Create(Grid: TtsBaseGrid; Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        
        function FullWidth: Integer; virtual;
        function FullHeight: Integer; virtual;
        function IsDefault: Boolean; virtual;

        property Bitmap: TBitmap read GetBitmap write SetBitmap;
        property Height: Integer read GetHeight write SetHeight;
        property Width: Integer read GetWidth write SetWidth;
        property TransparentColor: TColor read GetTransparentColor write SetTransparentColor;
    end;

    {TtsComboButton}
    {Combo box button used in TtsBaseGrid}

    TtsComboButton = class(TtsCustomButton)
    protected
        function GetBitmap: TBitmap; override;
    public
        constructor Create(Grid: TtsBaseGrid; bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        destructor Destroy; override;
        function IsDefault: Boolean; override;
    end; //TtsComboButton

    {TtsNormalButton}
    {Elipse button used in TtsBaseGrid}

    TtsNormalButton = class(TtsCustomButton)
    protected
        function  GetBitmap: TBitmap; override;
    public
        constructor Create(Grid: TtsBaseGrid; bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        destructor Destroy; override;
        function IsDefault: Boolean; override;
    end;

    TtsVertSpinButton = class(TtsCustomButton)
    public
        function FullHeight: Integer; override;
    end;

    TtsHorzSpinButton = class(TtsCustomButton)
    public
        function FullWidth: Integer; override;
    end;

    TtsDateTimeButton = class(TtsCustomButton)
    protected
        FDetailButton: Boolean;
        function GetBitmap: TBitmap; override;
    public
        constructor Create(Grid: TtsBaseGrid; bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        destructor Destroy; override;
        function IsDefault: Boolean; override;
    end;

    {TtsGridMaskLink}

    TtsGridMaskLink = class(TtsMaskLink)
    protected
        FGrid: TtsBaseGrid;
    public
        constructor Create(Grid: TtsBaseGrid);
    end;

    {TtsGridImageLink}

    TtsGridImageLink = class(TtsImageLink)
    protected
        FGrid: TtsBaseGrid;

        procedure ImageChanged(Image: TtsImageItem); override;
        procedure ImageListDeleted; override;
    public
        constructor Create(Grid: TtsBaseGrid);
    end;

    {TtsGridDateTimeLink}

    TtsGridDateTimeLink = class(TtsDateTimeLink)
    protected
        FGrid: TtsBaseGrid;
    public
        constructor Create(Grid: TtsBaseGrid);
        procedure DateTimeDefDeleted(DateTimeDef: TtsDateTimeDefComponent); override;
    end;

    {TtsCol}
    {Individual column for TtsBaseGrid}

    TtsCol = class(TPersistent)
    protected
        FGrid: TtsBaseGrid;
        FDisplayCol: Longint;
        FColor: TColor;
        FFont: TFont;
        FParentFont: Boolean;
        FAlignment : TAlignment;
        FHorzAlignment: TtsHorzAlignment;
        FVertAlignment: TtsVertAlignment;
        FWordWrap: TtsWordWrap;
        FAlign: Boolean;
        FHeading: string;
        FControlType: TtsControlType;
        FWidth: Integer;
        FOldWidth: Integer;
        FVisible: Boolean;
        FReadOnly: Boolean;
        FIs3D: Boolean;
        FButtonType: TtsButtonType;
        FNormalButton: TtsNormalButton;
        FDropDownStyle: TtsDropDownStyle;
        FAllowGrayed: Boolean;
        FHeadingButton: TtsColHeadingButton;
        FHeadingAlignment: TAlignment;
        FHeadingAlign: Boolean;
        FHeadingHorzAlignment: TtsHorzAlignment;
        FHeadingVertAlignment: TtsVertAlignment;
        FHeadingWordWrap: TtsWordWrap;
        FHeadingFont: TFont;
        FHeadingParentFont: Boolean;
        FHeadingColor: TColor;
        FSortPicture: TtsSortPicture;
        FMaxLength: Integer;
        FFieldName: string;
        FAccelKeyPos: Integer;
        FMaskName: string;
        FId: Longint;
        FAutoCreateFont: Boolean;
        FChangeFont: Integer;
        FCombo: TtsCombo;
        FParentCombo: Boolean;
        FStretchPicture: TtsDrawOption;
        FShrinkPicture: TtsDrawOption;
        FCenterPicture: TtsDrawOption;
        FKeepAspectRatio: TtsDrawOption;
        FSpinOptions: TtsSpinOptions;
        FSpinIncrement: Double;
        FDateTimeDef: TtsDateTimeDefComponent;
        FCheckBoxValues: string;
        FData : Pointer;
        FTag : Integer;
        FPrintTotals : Boolean;

        procedure FontChange(Sender: TObject);
        procedure HeadingFontChange(Sender: TObject);
        function  GetDataCol: Longint;
        function  GetSelected: Boolean;
        function  GetFixed: Boolean;

        procedure CopyFont(Value: TFont);
        procedure UpdateFont(Value: TFont);
        procedure CheckWidth(OldWidth: Integer);
        procedure CopyWidth(Value: Integer);
        procedure CopyHeadingFont(Value: TFont);
        procedure UpdateHeadingFont(Value: TFont);
        procedure RemoveFonts;
        procedure CheckFont;
        procedure CheckHeadingFont;
        procedure SetChangeFont(Value: Boolean);
        function  GetChangeFont: Boolean;

        procedure SetColor(Value: TColor);
        procedure SetFont(Value: TFont);
        procedure SetParentFont(Value: Boolean);
        procedure SetDisplayCol(Value: Longint);
        procedure SetHeading(Value: string);
        procedure SetControlType(Value: TtsControlType); virtual;
        procedure SetSelected(Value: Boolean);
        procedure SetReadOnly(Value: Boolean);
        procedure SetIs3D(Value: Boolean);
        procedure SetButtonType(Value: TtsButtonType);
        procedure SetDropDownStyle(Value: TtsDropDownStyle);
        function  GetDropDownStyle: TtsDropDownStyle;
        procedure SetHeadingButton(Value: TtsColHeadingButton);
        procedure SetHeadingAlignment(Value: TAlignment);
        procedure SetHeadingAlign(Value: Boolean);
        procedure SetHeadingHorzAlignment(Value: TtsHorzAlignment);
        procedure SetHeadingVertAlignment(Value: TtsVertAlignment);
        procedure SetHeadingWordWrap(Value: TtsWordWrap);
        procedure SetHeadingColor(Value: TColor);
        procedure SetHeadingFont(Value: TFont);
        procedure SetHeadingParentFont(Value: Boolean);
        procedure SetSortPicture(Value: TtsSortPicture);
        procedure SetMaxLength(Value: Integer); virtual;
        procedure SetFieldName(Value: string); virtual;
        procedure SetWordWrap(Value: TtsWordWrap);
        procedure SetButton(Button: TtsNormalButton);
        procedure SetStretchPicture(Value: TtsDrawOption);
        procedure SetShrinkPicture(Value: TtsDrawOption);
        procedure SetCenterPicture(Value: TtsDrawOption);
        procedure SetKeepAspectRatio(Value: TtsDrawOption);
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent);

        procedure Initialize;
        function  DefaultProps: Boolean; virtual;
        function  Empty: Boolean; virtual;
        function  StoreSpinIncrement: Boolean;
        procedure AssignProperties(Source: TtsCol); virtual;
        procedure Copy(Source: TtsCol); virtual;
        function  GetHeading: string; virtual;
        function  GetFont: TFont;
        function  GetHeadingFont: TFont;
        function  GetAlignment: TAlignment; virtual;
        function  GetMaxTextWidth : Integer; virtual;
        function  GetAlign: Boolean; virtual;
        function  GetHorzAlignment: TtsHorzAlignment; virtual;
        function  GetReadOnly: Boolean; virtual;
        function  GetAllowGrayed: Boolean; virtual;
        procedure SetWidth(Value: Integer); virtual;
        procedure SetAlignment(Value: TAlignment); virtual;
        procedure SetAlign(Value: Boolean); virtual;
        procedure SetHorzAlignment(Value: TtsHorzAlignment); virtual;
        procedure SetVertAlignment(Value: TtsVertAlignment); virtual;
        procedure UpdateVisibleCols;
        procedure SetVisible(Value: Boolean); virtual;
        procedure SetAllowGrayed(Value: Boolean); virtual;
        procedure SetMaskName(Value: string); virtual;
        procedure SetAutoCreateFont(Value: Boolean); virtual;
        function  StoreHeading: Boolean; virtual;
        function  StoreDisplayCol: Boolean; virtual;
        procedure SetCombo(Value: TtsCombo);
        function  GetCombo: TtsCombo;
        procedure SetParentCombo(Value: Boolean);
        function  UseCheckBoxValues: Boolean; virtual;
        procedure SetCheckBoxValues(Value: string);

        procedure ReadCombo(Stream: TStream);
        procedure WriteCombo(Stream: TStream);
        procedure ReadAlignment(Reader: TReader);
        procedure ReadAlign(Reader: TReader);
        procedure ReadHeadingAlignment(Reader: TReader);
        procedure ReadHeadingAlign(Reader: TReader);
        procedure DefineProperties(Filer: TFiler); override;

        property ChangeFont: Boolean read GetChangeFont write SetChangeFont;

    public
        constructor Create(Grid: TtsBaseGrid); virtual;
        destructor  Destroy; override;

        procedure Assign(Source: TPersistent); override;
        procedure AssignCombo;
        procedure AssignFont;
        procedure AssignHeadingFont;
        procedure CreateButton(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        procedure DestroyButton;
        procedure Reset(Properties: TtsProperties); virtual;
        procedure ResetCombo;
        procedure ResetFont;
        procedure ResetHeadingFont;

        function  HTMLCell(forValue : String) : String; 
        function  HTMLHeader : String;
        function  XMLHeading : String; virtual;

        //Design time property
        property AutoCreateFont: Boolean read FAutoCreateFont write SetAutoCreateFont;

        property Align: Boolean read GetAlign write SetAlign default False;
        property Alignment: TAlignment read GetAlignment write SetAlignment default taLeftJustify;
        property Grid: TtsBaseGrid read FGrid write FGrid;
        property Combo: TtsCombo read GetCombo write SetCombo;
        property DataCol: Longint read GetDataCol;
        property HeadingAlign: Boolean read FHeadingAlign write SetHeadingAlign default False;
        property HeadingAlignment: TAlignment read FHeadingAlignment write SetHeadingAlignment default taLeftJustify;
        property Id: Longint read FId;
        property Fixed: Boolean read GetFixed;
        property Selected: Boolean read GetSelected write SetSelected stored False default False ;
        property Data: Pointer read FData write FData;
        property Tag : Integer read FTag write FTag;
        property MaxTextWidth : Integer read GetMaxTextWidth;
    published

        property AllowGrayed: Boolean read GetAllowGrayed write SetAllowGrayed default False;
        property ButtonType: TtsButtonType read FButtonType write SetButtonType default btDefault;
        property CheckBoxValues: string read FCheckBoxValues write SetCheckBoxValues;
        property DateTimeDef: TtsDateTimeDefComponent read FDateTimeDef write SetDateTimeDef;
        property CenterPicture: TtsDrawOption read FCenterPicture write SetCenterPicture default dopDefault;
        property Color: TColor read FColor write SetColor default clNone;
        property ControlType: TtsControlType read FControlType write SetControlType default ctDefault;
        property DisplayCol: Longint read FDisplayCol write SetDisplayCol stored StoreDisplayCol;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property FieldName: string read FFieldName write SetFieldName;
        property Font: TFont read GetFont write SetFont;
        property Heading: string read GetHeading write SetHeading stored StoreHeading;
        property HeadingButton: TtsColHeadingButton read FHeadingButton write SetHeadingButton default cbGrid;
        property HeadingFont: TFont read GetHeadingFont write SetHeadingFont;
        property HeadingHorzAlignment: TtsHorzAlignment read FHeadingHorzAlignment write SetHeadingHorzAlignment default htaDefault;
        property HeadingParentFont: Boolean read FHeadingParentFont write SetHeadingParentFont default True;
        property HeadingVertAlignment: TtsVertAlignment read FHeadingVertAlignment write SetHeadingVertAlignment default vtaDefault;
        property HeadingWordWrap: TtsWordWrap read FHeadingWordWrap write SetHeadingWordWrap default wwDefault;
        property HeadingColor: TColor read FHeadingColor write SetHeadingColor default clNone;
        property Is3D: Boolean read FIs3D write SetIs3D default False;
        property KeepAspectRatio: TtsDrawOption read FKeepAspectRatio write SetKeepAspectRatio default dopDefault;
        property MaskName: string read FMaskName write SetMaskName;
        property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
        property ParentCombo: Boolean read FParentCombo write SetParentCombo default True;
        property ParentFont: Boolean read FParentFont write SetParentFont default True;
        property ReadOnly: Boolean read GetReadOnly write SetReadOnly default False;
        property ShrinkPicture: TtsDrawOption read FShrinkPicture write SetShrinkPicture default dopDefault;
        property SortPicture: TtsSortPicture read FSortPicture write SetSortPicture default spNone;
        property SpinIncrement: Double read FSpinIncrement write FSpinIncrement stored StoreSpinIncrement;
        property SpinOptions: TtsSpinOptions read FSpinOptions write FSpinOptions default [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
        property StretchPicture: TtsDrawOption read FStretchPicture write SetStretchPicture default dopDefault;
        property HorzAlignment: TtsHorzAlignment read GetHorzAlignment write SetHorzAlignment default htaDefault;
        property VertAlignment: TtsVertAlignment read FVertAlignment write SetVertAlignment default vtaDefault;
        property Visible: Boolean read FVisible write SetVisible default True;
        property Width: Integer read FWidth write SetWidth default 64;
        property WordWrap: TtsWordWrap read FWordWrap write SetWordWrap default wwDefault;
        property PrintTotals : Boolean read FPrintTotals write FPrintTotals default False;
    end;

    {TtsRow}
    {Individual row for TtsBaseGrid}

    TtsRow = class(TPersistent)
    protected
        FGrid: TtsBaseGrid;
        FDataRow: Longint;
        FColor: TColor;
        FFont: TFont;
        FParentFont: Boolean;
        FAlignment: TAlignment;
        FAlign: Boolean;
        FHorzAlignment: TtsHorzAlignment;
        FVertAlignment: TtsVertAlignment;
        FWordWrap: TtsWordWrap;
        FHeight: Integer;
        FOldHeight: Integer;
        FVisible: Boolean;
        FReadOnly: Boolean;
        FIs3D: Boolean;
        FMaskName: string;
        FAutoCreateFont: Boolean;
        FChangeFont: Integer;
        FButtonType: TtsButtonType;
        FDropDownStyle: TtsDropDownStyle;
        FCombo: TtsCombo;
        FParentCombo: Boolean;
        FStretchPicture: TtsDrawOption;
        FShrinkPicture: TtsDrawOption;
        FCenterPicture: TtsDrawOption;
        FKeepAspectRatio: TtsDrawOption;
        FControlType: TtsControlType;
        FSpinOptions: TtsSpinOptions;
        FSpinIncrement: Double;
        FDateTimeDef: TtsDateTimeDefComponent;

        procedure Initialize;
        function  DefaultProps: Boolean; virtual;
        function  Empty: Boolean; virtual;
        function  StoreSpinIncrement: Boolean;
        function  StoreDisplayRow: Boolean;
        procedure FontChange(Sender: TObject);
        function  GetDataRow: Longint;
        function  GetSelected: Boolean;
        function  GetFixed: Boolean;
        function  GetChanged: Boolean;
        function  GetFont: TFont;
        function  GetDisplayRow: Longint;
        function  GetId: Longint;
        procedure CopyFont(Value: TFont);
        procedure UpdateFont(Value: TFont);
        procedure CheckHeight(OldHeight: Integer);
        procedure CopyHeight(Value: Integer);
        procedure AssignProperties(Source: TtsRow); virtual;
        procedure Copy(Source: TtsRow); virtual;
        procedure RemoveFonts;
        procedure SetChangeFont(Value: Boolean);
        function  GetChangeFont: Boolean;
        procedure CheckFont;
        procedure AssignCombo;
        procedure ResetCombo;
        function  GetCombo: TtsCombo;
        procedure SetCombo(Value: TtsCombo);
        procedure SetParentCombo(Value: Boolean);
        procedure SetButtonType(Value: TtsButtonType);
        function  GetDropDownStyle: TtsDropDownStyle;
        procedure SetDropDownStyle(Value: TtsDropDownStyle);

        procedure SetColor(Value: TColor);
        procedure SetFont(Value: TFont);
        procedure SetParentFont(Value: Boolean);
        procedure SetDisplayRow(Value: Longint);
        procedure SetHeight(Value: Integer);
        procedure UpdateVisibleRows;
        procedure SetVisible(Value: Boolean);
        procedure SetAlignment(Value: TAlignment);
        procedure SetAlign(Value: Boolean);
        procedure SetHorzAlignment(Value: TtsHorzAlignment);
        procedure SetVertAlignment(Value: TtsVertAlignment);
        procedure SetSelected(Value: Boolean);
        procedure SetReadOnly(Value: Boolean);
        procedure SetIs3D(Value: Boolean);
        procedure SetChanged(Value: Boolean);
        procedure SetWordWrap(Value: TtsWordWrap);
        procedure SetMaskName(Value: string);
        procedure SetStretchPicture(Value: TtsDrawOption);
        procedure SetShrinkPicture(Value: TtsDrawOption);
        procedure SetCenterPicture(Value: TtsDrawOption);
        procedure SetKeepAspectRatio(Value: TtsDrawOption);
        procedure SetControlType(Value: TtsControlType);
        procedure SetAutoCreateFont(Value: Boolean); virtual;
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent);

        procedure ReadCombo(Stream: TStream);
        procedure WriteCombo(Stream: TStream);
        procedure ReadAlignment(Reader: TReader);
        procedure ReadAlign(Reader: TReader);
        procedure DefineProperties(Filer: TFiler); override;

        property Grid: TtsBaseGrid read FGrid write FGrid;
        property ChangeFont: Boolean read GetChangeFont write SetChangeFont;

    public
        constructor Create(Grid: TtsBaseGrid); virtual;
        destructor  Destroy; override;

        procedure Assign(Source: TPersistent); override;
        procedure AssignFont;
        procedure Reset(Properties: TtsProperties); virtual;
        procedure ResetFont;

        //Design time property
        property AutoCreateFont: Boolean read FAutoCreateFont write SetAutoCreateFont;

        property Align: Boolean read FAlign write SetAlign default False;
        property Alignment: TAlignment read FAlignment write SetAlignment default taLeftJustify;
        property Changed: Boolean read GetChanged write SetChanged default False;
        property Combo: TtsCombo read GetCombo write SetCombo;
        property DataRow: Longint read GetDataRow;
        property Id: Longint read GetId;
        property Selected: Boolean read GetSelected write SetSelected stored False default False;

    published
        property ButtonType: TtsButtonType read FButtonType write SetButtonType default btDefault;
        property DateTimeDef: TtsDateTimeDefComponent read FDateTimeDef write SetDateTimeDef;
        property CenterPicture: TtsDrawOption read FCenterPicture write SetCenterPicture default dopDefault;
        property Color: TColor read FColor write SetColor default clNone;
        property ControlType: TtsControlType read FControlType write SetControlType default ctDefault;
        property DisplayRow: Longint read GetDisplayRow write SetDisplayRow stored StoreDisplayRow;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property Font: TFont read GetFont write SetFont;
        property Height: Integer read FHeight write SetHeight default 14;
        property HorzAlignment: TtsHorzAlignment read FHorzAlignment write SetHorzAlignment default htaDefault;
        property Is3D: Boolean read FIs3D write SetIs3D default False;
        property KeepAspectRatio: TtsDrawOption read FKeepAspectRatio write SetKeepAspectRatio default dopDefault;
        property MaskName: string read FMaskName write SetMaskName;
        property ParentCombo: Boolean read FParentCombo write SetParentCombo default True;
        property ParentFont: Boolean read FParentFont write SetParentFont default True;
        property ReadOnly: Boolean read FReadOnly write SetReadOnly default False;
        property ShrinkPicture: TtsDrawOption read FShrinkPicture write SetShrinkPicture default dopDefault;
        property SpinIncrement: Double read FSpinIncrement write FSpinIncrement stored StoreSpinIncrement;
        property SpinOptions: TtsSpinOptions read FSpinOptions write FSpinOptions default [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
        property StretchPicture: TtsDrawOption read FStretchPicture write SetStretchPicture default dopDefault;
        property VertAlignment: TtsVertAlignment read FVertAlignment write SetVertAlignment default vtaDefault;
        property Visible: Boolean read FVisible write SetVisible default True;
        property WordWrap: TtsWordWrap read FWordWrap write SetWordWrap default wwDefault;
    end;

    TtsDesignRow = class(TPersistent)
    protected
        FGrid: TtsBaseGrid;
        FDataRow: Variant;

        function  GetAlign: Boolean; virtual;
        procedure SetAlign(Value: Boolean); virtual;
        function  GetAlignment: TAlignment; virtual;
        procedure SetAlignment(Value: TAlignment ); virtual;
        function  GetHorzAlignment: TtsHorzAlignment; virtual;
        procedure SetHorzAlignment(Value: TtsHorzAlignment ); virtual;
        function  GetVertAlignment: TtsVertAlignment; virtual;
        procedure SetVertAlignment(Value: TtsVertAlignment ); virtual;
        function  GetChanged: Boolean; virtual;
        procedure SetChanged(Value: Boolean); virtual;
        function  GetColor: TColor; virtual;
        procedure SetColor(Value: TColor); virtual;
        function  GetDisplayRow: Longint; virtual;
        procedure SetDisplayRow(Value: Longint); virtual;
        function  GetFont: TFont; virtual;
        procedure SetFont(Value: TFont); virtual;
        function  GetCombo: TtsCombo; virtual;
        procedure SetCombo(Value: TtsCombo); virtual;
        function  GetParentCombo: Boolean; virtual;
        procedure SetParentCombo(Value: Boolean); virtual;
        procedure AssignCombo; virtual;
        function  GetHeight: Integer; virtual;
        procedure SetHeight(Value: Integer); virtual;
        function  GetIs3D: Boolean; virtual;
        procedure SetIs3D(Value: Boolean); virtual;
        function  GetMaskName: string; virtual;
        procedure SetMaskName(Value: string); virtual;
        function  GetParentFont: Boolean; virtual;
        procedure SetParentFont(Value: Boolean); virtual;
        function  GetReadOnly: Boolean; virtual;
        procedure SetReadOnly(Value: Boolean); virtual;
        function  GetSelected: Boolean; virtual;
        procedure SetSelected(Value: Boolean); virtual;
        function  GetVisible: Boolean; virtual;
        procedure SetVisible(Value: Boolean); virtual;
        function  GetWordWrap: TtsWordWrap; virtual;
        procedure SetWordWrap(Value: TtsWordWrap); virtual;
        function  GetButtonType: TtsButtonType; virtual;
        procedure SetButtonType(Value: TtsButtonType); virtual;
        function  GetAutoCreateFont: Boolean; virtual;
        procedure SetAutoCreateFont(Value: Boolean); virtual;
        function  GetId: Longint; virtual;
        function  GetStretchPicture: TtsDrawOption; virtual;
        procedure SetStretchPicture(Value: TtsDrawOption); virtual;
        function  GetShrinkPicture: TtsDrawOption; virtual;
        procedure SetShrinkPicture(Value: TtsDrawOption); virtual;
        function  GetCenterPicture: TtsDrawOption; virtual;
        procedure SetCenterPicture(Value: TtsDrawOption); virtual;
        function  GetKeepAspectRatio: TtsDrawOption; virtual;
        procedure SetKeepAspectRatio(Value: TtsDrawOption); virtual;
        function  GetControlType: TtsControlType; virtual;
        procedure SetControlType(Value: TtsControlType); virtual;
        function  GetSpinOptions: TtsSpinOptions; virtual;
        procedure SetSpinOptions(Value: TtsSpinOptions); virtual;
        function  GetSpinIncrement: Double; virtual;
        procedure SetSpinIncrement(Value: Double); virtual;
        function  GetDateTimeDef: TtsDateTimeDefComponent; virtual;
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent); virtual;
        function  GetDropDownStyle: TtsDropDownStyle; virtual;
        procedure SetDropDownStyle(Value: TtsDropDownStyle); virtual;

        function  StoreSpinIncrement: Boolean;
        function  StoreDisplayRow: Boolean; virtual;
        function  StoreHeight: Boolean; virtual;
        procedure ReadCombo(Stream: TStream);
        procedure WriteCombo(Stream: TStream);
        procedure DefineProperties(Filer: TFiler); override;

    public
        constructor Create(Grid: TtsBaseGrid; DataRow: Variant);
        procedure Assign(Source: TPersistent); override;

        //Design time property
        property AutoCreateFont: Boolean read GetAutoCreateFont write SetAutoCreateFont;

        property Align: Boolean read GetAlign write SetAlign default False;
        property Alignment: TAlignment read GetAlignment write SetAlignment default taLeftJustify;
        property Changed: Boolean read GetChanged write SetChanged default False;
        property Combo: TtsCombo read GetCombo write SetCombo;
        property DataRow: Variant read FDataRow write FDataRow;
        property Grid: TtsBaseGrid read FGrid write FGrid;
        property Id: Longint read GetId;
        property Selected: Boolean read GetSelected write SetSelected stored False default False;

    published
        property ButtonType:TtsButtonType read GetButtonType write SetButtonType default btDefault;
        property CenterPicture: TtsDrawOption read GetCenterPicture write SetCenterPicture default dopDefault;
        property Color: TColor read GetColor write SetColor default clNone;
        property ControlType: TtsControlType read GetControlType write SetControlType default ctDefault;
        property DateTimeDef: TtsDateTimeDefComponent read GetDateTimeDef write SetDateTimeDef;        
        property DisplayRow: Longint read GetDisplayRow write SetDisplayRow stored StoreDisplayRow;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property Font: TFont read GetFont write SetFont;
        property Height: Integer read GetHeight write SetHeight stored StoreHeight default 14;
        property HorzAlignment: TtsHorzAlignment read GetHorzAlignment write SetHorzAlignment default htaDefault;
        property Is3D: Boolean read GetIs3D write SetIs3D default False;
        property KeepAspectRatio: TtsDrawOption read GetKeepAspectRatio write SetKeepAspectRatio default dopDefault;
        property MaskName: string read GetMaskName write SetMaskName;
        property ParentCombo: Boolean read GetParentCombo write SetParentCombo default True;
        property ParentFont: Boolean read GetParentFont write SetParentFont default True;
        property ReadOnly: Boolean read GetReadOnly write SetReadOnly default False;
        property ShrinkPicture: TtsDrawOption read GetShrinkPicture write SetShrinkPicture default dopDefault;
        property SpinOptions: TtsSpinOptions read GetSpinOptions write SetSpinOptions default [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
        property SpinIncrement: Double read GetSpinIncrement write SetSpinIncrement stored StoreSpinIncrement;
        property StretchPicture: TtsDrawOption read GetStretchPicture write SetStretchPicture default dopDefault;
        property VertAlignment: TtsVertAlignment read GetVertAlignment write SetVertAlignment default vtaDefault;
        property Visible: Boolean read GetVisible write SetVisible default True;
        property WordWrap: TtsWordWrap read GetWordWrap write SetWordWrap default wwDefault;
    end;

    PtsColProperties = ^TtsColProperties;
    TtsColProperties = array[0..(MaxListSize div ((SizeOf(TtsCol) div SizeOf(Longint)) + 1))] of TtsCol;

    PtsRowProperties = ^TtsRowProperties;
    TtsRowProperties = array[0..(MaxListSize div ((SizeOf(TtsRow) div SizeOf(Longint)) + 1))] of TtsRow;

    TtsVisibleItems = class(TtsSortIntList)
    protected
        FItemCount: Longint;
        FItemsCreated: Boolean;

        procedure Assign(Source: TtsSortIntList); override;
        procedure CheckSize(NewSize: Longint; StartValue: Longint);
        procedure SetSize(NewSize: Longint; StartValue: Longint);
        procedure MoveItem(OldValue, NewValue: Longint);
        function  GetItem(Index: Longint): Longint; override;

    public
        constructor Create;
        destructor Destroy; override;

        procedure Add(Value: Longint); override;
        function  Locate(Value: Longint; var Found: Boolean): Longint; override;
        procedure Remove(Value: Longint); override;

        property Count: Longint read FItemCount;
    end;

    {TtsGridCols}
    {List of all columns in TtsBaseGrid, implemented as an array of TtsCol}

    TtsGridCols = class(TObject)
    protected
        FCols: PtsColProperties;
        FGrid: TtsBaseGrid;
        FSize: Longint;
        FMaxId: Longint;

        procedure CreateDefaultValues(OldSize, NewSize: Longint);
        procedure FreeColProperties(FromIndex, ToIndex: Longint);
        procedure CntMoveProperties(FromIndex, ToIndex, Count: Longint);
        procedure Resize(OldSize: Longint);
        function  CreateCol: TtsCol; virtual;
        function  FindCol(FieldName: string): TtsCol;
        function  GetCol(DataCol: Variant): TtsCol;

        property Grid: TtsBaseGrid read FGrid;
        property Size: Longint read FSize;

    public
        constructor Create(Size: Longint; Grid: TtsBaseGrid);
        destructor  Destroy; override;

        property Col[DataCol: Variant]: TtsCol read GetCol; default;
    end;

    {TtsGridRows}
    {List of all rows in TtsBaseGrid, implemented as an array of TtsRow}

    TtsGridRows = class(TObject)
    protected
        FRows: PtsRowProperties;
        FDisplayRowNumber: PtsLongintArray;
        FRowId: PtsLongintArray;
        FGrid: TtsBaseGrid;
        FSize: Longint;
        FMaxId: Longint;

        procedure CreateDisplayRowNumber;
        procedure CreateDefaultValues(OldSize, NewSize: Longint);
        procedure FreeRowProperties(FromIndex, ToIndex: Longint);
        procedure CntMoveProperties(FromIndex, ToIndex, Count: Longint);
        procedure Resize(OldSize: Longint);
        function  CreateRow: TtsRow; virtual;
        procedure CreateDataRow(DataRow: Longint);
        procedure RemoveDataRow(DataRow: Longint);
        procedure CheckRemoveDataRow(DataRow: Longint);
        function  GetRow(DataRow: Longint): TtsRow;
        function  GetDisplayRowNumber(DataRow: Longint): Longint;
        procedure SetDisplayRowNumber(DataRow: Longint; Value: Longint);
        function  GetRowId(DataRow: Longint): Longint;
        function  GetRowHeight(DataRow: Longint): Integer;
        procedure SetRowHeight(DataRow: Longint; Value: Integer);
        function  GetOldRowHeight(DataRow: Longint): Integer;
        procedure SetOldRowHeight(DataRow: Longint; Value: Integer);
        procedure CopyRowHeight(DataRow: Longint; Height: Integer);

        property Grid: TtsBaseGrid read FGrid;
        property Size: Longint read FSize;

    public
        constructor Create(Size: Longint; Grid: TtsBaseGrid);
        destructor  Destroy; override;

        property DisplayRowNumber[DataRow: Longint]: Longint read GetDisplayRowNumber write SetDisplayRowNumber;
        property Row[DataRow: Longint]: TtsRow read GetRow; default;
        property RowId[DataRow: Longint]: Longint read GetRowId;
        property RowHeight[DataRow: Longint]: Integer read GetRowHeight write SetRowHeight;
        property OldRowHeight[DataRow: Longint]: Integer read GetOldRowHeight write SetOldRowHeight;
    end;

    {TtsCoordList}
    {Class for storing a list of (X,Y) coordinates}

    TtsCoordList = class(TtsIntegerList)
    public
        procedure AddCoord(X, Y: Integer);
        procedure RemoveCoord(X, Y: Integer);
        procedure UpdateCoord(Index, X, Y: Integer);
        function  NextCoord(var Index, X, Y: Integer): Boolean;
    end;

    {TtsCustomElement}
    {Base element class for storage in a binary tree}

    TtsCustomElement = class(TtsSetElement)
    protected
        FGrid: TtsBaseGrid;

        constructor Create(Grid: TtsBaseGrid);
        function  GetPropValue(Prop: TtsProperty; PropId: Integer): Variant; virtual; abstract;
        procedure SetPropValue(const Value: Variant; Prop: TtsProperty; PropId: Integer); virtual; abstract;
        procedure AssignProperties(Source: TtsCustomElement); virtual;
    public
        procedure Assign(Source: TtsCustomElement); virtual;
        function  Empty: Boolean; virtual; abstract;

        property Grid: TtsBaseGrid read FGrid;
    end;

    {TtsCustomPropElement}
    {Base element class for storing element properties in a binary tree}

    TtsCustomPropElement = class(TtsCustomElement)
    protected
        FColor: TColor;
        FFont: TFont;
        FParentFont: Boolean;
        FAlignment: TAlignment;
        FAlign: Boolean;
        FHorzAlignment: TtsHorzAlignment;
        FVertAlignment: TtsVertAlignment;
        FIs3D: Boolean;
        FReadOnly: Boolean;
        FWordWrap: TtsWordWrap;
        FButtonType: TtsButtonType;
        FDropDownStyle: TtsDropDownStyle;
        FCellReadOnly: TtsReadOnly;
        FMaskName: string;
        FChangeFont: Integer;
        FAutoCreateFont: Boolean;
        FCombo: TtsCombo;
        FParentCombo: Boolean;
        FStretchPicture: TtsDrawOption;
        FShrinkPicture: TtsDrawOption;
        FCenterPicture: TtsDrawOption;
        FKeepAspectRatio: TtsDrawOption;
        FControlType: TtsControlType;
        FSpinOptions: TtsSpinOptions;
        FSpinIncrement: Double;
        FDateTimeDef: TtsDateTimeDefComponent;
        FTag: Integer;
        FData: Pointer;

        procedure FontChange(Sender: TObject); virtual;
        procedure CopyFont(Value: TFont);
        procedure UpdateFont(Value: TFont);
        procedure SetFont(Value: TFont); virtual;
        procedure SetParentFont(Value: Boolean); virtual;
        function  GetPropValue(Prop: TtsProperty; PropId: Integer): Variant; override;
        procedure SetPropValue(const Value: Variant; Prop: TtsProperty; PropId: Integer); override;
        function  GetChangeFont: Boolean;
        procedure SetChangeFont(Value: Boolean);
        procedure CheckFont; virtual;
        procedure AssignCombo; virtual;
        procedure ResetCombo;
        procedure SetCombo(Value: TtsCombo);
        procedure SetParentCombo(Value: Boolean);
        function  GetDropDownStyle: TtsDropDownStyle;
        procedure SetDropDownStyle(Value: TtsDropDownStyle);
        procedure SetAlignment(Value: TAlignment);
        procedure SetAlign(Value: Boolean);
        procedure SetHorzAlignment(Value: TtsHorzAlignment);
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent);
        procedure SetButtonType(Value: TtsButtonType);
        procedure AssignProperties(Source: TtsCustomElement); override;

        property ChangeFont: Boolean read GetChangeFont write SetChangeFont;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle;

    public
        constructor Create(Grid: TtsBaseGrid);
        destructor  Destroy; override;

        procedure Assign(Source: TtsCustomElement); override;
        function  Empty: Boolean; override;
    end;

    {TtsCellElement}
    {Element for storing cell properties in a binary tree.}

    TtsCellElement = class(TtsCustomPropElement)
    protected
        FDataCol: Longint;
        FDataRow: Longint;

        procedure FontChange(Sender: TObject); override;
        procedure SetParentFont(Value: Boolean); override;
        procedure RemoveFonts;
        procedure CheckFont; override;
        procedure SetKey(DataCol, DataRow: Longint);
        procedure AssignCombo; override;

    public
        constructor Create(Grid: TtsBaseGrid; DataCol, DataRow: Longint);
        destructor  Destroy; override;

        procedure Assign(Source: TtsCustomElement); override;
        function  Compare(NodeSet: TtsCustomSet; Value: TtsSetElement): TtsSetOrder; override;
        function  CompareKey(NodeSet: TtsCustomSet; const KeyValue: array of const): TtsSetOrder; override;

        property DataCol: Longint read FDataCol;
        property DataRow: Longint read FDataRow;
    end;

    {TtsCustomPropSet}
    {Base binary tree class for storage of element properties}

    TtsCustomPropSet = class(TtsObjectSet)
    protected
        FGrid: TtsBaseGrid;

        constructor CreateNew(AGrid: TtsBaseGrid);

        function  CreateElement(const KeyValue: array of const): TtsCustomElement; virtual; abstract;
        procedure AddElement(Element: TtsCustomElement); virtual;
        procedure DeleteElement(Element: TtsCustomElement); virtual; abstract;
        function  CheckDelete(Element: TtsCustomElement): Boolean; virtual; abstract;
        function  SetProperty(const KeyValue: array of const; var Element: TtsCustomElement;
                              const Value: Variant; Prop: TtsProperty; PropId: Integer; Redraw: Boolean): Boolean; virtual;
        procedure ResetElement(Element: TtsCustomElement; Properties: TtsProperties; DoRedraw: Boolean);
        procedure ResetProperties(Properties: TtsProperties; DoRedraw: Boolean);
        procedure SetAutoCreateFont(const KeyValue: array of const; var Element: TtsCustomElement; Value: Boolean); virtual;
        function  NewNode(NodeValue : Pointer) : TtsSetNode; override;

        property Grid: TtsBaseGrid read FGrid;
    end;

    {TtsCellPropSet}
    {Binary tree for storage of TtsBaseGrid cell properties}

    TtsCellPropSet = class(TtsCustomPropSet)
    protected
        function  CreateElement(const KeyValue: array of const): TtsCustomElement; override;
        procedure AddElement(Element: TtsCustomElement); override;
        procedure DeleteElement(Element: TtsCustomElement); override;
        function  CheckDelete(Element: TtsCustomElement): Boolean; override;
        procedure CheckRedraw(DataCol, DataRow: Longint; CheckInvalidate: Boolean);
        function  SetProperty(const KeyValue: array of const; var Element: TtsCustomElement;
                              const Value: Variant; Prop: TtsProperty; PropId: Integer; Redraw: Boolean): Boolean; override;
        procedure SetAutoCreateFont(const KeyValue: array of const; var Element: TtsCustomElement; Value: Boolean); override;
    end;

    {TtsCell}
    {Used by the TopGrid component editor to set cell properties}

    TtsCell = class(TPersistent)
    protected
        FGrid: TtsBaseGrid;
        FDataCol: Longint;
        FDataRow: Variant;
        FData : Pointer;
        FTag : Integer;

        function  GetGrid: TtsCustomGrid;
        procedure SetGrid(Value: TtsCustomGrid);
        function  StoreSpinIncrement: Boolean;

        function  GetColor: TColor; virtual;
        procedure SetColor(Value: TColor); virtual;
        function  GetControlType: TtsControlType; virtual;
        procedure SetControlType(Value: TtsControlType); virtual;
        function  GetSpinOptions: TtsSpinOptions; virtual;
        procedure SetSpinOptions(Value: TtsSpinOptions); virtual;
        function  GetSpinIncrement: Double; virtual;
        procedure SetSpinIncrement(Value: Double); virtual;
        function  GetFont: TFont; virtual;
        procedure SetFont(Value: TFont); virtual;
        function  GetParentFont: Boolean; virtual;
        procedure SetParentFont(Value: Boolean); virtual;
        function  GetAlignment: TAlignment; virtual;
        procedure SetAlignment(Value: TAlignment); virtual;
        function  GetAlign: Boolean; virtual;
        procedure SetAlign(Value: Boolean); virtual;
        function  GetHorzAlignment: TtsHorzAlignment; virtual;
        procedure SetHorzAlignment(Value: TtsHorzAlignment); virtual;
        function  GetVertAlignment: TtsVertAlignment; virtual;
        procedure SetVertAlignment(Value: TtsVertAlignment); virtual;
        function  GetIs3D: Boolean; virtual;
        procedure SetIs3D(Value: Boolean); virtual;
        function  GetWordWrap: TtsWordWrap; virtual;
        procedure SetWordWrap(Value: TtswordWrap); virtual;
        function  GetButtonType: TtsButtonType; virtual;
        procedure SetButtonType(Value: TtsButtonType); virtual;
        function  GetDropDownStyle: TtsDropDownStyle; virtual;
        procedure SetDropDownStyle(Value: TtsDropDownStyle); virtual;
        function  GetReadOnly: TtsReadOnly; virtual;
        procedure SetReadOnly(Value: TtsReadOnly); virtual;
        function  GetMaskName: string; virtual;
        procedure SetMaskName(Value: string); virtual;
        function  GetAutoCreateFont: Boolean; virtual;
        procedure SetAutoCreateFont(Value: Boolean); virtual;
        function  GetCombo: TtsCombo; virtual;
        procedure SetCombo(Value: TtsCombo); virtual;
        procedure AssignCombo; virtual;
        function  GetParentCombo: Boolean; virtual;
        procedure SetParentCombo(Value: Boolean); virtual;
        function  GetStretchPicture: TtsDrawOption; virtual;
        procedure SetStretchPicture(Value: TtsDrawOption); virtual;
        function  GetShrinkPicture: TtsDrawOption; virtual;
        procedure SetShrinkPicture(Value: TtsDrawOption); virtual;
        function  GetCenterPicture: TtsDrawOption; virtual;
        procedure SetCenterPicture(Value: TtsDrawOption); virtual;
        function  GetKeepAspectRatio: TtsDrawOption; virtual;
        procedure SetKeepAspectRatio(Value: TtsDrawOption); virtual;
        function  GetDateTimeDef: TtsDateTimeDefComponent; virtual;
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent); virtual;

        procedure ReadCombo(Stream: TStream);
        procedure WriteCombo(Stream: TStream);
        procedure DefineProperties(Filer: TFiler); override;

    public
        constructor Create(Grid: TtsBaseGrid; DataCol: Longint; DataRow: Variant);
        procedure Assign(Source: TPersistent); override;

        //Design time property
        property AutoCreateFont: Boolean read GetAutoCreateFont write SetAutoCreateFont;

        property Align: Boolean read GetAlign write SetAlign default False;
        property Alignment: TAlignment read GetAlignment write SetAlignment default taLeftJustify;
        property Combo: TtsCombo read GetCombo write SetCombo;
        property DataCol: Longint read FDataCol write FDataCol;
        property DataRow: Variant read FDataRow write FDataRow;
        property Grid: TtsCustomGrid read GetGrid write SetGrid;
        property Data: Pointer read FData write FData;
        property Tag : Integer read FTag write FTag;
    published
        property ButtonType: TtsButtonType read GetButtonType write SetButtonType default btDefault;
        property DateTimeDef: TtsDateTimeDefComponent read GetDateTimeDef write SetDateTimeDef;
        property CenterPicture: TtsDrawOption read GetCenterPicture write SetCenterPicture default dopDefault;
        property Color: TColor read GetColor write SetColor default clNone;
        property ControlType: TtsControlType read GetControlType write SetControlType default ctDefault;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property Font: TFont read GetFont write SetFont;
        property HorzAlignment: TtsHorzAlignment read GetHorzAlignment write SetHorzAlignment default htaDefault;
        property Is3D: Boolean read GetIs3D write SetIs3D default False;
        property KeepAspectRatio: TtsDrawOption read GetKeepAspectRatio write SetKeepAspectRatio default dopDefault;
        property MaskName: string read GetMaskName write SetMaskName;
        property ParentCombo: Boolean read GetParentCombo write SetParentCombo default True;
        property ParentFont: Boolean read GetParentFont write SetParentFont default True;
        property ReadOnly: TtsReadOnly read GetReadOnly write SetReadOnly default roDefault;
        property ShrinkPicture: TtsDrawOption read GetShrinkPicture write SetShrinkPicture default dopDefault;
        property SpinIncrement: Double read GetSpinIncrement write SetSpinIncrement stored StoreSpinIncrement;
        property SpinOptions: TtsSpinOptions read GetSpinOptions write SetSpinOptions default [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
        property StretchPicture: TtsDrawOption read GetStretchPicture write SetStretchPicture default dopDefault;
        property VertAlignment: TtsVertAlignment read GetVertAlignment write SetVertAlignment default vtaDefault;
        property WordWrap: TtsWordWrap read GetWordWrap write SetWordWrap default wwDefault;
    end;

    PtsCellIndexArray = ^TtsCellIndexArray;
    TtsCellIndexArray = array[0..(MaxListSize div ((SizeOf(TtsIntegerSet) div SizeOf(Longint)) + 1))] of TtsIntegerSet;

    {TtsSelection}
    {List of selected rows/columns, implemented as a TBits array}

    TtsSelection = class(TObject)
    protected
        FBits: TBits;
        FFirst: Longint;
        FLast: Longint;
        FCount: Longint;

        function  Assign(Source: TtsSelection): Boolean; virtual;
        procedure SetSize(Value: Longint);
        function  GetSize: Longint;
        procedure SetSelected(Index: Longint; Value: Boolean);
        function  GetSelected(Index: Longint): Boolean;
        procedure Reset;

        property Size: Longint read GetSize;

    public
        constructor Create;
        destructor  Destroy; override;

        function  Next(Index: Longint): Longint;
        function  Previous(Index: Longint): Longint;
        function  RangeCount(FromIndex, ToIndex: Longint): Longint;

        property Count: Longint read FCount;
        property First: Longint read FFirst;
        property Last: Longint read FLast;
        property Selected[Index: Longint]: Boolean read GetSelected; default;
    end;

    {TtsCurrentCell}
    {The current cell in TtsBaseGrid}

    TtsCurrentCell = class(TObject)
    protected
        FGrid: TtsBaseGrid;
        FValue: Variant;
        FIsObject: Boolean;
        FValueCol: Longint;
        FValueRow: Longint;
        FSelStart: Integer;
        FSelLength: Integer;
        FStretchPicture: Boolean;
        FShrinkPicture: Boolean;
        FTransparentColor: TColor;
        FCenterPicture: Boolean;
        FKeepAspectRatio: Boolean;

        procedure SetBuffer(Value: Variant; IsObject: Boolean);
        procedure ClearBuffer;
        procedure FetchCellValue; virtual;
        function  InternalCutToClipboard(ByUser: Boolean): Boolean;
        function  InternalPasteFromClipboard(ByUser: Boolean): Boolean;
        function  NewlengthOk(InsertText: string): Boolean;

        function  GetTag : Integer;
        function  GetData : Pointer;
        procedure SetTag(Value : Integer);
        procedure SetData(Value : Pointer);
        function  GetDataCol: Longint;
        function  GetDataRow: Longint;
        function  GetControlType: TtsControlType; virtual;
        function  GetValue: Variant; virtual;
        function  GetSelStart: Integer;
        function  GetSelLength: Integer;
        function  GetSelText: string;
        function  GetTextWidth: Integer;
        function  GetTextHeight: Integer; virtual;
        function  GetTextLines: Integer; virtual;
        procedure SetValue(const Value: Variant);
        function  SetEditValue(const Value: Variant; ByUser, Redraw: Boolean): Boolean; virtual;
        procedure SetSelStart(Value: Integer);
        procedure SetSelLength(Value: Integer);
        procedure SetSelText(Value: string);
        function  ValueSet(DataCol, DataRow: Longint): Boolean;
        function  GetStretchPicture: Boolean;
        function  GetShrinkPicture: Boolean;
        function  GetCenterPicture: Boolean;
        function  GetKeepAspectRatio: Boolean;
        function  GetTransparentColor: TColor;

        property Grid: TtsBaseGrid read FGrid;

    public
        constructor Create(Grid: TtsBaseGrid);

        function  AllSelected: Boolean;
        function  BufferValue: Variant;
        function  CopyToClipboard: Boolean;
        function  CutToClipboard: Boolean;
        procedure FreeInstance; override;
        function  IsClear: Boolean;
	      procedure MoveTo(DataCol, DataRow : Longint);
        procedure MoveToInsertRow(DataCol: Longint); virtual;
        function  PasteFromClipboard: Boolean;
        procedure PutInView; virtual;
        procedure Refresh;
        procedure SelectAll;

        property CenterPicture: Boolean read GetCenterPicture;
        property ControlType: TtsControlType read GetControlType;
	      property DataCol : Longint read GetDataCol;
	      property DataRow : Longint read GetDataRow;
        property KeepAspectRatio: Boolean read GetKeepAspectRatio;
	      property SelLength : Integer read GetSelLength write SetSelLength;
	      property SelStart : Integer read GetSelStart write SetSelStart;
        property SelText : string read GetSelText write SetSelText;
        property ShrinkPicture: Boolean read GetShrinkPicture;
        property StretchPicture: Boolean read GetStretchPicture;
        property TextHeight: Integer read GetTextHeight;
        property TextWidth: Integer read GetTextWidth;
        property TextLines: Integer read GetTextLines;
        property TransparentColor: TColor read GetTransparentColor;
	      property Value : Variant read GetValue write SetValue;
        property Tag : Integer read GetTag write SetTag;
        property Data : Pointer read GetData write SetData;
    end;

    {TtsDrawData}
    {Drawing info used for drawing the contents of individual cells}

    TtsDrawData = record
        DisplayCol: Longint;
        DisplayRow: Longint;
        DataCol: Longint;
        DataRow: Longint;
        ControlType: TtsControlType;
        FullRect: TRect;
        BoxRect: TRect;
        DrawRect: TRect;
        ButtonRect: TRect;
        DrawButton: Boolean;
        Font: TFont;
        Cell3D: Boolean;
        Alignment: TAlignment;
        VertAlignment: TtsVertAlignment;
        BrushColor: TColor;
        DrawControl: Boolean;
        WordWrap: TtsWordWrap;
        ButtonType: TtsButtonType;
        DropDownStyle: TtsDropDownStyle;
        Transparent: TColor;
    end;

    {TtsPropCollection}
    {TCollection class for writing and reading row, column and cell properties}

    TtsPropCollection = class(TCollection)
    protected
        FGrid: TtsBaseGrid;
    public
        constructor Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
        property Grid: TtsBaseGrid read FGrid;
    end;

    TtsColCollection = class(TtsPropCollection)
    protected
        FColMatch: TtsColMatch;
        FTempGrid: TtsBaseGrid;
    public
        constructor Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
        destructor Destroy; override;
    end;

    {TtsColItem}
    {TCollectionItem class for writing and reading column properties}

    TtsColItem = class(TCollectionItem)
    protected
        FCol: TtsCol;
        FDataCol: Longint;
        FFieldName: string;
        procedure SetDataCol(Value: Longint);
        procedure SetReadColNumber(ReadColnr: Integer);
        procedure SetFieldName(Value: string);
        function  GetCol: TtsCol;
    public
        constructor Create(Collection: TCollection); override;
    published
        {DataCol should remain the first published property}
        property DataCol: Longint read FDataCol write SetDataCol;
        property FieldName: string read FFieldName write SetFieldName;
        property Col: TtsCol read GetCol write FCol;
    end;

    {TtsRowItem}
    {TCollectionItem class for writing and reading row properties}

    TtsRowItem = class(TCollectionItem)
    protected
        FRow: TtsRow;
        FDataRow: Longint;
        FDisplayRow: Longint;
        FSelected: Boolean;
        procedure SetDataRow(Value: Longint);
        procedure SetDisplayRow(Value: Longint);
        procedure SetSelected(Value: Boolean);
        function  GetSelected: Boolean;
    public
        constructor Create(Collection: TCollection); override;
    published
        {DataRow should remain the first published property}
        property DataRow: Longint read FDataRow write SetDataRow;
        property DisplayRow: Longint read FDisplayRow write SetDisplayRow;
        property Selected: Boolean read GetSelected write SetSelected default False;
        property Row: TtsRow read FRow write FRow;
    end;

    {TtsCellCollection}
    {TCollection class for writing and reading cell properties}

    TtsCellCollection = class(TtsPropCollection)
    protected
        FCell: TtsCell;
        function  CreateCell(Grid: TtsBaseGrid): TtsCell; virtual;
    public
        constructor Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
        destructor Destroy; override;
        procedure ApplyProps; virtual;
        property Cell: TtsCell read FCell write FCell;
    end;

    {TtsCellItem}
    {TCollectionItem class for writing and reading cell properties}

    TtsCellItem = class(TCollectionItem)
    protected
        FCell: TtsCell;
        FDataCol: Longint;
        FDataRow: Longint;
        function  GetCell: TtsCell;
    public
        constructor Create(Collection: TCollection); override;
        destructor Destroy; override;
    published
        {DataCol and DataRow should remain the first published properties}
        property DataCol: Longint read FDataCol write FDataCol;
        property DataRow: Longint read FDataRow write FDataRow;
        property Cell: TtsCell read GetCell write FCell;
    end;

    TtsStoredCell = record
        Empty: Boolean;
        DataCol: Longint;
        DataRow: Variant;
        Element: TtsCustomElement
    end;

    {C++Builder does not handle HDC types in virtual methods correctly. If HDC occurs
     in the parameter list of a virtual function, the component cannot be overriden
     without getting a link error. HDCType replaces HDC for C++Builder to prevent this.}

    {$IFDEF TSVER_CBUILD}
    {$IFDEF TSVER_V4}
        HDCType = LongWord;
    {$ELSE}
        HDCType = Integer;
    {$ENDIF}
    {$ENDIF}

    {TtsBaseGrid}
    {Base class for the visual components TtsGrid and TtsDBGrid. For the
     TtsGrid, most of its functionality is defined. For TtsDBGrid all non
     data related functionality is defined.}

    TtsBaseGrid = class(TCustomGrid_ts)
    protected
        FMetaFileCanvas : TMetaFileCanvas;
        FControlSet: Boolean;
        FControlHidden: Boolean;
        FControlEnabled: Boolean;
        FEditSelect: TtsTextSelectMode;
        FInPutInView: Boolean;
        FSetBounds: Boolean;
        FBoundsRect: TRect;
        FInCellLoaded: Boolean;
        FInDoCellLoaded: Boolean;
        FGridControl: TtsCustomGridControl;
        FEditControl: TtsEditGridControl;
        FCheckControl: TtsCheckGridControl;
        FPictureControl: TtsDefaultGridControl;
        FDefaultControl: TtsDefaultGridControl;
        FLastAddedCol, FLastAddedRow: Longint;
        FSelectedRows: TtsSelection;
        FSelectChanged: TtsSelectChange;
        FInActivateRowChanges:Boolean;
        FInActivateColChanges:Boolean;
        FSelectedCols: TtsSelection;
        FCurDisplayCol: Longint;
        FCurDisplayRow: Longint;
        FPrevDisplayCol: Longint;
        FPrevDisplayRow: Longint;
        FCurDataCol: Longint;
        FCurDataRow: Longint;
        FOldDataCol: Longint;
        FOldDataRow: Longint;
        FOldGridStatus: TtsGridStatus;
        FOldMouseStatus: TtsMouseStatus;
        FHitTest: TPoint;
        FDcPrepared: Boolean;
        FDoInitCanvas: Boolean;
        FInPaintWindow : Boolean;
        FSetGridControlVisible : Boolean;
        FMouseDownToControl : Boolean;
        FFirstTimePainted: Boolean;
        FMouseDownMessage : TWMLButtonDown;
        FMouseUpMessage : TWMLButtonDown;
        FDataColNumber: PtsLongintArray;
        FDataRowNumber: PtsLongintArray;
        FVisibleCols: TtsVisibleItems;
        FVisibleRows: TtsVisibleItems;
        FColCells: TtsIntegerSetList;
        FRowCells: TtsIntegerSetList;
        FCellPropSet: TtsCellPropSet;
        FHorzLineWidth, FVertLineWidth : Integer;
        FCurDeletedCols, FCurDeletedRows: Longint;
        FMovePos, FMoveIndex: Longint;
        FDoubleClicked: Boolean;
        FDownDisplayCol: Longint;
        FDownDisplayRow: Longint;
        FUpDisplayCol: Longint;
        FUpDisplayRow: Longint;
        FMouseDownOccured: Boolean;
        FResizeRow: Longint;
        FInScrollingMode: Boolean;
        FInStartingMode: Boolean;
        FResizeDoubleClicked: Boolean;
        FBaseSelectedCells, FSelectedCells: TRect;
        FColMoveDrawnOutsideGrid: Boolean;
        FRowMoveDrawnOutsideGrid: Boolean;
        FTopLeftChanged: Boolean;
        FInTopLeftChanged: Integer;
        FEnablePaintCount: Integer;
        FEnableRedrawCount: Integer;
        FFocusRectDisabled: Integer;
        FFastAssignCount: Integer;
        FAssigning: Boolean;
        FEnableStartEditCount: Integer;
        FDoUpdateScrollRange: Boolean;
        FForceUpdateScrollRange: Boolean;
        FDoUpdateScrollPos: Boolean;
        FInScrolling: Boolean;
        FInMouseMove: Boolean;
        FInGetCell: Boolean;
        FGetCellCol: Longint;
        FGetCellRow: Longint;
        FGetCellValue: Variant;
        FDrawFont: TFont;
        FOldTopLeft: TGridCoord;
        FLabelOrHeadingChanged: Boolean;
        FOldFixedCols, FOldFixedRows: Longint;
        FSizingOfs, FSizingPos: Integer;
        FSizingIndex: Integer;
        FInChangingAllRowHeights: Boolean;
        FInChangingAllColWidths: Boolean;
        FInResizingRowBar: Boolean;
        FInResizingHeading: Boolean;
        FOldDefaultRowHeight: Integer;
        FOldDefaultColWidth: Integer;
        FOldRowBarWidth: Integer;
        FOldHeadingHeight: Integer;
        FOldInsertionRow: Integer;
        FScrollDelayStart: Cardinal;
        FMinWaitingTime: Integer;
        FMaxWaitingTime: Integer;
        FGridCols: TtsGridCols;
        FGridRows: TtsGridRows;
        FNullRect: TRect;
        FChangedRows: TBits;
        FCurRowChanged: Boolean;
        FRowEdited: Boolean;
        FInsertRowEdit: Boolean;
        FHorzFixedWidth: Integer;
        FVertFixedHeight: Integer;
        FCellDrawn: TGridCoord;
        FDrawSelectCell: TGridCoord;
        FDrawCellSelected: Boolean;
        FInHidingGridControl: Boolean;
        FSkipColWidthsChanged: Boolean;
        FSkipRowHeightsChanged: Boolean;
        FColMoveVisible: Boolean;
        FRowMoveVisible: Boolean;
        FDisplayAsControl: Boolean;
        FScrollMode: TtsScrollMode;
        FGridControlRect: TRect;
        FRowSelectRect: TRect;
        FIsHorzVisible: Boolean;
        FIsVertVisible: Boolean;
        FInUndoEdit: Boolean;
        FDrawBitmap: TBitmap;
        FButtonUp: TGridCoord;
        FButtonDown: TGridCoord;
        FDownSpinButton: TtsSpinButton;
        FSpinRepeatCount: Integer;
        FUpSpinButton: TtsSpinButton;
        FButtonClicked: Boolean;
        FSpinButtonClicked: TtsSpinButton;
        FGridButton: TtsCustomButton;
        FComboButton: TtsComboButton;
        FNormalButton: TtsNormalButton;
        FVertSpinButton: TtsVertSpinButton;
        FHorzSpinButton: TtsHorzSpinButton;
        FDateTimeDropDownButton: TtsDateTimeButton;
        FDateTimePopupButton: TtsDateTimeButton;
        FCombo: TtsCombo;
        FComboInitialized: Boolean;
        FInComboInit: Boolean;
        FDateTimeInitialized: Boolean;
        FComboForm: TtsDropDownForm;
        FDateTimeForm: TtsDropDownForm;
        FDateTimeComponent: TtsDateTimeDefComponent;
        FDateTimeDateSelected: Boolean;
        FDateTimeDateCanceled: Boolean;
        FDateTimeDisplayed: Boolean;
        FDropDownCol: Longint;
        FDropDownRow: Longint;
        FAsCombo: Boolean;
        FMouseDownToCombo: Boolean;
        FIgnoreScrolling: Boolean;
        FHeadingClicked: Longint;
        FHeadingButtonClicked: Boolean;
        FDrawHeadingButtonDown: Boolean;
        FHasKeyFocus: Boolean;
        FComboSearchValue: string;
        FLastIncrSearchTime: Cardinal;
        FButtonTimer: Integer;
        FSpinTimer: Integer;
        FUseSpinStartDelay: Boolean;
        FInCheckEndEdit: Boolean;
        FInternalFixedCols: Integer;
        FInternalFixedRows: Integer;
        FSetCursor: Boolean;
        FInSetFocus: Integer;
        FInDoExit: Integer;
        FCanProcessKey: Integer;
        FMaskLink: TtsGridMaskLink;
        FAutoFontCols: TtsIntegerList;
        FAutoFontRows: TtsIntegerList;
        FAutoFontCells: TtsCoordList;
        FFastAssignActions: TtsGridActions;
        FSaveTtsBaseGridProp: Boolean;
        FLastUsedCombo: TtsCombo;
        FLastUsedDateTime: TtsDateTimeDefComponent;
        FDesigning: Boolean;
        FSetComboExtents: Integer;
        FSaveAllProps: Integer;
        FReading: Boolean;
        FWriting: Boolean;
        FGridData: Tts2DStorage;
        FImageLink: TtsGridImageLink;
        FImageListIds: TStringList;
        FLastCell: TtsStoredCell;
        FPictureColorMask: TBitmap;
        FPictureMaskRGBColor: Longint;
        FWriteCols: TtsPropCollection;
        FWriteRows: TtsPropCollection;
        FCellPropCollection: TtsCellCollection;
        FColMatch: TtsColMatch;
        FReadColNumbers: TList;
        FReadColProperties: TtsProperties;
        FDateTimeLink: TtsGridDateTimeLink;
        FMouseOverGrid: Boolean;
        FScaledRowHeight: Integer;

        {$IFNDEF TSVER_V3}
        FStoredPropKinds: TtsPropKinds;
        FStoredCols: TCollection;
        FStoredRows: TCollection;
        FStoredCells: TCollection;
        {$ENDIF}

        {Property fields}
        FButtonEdgeWidth: Integer;
        FCellEditing: Boolean;
        FCellSelectMode: TtsCellSelectMode;
        FCenterPicture: Boolean;
        FCheckBoxStyle : TtsCheckBoxStyle;
        FColMoving: Boolean;
        FCols, FRows: Longint;
        FColSelectMode: TtsColSelectMode;
        FCurrentCell: TtsCurrentCell;
        FDefaultButtonHeight: Integer;
        FDefaultButtonWidth: Integer;
        FDrawOverlap: TtsDrawOverlap;
        FEditColor: TColor;
        FEditFontColor: TColor;
        FEditMode: TtsEditMode;
        FGridMode: TtsGridMode;
        FFixedColCount: Integer;
        FFixedLineColor: TColor;
        FFixedRowCount: Integer;
        FFlatButtons: Boolean;
        FGridLines: TtsGridLines;
        FFocusLineOnVertFixed: Boolean;
        FFocusLineOnHorzFixed: Boolean;
        FGridStatus: TtsGridStatus;
        FHeading3D: Boolean;
        FHeadingAlignment: TAlignment;
        FHeadingHorzAlignment: TtsHorzAlignment;
        FHeadingVertAlignment: TtsVertAlignment;
        FHorzAlignment: TtsHorzAlignment;
        FVertAlignment: TtsVertAlignment;
        FRowBarAlignment: TtsVertAlignment;
        FHeadingButton: TtsHeadingButton;
        FHeadingColor: TColor;
        FHeadingFont: TFont;
        FHeadingParentFont: Boolean;
        FHeadingWordWrap: TtsWordWrap;
        FInactiveButtonState: TtsInactiveButtonState;
        FInsertionRow: Integer;
        FIs3D: Boolean;
        FLineColor: TColor;
        FMouseStatus: TtsMouseStatus;
        FRaiseErrors: Boolean;
        FReadOnlyButton: Boolean;
        FResizeCols: TtsResizeCols;
        FResizeRows: TtsResizeRows;
        FResizeRowsInGrid: Boolean;
        FResizeColsInGrid: Boolean;
        FRowBarIndicator: Boolean;
        FRowEditing: Boolean;
        FRowMoving: Boolean;
        FRowSelectMode: TtsRowSelectMode;
        FScrollBars: TScrollStyle;
        FScrollSpeed: TtsScrollSpeed;
        FSelectedAreaCursor: TCursor;
        FSelectFixed: Boolean;
        FStretchPicture: Boolean;
        FShrinkPicture: Boolean;
        FKeepAspectRatio: Boolean;
        FTabRowWrap: Boolean;
        FThumbTracking: Boolean;
        FTransparentColor: TColor;
        FWantTabs: Boolean;
        FWordWrap: TtsWordWrap;
        FStoreData: Boolean;
        FSelectionType: TtsSelectionType;
        FSelectionColor: TColor;
        FSelectionFontColor: TColor;
        FFocusBorder: TtsFocusBorder;
        FFocusColor: TColor;
        FFocusBorderColor: TColor;
        FFocusFontColor: TColor;
        FAlwaysShowEditor: Boolean;
        FAlwaysShowFocus: Boolean;
        FSkipReadOnly: Boolean;
        FRowChangedIndicator: TtsRowChangedIndicator;
        FSpinButtonWidth: Integer;
        FSpinButtonHeight: Integer;
        FSpinStartDelay: Integer;
        FSpinRepeatDelay: Integer;
        FDateTimeDef: TtsDateTimeDefComponent;
        FCheckMouseFocus: Boolean;
        FCheckBoxValues: string;
        FAlwaysShowScrollBar: TScrollStyle;
        FAutoScale: Boolean;
        FInUpdateScrollRange: Boolean;
        FPrintTitle : String;
        FPrintLinesPerPage : Integer;
        FPrintOrientation : TtsPrintMode;
        FPrintTotals : Boolean;
        FPrintCols : Integer;
        FPrintWithGridFormats : Boolean;
        FProvideGridMenu : Boolean;
        FGridMenu : TPopupMenu;
        FExportDelimiter : String;
        FGridReport : TosCustomGridReport;
        FAlwaysDetectButton : Boolean;
        FXMLExport : TosXMLExport;

        {Event Fields}
        FOnCanStartDrag: TtsCanStartDragEvent;
        FOnColChanged: TtsColChangedEvent;
        FOnColCountChanged: TtsCountChangedEvent;
        FOnColMoved: TtsColMovedEvent;
        FOnColResized: TtsResizedEvent;
        FOnComboCompareValue: TtsComboCompareValueEvent;
        FOnComboLCompareValue: TtsComboLCompareValueEvent;
        FOnDeleteCol: TtsDeleteColEvent;
        FOnDrawCell: TDrawCellEvent;
        FOnGridStatusChanged: TtsGridStatusChangedEvent;
        FOnHeadingClick: TtsHeadingClickEvent;
        FOnHeadingDown: TtsHeadingClickEvent;
        FOnHeadingUp: TtsHeadingClickEvent;
        FOnInsertCol: TtsInsertColEvent;
        FOnMouseStatusChanged: TtsMouseStatusChangedEvent;
        FOnRowCountChanged: TtsCountChangedEvent;
        FOnRowMoved: TtsRowMovedEvent;
        FOnRowResized: TtsResizedEvent;
        FOnSelectChanged: TtsSelectChangedEvent;
        FOnPaint: TNotifyEvent;
        FOnResize: TNotifyEvent;
        FOnEditTextResized: TtsEditTextResizedEvent;
        FOnPrintGrid: TtsPrintGridEvent;

        procedure CMCursorChanged(var Message: TMessage); message CM_CURSORCHANGED;
        procedure CMDesignHitTest(var Msg: TCMDesignHitTest); message CM_DESIGNHITTEST;
        procedure CMDialogChar(var Message: TCMDialogChar); message CM_DIALOGCHAR;
        procedure WMEraseBkGnd(var Message: TWMEraseBkGnd); message WM_ERASEBKGND;
        procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
        procedure WMHScroll(var Msg: TWMHScroll); message WM_HSCROLL;
        procedure WMKillFocus(var Message : TMessage); message WM_KILLFOCUS;
        procedure WMNCHitTest(var Msg: TWMNCHitTest); message WM_NCHITTEST;
        procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
        procedure WMSetCursor(var Msg: TWMSetCursor); message WM_SETCURSOR;
        procedure WMSetFocus(var Message : TMessage); message WM_SETFOCUS;
        procedure WMSize(var Msg: TWMSize); message WM_SIZE;
        procedure WMTimer(var Msg: TWMTimer); message WM_TIMER;
        procedure WMVScroll(var Msg: TWMVScroll); message WM_VSCROLL;
        procedure WMPaste(var Msg: TWMPaste); message WM_PASTE;
        procedure WMCopy(var Msg: TWMCopy); message WM_COPY;
        procedure WMCut(var Msg: TWMCut); message WM_CUT;
        procedure CMEnter(var Message: TCMEnter); message CM_ENTER;
        procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
        procedure CMParentFontChanged(var Message: TMessage); message CM_PARENTFONTCHANGED;

        {Error detection procedures}
        procedure InvalidOp(Msg: string);
        procedure InvalidMaskOp(Msg: string);
        procedure CheckRaise(Msg: string);
        function  CheckIndex(IndexType: TtsIndexType; Value, Lower, Upper: Longint): Boolean;
        function  CheckGetCell: Boolean;
        function  CheckVarType(ControlType: TtsControlType; const Value: Variant): Boolean;

        {Grid Menu Clicks}
        procedure OnPrintGridClick(Sender : TObject);
        procedure OnPreviewGridClick(Sender : TObject);
        procedure OnExportGridClick(Sender : TObject);

        {Miscellaneous procedures}
        procedure StartTimer(var TimerHandle: Integer; TimerID: Integer;
                             Interval: Integer; Restart: Boolean);
        function  StopTimer(var TimerHandle: Integer): Boolean;
        procedure StartButtonTimer;
        procedure StartSpinTimer(UseStartDelay: Boolean);
        procedure CheckRestartSpinTimer;
        function  InSetFocus: Boolean;
        function  InDoExit: Boolean;
        function  CanActivateEvent: Boolean; virtual;
        procedure UpdateDesigner;
        procedure SetGridFocus;

        {Drawing procedures}
        procedure DrawRowCells(DisplayRow: Longint; YPos: Integer; DrawRect: TRect;
                               LeftColPos: Longint; var ColBoundary: Integer); virtual;
        procedure DrawCells(DrawRect: TRect; LeftColPos, TopRowPos: Longint; var ColBoundary, RowBoundary: Integer); virtual;
        procedure DrawEmptyArea(XPos, YPos: Integer); virtual;
        procedure DrawHorzLine(DisplayRow: Longint; VertPos: Integer; DrawRect: TRect; DrawFixed: Boolean; LeftColPos: Longint);
        procedure DrawHorzLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
        procedure DrawVertLine(DisplayCol: Longint; HorzPos: Integer; DrawRect: TRect; DrawFixed: Boolean; TopRowPos: Longint);
        procedure DrawVertLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
        procedure DrawGridLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
        procedure PaintGrid; virtual;
        function  CalcColOffset(DisplayCol: Longint): Integer;
        function  CalcRowOffset(DisplayRow: Longint): Integer;
        function  CalcCellRect(DisplayCol, DisplayRow: Longint): TRect;
        procedure SetRedraw;
        procedure SetEnablePaint(Value: Boolean);
        function  GetEnablePaint: Boolean;
        procedure SetEnableRedraw(Value: Boolean);
        function  GetEnableRedraw: Boolean;
        procedure PerformFastAssignActions;
        procedure InitFastAssign;
        procedure EndFastAssign;
        procedure SetFastAssign(Value: Boolean);
        function  GetFastAssign: Boolean;
        procedure SetFocusRectDisabled(Value: Boolean);
        function  GetFocusRectDisabled: Boolean;
        function  CanPaint: Boolean;
        function  InClipRect(ARect: TRect): Boolean;
        function  BoxRect(ALeft, ATop, ARight, ABottom: Longint): TRect;
        function  ColInView(DisplayCol: Longint): Boolean;
        function  RowInView(DisplayRow: Longint): Boolean;
        function  CanDrawCell(DisplayCol, DisplayRow: Longint): Boolean;
        procedure ClearRowBarCell(DisplayRow: Longint); virtual;
        procedure CopyToDrawBitmap(Bmp:TBitmap);
        procedure DrawBmpRowBar(DisplayRow: Longint; Bmp: TBitmap;
                                ClearInsert: Boolean; CopyMode: TCopyMode); virtual;
        function  ButtonsActive: Boolean; virtual;
        function  CanDrawInsert: Boolean; virtual;
        procedure DrawInsert;
        procedure DrawFixedCellSelected(ARect: TRect);
        procedure DrawFixedCellUnselected(ARect: TRect; ACol: Longint);
        procedure DrawGridCellUnselected(ARect: TRect);
        procedure DrawFixedLines(ARect: TRect; AColor: TColor);
        procedure DrawHeadingButtonUp(Canvas: TCanvas; const DrawData: TtsDrawData;
                                      DisplayCol: Longint);
        procedure DrawHeadingButtonDown(Canvas: TCanvas; const DrawData: TtsDrawData;
                                        DisplayCol: Longint);
        procedure DoGetSortPicture(SortPicture: TtsSortPicture; var Bitmap: TBitmap); virtual;
        procedure DrawHeadingButton(Canvas: TCanvas; DisplayCol: Longint; const DrawData: TtsDrawData); virtual;
        procedure DrawHeadingText(DisplayCol: Longint; ARect: TRect);
        procedure DrawButtonInCell(var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  DrawCurrentButton(DisplayCol, DisplayRow: Longint): Boolean;
        function  CanDrawButton(DisplayCol, DisplayRow: Longint; InActive: Boolean): Boolean;
        function  DrawFlatButtonUp(DisplayCol, DisplayRow: Longint): Boolean;
        procedure DrawButtonPicture(const DrawData: TtsDrawData; AColor: TColor; ButtonMode: TtsButtonMode);
        function  ButtonBrushColor(AColor: TColor; var DrawData: TtsDrawData; DrawSelected: Boolean): TColor;
        procedure DrawUpButton(ARect: TRect; LineColor: TColor; ButtonWidth, ButtonHeight: Integer; DrawTopLine, DrawLeftLine: Boolean);
        procedure DrawDownButton(ARect: TRect; LineColor: TColor; ButtonWidth, ButtonHeight: Integer; DrawTopLine, DrawLeftLine: Boolean);
        procedure DrawButtonBox(AColor: TColor; ButtonMode: TtsButtonMode;
                                var DrawData: TtsDrawData; DrawSelected: Boolean);
        procedure GetVertSpinRects(ButtonRect: TRect; var TopRect, BottomRect: TRect; var TopHeight, BottomHeight: Integer);
        procedure GetHorzSpinRects(ButtonRect: TRect; var RightRect, LeftRect: TRect; var RightWidth, LeftWidth: Integer);
        procedure GetSpinRects(ButtonType: TtsButtonType; ButtonRect: TRect; var TopRightRect, BottomLeftRect: TRect; var TopRightExtent, BottomLeftExtent: Integer);
        function  GetSpinButtonXY(X, Y: Integer; DisplayCol, DisplayRow: Longint): TtsSpinButton;
        function  OverSpinButton(X, Y: Integer; DisplayCol, DisplayRow: Longint; SpinButton: TtsSpinButton): Boolean;
        procedure DrawSpinPicture(ButtonType: TtsButtonType; SpinButton: TtsSpinButton; DrawRect: TRect; ButtonWidth, ButtonHeight: Integer; Bitmap: TBitmap; ButtonDown: Boolean);
        procedure DrawSpinButtons(ButtonType: TtsButtonType; DrawButtons: TtsSpinButtons; DownButton: TtsSpinButton; AColor: TColor; var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  IsSpinButton(ButtonType: TtsButtonType): Boolean;
        function  NextToCurrentCell(DisplayCol, DisplayRow: Longint): Boolean;
        procedure DoDrawButton(DisplayCol, DisplayRow: Longint; SpinButtons: TtsSPinButtons;
                               DownButton: TtsSpinButton; AColor: TColor; ButtonMode: TtsButtonMode);
        function  DrawButtonDown(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
        procedure DrawTextInRect(Value: PChar; var DrawData: TtsDrawData; DrawControl: Boolean; DrawSelected: Boolean);
        procedure DrawText(Value: PChar; var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  CalcCheckRect(Cell3D: Boolean; Bitmap: TBitmap; CellRect, BmpRect: TRect; LeftOffset: Integer): TRect;
        procedure DrawCheck(Value: Variant; var DrawData: TtsDrawData; DrawSelected: Boolean);
        procedure DrawCheckOnCanvas(ARect : TRect; Bitmap : TBitmap; BmpRect: TRect; CopyMode : TCopyMode);
        procedure GetEditColor(var DrawData: TtsDrawData; SetEditColor: Boolean);
        procedure GetHeadDrawData(DisplayCol: Longint; var DrawData: TtsDrawData);
        procedure SetDrawFont(var DrawData: TtsDrawData);
        procedure FetchDrawInfo(var DrawData: TtsDrawData);
        procedure SetDrawRect(var DrawData: TtsDrawData);
        procedure UpdateDrawData(var DrawData: TtsDrawData; SetEditColor: Boolean);
        procedure GetDrawData(ADisplayCol, ADisplayRow: Longint; FullInfo: Boolean; var DrawData: TtsDrawData);
        procedure FillCellRect(const DrawData: TtsDrawData; ARect: TRect; ControlType: TtsControlType; DrawSelected: Boolean);
        procedure DrawEmpty(var DrawData: TtsDrawData; ControlType: TtsControlType; DrawSelected: Boolean);
        procedure GetDrawOptions(DataCol, DataRow: Longint; CurrentCellSet: Boolean; var Stretch, Shrink, Center, KeepAspect: Boolean);
        function  PictureTransparentColor(Bitmap: TBitmap; Image: TtsImageItem): TColor;
        procedure DrawPictureMask(DrawRect: TRect; MaskColor: TColor);
        procedure DrawPictureInRect(Bitmap: TBitmap; Image: TtsImageItem; var DrawData: TtsDrawData; DrawSelected: Boolean);
        procedure DrawPicture(Bitmap: TBitmap; Image: TtsImageItem; var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  EmptyCellValue(ControlType: TtsControlType): Variant;
        procedure DrawEmptyCell(var DrawData: TtsDrawData; DrawSelected: Boolean);
        procedure FillSelectionPart(ControlType: TtsControlType; const DrawData: TtsDrawData; DrawSelected: Boolean);
        procedure FillButtonPart(var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  GridCellButton(DisplayCol: Longint; ButtonType: TtsButtonType): TtsCustomButton;
        function  GridCellControl(ControlType: TtsControlType) : TtsCustomGridControl;
        function  GiveHeadingFont(DataCol: Longint): TFont;
        function  GiveCellFont(DataCol, DataRow: Longint): TFont;
        function  GiveHeadingWordWrap(DataCol: Longint): TtsWordWrap;
        function  GiveCellWordWrap(DataCol, DataRow: Longint): TtsWordWrap;
        function  GiveCellButtonType(DataCol, DataRow: Longint): TtsButtonType;
        function  GiveCellButton(DataCol, DataRow: Longint; var Style: TtsDropDownStyle): TtsButtonType;
        function  GiveCellDropDownStyle(DataCol, DataRow: Longint): TtsDropDownStyle;
        function  GiveCellColor(DataCol, DataRow: Longint; Cell3D: Boolean): TColor;
        function  GiveCellAlignment(DataCol, DataRow: Longint): TAlignment;
        function  GiveHeadingHorzAlignment(DataCol: Longint): TtsHorzAlignment;
        function  GiveCellHorzAlignment(DataCol, DataRow: Longint): TtsHorzAlignment;
        function  GiveHeadingVertAlignment(DataCol: Longint): TtsVertAlignment;
        function  GiveCellVertAlignment(DataCol, DataRow: Longint): TtsVertAlignment;
        function  GiveCell3D(DataCol, DataRow: Longint): Boolean;
        function  GiveCellMaskName(DataCol, DataRow: Longint): string;
        function  GiveCellControlType(DataCol, DataRow: Longint): TtsControlType; virtual;
        function  GiveCellSpinOptions(DataCol, DataRow: Longint): TtsSpinOptions; virtual;
        function  GiveCellSpinIncrement(DataCol, DataRow: Longint): Double; virtual;
        function  GiveCellStretchPicture(DataCol, DataRow: Longint): TtsDrawOption;
        function  GiveCellShrinkPicture(DataCol, DataRow: Longint): TtsDrawOption;
        function  GiveCellCenterPicture(DataCol, DataRow: Longint): TtsDrawOption;
        function  GiveCellKeepAspectRatio(DataCol, DataRow: Longint): TtsDrawOption;
        function  GiveCellCheckBoxValues(DataCol, DataRow: Longint): string; virtual;
        function  CurCellMaskName: string; virtual;
        function  CurCellControlType: TtsControlType; virtual;
        function  CurCellReadOnly: Boolean; virtual;
        function  CurCellSelected: Boolean; virtual;
        function  CurCellCheckBoxValues: string; virtual;
        procedure DeleteColoredColCells(DataCol: Longint);
        procedure MoveColoredColCells(DataCol: Longint; MaxCol: Longint);
        procedure DeleteColoredRowCells(DataRow: Longint);
        procedure MoveColoredRowCells(DataRow: Longint; MaxRow: Longint);
        procedure InvalidateNextRows(DataRow: Longint);
        procedure InvalidateRow(DisplayRow: Longint);
        procedure InvalidateCol(DisplayCol: Longint);
        procedure InvalidateCell(DisplayCol, DisplayRow: Longint);
        function  CellVisible(DisplayCol, DisplayRow: Longint): Boolean;
        function  CheckInvalidateCell(DisplayCol, DisplayRow: Longint): Boolean;
        function  CheckInvalidateRow(DisplayRow: Longint): Boolean;
        function  CheckInvalidateCol(DisplayCol: Longint): Boolean;
        function  CellInGridSelection(DisplayCol, DisplayRow: Longint): Boolean;
        procedure GetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo); virtual;
        procedure CellLoadedEvent(DataCol, DataRow: Longint; ControlType: TtsControlType; var Value: Variant); virtual; abstract;
        procedure CellLoaded(var DrawData: TtsDrawData; DrawSelected: Boolean);
        function  PaintCell(var DrawData: TtsDrawData; ARect: TRect; DrawSelected: Boolean): Boolean; virtual; abstract;
        procedure GetPaintCellPars(DisplayCol, DisplayRow: Longint; var State: TtsPaintCellState);
        function  ActivateDoGetDrawInfo: Boolean; virtual; abstract;
        procedure CalcHorzFixedWidth;
        procedure CalcVertFixedHeight;
        procedure AssignCellValue(DataCol, DataRow: Longint; var DrawData: TtsDrawData;
                                  DrawSelected: Boolean; const Value: Variant; PValue: PChar; Edit, ByUser: Boolean);
        procedure UpdateCellFonts;
        function  IsDrawProp(Prop: TtsProperty): Boolean;
        procedure InitPictureMaskColor(MaskColor: TColor);
        procedure CheckPictureMaskColor(MaskColor: TColor);
        procedure CheckPictureMask(Create: Boolean);
        function  FocusEnabled: Boolean;
        function  FocusRectActive: Boolean;
        function  FocusRectVisible(DisplayCol, DisplayRow: Longint): Boolean;
        function  CheckCellFocusRect(DisplayCol, DisplayRow: Longint; CheckFocus: Boolean): Boolean;
        function  DisplayFocusRect(DisplayCol, DisplayRow: Longint; CheckFocus: Boolean): Boolean;
        procedure DrawFocusRect(Canvas: TCanvas; DisplayCol, DisplayRow: Longint);
        procedure DrawCellFocusRect(DisplayCol, DisplayRow: Longint);
        procedure InvalidateFocusRect(DisplayCol, DisplayRow: Longint; OuterBorder: Boolean);
        procedure ClearCurrentFocusRect(DoUpdate: Boolean);
        procedure DrawCurrentFocusRect(DoUpdate: Boolean);
        procedure FocusChanged(ResetOuterBorder: Boolean);
        procedure UpdateGrid(IgnoreFocus: Boolean);
        function  SelectionColorEnabled: Boolean;
        procedure CheckResizeButtons;
        procedure CheckResizeSpinButtons;

        {ImageList procedures}
        procedure ImageListDeleted;
        procedure ImageChanged(Image: TtsImageItem);
        function  ImageListPicture(Value: Variant): TtsImageItem;

        {Col/row/cell inversion}
        procedure RectInvert(Dc: HDC; ARect: TRect; Selected: Boolean);
        procedure GridRectInvert(Dc: HDC; ARect: TGridRect; InvertRect: TRect; Selected: Boolean);
        procedure InvertSelectedRows(FromRow, ToRow: Longint; Select: Boolean); virtual;
        procedure InvertSelectedColHeadings(FromCol, ToCol: Longint);
        procedure InvertUnselectedCols(FromCol, ToCol: Longint; Invert: TtsInvert);
        procedure InvertUnselectedRows(FromRow, ToRow: Longint); virtual;
        {$IFDEF TSVER_CBUILD}
        procedure InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom: Longint; const ARect: TRect; Selected: Boolean; Dc: HDCType); virtual;
        procedure InvertRow(DisplayRow: Longint; Selected: Boolean; Dc: HDCType); virtual;
        {$ELSE}
        procedure InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom: Longint; const ARect: TRect; Selected: Boolean; Dc: HDC); virtual;
        procedure InvertRow(DisplayRow: Longint; Selected: Boolean; Dc: HDC); virtual;
    	{$ENDIF}
        procedure InvertCell(DisplayCol, DisplayRow: Longint; const ARect: TRect; Selected: Boolean; Dc: HDC);
        procedure InvertCol(DisplayCol: Longint; Invert: TtsInvert; Selected: Boolean; Dc: HDC);
        procedure InvertHeading(Selected: Boolean);
        procedure InvertLabel(Selected: Boolean);
        procedure InvertGrid(Selected: Boolean);
        procedure InvertNew(NewLeft, NewTop, NewRight, NewBottom: Longint);
        procedure InvertNewRangeSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
        procedure InvertNewColSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
        procedure InvertNewRowSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
        procedure ChangeRowInversion(FromRow, ToRow: Longint; SelectionSet: Boolean);
        procedure AddColInversion(FromCol, ToCol: Longint);
        procedure ChangeColInversion(FromCol, ToCol: Longint; SelectionSet: Boolean);
        procedure DeleteColInversion(FromCol, ToCol: Longint);
        procedure AddRangeInversion(DisplayLeft, DisplayTop, DisplayRight,
                                    DisplayBottom: Longint);
        procedure DeleteRangeInversion(DisplayLeft, DisplayTop, DisplayRight,
                                       DisplayBottom: Longint);
        procedure ModifyRangeInversion(NewLeft, NewTop, NewRight, NewBottom: Longint);

        {Child edit control procedures}
        procedure DoHideControl(RemoveSelect: Boolean);
        function  CheckHideControl(RemoveSelect: Boolean): Boolean;
        function  CurrentCellInView: Boolean;
        function  GridControlActive: Boolean;
        function  CanSetControl: Boolean;
        function  ControlDisplayed: Boolean;
        function  FocusToGridControl: Boolean;
        procedure MakeGridControlVisible(SelectMode: TtsTextSelectMode);
        procedure CheckEnableControl(Enable, Redisplay: Boolean; SelectMode: TtsTextSelectMode);
        function  InternalShowEditor(SelectMode: TtsTextSelectMode; DoUpdate: Boolean): Boolean;
        function  StartShowEditor(DoUpdate: Boolean): Boolean;
        procedure ShowGridControl;
        procedure HideGridControl(RemoveSelect: Boolean);
        procedure HideControlBeforeScroll(DoInvalidate: Boolean);
        procedure ShowControlAfterScroll;
        procedure SetControlSelectMode(SelectMode: TtsTextSelectMode);
        procedure SetControlProperties(CellControl: TtsCustomGridControl); virtual;
        procedure SetGridControl(ControlType: TtsControlType);
        procedure RedisplayControl(RemoveSelect: Boolean);
        function  GetCheckBoxValue(Value: Variant): Variant;
        function  AssignControlValue(ControlType: TtsControlType; Value: Variant; Edit, ByUser: Boolean): Variant;
        procedure SetControlValue(const Value: Variant; Edit, ByUser: Boolean);
        procedure SetControlMask;
        function  SetControlCheckBoxValues: Boolean;

        {Current row/cell procedures}
        procedure UpdateControlProperties(const DrawData: TtsDrawData);
        procedure SetCurrentCell(DisplayCol, DisplayRow: Longint);
        procedure SetCurrentValue(Value: Variant; Select: Boolean; Redraw: Boolean);
        procedure ClearControlBuffer;
        procedure ClearCellBuffer;
        procedure MoveCellBuffer(NewDataCol, NewDataRow: Longint);
        procedure PositionCurrentCell(DataCol, DataRow: Longint);
        procedure CheckDisableControl;
        procedure PositionCell(DisplayCol, DisplayRow: Longint);
        procedure SetCurrentPosition(DisplayCol, DisplayRow: Longint;
                                     InvalidateInsertRow, InvalidateOldCell: Boolean); virtual;
        procedure SetCurrentPositionAndDraw(DisplayCol, DisplayRow: Longint;
                                            InvalidateInsertRow, InvalidateOldCell: Boolean);
        function  DrawRowChangedIndicator(DataRow: Longint): Boolean;
        procedure DrawCurrent(DisplayRow: Longint);
        procedure DrawCurrentSelected(DisplayRow: Longint);
        procedure ClearCurrent(DisplayRow: Longint);

        {Column, row and grid selection procedures}
        procedure SetLastAddedRow(DisplayRow: Longint); virtual;
        procedure SetSelectionStartRow(DisplayRow: Longint); virtual;
        function  SelectionStartRownr: Integer; virtual;
        procedure CheckSetCurrentRow(DisplayRow: Longint); virtual;

        procedure SetSelectChanged(SelectType: TtsSelectType);
        procedure SelectChanged(SelectType: TtsSelectType; ByUser: Boolean);
        procedure SelectionsChanged(ByUser: Boolean);
        procedure DeleteAllColSelection;
        procedure DeleteAllRowSelection; virtual;
        procedure AddColSelection(First, Last: Longint);
        procedure DeleteColSelection(First, Last: Longint);
        procedure ChangeColSelection(First, Last: Longint);
        procedure NewColSelection(First, Last: Longint);
        procedure AddRowSelection(First, Last: Longint); virtual;
        procedure DeleteRowSelection(First, Last: Longint); virtual;
        procedure ChangeRowSelection(First, Last: Longint); virtual;
        procedure NewRowSelection(First, Last: Longint);
        procedure AddScrollingRight;
        procedure DeleteScrollingRight;
        procedure AddScrollingLeft(NewLeftCol: Longint);
        procedure DeleteScrollingLeft(NewLeftCol: Longint);
        procedure AddScrollingUp(NewTopRow: Longint);
        procedure DeleteScrollingUp(NewTopRow: Longint);
        procedure AddScrollingDown; virtual;
        procedure DeleteScrollingDown; virtual;
        procedure RightColSelecting(CurrentPos, CheckPos: TPoint);
        procedure LeftColSelecting(CurrentPos, CheckPos: TPoint);
        procedure UpRowSelecting(CurrentPos, CheckPos: TPoint; DisplayRow: Longint); virtual;
        procedure DownRowSelecting(CurrentPos, CheckPos: TPoint; DisplayRow: Longint); virtual;
        function  RowRangeSelected(FromRow, ToRow: Longint): Boolean;
        function  ColRangeSelected(FromCol, ToCol: Longint): Boolean;
        function  RowRangeUnselected(FromRow, ToRow: Longint): Boolean;
        function  ColRangeUnselected(FromCol, ToCol: Longint): Boolean;
        function  CompareRowPos(DisplayRow: Longint): Integer; virtual;
        procedure SelectRowShiftMouseDown(DisplayRow: Longint; var Canceled: Boolean); virtual;
        procedure SelectRowCtrlMouseDown(DisplayRow: Longint);
        procedure SelectRowShiftCtrlMouseDown(DisplayRow: Longint; var Canceled: Boolean); virtual;
        procedure SelectRowMouseDown(DisplayRow: Longint);
        procedure SelectSingleRow(DisplayRow: Longint; Invalidate: Boolean); virtual;
        procedure SetNewSelectedRow(DisplayRow: Longint); virtual;
        procedure CheckRowSelection(Invalidate: Boolean); virtual;
        procedure SelectColShiftMouseDown(DisplayCol: Longint);
        procedure SelectColCtrlMouseDown(DisplayCol: Longint);
        procedure SelectColShiftCtrlMouseDown(Column: Longint);
        procedure SelectColMouseDown(Column: Longint);
        procedure MouseSelectRows(Shift: TShiftState; DisplayRow: Longint; var Canceled: Boolean);
        procedure MouseSelectCols(Shift: TShiftState; DisplayCol: Longint);
        procedure InvertRowSelection(FromDisplayRow, ToDisplayRow: Longint; Select: Boolean);
        procedure DoRowSelection(FromDisplayRow, ToDisplayRow: Longint;
                                 Select: Boolean; ByUser: Boolean);
        procedure AdjustSelection(SelectType: TtsSelectType);
        procedure DeleteSelections(Status: TtsGridStats; DoUpdate: Boolean);
        procedure SelectNone(var DisplayCol: Longint; DisplayRow, MouseCol: Longint; SelectMode: TtsTextSelectMode);
        procedure SelectLargerRows(DisplayRow: Longint); virtual;
        procedure SelectSmallerRows(DisplayRow: Longint); virtual;
        procedure SelectCurrentRow(DisplayRow: Longint); virtual;
        procedure SelectLargerCols(DisplayCol: Longint);
        procedure SelectSmallerCols(DisplayCol: Longint);
        procedure SelectCurrentCol(DisplayCol: Longint);
        function  IsCellSelected(DisplayCol, DisplayRow: Longint): Boolean;
        procedure SetSelectedRow(DisplayRow: Longint; Select: Boolean);
        procedure GridStatusChanged;
        procedure MouseStatusChanged;
        procedure SetMouseStatus(Status: TtsMouseStatus);
        function  FixedColsSelected: Boolean;
        function  FixedRowsSelected: Boolean;
        function  NumberOfColsSelected(FromDisplayCol, ToDisplayCol: Longint): Longint;
        function  NumberOfRowsSelected(FromDisplayRow, ToDisplayRow: Longint): Longint;
        procedure ColFromX(X: Integer; var DisplayCol: Longint);
        procedure RowFromY(Y: Integer; var DisplayRow: Longint);
        procedure ColRowFromXY(X, Y: Integer; var DisplayCol, DisplayRow: Longint);

        {Cell range selection procedures}
        procedure DeleteRangeSelection;
        procedure ChangeCellSelection(DisplayCol, DisplayRow: Longint);
        procedure DeleteSelectedCellsCol(DisplayCol: Longint);
        procedure CheckSelectedCellsCol(DisplayCol: Longint);
        procedure DeleteSelectedCellsRow(DisplayRow: Longint);
        procedure CheckSelectedCellsRow(DisplayRow: Longint);
        procedure SelectRangeLargerRowsLargerCols(DisplayCol, DisplayRow: Longint);
        procedure SelectRangeLargerRowsSmallerCols(DisplayCol, DisplayRow: Longint);
        procedure SelectRangeSmallerRowsLargerCols(DisplayCol, DisplayRow: Longint);
        procedure SelectRangeSmallerRowsSmallerCols(DisplayCol, DisplayRow: Longint);
        procedure LeftRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure LeftUpRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure UpRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure RightUpRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure RightRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure RightDownRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure DownRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure LeftDownRangeSelecting(CurrentPos, CheckPos: TPoint);
        procedure DeleteInversionAtNewRange(DisplayCol, DisplayRow: Longint);
        procedure StartCellSelection(DisplayCol, DisplayRow: Longint);

        {Column and row change procedures}
        procedure CheckTopLeftChanged(ByUser: Boolean); virtual;
        procedure TopLeftChangedEvent(OldCol, OldRow, NewCol, NewRow: Longint;
                                      ByUser: Boolean); virtual; abstract;
        function  CheckColChanged(var OldCol: Longint): Boolean;
        function  CheckRowChanged(var OldRow: Variant): Boolean; virtual;
        procedure ActivateCellChanged(OldCol: Integer; OldRow: Variant); virtual;
        procedure CheckRowColChanged;

        {Column and row moving procedures}
        procedure LeftColMoving(CurrentPos, CheckPos: TPoint);
        procedure RightColMoving(CurrentPos, CheckPos: TPoint);
        procedure UpRowMoving(CurrentPos, CheckPos: TPoint);
        procedure DownRowMoving(CurrentPos, CheckPos: TPoint);
        procedure ChangeDisplayCol(FromDisplayCol, ToDisplayCol: Longint);
        procedure MoveVisibleCol(FromDisplayCol, ToDisplayCol: Longint);
        procedure UpdateVisibleCols;
        procedure ChangeColWidths(FromDisplayCol, ToDisplayCol: Longint);
        function  DiffSelectedCols(DisplayCol, FromDisplayCol: Longint): Longint;
        procedure MoveColRangeLeft(FromDisplayCol, ToDisplayCol: Longint);
        procedure MoveColRangeRight(FromDisplayCol, ToDisplayCol: Longint);
        procedure MoveColRange(FromDisplayCol, ToDisplayCol: Longint);
        procedure ChangeDisplayRow(FromDisplayRow, ToDisplayRow: Longint);
        procedure MoveVisibleRow(FromDisplayRow, ToDisplayRow: Longint);
        procedure UpdateVisibleRows;
        procedure ChangeRowHeights(FromDisplayRow, ToDisplayRow: Longint);
        function  DiffSelectedRows(DisplayRow, FromDisplayRow: Longint): Longint;
        procedure MoveRowRangeUp(FromDisplayRow, ToDisplayRow: Longint);
        procedure MoveRowRangeDown(FromDisplayRow, ToDisplayRow: Longint);
        procedure MoveRowRange(FromDisplayRow, ToDisplayRow: Longint);
        procedure ChangeSelectedCols(FromDisplayCol, ToDisplayCol: Longint);
        procedure ChangeSelectedRows(FromDisplayRow, ToDisplayRow: Longint);
        procedure ChangeCurrentColPosition(FromDisplayCol, ToDisplayCol: Longint);
        procedure ChangeCurrentRowPosition(FromDisplayRow, ToDisplayRow: Longint);
        procedure DrawColMove;
        procedure StartColMoving(Column: Longint);
        procedure EndColMoving(Move: Boolean);
        procedure DrawRowMove;
        procedure StartRowMoving(DisplayRow: Longint);
        procedure EndRowMoving(Move: Boolean);
        procedure EndColSelecting(Select: Boolean);
        procedure EndRowSelecting(Select: Boolean); virtual;
        procedure EndCellSelecting(Select: Boolean);

        {Scrolling procedures}
        function  GetMaxScrollHeight: Integer;
        procedure ScrollUp(Delta: Integer);
        procedure ScrollDown(Delta: Integer);
        procedure ScrollWindow(DX, DY: Integer; var DrawInfo: TGridDrawInfo);
        procedure ScrollRowSelect(Delta: Integer);
        procedure MoveViewLeft(CurrentPos, CheckPos: TPoint);
        procedure MoveViewRight(CurrentPos, CheckPos: TPoint);
        procedure MoveViewDown(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
        procedure MoveViewUp(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
        procedure MoveView(Direct: TtsMoveDirection; var LastCol, LastRow: Longint);
        function  WaitingTime(X, Y: Integer; Direction: Integer): Integer;
        function  ScrollDelay(X, Y: Integer; Direction: Integer): Boolean;
        function  CheckEscape: Boolean;
        function  GetScrollWidth(Delta: Integer) : Integer;
        function  GetScrollHeight(Delta: Integer) : Integer;
        procedure ScrollLeft(Delta: Integer);
        procedure ScrollRight(Delta: Integer);
        procedure ScrollControlVertical(Delta: Integer);
        procedure ScrollControlHorizontal(Delta: Integer);
        procedure ScrollControl(DX, DY: Integer; var DrawInfo: TGridDrawInfo);
        procedure ScrollRect(Left, Top, Right, Bottom: Integer; Delta: Integer; Horz: Boolean);
        function  ScrollRows(X, Y: integer; var DisplayCol, DisplayRow: Longint): Boolean; virtual;
        function  ScrollCols(X, Y: integer; var DisplayCol, DisplayRow: Longint): Boolean;
        function  CalcVertScrollBar(ScrollCode, Pos: Integer): Longint;
        procedure ModifyVertScrollBar(var Msg: TWMVScroll);
        function  CalcHorzScrollBar(ScrollCode, Pos: Integer): Longint;
        procedure ModifyHorzScrollBar(var Msg: TWMVScroll);
        procedure SetControlRect(DisplayCol, DisplayRow: Longint);
        procedure SetRowSelectRect(DisplayRow: Longint);
        procedure SetScrollMode(Mode: TtsScrollMode);
        procedure ResetScrollMode;
        function  EditScrollMode: TtsScrollMode;
        procedure ScrollGrid(NewLeft, NewTop: Longint; ScrollMode: TtsScrollMode);

        {Scrollbar procedures}
        function  GetHorzScrollPos: Integer;
        procedure UpdateScrollRange; virtual;
        procedure GetHorzScrollRange(var ScrollCols, ScrollRange, StartCol,
                                     EndCol: Longint; var OutsideMaxRange: Boolean);
        procedure GetVertScrollRange(var ScrollRows, ScrollRange, StartRow,
                                     EndRow: Longint; var OutsideMaxRange: Boolean); virtual;
        function  GetVertScrollPos: Integer; virtual;
        procedure UpdateScrollPos; virtual;
        function  ShowHorzScrollBar(MaxWidth: Integer): Boolean; virtual;
        function  ShowVertScrollBar(MaxHeight: Integer): Boolean; virtual;
        function  CanShowHorzScrollBar: Boolean; virtual;
        function  CanShowVertScrollBar: Boolean; virtual;
        function  GetHorzScrollBarVisible: Boolean;
        function  GetVertScrollBarVisible: Boolean;
        function  VertScrollPageSize(ScrollRange, ScrollCount, EndRow: Longint): Integer; virtual;
        function  CurrentScrollInfo(ScrollBar: Integer): TScrollInfo;
        procedure GetScrollBarInfo(ScrollBar: Integer; var OldInfo, NewInfo: TScrollInfo);
        function  AlwaysShowHorzScrollBar: Boolean;
        function  AlwaysShowVertScrollBar: Boolean;
        procedure SetHorzVisible(Value: Boolean);
        procedure SetVertVisible(Value: Boolean);
        function  GetHorzScrollBarHeight: Integer;
        function  GetVertScrollBarWidth: Integer;

        {Mouse procedures}
        procedure MouseMessageToControl(Capture: Boolean);
        procedure SetMouseDownColRow(DisplayCol, DisplayRow: Longint); virtual;
        procedure SetMouseUpColRow(DisplayCol, DisplayRow: Longint); virtual;
        function  ClickPos(DataCol, DataRow: Longint): TtsClickPosition;
        procedure ClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp: Longint);
        function  CheckClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp: Longint;
                                 DownPos, UpPos: TtsClickPosition): Boolean; virtual;
        function  CanSelect(DisplayCol, DisplayRow: Longint): Boolean;
        function  InDragArea(DisplayCol, DisplayRow: Longint): Boolean;
        function  ShapeCursor(X, Y: integer; DisplayCol, DisplayRow: Longint): HCursor; virtual;
        procedure MouseMoveRangeSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
        procedure MouseMoveColSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
        function  CheckMouseOverGrid(X, Y: Integer): Boolean;
        procedure MouseMoveRowSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
        procedure ChangeColMovePos(DisplayCol: Longint);
        procedure MouseMoveColMoving(X, Y: Integer; DisplayCol, DisplayRow: Longint);
        procedure ChangeRowMovePos(DisplayRow: Longint);
        procedure MouseMoveRowMoving(X, Y: Integer; DisplayCol, DisplayRow: Longint);
        procedure MouseMoveSetPosition(X, Y: integer; var NewX, NewY: Integer;
                                       var DisplayCol, DisplayRow: Longint);
        procedure CancelMouseAction;
        function  MouseOverButton(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
        procedure CheckMousePosition;
        function  SpinTimerActive: Boolean;
        function  ResetSpinTimer: Boolean;
        procedure SpinTimerEvent;
        function  MouseOverCombo(X, Y: Integer): Boolean;
        procedure DblClickCell(DataCol, DataRow: Longint); virtual;
        procedure MouseMoveButtonDown(X, Y: Integer; DisplayCol, DisplayRow: Longint);
        procedure MouseMoveDrawButton(X, Y: Integer; DisplayCol, DisplayRow: Longint);
        function  CheckMoveCol(Shift: TShiftState; Key: Word): Boolean;
        function  CheckMoveRow(Shift: TShiftState; Key: Word): Boolean;
        function  MDSizing(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
        procedure MDRangeSelecting(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint); virtual;
        procedure MDRowSelect(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint); virtual;
        procedure MDColSelect(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
        procedure MDSelectNone(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
        function  DblClickSelectNone(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
        procedure MDSelectAll(WithMouse: Boolean); virtual;
        procedure MDButtonDown(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
        procedure MUResizedCol(X, Y: Integer; Resize: Boolean);
        procedure MUResizedRow(X, Y: Integer; Resize: Boolean);
        procedure MUButtonUp(X, Y: Integer);
        procedure MUHeadingUp(Button:TMouseButton; X, Y: Integer);

        {Keyboard Procedures}
        procedure SetCanProcessKey(Value: Boolean);
        function  GetCanProcessKey: Boolean;
        procedure MoveRowIntoView(DisplayRow: Longint; var NewTopRow: Longint);
        procedure MoveColToRight(DisplayCol: Longint; var NewLeftCol: Longint);
        procedure MoveRowToBottom(DisplayRow: Longint; var NewTopRow: Longint);
        function  MoveToDisplayCol(StartCol, DisplayCol: Longint; Position: TtsViewPosition): Longint;
        procedure PutInView(DisplayCol, DisplayRow: Longint; Position: TtsViewPosition;
                            ResetCurrent, SetCurPos: Boolean; ChangeTopLeft: TtsChangeTopLeft);
        function  CalcNewTopRowVK_Next(NewCurrentRow: Longint): Longint;
        function  CurrentPosInView: Boolean;
        procedure BackToCurrentCell(MoveCol, MoveRow: Boolean);
        procedure CtrlKeyDown(var Key: Word);
        procedure KeyCtrl_Left;
        procedure KeyCtrl_Right;
        procedure KeyDownVK_Up; virtual;
        procedure VK_UpRowSelect; virtual;
        procedure KeyDownVK_Down; virtual;
        procedure VK_DownRowSelect; virtual;
        procedure KeyDownVK_Prior; virtual;
        procedure KeyDownVK_Next; virtual;
        procedure KeyCtrl_Up; virtual;
        procedure KeyCtrl_Down; virtual;
        procedure KeyCtrl_Home; virtual;
        procedure KeyCtrl_End; virtual;
        procedure KeyDownVK_Tab(Key: Word); virtual;
        procedure ShiftKeyDownVK_Tab; virtual;
        function  KeydownVK_Escape: Boolean; virtual;
        procedure ProcessKeyDown(var Key: Word; Shift: TShiftState); virtual;
        procedure ProcessKeyDownCombo(var Key: Word; Shift: TShiftState);
        procedure ProcessKeyDownDateTime(var Key: Word; Shift: TShiftState);
        procedure ProcessKeyDropDownList(var Key: Char);
        function  CanDropDown(DataCol, DataRow: Longint; Buttons: TtsButtonTypes): Boolean;
        function  KeyDropDownCombo: Boolean;
        function  KeyDropDownDateTime: Boolean;
        function  KeyDropDown: Boolean;

        {Visible/ReadOnly procedures}
        function  MinLeftCol: Longint;
        function  MinTopRow: Longint;
        function  GetVisibleLeftCol(ALeft: Longint; var NewLeft: Longint): Boolean;
        function  GetVisibleTopRow(ATop: Longint; var NewTop: Longint): Boolean;
        function  MaxVisibleCol: Longint;
        function  MaxVisibleRow: Longint;
        function  GetMaxLeftCol: Longint;
        function  GetMaxTopRow: Longint;
        function  GetMaxScrollRow: Longint;
        function  GetMaxScrollCol: Longint;
        function  GetMaxTopLeft: TGridCoord;
        procedure MoveTopLeft(ALeft, ATop: Longint); override;
        function  CanMoveToPos(DisplayCol, DisplayRow: Longint): Boolean; virtual;
        procedure CheckTopLeft(DoPaint: Boolean);
        function  CompVisibleCols(StartCol: Longint): Longint;
        function  PrevVisibleCols: Longint;
        function  CompVisibleRows(StartRow: Longint): Longint;
        function  PrevScrollRows: Longint;
        function  VisibleScrollRows: Longint;
        function  PrevScrollCols: Longint;
        function  VisibleScrollCols: Longint;
        function  LastVisibleCol(StartCol: Longint): Longint;
        function  LastVisibleRow(StartRow: Longint): Longint;
        function  CellIsReadOnly(DataCol: Longint; DataRow: Longint): Boolean;
        function  CanEditCol(DataCol: Longint): Boolean;
        function  CanEditRow(DataRow: Longint): Boolean;
        function  CanEditCell(DataCol, DataRow: Longint): Boolean;
        function  GetNextCol(DisplayCol: Longint; CheckEdit, CheckSelect: Boolean; var NewCol: Longint): Boolean;
        function  GetPrevCol(DisplayCol: Longint; CheckEdit, CheckSelect: Boolean; var NewCol: Longint): Boolean;
        function  LeftMostCol(CheckEdit, CheckSelect: Boolean): Longint;
        function  LeftMostScrollCol: Longint;
        function  RightMostCol(CheckEdit, CheckSelect: Boolean): Longint;
        function  GetNextRow(DisplayRow: Longint; CheckEdit, CheckSelect: Boolean; var NewRow: Longint): Boolean;
        function  GetPrevRow(DisplayRow: Longint; CheckEdit, CheckSelect: Boolean; var NewRow: Longint): Boolean;
        function  TopMostRow(CheckEdit, CheckSelect: Boolean): Longint;
        function  TopMostScrollRow: Longint;
        function  BottomMostRow(CheckEdit, CheckSelect: Boolean): Longint;
        function  GetNextCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                              var NewCol, NewRow: Longint): Boolean;
        function  GetNextDownCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                  var NewCol, NewRow: Longint): Boolean;
        function  GetPrevCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                              var NewCol, NewRow: Longint): Boolean;
        function  GetNextUpCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                var NewCol, NewRow: Longint): Boolean;
        procedure MoveToNewCol(DisplayCol: Longint; ClearFocus, CheckEdit, CheckSelect: Boolean);
        procedure MoveToNewRow(DisplayRow: Longint; ClearFocus, CheckEdit, CheckSelect: Boolean); virtual;
        procedure CheckRowColPos;
        procedure SetNewCurrentCell(DataCol, DataRow: Longint);

        {Resizing procedures}
        function  InResizing: Boolean;
        function  NextSizingCol(DisplayCol: Longint): Longint;
        procedure CalcColSizingState(X, Y: Integer; var State: TtsMouseStatus);
        function  NextSizingRow(DisplayRow: Longint): Longint;
        procedure CalcRowSizingState(X, Y: Integer; var State: TtsMouseStatus);
        function  GetSizingState(X, Y: Integer; DisplayCol, DisplayRow: Longint): TtsMouseStatus;
        procedure MouseDownResize;
        procedure DrawSizingLine;
        function  RowsInView(NewHeight: Integer; FixedHeight: Integer): integer;
        function  ColsInView(NewWidth: Integer): integer;
        procedure SetNewTopRow(DisplayRow: Longint; NewHeight: Integer; OldTop: Integer); virtual;
        procedure SetNewLeftCol(DisplayCol: Longint; NewWidth: Integer; OldLeft: Integer);
        procedure ChangeAllRowHeights(NewHeight: integer; SetNewTop: Boolean);
        procedure ChangeAllColWidths(NewWidth: integer; SetNewLeft: Boolean);
        procedure CheckRowHeights(var NewHeight: Integer);
        procedure CheckColWidths(var NewWidth: Integer);
        function  RowBarSizingArea: TRect;
        function  HeadingSizingArea: TRect;
        procedure SingleColWidthChanged(DisplayCol: Longint);
        procedure SingleRowHeightChanged(DisplayRow: Longint);
        procedure ColResized(DataCol: Longint); virtual;
        procedure RowResized(DataRow: Longint); virtual;
        procedure ResizeRowChanged;
        function  ResizeCol(DisplayCol: Longint; Value: Integer): Boolean;
        function  ResizeRow(DisplayRow: Longint; Value: Integer; bDeleteInProgress : Boolean = False): Boolean;
        procedure ScaleRows(M, D: Integer; Flags: TScalingFlags); virtual;
        procedure ScaleCols(M, D: Integer; Flags: TScalingFlags); virtual;
        procedure ScaleCells(M, D: Integer; Flags: TScalingFlags); virtual;

        {In memory canvas procedures}
        procedure SetGridDc(Dc: Hdc);
        procedure ResetGridDc;
        function  PrepareCanvas(ClipRect: TRect): Boolean;
        procedure CanvasToScreen(ClipRect: TRect);
        procedure RestoreHandle;
        function  BmpHandleNeeded(Bitmap: TBitmap): Hdc;

        {Create/Destroy/Assign procedures}
        procedure CreateDefaultValues;
        procedure CreateDefaultColNumber(OldColCount: Longint);
        procedure CreateDefaultRowNumber(OldRowCount: Longint);
        procedure ResizeVisibleCols(OldSize: Longint);
        procedure ResizeVisibleRows(OldSize: Longint);
        function  CreateCols: TtsGridCols; virtual;
        function  CreateRows: TtsGridRows; virtual;
        function  CreateCurrentCell: TtsCurrentCell; virtual;
        procedure CreateRowColSelections;
        procedure SetGridControlParent; virtual;
        procedure CreateGridControls; virtual;
        procedure CreateWnd; override;
        procedure CreateNullRect;
        function  DefaultColCount: Longint;
        function  DefaultRowCount: Longint;
        procedure SetControlEvents(GridControl: TtsCustomGridControl);
        procedure AssignDisplayCols(Source: TtsBaseGrid);
        procedure ActivateMovedCols(MovedCols: TBits);
        procedure AssignColWidths;
        procedure AssignColProperties(Source: TtsBaseGrid); virtual;
        procedure AssignDisplayRows(Source: TtsBaseGrid);
        procedure ActivateMovedRows(MovedRows: TBits);
        procedure AssignRowHeights;
        procedure AssignRowProperties(Source: TtsBaseGrid); virtual;
        procedure AssignChangedRows(Source: TtsBaseGrid); virtual;
        procedure AssignCellProperties(Source: TtsBaseGrid); virtual;
        procedure AssignProperties(Source: TtsBaseGrid; ExcludeProps: string); virtual;
        procedure AssignGridData(Source: TtsBaseGrid); virtual;
        procedure AssignPropKinds(Source: TtsBaseGrid; PropKinds: TtsPropKinds; AssignData: Boolean); virtual;
        procedure ResetPropKinds(PropKinds: TtsPropKinds);
        procedure CheckGridStatus; virtual;
        procedure AssignColSelections(Source: TtsBaseGrid); virtual;
        procedure AssignRowSelections(Source: TtsBaseGrid); virtual;
        procedure AssignCellSelections(Source: TtsBaseGrid); virtual;
        procedure AssignSelections(Source: TtsBaseGrid; PropKinds: TtsPropKinds); virtual;
        procedure DeleteAllCellProperties;
        procedure DeleteRowColProperties;
        function  CreateCellElement(DataCol: Longint; DataRow: Variant): TtsCustomElement; virtual;

        {Data storage procedures}
        function  ControlDataType(ControlType: TtsControlType; Value: Variant): TtsValueType;
        function  ControlDataTypeOk(ControlType: TtsControlType; DataType: TtsValueType): Boolean;
        function  CheckPictureValue(DataCol, DataRow: Longint; ControlType: TtsControlType; Value: Variant): Variant;
        function  GetDataValue(DataCol, DataRow: Longint; ControlType: TtsControlType): Variant;
        function  ImageListIndex(ImageList: TtsImageListComponent): Integer;
        procedure SetDataValue(DataCol, DataRow: Longint; ControlType: TtsControlType; Value: Variant);
        procedure FreeGridData;
        procedure CheckGridData(DataCol, DataRow: Longint);
        procedure DeleteColData(FromDataCol, ToDataCol: Longint);
        procedure DeleteRowData(FromDataRow, ToDataRow: Longint);

        {Read/Write procedures}
        function  DoColWidths: Boolean;
        procedure WriteColWidths(Writer: TWriter);
        procedure WriteRowHeights(Writer: TWriter);
        procedure ReadColWidths(Reader: TReader);
        procedure ReadRowHeights(Reader: TReader);
        function  CreateColCollection(Writing: Boolean): TtsColCollection; virtual;
        function  CreateRowCollection(Writing: Boolean): TtsPropCollection; virtual;
        procedure AddCellProps(Cells: TtsCellCollection; Node: TtsSetNode);
        function  CreateCellCollection(Writing: Boolean): TtsCellCollection; virtual;
        procedure WriteColumns(Writer: TWriter); virtual;
        procedure ReadColCollection(Reader: TReader; ColMatch: TtsColMatch);
        procedure ReadColumns(Reader: TReader); virtual;
        procedure WriteRows(Writer: TWriter); virtual;
        procedure ReadRows(Reader: TReader); virtual;
        procedure WriteCells(Writer: TWriter); virtual;
        procedure ReadCells(Reader: TReader); virtual;
        procedure ReadEditMode(Reader: TReader); virtual;
        procedure ReadHeadingAlignment(Reader: TReader); virtual;
        procedure WriteImageListIds(Writer: TWriter);
        procedure ReadImageListIds(Reader: TReader);
        procedure WriteData(Stream: TStream); virtual;
        procedure ReadData(Stream: TStream); virtual;
        function  DoColProps(Ancestor: TPersistent): Boolean; virtual;
        function  DoRowProps(Ancestor: TPersistent): Boolean; virtual;
        function  DoCellProps(Ancestor: TPersistent): Boolean; virtual;
        procedure DefineProperties(Filer: TFiler); override;
        procedure Loaded; override;
        procedure SetSaveAllProps(Value: Boolean);
        function  GetSaveAllProps: Boolean;
        function  StoreCols: Boolean; virtual;
        function  StoreRows: Boolean; virtual;

        procedure SetXMLExport(Value : TosXMLExport);

        {$IFNDEF TSVER_V3}
        function  StoreColProps: Boolean; virtual;
        function  StoreRowProps: Boolean; virtual;
        function  StoreCellProps: Boolean; virtual;
        {$ENDIF}

        function  CreateStreamComponent: TtsGridStreamComponent; virtual;
        function  ReadStreamFromRegistry(Registry: TRegistry; ValueName: string; ColMatch: TtsColMatch): Boolean;
        function  ReadFileFromRegistry(Registry: TRegistry; ValueName: string; ColMatch: TtsColMatch): Boolean;

        {Column and row delete/insert procedures}
        procedure DeleteAutoFontCol(DataCol: Longint);
        procedure DeleteAllAtCol(DataCol: Longint; MaxCol: Longint);
        procedure DeleteAutoFontRow(DataRow: Longint);
        procedure DeleteAllAtRow(DataRow: Longint; MaxRow: Longint);
        procedure RowInserted(DataRow: Longint; ByUser: Boolean); virtual; abstract;
        procedure RowDeleted(DataRow: Longint; ByUser: Boolean); virtual; abstract;
        function  AddColumn(DisplayCol: Longint): Boolean;
        procedure CheckRowCountChanged(OldCount, NewCount: Longint); virtual;
        procedure CheckFixedCols;
        procedure SetNewColCount(Value: Longint);
        procedure CheckFixedRows;
        procedure SetNewRowCount(Value: Longint);
        procedure AddToPropList(Cell: TtsCellElement);
        procedure DeleteFromPropList(Cell: TtsCellElement);

        {Editing procedures}
        procedure ResetChangedRowStatus;
        function  InRowSelectMode: Boolean;
        procedure SetEnableStartEdit(Value: Boolean);
        function  GetEnableStartEdit: Boolean;
        function  IsInsertRow(DisplayRow: Longint): Boolean;
        function  IsAppendRow(DisplayRow: Longint): Boolean;
        procedure SetInsertionRow(Value: Integer);
        procedure ShowInsertionRow;
        procedure CheckInsertionRow(CanInvalidate: Boolean);
        procedure SetInsertRowOn; virtual;
        procedure SetInsertRowOff; virtual;
        function  StartCellChange(DataCol: Longint; SetModified: Boolean): Boolean; virtual;
        function  InEditMode: Boolean;
        function  InGridMode: Boolean;
        function  InEditState: Boolean;
        function  InGridState: Boolean;
        function  CanSkipReadOnly: Boolean;
        function  CheckEndEdit(NewDataCol, NewDataRow: Longint; ByUser: Boolean): Boolean; virtual;
        function  StartEdit: Boolean;
        function  StartCellEdit: Boolean; virtual;
        function  StartRowEdit: Boolean; virtual;
        procedure CellEdit(DataCol, DataRow: Longint; ByUser: Boolean); virtual;
        function  EndCellEdit: Boolean; virtual;
        function  CheckMaskValue: Boolean; virtual;
        function  EndRowEdit: Boolean; virtual;
        function  CanEndEdit(ByUser: Boolean): Boolean; virtual;
        function  CanEndCellEdit(ByUser: Boolean): Boolean; virtual;
        function  CanEndRowEdit(ByUser: Boolean): Boolean; virtual;
        function  UndoCellEdit(ByUser: Boolean): Boolean; virtual;
        function  UndoRowEdit(ByUser: Boolean; RowEditing: Boolean): Boolean; virtual;
        procedure UndoInsertRow;
        function  CheckUndoRowEdit(UndoAll: Boolean; var RowEditing: Boolean): Boolean; virtual;
        function  UndoEdit(UndoAll: Boolean; ByUser: Boolean; var Restore, UndoDone: Boolean): Boolean;
        procedure ResetEdit(DataRow: Longint);
        procedure ResetCellEdit;
        procedure ControlValueChanged(Edit, ByUser, TextAdded: Boolean);
        function  CalcTextHeight: Integer;
        procedure ComputeTextSize(DataCol: Longint; DrawWidth: Integer; Value: string; Font: TFont; Alignment: TAlignment; WordWrap: TtsWordWrap;
                                  ButtonType: TtsButtonType; var TextLines, TextHeight: Integer);
        procedure GetTextSize(DataCol: Longint; DataRow: Variant; var TextLines, TextHeight: Integer); virtual;
        procedure GetHeadingTextSize(DataCol: Longint; var TextLines, TextHeight: Integer);
        function  CheckStrValue(ControlType: TtsControlType; const Value: Variant): Variant;
        procedure CheckSetMask(DataCol: Longint; DataRow: Variant); virtual;
        function  CopyCellToClipboard: Boolean;
        function  CutCellToClipboard: Boolean;
        function  PasteCellFromClipboard: Boolean;
        function  IncrementPictureValue(DataCol, DataRow: Longint; SpinButton: TtsSpinButton): Variant;
        procedure CheckIncrementValue(DataCol, DataRow: Longint; var Value: Variant; var Pos, Len: Integer);
        function  IncrementTextValue(DataCol, DataRow: Longint; SpinButton: TtsSpinButton; var Pos, Len: Integer): Variant;
        procedure CheckSpinIncrement(DataCol, DataRow: Longint; SpinButton: TtsSpinButton); virtual;

        {Button procedures}
        function  ValidButton(X, Y: Integer; DisplayCol, DisplayRow: Longint; ButtonType: TtsButtonType): Boolean;
        procedure ResetButtonUp;
        procedure ResetButtonDown;
        procedure ResetButton;
        procedure CheckResetButtons;
        function  ButtonColor(DisplayCol, DisplayRow: Longint): TColor;
        procedure ButtonClick(DataCol, DataRow: Longint); virtual;
        procedure ButtonDown(DataCol, DataRow: Longint); virtual;
        procedure ButtonUp(DataCol, DataRow: Longint); virtual;
        procedure SpinButtonClick(DataCol, DataRow: Longint; SpinButton: TtsSpinButton); virtual;
        procedure SpinButtonDown(DataCol, DataRow: Longint; SpinButton: TtsSpinButton); virtual;
        procedure SpinButtonUp(DataCol, DataRow: Longint; SpinButton: TtsSpinButton); virtual;
        procedure SpinRepeat(DataCol, DataRow: Longint; Count: Integer; SpinButton: TtsSpinButton); virtual;
        procedure SpinIncrement(DataCol, DataRow: Longint; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean); virtual;

        {Heading procedures}
        function  ButtonInColHeading(DisplayCol: Longint): Boolean;
        function  IsColHeadingButton(DisplayCol: Longint): Boolean;
        function  MouseOverHeadingButton(X, Y: Integer; DisplayCol: Longint): Boolean;
        function  CanClickHeading(X, Y: Integer; DisplayCol: Longint): Boolean;
        function  HasHeadingButtons: Boolean;
        function  GetAccelHeading(var Key: Word): Longint;
        procedure HeadingFontChange(Sender: TObject);

        {Combo box procedures}
        function  GetCombo: TtsCombo;
        function  GetComboForm: TtsDropDownForm;
        function  GetDropDownRows: Longint; virtual;
        procedure SetDropDownRows(Value: Longint); virtual;
        function  GetAutoLookup: Boolean; virtual;
        procedure SetAutoLookup(Value: Boolean); virtual;
        function  GetDropDownCols: Longint; virtual;
        procedure SetDropDownCols(Value: Longint); virtual;
        function  GetParentGrid: TtsBaseGrid; virtual;
        procedure SetParentGrid(Value: TtsBaseGrid); virtual;
        function  GetValueCol: Longint; virtual;
        function  GetValueColSorted: Boolean; virtual;
        function  GetCompareType: TtsComboCompareType; virtual;
        function  GetAutoSearch: TtsComboAutoSearchType; virtual;
        function  GetAutoFill: Boolean; virtual;
        function  GetDropDownStyle: TtsDropDownStyle; virtual;
        procedure SetValueCol(Value: Longint); virtual;
        procedure SetDisplayCol(Value: Longint); virtual;
        procedure SetValueColSorted(Value: Boolean); virtual;
        procedure SetCompareType(Value: TtsComboCompareType); virtual;
        procedure SetAutoSearch(value: TtsComboAutoSearchType); virtual;
        procedure SetAutoFill(Value: Boolean); virtual;
        procedure SetDropDownStyle(Value: TtsDropDownStyle); virtual;
        procedure SetSetComboExtents(Value: Boolean);
        function  GetSetComboExtents: Boolean;
        procedure CheckComboCreated;
        function  CreateCombo: TtsCombo; virtual;
        function  CreateComboGrid: TtsBaseGrid; virtual;
        procedure ResetComboInit(ResetCombo: Boolean);
        procedure CheckResetComboInit(Combo: TtsCombo; ResetCombo: Boolean);
        procedure ResetLastUsedCombo;
        procedure CheckLastUsedCombo(Combo: TtsCombo);
        function  GetParentGridCombo: TtsCombo; virtual;
        procedure SetParentGridCombo(Value: TtsCombo); virtual;
        function  GiveCellCombo(DataCol, DataRow: Longint): TtsCombo; virtual;
        procedure InitializeDropDownForm(Form: TtsDropDownForm); virtual;
        procedure InitializeComboSettings(ComboGrid: TtsbaseGrid); virtual;
        procedure ComboButtonDown(DataCol, DataRow: Longint);
        procedure SetComboVisible;
        function  CheckInitComboRow: Boolean; virtual;
        procedure InternalShowCombo(DataCol, DataRow: Longint);
        procedure DisplayCombo(DataCol, DataRow: Longint);
        procedure SetComboPoint;
        function  CanSetComboExtents: Boolean;
        procedure SetComboGridExtents(DropCols, DropRows: Longint); virtual;
        procedure SetComboFormExtents(ComboGrid: TtsBaseGrid); virtual;
        procedure GetComboGridExtents(DropCols, DropRows: Longint; var NewWidth, NewHeight: Integer);
        procedure UpdateComboExtents(DropCols, DropRows: Longint; Redraw: Boolean);
        procedure SetComboFormGridExtents(ComboGrid: TtsBaseGrid; NewWidth, NewHeight: Integer);
        procedure AdjustComboGridExtents(DropCols, DropRows: Longint);
        function  ComboInitWidth(DropCols: Longint): Integer; virtual;
        function  ComboInitHeight(DropRows: Longint): Integer; virtual;
        procedure InitComboColWidth(ColWidth: Integer);
        procedure InitCombo(Combo: TtsCombo); virtual;
        procedure InitComboData(CellHasCombo: Boolean); virtual;
        procedure ComboInit(DataCol, DataRow: Longint); virtual;
        procedure ComboDropDown(DataCol, DataRow: Longint); virtual;
        procedure ComboRollUp;
        procedure ActivateComboInit(DataCol, DataRow: Longint); virtual;
        procedure ActivateComboDropDown(DataCol, DataRow: Longint); virtual;
        procedure ActivateComboRollUp(DataCol, DataRow: Longint); virtual;
        procedure GetComboValue(ValueCol, DataColUp, DataRowUp: Longint; var Value: Variant); virtual;
        function  IsLookupCombo(DataCol: Integer): Boolean; virtual;
        procedure SetComboValue(Value: Variant); virtual;
        procedure ComboClickCell(Sender: TObject; DataColDown, DataRowDown, DataColUp, DataRowUp: Longint);
        function  TurnComboOff(ResetForm, DoUpdate: Boolean): Boolean;
        procedure CheckDropDownOff(ResetForm: Boolean);
        procedure PositionDropDownForm(DataCol, DataRow: Longint; AWidthHeight: TPoint; var ATopLeft: TPoint);
        procedure PositionPopupForm(DataCol, DataRow: Longint; AWidthHeight: TPoint; var ATopLeft: TPoint);
        procedure MouseCaptureToCombo;
        function  CompCaseSensitive(Value1, Value2: string; Len: Integer): Integer;
        function  CompCaseInsensitive(Value1, Value2: string; Len: Integer): Integer;
        function  CompOwn(Value1, Value2: string; Len: Integer): Integer;
        procedure SearchBinary(Top, Bottom: Longint; Cmpvalue: string; CmpFunc: TtsCompareFunction;
                               var MinCmpLen: Integer; var Row: Longint; var Found: Boolean);
        procedure SearchLinear(FromRow, ToRow: Longint; SearchValue: string;
                               var Row: Longint; var Found: Boolean; CmpFunc: TtsCompareFunction);
        procedure SetComboRow(DataRow: Longint);
        function  FindComboRow(SearchValue: string; FullCmpLen: Boolean; var Found: Boolean): Longint;
        function  FindNextComboRow(SearchValue: string; var Found: Boolean): Longint;
        function  ComboValueEqual(Value1, Value2: string): Boolean;
        procedure PositionComboRow; virtual;
        function  FindComboFirstChar(Key: Char; var Found: Boolean): Integer;
        function  FindComboString(Key: Char; var Found: Boolean): Integer;
        function  PositionDropDownList(Key: Char): Variant; virtual;
        procedure CheckSetAutoFillValue;
        procedure SetAutoFillValue(Value: Variant; ConvertCase: TtsConvertCase; CellExit: Boolean);
        function  PositionAutoFill(CellExit: Boolean): Boolean; virtual;
        function  ResetComboSearchValue: Boolean;
        procedure CheckResetComboSearchValue;
        function  CanSetFocus: Boolean; virtual;

        {DateTime procedures}
        function  GetDateTimeForm: TtsDropDownForm;
        procedure UpdateDateTime;
        function  GiveCellDateTime(DataCol, DataRow: Longint): TtsDateTimeDefComponent; virtual;
        procedure CheckCreateDateTime(DataCol, DataRow: Longint);
        procedure DateTimeInit(DataCol, DataRow: Longint; ButtonType: TtsButtonType);
        function  DateTimeControlAssigned: Boolean;
        procedure SetdateTimeFormExtents(DataCol, DataRow: Longint);
        procedure DateTimeActivate(Sender: TObject);
        procedure DateTimeClose(Sender: TObject; var Action: TCloseAction);
        procedure SetDateTimeVisible;
        function  GetCurrentDateTime: Variant; virtual;
        procedure InitDateTimeForm(DataCol, DataRow: Longint; ButtonType: TtsButtonType);
        procedure InternalShowDateTime(DataCol, DataRow: Longint);
        procedure DisplayDateTime(DataCol, DataRow: Longint);
        function  DateTimeButtonDown(DataCol, DataRow: Longint): Boolean;
        function  IsDateTimeHandle(Handle: Hwnd): Boolean;
        function  TurnDateTimeOff(ResetForm, DoUpdate: Boolean): Boolean;
        procedure ResetDateTimeInit;
        procedure CheckResetDateTimeInit(DateTime: TtsDateTimeDefComponent);
        procedure ResetLastUsedDateTime;
        procedure CheckLastUsedDateTime(DateTime: TtsDateTimeDefComponent);
        procedure GetDateTimeValue(DataCol, DataRow: Longint; var Value: Variant);
        procedure SetDateTimeSelection;
        procedure CancelDateTimeSelection;
        procedure DateTimeSelect(Sender: TObject);
        procedure DateTimeCancel(Sender: TObject);
        procedure ActivateDateTimeInit(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint); virtual;
        procedure ActivateDateTimeDropDown(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint); virtual;
        procedure ActivateDateTimeRollUp(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint); virtual;
        procedure ActivateDateTimeGetValue(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint; var Value: Variant); virtual;
        procedure DateTimeDropDown(DataCol, DataRow: Longint);
        procedure DateTimeRollUp;
        procedure RemoveDateTime(DateTime: TtsDateTimeDefComponent);
        procedure AddDateTime(DateTime: TtsDateTimeDefComponent);
        procedure RemoveRowDateTimeDef(DateTimeDef: TtsDateTimeDefComponent); virtual;
        procedure RemoveCellDateTimeDef(DateTimeDef: TtsDateTimeDefComponent); virtual;
        procedure DateTimeDefDeleted(DateTimeDef: TtsDateTimeDefComponent);

        {Overrides from parent class}
        procedure Notification(AComponent: TComponent; Operation: TOperation); override;
        procedure Paint; override;
        procedure SetParent(AParent: TWinControl); override;
        procedure SetName(const Value: TComponentName); override;
        procedure ChangeScale(M, D: Integer); override;
        procedure DoDrawCell(ACol, ARow: Longint; ARect: TRect; DrawSelected: Boolean);
        procedure DrawCell(ACol, ARow: Longint; ARect: TRect; AState: TGridDrawState); override;
        procedure ScrollDataInfo(DX, DY: Integer; var DrawInfo: TGridDrawInfo); override;
        procedure TopLeftMoved(const OldTopLeft: TGridCoord); override;
        procedure TopLeftChanged; override;
        procedure RowHeightsChanged; override;
        procedure ColWidthsChanged; override;
        procedure KeyDown(var Key: Word; Shift: TShiftState); override;
        procedure KeyUp(var Key: Word; Shift: TShiftState); override;
        procedure KeyPress(var Key: Char); override;
        procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
        procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
        {$IFDEF TSVER_V5}
        procedure DoContextPopup(MousePos: TPoint; var Handled: Boolean); override;
        {$ENDIF}
        procedure Click; override;
        procedure DblClick; override;
        procedure SetDataAllocSize(ColSize, RowSize: Longint);
        procedure SizeChanged(OldColCount, OldRowCount: Longint); override;
        {$IFDEF TSVER_V3}
        procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
        {$ELSE}
        procedure GetChildren(Proc: TGetChildProc); override;
        procedure WriteState(Writer: TWriter); override;
        procedure ReadState(Reader: TReader); override;
        {$ENDIF}          
        procedure DoEnter; override;
        procedure DoExit; override;

        procedure SetGridReport(Value : TosCustomGridReport);
        {PopupMenu Procedures}
        procedure ConfigureGridMenu; virtual;
        procedure AddGridMenuItems(aPopupMenu : TPopupMenu); virtual;
        
        {Property procedures}
        function  GetVersion: string; virtual;
        procedure SetVersion(Value: string); virtual;
        procedure SetFixedColCount(Value: Integer);
        procedure SetInternalFixedCols(Value: Integer);
        procedure SetFixedRowCount(Value: Integer);
        procedure SetInternalFixedRows(Value: Integer);
        procedure SetFixedLineColor(Value: TColor);
        procedure SetHeadingColor(Value: TColor);
        function  GetVisibleColCount: Integer;
        function  GetVisibleRowCount: Integer;
        function  GetVisibleCols: Double;
        function  GetVisibleRows: Double;
        function  GetGridRowHeights(Index: Longint): Integer;
        procedure SetDrawOverlap(Value: TtsDrawOverlap);
        function  GetCol(DataCol: Variant): TtsCol;
        function  GetDataCol(DisplayCol: Longint): Longint;
        procedure SetDataCol(DisplayCol, Value: Longint);
        function  GetDataColnr(DisplayCol: Longint): Longint;
        function  GetDataRow(DisplayRow: Longint): Longint;
        procedure SetDataRow(DisplayRow, Value: Longint);
        function  GetDataRownr(DisplayRow: Longint): Longint;
        procedure SetCheckBoxStyle(Value: TtsCheckBoxStyle);
        procedure ResizeCellPropArrays(OldColCount, OldRowCount: Longint);
        function  GetCellValue(DataCol: Longint; DataRow: Longint): Variant; virtual;
        procedure SetCellValue(DataCol: Longint; DataRow: Longint; const Value: Variant); virtual;
        procedure SetCellPText(DataCol: Longint; DataRow: Longint; Value: PChar);
        function  GetRowBarOn: Boolean;
        procedure SetRowBarOn(Value: Boolean);
        function  GetHeadingOn: Boolean;
        procedure SetHeadingOn(Value: Boolean); virtual;
        function  GetRowBarWidth: Integer;
        procedure SetRowBarWidth(Value: Integer);
        function  GetHeadingHeight: Integer;
        procedure SetHeadingHeight(Value: Integer);
        procedure SetLineColor(Value: TColor);
        function  GetGridColCount: Longint; virtual;
        procedure SetGridColCount(Value: Longint); virtual;
        function  GetGridRowCount: Longint; virtual;
        procedure SetGridRowCount(Value: Longint); virtual;
        procedure SetColSelectMode(Value: TtsColSelectMode);
        function  GetRowSelectMode: TtsRowSelectMode;
        function  GetCurrentSelected: Boolean; virtual;
        function  GetStartRowSelected: Boolean; virtual;
        procedure SetCurrentSelected; virtual;
        procedure SetRowSelectMode(Value: TtsRowSelectMode);
        function  GetCellSelectMode: TtsCellSelectMode; virtual;
        procedure SetCellSelectMode(Value: TtsCellSelectMode); virtual;
        procedure SetGridLines(Value: TtsGridLines);
        procedure SetThumbTracking(Value: Boolean);
        procedure SetIs3D(Value: Boolean);
        procedure SetEditColor(Value: TColor);
        procedure SetEditFontColor(Value: TColor);
        procedure SetHeading3D(Value: Boolean);
        procedure SetSelectFixed(Value: Boolean);
        procedure SetCurrentDataRow(Value: Longint);
        function  GetCurrentDataRow: Longint;
        procedure SetCurrentDataCol(Value: Longint);
        function  GetCurrentDataCol: Longint;
        procedure SetCheckBoxOnBitmap(Bmp : TBitmap);
        procedure SetCheckBoxOffBitmap(Bmp : TBitmap);
        procedure SetCheckBoxGrayedBitmap(Bmp : TBitmap);
        procedure SetMaxTextLength(DisplayCol: Longint; MaxLen: Integer);
        procedure SetWantTabs(Value: Boolean);
        procedure SetFlatButtons(Value: Boolean);
        procedure SetRowBarIndicator(Value: Boolean);
        procedure SetInactiveButtonState(Value: TtsInactiveButtonState);
        procedure SetButtonEdgeWidth(Value: Integer);
        procedure SetDefaultButtonWidth(Value: Integer);
        procedure SetDefaultButtonHeight(Value: Integer);
        procedure SetSpinButtonWidth(Value: Integer);
        procedure SetSpinButtonHeight(Value: Integer);
        procedure SetHeadingButton(Value: TtsHeadingButton);
        procedure SetHeadingAlignment(Value: TAlignment);
        procedure SetHeadingHorzAlignment(Value: TtsHorzAlignment);
        procedure SetHeadingVertAlignment(Value: TtsVertAlignment);
        procedure SetHorzAlignment(Value: TtsHorzAlignment);
        procedure SetVertAlignment(Value: TtsVertAlignment);
        procedure SetRowBarAlignment(Value: TtsVertAlignment);
        procedure SetHeadingWordWrap(Value: TtsWordWrap);
        function  GridModeToEditMode(Value: TtsGridMode): TtsEditMode;
        function  EditModeToGridMode(Value: TtsEditMode): TtsGridMode;
        function  EditModeStrValue(Value: string): TtsEditMode;
        procedure SetEditMode(Value: TtsEditMode); virtual;
        procedure SetGridMode(Value: TtsGridMode); virtual;
        procedure SetAlwaysShowEditor(Value: Boolean);
        procedure SetAlwaysShowFocus(Value: Boolean);
        procedure SetSkipReadOnly(Value: Boolean);
        procedure SetRowChangedIndicator(Value: TtsRowChangedIndicator); virtual;
        procedure SetScrollBars(Value: TScrollStyle);
        procedure SetWordWrap(Value: TtsWordWrap);
        procedure SetReadOnlyButton(Value: Boolean);
        procedure SetHeadingFont(Value: TFont);
        procedure SetHeadingParentFont(Value: Boolean);
        function  GetMaskDefs: TtsMaskDefsComponent; virtual;
        procedure SetMaskDefs(Value: TtsMaskDefsComponent); virtual;
        function  GetImageList: TtsImageListComponent;
        procedure SetImageList(Value: TtsImageListComponent);
        procedure SetStretchPicture(Value: Boolean);
        procedure SetShrinkPicture(Value: Boolean);
        procedure SetCenterPicture(Value: Boolean);
        procedure SetTransparentColor(Value: TColor);
        procedure SetKeepAspectRatio(Value: Boolean);
        function  GetInDesignMode: Boolean;
        procedure SetInDesignMode(Value: Boolean);
        procedure SetStoreData(Value: Boolean); virtual;
        procedure SetSelectionColor(Value: TColor);
        procedure SetSelectionFontColor(Value: TColor);
        procedure SetSelectionType(Value: TtsSelectionType);
        procedure SetFocusBorder(Value: TtsFocusBorder);
        procedure SetFocusColor(Value: TColor);
        procedure SetFocusBorderColor(Value: TColor);
        procedure SetFocusFontColor(Value: TColor);
        function  GetDrawBitmap: TBitmap;
        function  GetPictureColorMask: TBitmap;
        procedure SetDateTimeDef(Value: TtsDateTimeDefComponent);
        procedure SetCheckBoxValues(Value: string);
        procedure SetAlwaysShowScrollBar(Value: TScrollStyle);
        function  GetAutoScale: Boolean;
        procedure SetAutoScale(Value: Boolean);

        {Event procedures}
        function  DoClickCell(DataColDown: Longint; DataRowDown: Variant; DataColUp: Longint;
                              DataRowUp: Variant; DownPos, UpPos: TtsClickPosition): Boolean; virtual; abstract;
        procedure DoButtonClick(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoButtonDown(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoButtonUp(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoSpinButtonClick(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); virtual; abstract;
        procedure DoSpinButtonDown(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); virtual; abstract;
        procedure DoSpinButtonUp(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); virtual; abstract;
        procedure DoSpinRepeat(DataCol: Longint; DataRow: Variant; Count: Integer; SpinButton: TtsSpinButton); virtual; abstract;
        procedure DoSpinIncrement(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean); virtual; abstract;
        procedure DoCanStartDrag; virtual;
        procedure DoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean); virtual; abstract;
        procedure DoColChanged(OldCol, NewCol: Longint); virtual;
        procedure DoColCountChanged(OldCount, NewCount: Longint); virtual;
        procedure DoColMoved(ToDisplayCol, Count: Longint; ByUser: Boolean); virtual;
        procedure DoColResized(DataCol: Longint); virtual;
        procedure DoComboCompareValue(ComboString, CurrentCellString: string; var CompareRes: Integer); virtual;
        procedure DoKeyDown(var Key: Word; Shift: TShiftState); virtual;
        procedure DoKeyUp(var Key: Word; Shift: TShiftState); virtual;
        procedure DoKeyPress(var Key: Char); virtual;
        procedure DoComboLCompareValue(ComboString, CurrentCellString: string; Len: Integer; var CompareRes: Integer); virtual;
        procedure DoComboDropDown(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoComboGetValue(GridDataCol: Longint; GridDataRow, ComboDataRow: Variant; var Value: Variant); virtual; abstract;
        procedure DoComboInit(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoComboRollUp(DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoDateTimeInit(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoDateTimeDropDown(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoDateTimeRollUp(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); virtual; abstract;
        procedure DoDateTimeGetValue(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant; var Value: Variant); virtual; abstract;
        procedure DoDblClickCell(DataCol: Longint; DataRow: Variant; Pos: TtsClickPosition); virtual; abstract;
        procedure DoDeleteCol(DataCol: Longint; ByUser: Boolean); virtual;
        procedure DoEndCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); virtual; abstract;
        procedure DoEndRowEdit(DataRow: Variant; var Cancel: Boolean); virtual; abstract;
        procedure DoInvalidMaskValue(DataCol: Longint; DataRow: Variant; var Accept: Boolean); virtual; abstract;
        procedure DoInvalidMaskEdit(Keys: string; DataCol: Longint; DataRow: Variant; var Accept: Boolean); virtual; abstract;
        procedure DoGridStatusChanged(OldStatus, NewStatus: TtsGridStatus); virtual;
        procedure DoEditTextResized(ByUser: Boolean); virtual;
        procedure DoPaint; virtual;
        procedure DoResize; virtual;
        procedure DoHeadingClick(DataCol: Longint); virtual;
        procedure DoHeadingDown(DataCol: Longint; Button: TMouseButton); virtual;
        procedure DoHeadingUp(DataCol: Longint; Button: TMouseButton); virtual;
        procedure DoInsertCol(DataCol: Longint; ByUser: Boolean); virtual;
        procedure DoMouseStatusChanged(OldStatus, NewStatus: TtsMouseStatus); virtual;
        procedure DoCellChanged(OldDataCol, NewDataCol: Longint; OldDataRow, NewDataRow: Variant); virtual; abstract;
        procedure DoRowChanged(OldDataRow, NewDataRow: Variant); virtual; abstract;
        procedure DoRowCountChanged(OldCount, NewCount: Longint); virtual;
        procedure DoRowLoaded(DataRow: Variant); virtual; abstract;
        procedure DoRowMoved(ToDisplayRow, Count: Longint; ByUser: Boolean); virtual;
        procedure DoRowResized(DataRow: Longint); virtual;
        procedure DoSelectChanged(SelectType: TtsSelectType; ByUser: Boolean); virtual;
        procedure DoStartCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); virtual; abstract;
        procedure DoStartRowEdit(DataRow: Variant; var Cancel: Boolean); virtual; abstract;
        procedure DoUndoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean; var Cancel: Boolean); virtual; abstract;
        procedure DoUndoRowEdit(DataRow: Variant; ByUser: Boolean; var Cancel: Boolean); virtual; abstract;
        procedure DoShowEditor(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); virtual; abstract;
        procedure ActivateInvalidMaskValue(var Accept: Boolean); virtual;
        procedure ActivateInvalidMaskEdit(Keys: string; var Accept: Boolean); virtual;
        {$IFDEF TSVER_V4}
        function  DoMouseWheelDown(Shift: TShiftState; MousePos: TPoint): Boolean; override;
        function  DoMouseWheelUp(Shift: TShiftState; MousePos: TPoint): Boolean; override;
        {$ENDIF}

        {Child control event hook procedures}
        procedure CtrlOnCanChange(Sender : TObject; Edit: Boolean; var Cancel : Boolean); virtual;
        procedure CtrlOnChanged(Sender : TObject; Edit, ByUser, TextAdded: Boolean); virtual;
        procedure CtrlOnClick(Sender: TObject); virtual;
        procedure CtrlOnDblClick(Sender: TObject); virtual;
        procedure CtrlOnDragDrop(Sender, Source: TObject; X, Y: Integer); virtual;
        procedure CtrlOnDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState; var Accept: Boolean); virtual;
        procedure CtrlOnEdit(Sender : TObject; var Cancel : Boolean); virtual;
        procedure CtrlOnEndDrag(Sender, Target: TObject; X, Y: Integer); virtual;
        procedure CtrlOnEndKeyDown(Sender : TObject; var Key : Word; Shift : TShiftState); virtual;
        procedure CtrlOnEndKeyPress(Sender : TObject; var Key : Char); virtual;
        procedure CtrlOnKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState); virtual;
        procedure CtrlOnKeyPress(Sender: TObject; var Key: Char); virtual;
        procedure CtrlOnKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState); virtual;
        procedure CtrlOnKillFocus(Sender: TObject); virtual;
        procedure CtrlOnMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
        procedure CtrlOnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer); virtual;
        procedure CtrlOnMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
        procedure CtrlOnNotifyChanged(Sender: TObject; DataChanged: Boolean); virtual;
        procedure CtrlOnStartDrag(Sender: TObject; var DragObject: TDragObject); virtual;
        procedure CtrlOnUndoChanged(Sender : TObject; ByUser: Boolean; var Cancel: Boolean); virtual;
        procedure CtrlOnWantKey(Sender : TObject; Key: Word; var WantKey: Boolean); virtual;
        procedure CtrlOnInvalidMaskEdit(Sender : TObject; Keys: string; var Accept: Boolean); virtual;
        procedure CtrlOnEditTextResized(Sender : TObject; ByUser: Boolean); virtual;

        {Row property procedures}
        procedure SetRowColor(DataRow: Longint; Value: TColor); virtual;
        function  GetRowColor(DataRow: Longint): TColor; virtual;
        procedure SetRowFont(DataRow: Longint; Value: TFont); virtual;
        function  GetRowFont(DataRow: Longint): TFont; virtual;
        procedure SetRowParentFont(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowParentFont(DataRow: Longint): Boolean; virtual;
        procedure SetRowAutoCreateFont(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowAutoCreateFont(DataRow: Longint): Boolean; virtual;
        procedure SetRowHeight(DataRow: Longint; Value: Integer); virtual;
        function  GetRowHeight(DataRow: Longint): Integer; virtual;
        function  GetRowId(DataRow: Longint): Longint; virtual;
        procedure SetRowVisible(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowVisible(DataRow: Longint): Boolean;
        function  IsRowVisible(DataRow: Longint): Boolean; virtual;
        procedure SetRowAlignment(DataRow: Longint; Value: TAlignment); virtual;
        function  GetRowAlignment(DataRow: Longint): TAlignment; virtual;
        procedure SetRowAlign(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowAlign(DataRow: Longint): Boolean; virtual;
        procedure SetRowHorzAlignment(DataRow: Longint; Value: TtsHorzAlignment); virtual;
        function  GetRowHorzAlignment(DataRow: Longint): TtsHorzAlignment; virtual;
        procedure SetRowVertAlignment(DataRow: Longint; Value: TtsVertAlignment); virtual;
        function  GetRowVertAlignment(DataRow: Longint): TtsVertAlignment; virtual;
        procedure SetRowButtonType(DataRow: Longint; Value: TtsButtonType);
        function  GetRowButtonType(DataRow: Longint): TtsButtonType; virtual;
        procedure SetRowWordWrap(DataRow: Longint; Value: TtsWordWrap);
        function  GetRowWordWrap(DataRow: Longint): TtsWordWrap; virtual;
        procedure SetRowReadOnly(DataRow: Longint; Value: Boolean);
        function  GetRowReadOnly(DataRow: Longint): Boolean;
        function  IsRowReadOnly(DataRow: Longint): Boolean; virtual;
        procedure SetRowIs3D(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowIs3D(DataRow: Longint): Boolean; virtual;
        procedure SetRowMaskName(DataRow: Longint; Value: string);
        function  GetRowMaskName(DataRow: Longint): string; virtual;
        procedure SetRowCombo(DataRow: Longint; Value: TtsCombo);
        function  GetRowCombo(DataRow: Longint): TtsCombo; virtual;
        procedure SetRowParentCombo(DataRow: Longint; Value: Boolean);
        function  GetRowParentCombo(DataRow: Longint): Boolean; virtual;
        procedure SetRowStretchPicture(DataRow: Longint; Value: TtsDrawOption);
        function  GetRowStretchPicture(DataRow: Longint): TtsDrawOption; virtual;
        procedure SetRowShrinkPicture(DataRow: Longint; Value: TtsDrawOption);
        function  GetRowShrinkPicture(DataRow: Longint): TtsDrawOption; virtual;
        procedure SetRowCenterPicture(DataRow: Longint; Value: TtsDrawOption);
        function  GetRowCenterPicture(DataRow: Longint): TtsDrawOption; virtual;
        procedure SetRowKeepAspectRatio(DataRow: Longint; Value: TtsDrawOption);
        function  GetRowKeepAspectRatio(DataRow: Longint): TtsDrawOption; virtual;
        procedure SetRowControlType(DataRow: Longint; Value: TtsControlType);
        function  GetRowControlType(DataRow: Longint): TtsControlType; virtual;
        procedure SetRowSpinOptions(DataRow: Longint; Value: TtsSpinOptions);
        function  GetRowSpinOptions(DataRow: Longint): TtsSpinOptions; virtual;
        procedure SetRowSpinIncrement(DataRow: Longint; Value: Double);
        function  GetRowSpinIncrement(DataRow: Longint): Double; virtual;
        procedure SetRowDateTimeDef(DataRow: Longint; Value: TtsDateTimeDefComponent);
        function  GetRowDateTimeDef(DataRow: Longint): TtsDateTimeDefComponent; virtual;
        procedure SetRowDropDownStyle(DataRow: Longint; Value: TtsDropDownStyle);
        function  GetRowDropDownStyle(DataRow: Longint): TtsDropDownStyle; virtual;
        function  GetDisplayCol(DataCol: Longint): Longint; virtual;
        procedure SetDisplayColnr(DataCol: Longint; Value: Longint); virtual;
        function  GetDisplayColnr(DataCol: Longint): Longint; virtual;
        function  GetDisplayRow(DataRow: Longint): Longint; virtual;
        procedure SetDisplayRownr(DataRow: Longint; Value: Longint); virtual;
        function  GetDisplayRownr(DataRow: Longint): Longint; virtual;
        procedure SetRowChanged(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowChanged(DataRow: Longint): Boolean;
        function  IsRowChanged(DataRow: Longint): Boolean; virtual;
        procedure SetRowSelected(DataRow: Longint; Value: Boolean); virtual;
        function  GetRowSelected(DataRow: Longint): Boolean;
        function  IsRowSelected(DataRow: Longint): Boolean; virtual;
        procedure SetRowMoving(Value: Boolean); virtual;
        function  GetRowMoving: Boolean; virtual;
        function  GetIdDataRow(Id: Longint): Longint; virtual;
        function  GetIDDataCol(Id: Longint): Longint; virtual;

        {Cell property procedures}
        procedure ResetLastCell;
        function  GetCellElement(DataCol, DataRow: Longint; Check: Boolean): TtsCellElement;
        function  GetCellControlType(DataCol, DataRow: Longint): TtsControlType; virtual;
        procedure SetCellControlType(DataCol, DataRow: Longint; Value: TtsControlType); virtual;
        function  GetCellSpinOptions(DataCol, DataRow: Longint): TtsSpinOptions; virtual;
        procedure SetCellSpinOptions(DataCol, DataRow: Longint; Value: TtsSpinOptions); virtual;
        function  GetCellSpinIncrement(DataCol, DataRow: Longint): Double; virtual;
        procedure SetCellSpinIncrement(DataCol, DataRow: Longint; Value: Double); virtual;
        function  GetCellTag(DataCol, DataRow: Longint): Integer; virtual;
        procedure SetCellTag(DataCol, DataRow: Longint; Value: Integer); virtual;
        function  GetCellData(DataCol, DataRow: Longint): Pointer; virtual;
        procedure SetCellData(DataCol, DataRow: Longint; Value: Pointer); virtual;
        function  GetCellColor(DataCol, DataRow: Longint): TColor; virtual;
        procedure SetCellColor(DataCol, DataRow: Longint; Value: TColor); virtual;
        function  GetCellCheckBoxState(DataCol, DataRow: Longint): TCheckBoxState; 
        procedure SetCellCheckBoxState(DataCol, DataRow: Longint; Value : TCheckBoxState);
        function  GetCellFont(DataCol, DataRow: Longint): TFont; virtual;
        procedure SetCellFont(DataCol, DataRow: Longint; Value: TFont); virtual;
        function  GetCellParentFont(DataCol, DataRow: Longint): Boolean; virtual;
        procedure SetCellParentFont(DataCol, DataRow: Longint; Value: Boolean); virtual;
        function  GetCellAlignment(DataCol, DataRow: Longint): TAlignment; virtual;
        procedure SetCellAlignment(DataCol, DataRow: Longint; Value: TAlignment); virtual;
        function  GetCellAlign(DataCol, DataRow: Longint): Boolean; virtual;
        procedure SetCellAlign(DataCol, DataRow: Longint; Value: Boolean); virtual;
        function  GetCellHorzAlignment(DataCol, DataRow: Longint): TtsHorzAlignment; virtual;
        procedure SetCellHorzAlignment(DataCol, DataRow: Longint; Value: TtsHorzAlignment); virtual;
        function  GetCellVertAlignment(DataCol, DataRow: Longint): TtsVertAlignment; virtual;
        procedure SetCellVertAlignment(DataCol, DataRow: Longint; Value: TtsVertAlignment); virtual;
        function  GetCellIs3D(DataCol, DataRow: Longint): Boolean; virtual;
        procedure SetCellIs3D(DataCol, DataRow: Longint; Value: Boolean); virtual;
        function  IsCellReadOnly(DataCol, DataRow: Longint): TtsReadOnly; virtual;
        function  GetCellReadOnly(DataCol, DataRow: Longint): TtsReadOnly;
        procedure SetCellReadOnly(DataCol, DataRow: Longint; Value: TtsReadOnly); virtual;
        function  GetCellWordWrap(DataCol, DataRow: Longint): TtsWordWrap; virtual;
        procedure SetCellWordWrap(DataCol, DataRow: Longint; Value: TtsWordWrap); virtual;
        function  GetCellButtonType(DataCol, DataRow: Longint): TtsButtonType; virtual;
        procedure SetCellButtonType(DataCol, DataRow: Longint; Value: TtsButtonType); virtual;
        function  GetCellDropDownStyle(DataCol, DataRow: Longint): TtsDropDownStyle; virtual;
        procedure SetCellDropDownStyle(DataCol, DataRow: Longint; Value: TtsDropDownStyle); virtual;
        function  GetHeadingTextHeight(DataCol: Longint): Integer;
        function  GetHeadingTextLines(DataCol: Longint): Integer;
        function  GetCellTextHeight(DataCol, DataRow: Longint): Integer;
        function  GetCellTextWidth(DataCol, DataRow: Longint): Integer; virtual;
        function  GetCellTextLines(DataCol, DataRow: Longint): Integer;
        function  GetCellMaskName(DataCol, DataRow: Longint): string; virtual;
        procedure SetCellMaskName(DataCol, DataRow: Longint; Value: string);
        function  GetCellCombo(DataCol, DataRow: Longint): TtsCombo; virtual;
        procedure SetCellCombo(DataCol, DataRow: Longint; Value: TtsCombo);
        function  GetCellParentCombo(DataCol, DataRow: Longint): Boolean; virtual;
        procedure SetCellParentCombo(DataCol, DataRow: Longint; Value: Boolean);
        function  GetCellStretchPicture(DataCol, DataRow: Longint): TtsDrawOption; virtual;
        procedure SetCellStretchPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
        function  GetCellShrinkPicture(DataCol, DataRow: Longint): TtsDrawOption; virtual;
        procedure SetCellShrinkPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
        function  GetCellCenterPicture(DataCol, DataRow: Longint): TtsDrawOption; virtual;
        procedure SetCellCenterPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
        function  GetCellKeepAspectRatio(DataCol, DataRow: Longint): TtsDrawOption; virtual;
        procedure SetCellKeepAspectRatio(DataCol, DataRow: Longint; Value: TtsDrawOption);
        function  GetCellDateTimeDef(DataCol, DataRow: Longint): TtsDateTimeDefComponent; virtual;
        procedure SetCellDateTimeDef(DataCol, DataRow: Longint; Value: TtsDateTimeDefComponent);

        {Properties for protected use}
        property InScrollingMode: Boolean read FInScrollingMode write FInScrollingMode;
        property GridCols: TtsGridCols read FGridCols;
        property GridRows: TtsGridRows read FGridRows;
        property EnableStartEdit: Boolean read GetEnableStartEdit write SetEnableStartEdit;
        property VisibleColCount: Integer read GetVisibleColCount;
        property VisibleRowCount: Integer read GetVisibleRowCount;
        property CurDisplayRow: Longint read FCurDisplayRow;
        property CurDisplayCol: Longint read FCurDisplayCol;
        property ControlSelectMode: TtsTextSelectMode read FEditSelect write SetControlSelectMode;
        property DisplayAsControl: Boolean read FDisplayAsControl write FDisplayAsControl;
        property CurDataCol: Longint read FCurDataCol;
        property CurDataRow: Longint read FCurDataRow;
        property InHidingGridControl: Boolean read FInHidingGridControl;
        property InUndoEdit: Boolean read FInUndoEdit;
        property InsertRowEdit: Boolean read FInsertRowEdit write FInsertRowEdit;
        property InternalFixedCols: Integer read FInternalFixedCols write SetInternalFixedCols;
        property InternalFixedRows: Integer read FInternalFixedRows write SetInternalFixedRows;
        property CanProcessKey: Boolean read GetCanProcessKey write SetCanProcessKey;
        property MaxScrollRow: Longint read GetMaxScrollRow;
        property MaxScrollCol: Longint read GetMaxScrollCol;
        property ComboForm: TtsDropDownForm read GetComboForm write FComboForm;
        property DropDownRows: Longint read GetDropDownRows write SetDropDownRows;
        property DropDownCols: Longint read GetDropDownCols write SetDropDownCols;
        property AutoLookup: Boolean read GetAutoLookup write SetAutoLookup default True;
        property ParentGrid: TtsBaseGrid read GetParentGrid write SetParentGrid;
        property SetComboExtents: Boolean read GetSetComboExtents write SetSetComboExtents;
        property DateTimeForm: TtsDropDownForm read GetDateTimeForm write FDateTimeForm;
        property Assigning: Boolean read FAssigning write FAssigning;
        property SaveAllProps: Boolean read GetSaveAllProps write SetSaveAllProps;
        property ParentGridCombo: TtsCombo read GetParentGridCombo write SetParentGridCombo;
        property DrawBitmap: TBitmap read GetDrawBitmap write FDrawBitmap;
        property PictureColorMask: TBitmap read GetPictureColorMask write FPictureColorMask;
        property HeadingTextHeight[DataCol: Longint]: Integer read GetHeadingTextHeight;
        property HeadingTextLines[DataCol: Longint]: Integer read GetHeadingTextLines;

        {Properties for public/published use}
        property Version: string read GetVersion write SetVersion;
        property DisplayColnr[DataCol: Longint]: Longint read GetDisplayColnr write SetDisplayColnr;
        property DisplayRownr[DataRow: Longint]: Longint read GetDisplayRownr write SetDisplayRownr;
        property RowColor[DataRow: Longint]: TColor read GetRowColor write SetRowColor;
        property RowFont[DataRow: Longint]: TFont read GetRowFont write SetRowFont;
        property RowHeight[DataRow: Longint]: Integer read GetRowHeight write SetRowHeight;
        property RowId[DataRow: Longint]: Longint read GetRowId;
        property IdDataRow[Id: Longint]: Longint read GetIdDataRow;
        property IdDataCol[Id: Longint]: Longint read GetIdDataCol;
        property RowParentFont[DataRow: Longint]: Boolean read GetRowParentFont write SetRowParentFont;
        property RowAutoCreateFont[DataRow: Longint]: Boolean read GetRowAutoCreateFont write SetRowAutoCreateFont;
        property RowVisible[DataRow: Longint]: Boolean read GetRowVisible write SetRowVisible;
        property RowAlignment[DataRow: Longint]: TAlignment read GetRowAlignment write SetRowAlignment;
        property RowAlign[DataRow: Longint]: Boolean read GetRowAlign write SetRowAlign;
        property RowHorzAlignment[DataRow: Longint]: TtsHorzAlignment read GetRowHorzAlignment write SetRowHorzAlignment;
        property RowVertAlignment[DataRow: Longint]: TtsVertAlignment read GetRowVertAlignment write SetRowVertAlignment;
        property RowButtonType[DataRow: Longint]: TtsButtonType read GetRowButtonType write SetRowButtonType;
        property RowDropDownStyle[DataRow: Longint]: TtsDropDownStyle read GetRowDropDownStyle write SetRowDropDownStyle;
        property RowWordWrap[DataRow: Longint]: TtsWordWrap read GetRowWordWrap write SetRowWordWrap;
        property RowReadOnly[DataRow: Longint]: Boolean read GetRowReadOnly write SetRowReadOnly;
        property RowIs3D[DataRow: Longint]: Boolean read GetRowIs3D write SetRowIs3D;
        property RowChanged[DataRow: Longint]: Boolean read GetRowChanged write SetRowChanged;
        property RowSelected[DataRow: Longint]: Boolean read GetRowSelected write SetRowSelected;
        property RowMaskName[DataRow: Longint]: string read GetRowMaskName write SetRowMaskName;
        property RowCombo[DataRow: Longint]: TtsCombo read GetRowCombo write SetRowCombo;
        property RowParentCombo[DataRow: Longint]: Boolean read GetRowParentCombo write SetRowParentCombo;
        property RowStretchPicture[DataRow: Longint]: TtsDrawOption read GetRowStretchPicture write SetRowStretchPicture;
        property RowShrinkPicture[DataRow: Longint]: TtsDrawOption read GetRowShrinkPicture write SetRowShrinkPicture;
        property RowCenterPicture[DataRow: Longint]: TtsDrawOption read GetRowCenterPicture write SetRowCenterPicture;
        property RowKeepAspectRatio[DataRow: Longint]: TtsDrawOption read GetRowKeepAspectRatio write SetRowKeepAspectRatio;
        property RowControlType[DataRow: Longint]: TtsControlType read GetRowControlType write SetRowControlType;
        property RowSpinOptions[DataRow: Longint]: TtsSpinOptions read GetRowSpinOptions write SetRowSpinOptions;
        property RowSpinIncrement[DataRow: Longint]: Double read GetRowSpinIncrement write SetRowSpinIncrement;
        property RowDateTimeDef[DataRow: Longint]: TtsDateTimeDefComponent read GetRowDateTimeDef write SetRowDateTimeDef;
        property CellTag[DataCol, DataRow: Longint]: Integer read GetCellTag write SetCellTag;
        property CellData[DataCol, DataRow: Longint]: Pointer read GetCellData write SetCellData;
        property CellColor[DataCol, DataRow: Longint]: TColor read GetCellColor write SetCellColor;
        property CellCheckBoxState[DataCol, DataRow: Longint]: TCheckBoxState read GetCellCheckBoxState write SetCellCheckBoxState;
        property CellControlType[DataCol, DataRow: Longint]: TtsControlType read GetCellControlType write SetCellControlType;
        property CellSpinOptions[DataCol, DataRow: Longint]: TtsSpinOptions read GetCellSpinOptions write SetCellSpinOptions;
        property CellSpinIncrement[DataCol, DataRow: Longint]: Double read GetCellSpinIncrement write SetCellSpinIncrement;
        property CellFont[DataCol, DataRow: Longint]: TFont read GetCellFont write SetCellFont;
        property CellAlignment[DataCol, DataRow: Longint]: TAlignment read GetCellAlignment write SetCellAlignment;
        property CellAlign[DataCol, DataRow: Longint]: Boolean read GetCellAlign write SetCellAlign;
        property CellHorzAlignment[DataCol, DataRow: Longint]: TtsHorzAlignment read GetCellHorzAlignment write SetCellHorzAlignment;
        property CellVertAlignment[DataCol, DataRow: Longint]: TtsVertAlignment read GetCellVertAlignment write SetCellVertAlignment;
        property CellIs3D[DataCol, DataRow: Longint]: Boolean read GetCellIs3D write SetCellIs3D;
        property CellReadOnly[DataCol, DataRow: Longint]: TtsReadOnly read GetCellReadOnly write SetCellReadOnly;
        property CellWordWrap[DataCol, DataRow: Longint]: TtsWordWrap read GetCellWordWrap write SetCellWordWrap;
        property CellButtonType[DataCol, DataRow: Longint]: TtsButtonType read GetCellButtonType write SetCellButtonType;
        property CellDropDownStyle[DataCol, DataRow: Longint]: TtsDropDownStyle read GetCellDropDownStyle write SetCellDropDownStyle;
        property CellParentFont[DataCol, DataRow: Longint]: Boolean read GetCellParentFont write SetCellParentFont;
        property CellTextHeight[DataCol, DataRow: Longint]: Integer read GetCellTextHeight;
        property CellTextWidth[DataCol, DataRow: Longint]: Integer read GetCellTextWidth;
        property CellTextLines[DataCol, DataRow: Longint]: Integer read GetCellTextLines;
        property CellMaskName[DataCol, DataRow: Longint]: string read GetCellMaskName write SetCellMaskName;
        property CellCombo[DataCol, DataRow: Longint]: TtsCombo read GetCellCombo write SetCellCombo;
        property CellParentCombo[DataCol, DataRow: Longint]: Boolean read GetCellParentCombo write SetCellParentCombo;
        property CellStretchPicture[DataCol, DataRow: Longint]: TtsDrawOption read GetCellStretchPicture write SetCellStretchPicture;
        property CellShrinkPicture[DataCol, DataRow: Longint]: TtsDrawOption read GetCellShrinkPicture write SetCellShrinkPicture;
        property CellCenterPicture[DataCol, DataRow: Longint]: TtsDrawOption read GetCellCenterPicture write SetCellCenterPicture;
        property CellKeepAspectRatio[DataCol, DataRow: Longint]: TtsDrawOption read GetCellKeepAspectRatio write SetCellKeepAspectRatio;
        property CellDateTimeDef[DataCol, DataRow: Longint]: TtsDateTimeDefComponent read GetCellDateTimeDef write SetCellDateTimeDef;
        property Canvas;
        property GridHeight;
        property GridWidth;
        property LeftCol;
        property TopRow;
        property EnablePaint: Boolean read GetEnablePaint write SetEnablePaint;
        property EnableRedraw: Boolean read GetEnableRedraw write SetEnableRedraw;
        property FastAssign: Boolean read GetFastAssign write SetFastAssign;
        property FocusRectDisabled: Boolean read GetFocusRectDisabled write SetFocusRectDisabled;
        property Col[DataCol: Variant]: TtsCol read GetCol;
        property CurrentCell: TtsCurrentCell read FCurrentCell;
        property DataColnr[DisplayCol: Longint]: Longint read GetDataColnr;
        property DataRownr[DisplayRow: Longint]: Longint read GetDataRownr;
        property Cell[DataCol: Longint; DataRow: Longint]: Variant read GetCellValue write SetCellValue;
        property CellPText[DataCol: Longint; DataRow: Longint]: PChar write SetCellPText;
        property CurrentDataCol : Longint read GetCurrentDataCol write SetCurrentDataCol;
        property CurrentDataRow : Longint read GetCurrentDataRow write SetCurrentDataRow;
        property CheckBoxOnBitmap : TBitmap write SetCheckBoxOnBitmap;
        property CheckBoxOffBitmap : TBitmap write SetCheckBoxOffBitmap;
        property CheckBoxGrayedBitmap : TBitmap write SetCheckBoxGrayedBitmap;
        property SelectedCols: TtsSelection read FSelectedCols;
        property SelectedRows: TtsSelection read FSelectedRows;
        property SelectedCells: TRect read FSelectedCells;
        property GridStatus: TtsGridStatus read FGridStatus;
        property MouseStatus: TtsMouseStatus read FMouseStatus;
        property VisibleCols: Double read GetVisibleCols;
        property VisibleRows: Double read GetVisibleRows;
        property HorzScrollBarVisible: Boolean read GetHorzScrollBarVisible;
        property VertScrollBarVisible: Boolean read GetVertScrollBarVisible;
        property VertScrollBarWidth: Integer read GetVertScrollBarWidth;
        property HorzScrollBarHeight: Integer read GetHorzScrollBarHeight;
        property InsertionRow: Integer read FInsertionRow;
        property Combo: TtsCombo read GetCombo;
        property DrawOverlap: TtsDrawOverlap read FDrawOverlap write SetDrawOverlap default doDrawColOnTop;
        property RowBarOn: Boolean read GetRowBarOn write SetRowBarOn default True;
        property HeadingOn: Boolean read GetHeadingOn write SetHeadingOn default True;
        property RowBarWidth: Integer read GetRowBarWidth write SetRowBarWidth default 14;
        property HeadingHeight: Integer read GetHeadingHeight write SetHeadingHeight default 15;
        property EditColor: TColor read FEditColor write SetEditColor default clNone;
        property EditFontColor: TColor read FEditFontColor write SetEditFontColor default clNone;
        property CheckBoxStyle : TtsCheckBoxStyle read FCheckBoxStyle write SetCheckBoxStyle;
        property LineColor: TColor read FLineColor write SetLineColor default clSilver;
        property Cols: Longint read GetGridColCount write SetGridColCount stored StoreCols;
        property Rows: Longint read GetGridRowCount write SetGridRowCount stored StoreRows;
        property EditMode: TtsEditMode read FEditMode write SetEditMode default emEdit;
        property GridMode: TtsGridMode read FGridMode write SetGridMode default gmEdit;
        property AlwaysShowEditor: Boolean read FAlwaysShowEditor write SetAlwaysShowEditor default True;
        property AlwaysShowFocus: Boolean read FAlwaysShowFocus write SetAlwaysShowFocus default False;
        property SkipReadOnly: Boolean read FSkipReadOnly write SetSkipReadOnly default True;
        property RowChangedIndicator: TtsRowChangedIndicator read FRowChangedIndicator write SetRowChangedIndicator default riOn;
        property ColSelectMode: TtsColSelectMode read FColSelectMode write SetColSelectMode default csMulti;
        property RowSelectMode: TtsRowSelectMode read GetRowSelectMode write SetRowSelectMode default rsMulti;
        property CellSelectMode: TtsCellSelectMode read GetCellSelectMode write SetCellSelectMode default cmRange;
        property ColMoving: Boolean read FColMoving write FColMoving default True;
        property RowMoving: Boolean read GetRowMoving write SetRowMoving default True;
        property ResizeRows: TtsResizeRows read FResizeRows write FResizeRows default rrAll;
        property ResizeCols: TtsResizeCols read FResizeCols write FResizeCols default rcSingle;
        property ResizeRowsInGrid: Boolean read FResizeRowsInGrid write FResizeRowsInGrid default False;
        property ResizeColsInGrid: Boolean read FResizeColsInGrid write FResizeColsInGrid default False;
        property GridLines: TtsGridLines read FGridLines write SetGridLines default glBoth;
        property ScrollSpeed: TtsScrollSpeed read FScrollSpeed write FScrollSpeed default spVariable;
        property FixedColCount: Integer read FFixedColCount write SetFixedColCount default 0;
        property FixedRowCount: Integer read FFixedRowCount write SetFixedRowCount default 0;
        property FixedLineColor: TColor read FFixedLineColor write SetFixedLineColor default clBlack;
        property HeadingColor: TColor read FHeadingColor write SetHeadingColor default clBtnFace;
        property SelectedAreaCursor: TCursor read FSelectedAreaCursor write FSelectedAreaCursor default crDefault;
        property ThumbTracking: Boolean read FThumbTracking write SetThumbTracking default False;
        property Is3D: Boolean read FIs3D write SetIs3D default False;
        property Heading3D: Boolean read FHeading3D write SetHeading3D default True;
        property SelectFixed: Boolean read FSelectFixed write SetSelectFixed default True;
        property InactiveButtonState: TtsInactiveButtonState read FInactiveButtonState write SetInactiveButtonState default ibsBackGround;
        property ButtonEdgeWidth: Integer read FButtonEdgeWidth write SetButtonEdgeWidth default 2;
        property DefaultButtonWidth: Integer read FDefaultButtonWidth write SetDefaultButtonWidth default 11;
        property DefaultButtonHeight: Integer read FDefaultButtonHeight write SetDefaultButtonHeight default 9;
        property StretchPicture: Boolean read FStretchPicture write SetStretchPicture default True;
        property ShrinkPicture: Boolean read FShrinkPicture write SetShrinkPicture default True;
        property TransparentColor: TColor read FTransparentColor write SetTransparentColor default clNone;
        property CenterPicture: Boolean read FCenterPicture write SetCenterPicture default True;
        property KeepAspectRatio: Boolean read FKeepAspectRatio write SetKeepAspectRatio default False;
        property CellEditing: Boolean read FCellEditing;
        property RowEditing: Boolean read FRowEditing;
        property WordWrap: TtsWordWrap read FWordWrap write SetWordWrap default wwDefault;
        property ReadOnlyButton: Boolean read FReadOnlyButton write SetReadOnlyButton default True;
        property HeadingButton: TtsHeadingButton read FHeadingButton write SetHeadingButton default hbNone;
        property HeadingAlignment: TAlignment read FHeadingAlignment write SetHeadingAlignment default taLeftJustify;
        property HeadingHorzAlignment: TtsHorzAlignment read FHeadingHorzAlignment write SetHeadingHorzAlignment default htaDefault;
        property HeadingVertAlignment: TtsVertAlignment read FHeadingVertAlignment write SetHeadingVertAlignment default vtaDefault;
        property HorzAlignment: TtsHorzAlignment read FHorzAlignment write SetHorzAlignment default htaDefault;
        property VertAlignment: TtsVertAlignment read FVertAlignment write SetVertAlignment default vtaDefault;
        property RowBarAlignment: TtsVertAlignment read FRowBarAlignment write SetRowBarAlignment default vtaDefault;
        property HeadingWordWrap: TtsWordWrap read FHeadingWordWrap write SetHeadingWordWrap default wwDefault;
        property HeadingFont: TFont read FHeadingFont write SetHeadingFont;
        property HeadingParentFont: Boolean read FHeadingParentFont write SetHeadingParentFont default True;
        property WantTabs: Boolean read FWantTabs write SetWantTabs default True;
        property TabRowWrap: Boolean read FTabRowWrap write FTabRowWrap default True;
        property FlatButtons: Boolean read FFlatButtons write SetFlatButtons default True;
        property RowBarIndicator: Boolean read FRowBarIndicator write SetRowBarIndicator default True;
        property MaxLeftCol: Longint read GetMaxLeftCol;
        property MaxTopRow: Longint read GetMaxTopRow;
        property SelectionColor: TColor read FSelectionColor write SetSelectionColor default clHighlight;
        property SelectionFontColor: TColor read FSelectionFontColor write SetSelectionFontColor default clHighlightText;
        property SelectionType: TtsSelectionType read FSelectionType write SetSelectionType default sltDefault;
        property FocusBorder: TtsFocusBorder read FFocusBorder write SetFocusBorder default fbDot;
        property FocusColor: TColor read FFocusColor write SetFocusColor default clNone;
        property FocusBorderColor: TColor read FFocusBorderColor write SetFocusBorderColor default clNone;
        property FocusFontColor: TColor read FFocusFontColor write SetFocusFontColor default clNone;
        property Align;
        property BorderStyle;
        property Color;
        property Ctl3D;
        property DefaultColWidth;
        property DefaultRowHeight default 14;
        property DragCursor;
        property DragMode;
        property Enabled;
        property Font;
        property ParentColor;
        property ParentCtl3D;
        property ParentFont;
        property ParentShowHint;
        property PopupMenu;
        property ScrollBars: TScrollStyle read FScrollBars write SetScrollBars default ssBoth;
        property ShowHint;
        property TabOrder;
        property Visible;
        property MaskDefs: TtsMaskDefsComponent read GetMaskDefs write SetMaskDefs;
        property PrintTitle : String read FPrintTitle write FPrintTitle;
        property PrintLinesPerPage : Integer read FPrintLinesPerPage write FPrintLinesPerPage default 40;
        property PrintOrientation : TtsPrintMode read FPrintOrientation write FPrintOrientation default pmLandscape;
        property PrintTotals : Boolean read FPrintTotals write FPrintTotals default True;
        property PrintCols : Integer read FPrintCols write FPrintCols default 0;
        property PrintWithGridFormats : Boolean read FPrintWithGridFormats write FPrintWithGridFormats default True;
        property ProvideGridMenu : Boolean read FProvideGridMenu write FProvideGridMenu default False;
        property ExportDelimiter : String read FExportDelimiter write FExportDelimiter;
        property GridReport : TosCustomGridReport read FGridReport write SetGridReport;
        property AlwaysDetectButton : Boolean read FAlwaysDetectButton write FAlwaysDetectButton default False;
        property XMLExport : TosXMLExport read FXMLExport write SetXMLExport;
        {$IFDEF TSVER_V4}
        property DragKind;
        {$ENDIF}
        property StoreData: Boolean read FStoreData write SetStoreData default False;
        property GridData: Tts2DStorage read FGridData write FGridData;
        property ImageList: TtsImageListComponent read GetImageList write SetImageList;
        property InDesignMode: Boolean read GetInDesignMode write SetInDesignMode;
        property SpinButtonWidth: Integer read FSpinButtonWidth write SetSpinButtonWidth default 11;
        property SpinButtonHeight: Integer read FSpinButtonHeight write SetSpinButtonHeight default 9;
        property SpinStartDelay: Integer read FSpinStartDelay write FSpinStartDelay default 500;
        property SpinRepeatDelay: Integer read FSpinRepeatDelay write FSpinRepeatDelay default 80;
        property DateTimeDef: TtsDateTimeDefComponent read FDateTimeDef write SetDateTimeDef;
        property CheckMouseFocus: Boolean read FCheckMouseFocus write FCheckMouseFocus default True;
        property CheckBoxValues: string read FCheckBoxValues write SetCheckBoxValues;
        property AlwaysShowScrollBar: TScrollStyle read FAlwaysShowScrollBar write SetAlwaysShowScrollBar default ssNone;
        property AutoScale: Boolean read GetAutoScale write SetAutoScale default False;

        {$IFNDEF TSVER_V3}
        property ColProperties: TCollection read FStoredCols write FStoredCols stored  StoreColProps;
        property RowProperties: TCollection read FStoredRows write FStoredRows stored  StoreRowProps;
        property CellProperties: TCollection read FStoredCells write FStoredCells stored  StoreCellProps;
        {$ENDIF}

        {Events for published use}
        property OnClick;
        {$IFDEF TSVER_V5}
        property OnContextPopup;
        {$ENDIF}
        property OnDblClick;
        property OnStartDrag;
        property OnDragDrop;
        property OnDragOver;
        property OnEndDrag;
        property OnEnter;
        property OnExit;
        property OnKeyDown;
        property OnKeyPress;
        property OnKeyUp;
        property OnMouseDown;
        property OnMouseMove;
        property OnMouseUp;
        property OnHeadingDown: TtsHeadingClickEvent read FOnHeadingDown write FOnHeadingDown;
        property OnHeadingUp: TtsHeadingClickEvent read FOnHeadingUp write FOnHeadingUp;
        property OnHeadingClick: TtsHeadingClickEvent read FOnHeadingClick write FOnHeadingClick;
        property OnComboCompareValue: TtsComboCompareValueEvent read FOnComboCompareValue write FOnComboCompareValue;
        property OnComboLCompareValue: TtsComboLCompareValueEvent read FOnComboLCompareValue write FOnComboLCompareValue;
        property OnColMoved: TtsColMovedEvent read FOnColMoved write FOnColMoved;
        property OnRowMoved: TtsRowMovedEvent read FOnRowMoved write FOnRowMoved;
        property OnColChanged: TtsColChangedEvent read FOnColChanged write FOnColChanged;
        property OnSelectChanged: TtsSelectChangedEvent read FOnSelectChanged write FOnSelectChanged;
        property OnColCountChanged: TtsCountChangedEvent read FOnColCountChanged write FOnColCountChanged;
        property OnRowCountChanged: TtsCountChangedEvent read FOnRowCountChanged write FOnRowCountChanged;
        property OnColResized: TtsResizedEvent read FOnColResized write FOnColResized;
        property OnRowResized: TtsResizedEvent read FOnRowResized write FOnRowResized;
        property OnCanStartDrag: TtsCanStartDragEvent read FOnCanStartDrag write FOnCanStartDrag;
        property OnMouseStatusChanged: TtsMouseStatusChangedEvent read FOnMouseStatusChanged write FOnMouseStatusChanged;
        property OnGridStatusChanged: TtsGridStatusChangedEvent read FOnGridStatusChanged write FOnGridStatusChanged;
        property OnDeleteCol: TtsDeleteColEvent read FOnDeleteCol write FOnDeleteCol;
        property OnInsertCol: TtsInsertColEvent read FOnInsertCol write FOnInsertCol;
        property OnPaint: TNotifyEvent read FOnPaint write FOnPaint;
        property OnResize: TNotifyEvent read FOnResize write FOnResize;
        property OnEditTextResized: TtsEditTextResizedEvent read FOnEditTextResized write FOnEditTextResized;
        {$IFDEF TSVER_V4}
        property OnStartDock;
        property OnEndDock;
        {$ENDIF}
        property OnPrintGrid: TtsPrintGridEvent read FOnPrintGrid write FOnPrintGrid;
    public
        constructor Create(AOwner: TComponent); override;
        destructor Destroy; override;

        procedure Print; virtual; abstract;
        procedure PrintPreview; virtual; abstract;
        procedure ExportGrid; virtual; abstract;

        procedure PaintToMetaFileCanvas(aMetaFileCanvas : TMetaFileCanvas);
        procedure BeginUpdate;
        procedure EndUpdate;
        procedure ShowGridMenu(X, Y : Longint); virtual;
        function  HTMLFont : String;
        function  ActiveCombo(DataCol: Longint; DataRow: Variant): TtsCombo; virtual;
        function  ActiveControlType(DataCol: Longint; DataRow: Variant): TtsControlType; virtual;
        procedure Assign(Source: TPersistent); override;
        procedure AssignCellCombo(DataCol: Longint; DataRow: Longint);
        procedure AssignCellFont(DataCol: Longint; DataRow: Longint);
        procedure AssignRowCombo(DataRow: Longint);
        procedure AssignRowFont(DataRow: Longint);
        procedure CellFromXY(X, Y: Integer; var DisplayCol, DisplayRow: Longint);
        procedure CellInvalidate(DisplayCol, DisplayRow: Longint);
        function  CellRect(DisplayCol, DisplayRow: Longint): TRect;
        function  CellSelected(DisplayCol, DisplayRow: Longint): Boolean;
        procedure ColInvalidate(DisplayCol: Longint);
        function  ComboVisible: Boolean;
        procedure CopyData(Source: TtsBaseGrid); virtual;
        function  DateTimeVisible: Boolean;
        function  DropDownVisible: Boolean;
        procedure CreateDefaultButton(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        procedure CreateDefaultCombo(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
        procedure DeleteCols(FromDataCol, ToDataCol: Longint); virtual;
        procedure DeleteRows(FromDataRow, ToDataRow: Longint); virtual;
        procedure DeleteSelectedCols; virtual;
        procedure DeleteSelectedRows; virtual;
        procedure DestroyDefaultButton;
        procedure DestroyDefaultCombo;
        procedure DoDeleteCols(FromDataCol, ToDataCol: Longint);
        function  DrawCell3D(DataCol: Longint; DataRow: Longint): Boolean;
        function  Edit: Boolean; virtual;
        function  EditorActive: Boolean;
        function  EditRow: Boolean;
        function  EndEdit(Undo: Boolean): Boolean;
        function  GetRow(DataRow: Longint): TtsRow;
        function  GetCellPropSet: TtsCellPropSet;
        procedure HideDateTime;
        procedure HideCombo;
        function  HideEditor: Boolean;
        procedure InsertCol(DisplayCol: Longint);
        procedure InsertRow(DisplayRow: Longint);
        procedure Invalidate; override;
        procedure InvalidateNextCols(DataCol: Longint);
        function  IsFocused: Boolean;
        procedure LoadFromFile(const FileName: string; ColMatch: TtsColMatch); virtual;
        function  LoadFromRegistry(const Key, ValueName: string; ColMatch: TtsColMatch): Boolean; virtual;
        procedure LoadFromStream(Stream: TStream; ColMatch: TtsColMatch); virtual;
        procedure PutCellInView(DataCol, DataRow: Longint);
        procedure RefreshData(ResetOrder: TtsResetOrder; ResetPosition: TtsResetPosition);
        function  Reading: Boolean; virtual;
        procedure Reset; virtual;
        procedure ResetCellCombo(DataCol: Longint; DataRow: Longint);
        procedure ResetCellFont(DataCol: Longint; DataRow: Longint);
        procedure ResetCellTag(DataCol: Longint; DataRow: Longint);
        procedure ResetCellData(DataCol: Longint; DataRow: Longint);
        procedure ResetCellProperties(Properties: TtsProperties); virtual;
        procedure ResetColProperties(Properties: TtsProperties);
        procedure ResetCombo;
        procedure ResetProperties(Properties: TtsProperties);
        procedure ResetRowCombo(DataRow: Longint);
        procedure ResetRowFont(DataRow: Longint);
        procedure ResetRowProperties(Properties: TtsProperties); virtual;
        procedure ResetSelection;
        procedure RowInvalidate(DisplayRow: Longint);
        procedure SavePropToFile(const FileName: string; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean); virtual;
        procedure SavePropToStream(Stream: TStream; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean); virtual;
        procedure SavePropToRegistry(const Key, ValueName, FileName: string; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean); virtual;
        procedure SaveToFile(const FileName: string; SaveData: Boolean);
        procedure SaveToStream(Stream: TStream; SaveData: Boolean); virtual;
        procedure SaveToRegistry(const Key, ValueName, FileName: string; SaveData: Boolean); virtual;
        procedure SelectAll;
        procedure SelectCells(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom: Longint);
        procedure SelectCols(FromDisplayCol, ToDisplayCol: Longint; Select: Boolean);
        procedure SelectRows(FromDisplayRow, ToDisplayRow: Longint; Select: Boolean);
        procedure SetFocus; override;
        procedure SetTopLeft(DisplayCol, DisplayRow: Longint);
        procedure ShowDateTime;
        procedure ShowCombo;
        function  ShowEditor: Boolean;
        function  TotalColWidth : Integer;  // V3.0
        procedure Update; override;
        function  Writing: Boolean; virtual;
    end;

    {TtsCustomGrid}
    {Non data-aware grid component which can be used as a custom grid for
     creating visual grid components. Inherits most of its functionality from
     the base class TtsBaseGrid.}

    TtsCustomGrid = class(TtsBaseGrid)
    protected
        FLastRowLoaded: Longint;

        {Event fields}
        FOnButtonClick: TtsButtonEvent;
        FOnButtonDown: TtsButtonEvent;
        FOnButtonUp: TtsButtonEvent;
        FOnSpinButtonClick: TtsSpinButtonEvent;
        FOnSpinButtonDown: TtsSpinButtonEvent;
        FOnSpinButtonUp: TtsSpinButtonEvent;
        FOnSpinRepeat: TtsSpinRepeatEvent;
        FOnSpinIncrement: TtsSpinIncrementEvent;
        FOnCellEdit: TtsCellEditEvent;
        FOnCellLoaded: TtsCellLoadedEvent;
        FOnClickCell: TtsClickCellEvent;
        FOnComboCellLoaded: TtsComboCellLoadedEvent;
        FOnComboDropDown: TtsComboCellEvent;
        FOnComboGetValue: TtsComboGetValueEvent;
        FOnComboInit: TtsComboCellEvent;
        FOnComboRollUp: TtsComboCellEvent;
        FOnDateTimeInit: TtsDateTimeCellEvent;
        FOnDateTimeDropDown: TtsDateTimeCellEvent;
        FOnDateTimeRollUp: TtsDateTimeCellEvent;
        FOnDateTimeGetValue: TtsDateTimeGetValueEvent;
        FOnDblClickCell: TtsDblClickCellEvent;
        FOnDeleteRow: TtsDeleteRowEvent;
        FOnEndCellEdit: TtsCellEditingEvent;
        FOnEndRowEdit: TtsRowEditingEvent;
        FOnShowEditor: TtsShowEditorEvent;
        FOnInvalidMaskValue: TtsInvalidCellValueEvent;
        FOnInvalidMaskEdit: TtsInvalidCellKeysEvent;
        FOnGetDrawInfo: TtsGetDrawInfoEvent;
        FOnInsertRow: TtsInsertRowEvent;
        FOnPaintCell: TtsPaintCellEvent;
        FOnCellChanged: TtsCellChangedEvent;
        FOnRowChanged: TtsRowChangedEvent;
        FOnRowLoaded: TtsRowLoadedEvent;
        FOnStartCellEdit: TtsCellEditingEvent;
        FOnStartRowEdit: TtsRowEditingEvent;
        FOnTopLeftChanged: TtsTopLeftChangedEvent;
        FOnUndoCellEdit: TtsUndoCellEditEvent;
        FOnUndoRowEdit: TtsUndoRowEditEvent;
        FOnPrintRow : TtsPrintRowEvent;
        FOnPrintCell : TtsPrintCellEvent;

    protected
        {Miscellaneous procedures}
        procedure Paint; override;
        function  CreateCombo: TtsCombo; override;
        function  CreateComboGrid: TtsBaseGrid; override;
        procedure GetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo); override;
        procedure CellLoadedEvent(DataCol, DataRow: Longint; ControlType: TtsControlType; var Value: Variant); override;
        function  PaintCell(var DrawData: TtsDrawData; ARect: TRect; DrawSelected: Boolean): Boolean; override;
        procedure RowInserted(DataRow: Longint; ByUser: Boolean); override;
        procedure RowDeleted(DataRow: Longint; ByUser: Boolean); override;
        procedure TopLeftChangedEvent(OldCol, OldRow, NewCol, NewRow: Longint;
                                      ByUser: Boolean); override;
        function  ActivateDoGetDrawInfo: Boolean; override;

        {Event procedures}
        procedure DoRowLoaded(DataRow: Variant); override;
        procedure DoStartCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); override;
        procedure DoStartRowEdit(DataRow: Variant; var Cancel: Boolean); override;
        procedure DoEndCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); override;
        procedure DoEndRowEdit(DataRow: Variant; var Cancel: Boolean); override;
        procedure DoShowEditor(DataCol: Longint; DataRow: Variant; var Cancel: Boolean); override;
        procedure DoInvalidMaskValue(DataCol: Longint; DataRow: Variant; var Accept: Boolean); override;
        procedure DoInvalidMaskEdit(Keys: string; DataCol: Longint; DataRow: Variant; var Accept: Boolean); override;
        procedure DoUndoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean; var Cancel: Boolean); override;
        procedure DoUndoRowEdit(DataRow: Variant; ByUser: Boolean; var Cancel: Boolean); override;
        procedure DoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean); override;
        procedure DoCellChanged(OldDataCol, NewDataCol: Longint; OldDataRow, NewDataRow: Variant); override;
        procedure DoRowChanged(OldDataRow, NewDataRow: Variant); override;
        procedure DoPrintRow(DataRow: Longint; var Cancel : Boolean); virtual;
        procedure DoPrintCell(DataCol, DataRow: Longint; var Cancel : Boolean); virtual;
        procedure DoButtonClick(DataCol: Longint; DataRow: Variant); override;
        procedure DoButtonDown(DataCol: Longint; DataRow: Variant); override;
        procedure DoButtonUp(DataCol: Longint; DataRow: Variant); override;
        procedure DoSpinButtonClick(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); override;
        procedure DoSpinButtonDown(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); override;
        procedure DoSpinButtonUp(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton); override;
        procedure DoSpinRepeat(DataCol: Longint; DataRow: Variant; Count: Integer; SpinButton: TtsSpinButton); override;
        procedure DoSpinIncrement(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean); override;
        function  DoClickCell(DataColDown: Longint; DataRowDown: Variant; DataColUp: Longint;
                              DataRowUp: Variant; DownPos, UpPos: TtsClickPosition): Boolean; override;
        procedure DoDblClickCell(DataCol: Longint; DataRow: Variant; Pos: TtsClickPosition); override;
        procedure DoComboInit(DataCol: Longint; DataRow: Variant); override;
        procedure DoComboDropDown(DataCol: Longint; DataRow: Variant); override;
        procedure DoComboRollUp(DataCol: Longint; DataRow: Variant); override;
        procedure DoComboGetValue(GridDataCol: Longint; GridDataRow,
                                  ComboDataRow: Variant; var Value: Variant); override;
        procedure DoDateTimeInit(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); override;
        procedure DoDateTimeDropDown(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); override;
        procedure DoDateTimeRollUp(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant); override;
        procedure DoDateTimeGetValue(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant; var Value: Variant); override;
        procedure DoGetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo); virtual;
        procedure DoComboCellLoaded(DataCol, DataRow: Longint; var Value: Variant); virtual;
        procedure DoTopLeftChanged(OldCol, OldRow, NewCol, NewRow: Longint; ByUser: Boolean); virtual;
        procedure DoPaintCell(DataCol, DataRow: Longint; DrawRect:TRect;
                              State: TtsPaintCellState; var Cancel: Boolean); virtual;
        procedure DoCellLoaded(DataCol, DataRow: Longint; var Value: Variant); virtual;
        procedure DoDeleteRow(DataRow: Longint; ByUser: Boolean); virtual;
        procedure DoInsertRow(DataRow: Longint; ByUser: Boolean); virtual;

    protected
        function  GetXMLMetaData : String; virtual;
        function  GetXMLData : String; virtual;
        function  GetXMLRowData(forRow : Variant) : String; virtual;
        function  GetCSVRowData(forRow : Longint) : String; virtual;

        {event properties for published use}
        property OnButtonClick: TtsButtonEvent read FOnButtonClick write FOnButtonClick;
        property OnButtonDown: TtsButtonEvent read FOnButtonDown write FOnButtonDown;
        property OnButtonUp: TtsButtonEvent read FOnButtonUp write FOnButtonUp;
        property OnSpinButtonClick: TtsSpinButtonEvent read FOnSpinButtonClick write FOnSpinButtonClick;
        property OnSpinButtonDown: TtsSpinButtonEvent read FOnSpinButtonDown write FOnSpinButtonDown;
        property OnSpinButtonUp: TtsSpinButtonEvent read FOnSpinButtonUp write FOnSpinButtonUp;
        property OnSpinRepeat: TtsSpinRepeatEvent read FOnSpinRepeat write FOnSpinRepeat;
        property OnSpinIncrement: TtsSpinIncrementEvent read FOnSpinIncrement write FOnSpinIncrement;
        property OnCellChanged: TtsCellChangedEvent read FOnCellChanged write FOnCellChanged;
        property OnCellEdit: TtsCellEditEvent read FOnCellEdit write FOnCellEdit;
        property OnCellLoaded: TtsCellLoadedEvent read FOnCellLoaded write FOnCellLoaded;
        property OnClickCell: TtsClickCellEvent read FOnClickCell write FOnClickCell;
        property OnComboCellLoaded: TtsComboCellLoadedEvent read FOnComboCellLoaded write FOnComboCellLoaded;
        property OnComboDropDown: TtsComboCellEvent read FOnComboDropDown write FOnComboDropDown;
        property OnComboGetValue: TtsComboGetValueEvent read FOnComboGetValue write FOnComboGetValue;
        property OnComboInit: TtsComboCellEvent read FOnComboInit write FOnComboInit;
        property OnComboRollUp: TtsComboCellEvent read FOnComboRollUp write FOnComboRollUp;
        property OnDateTimeDropDown: TtsDateTimeCellEvent read FOnDateTimeDropDown write FOnDateTimeDropDown;
        property OnDateTimeGetValue: TtsDateTimeGetValueEvent read FOnDateTimeGetValue write FOnDateTimeGetValue;
        property OnDateTimeInit: TtsDateTimeCellEvent read FOnDateTimeInit write FOnDateTimeInit;
        property OnDateTimeRollUp: TtsDateTimeCellEvent read FOnDateTimeRollUp write FOnDateTimeRollUp;
        property OnDblClickCell: TtsDblClickCellEvent read FOnDblClickCell write FOnDblClickCell;
        property OnDeleteRow: TtsDeleteRowEvent read FOnDeleteRow write FOnDeleteRow;
        property OnEndCellEdit: TtsCellEditingEvent read FOnEndCellEdit write FOnEndCellEdit;
        property OnEndRowEdit: TtsRowEditingEvent read FOnEndRowEdit write FOnEndRowEdit;
        property OnShowEditor: TtsShowEditorEvent read FOnShowEditor write FOnShowEditor;
        property OnGetDrawInfo: TtsGetDrawInfoEvent read FOnGetDrawInfo write FOnGetDrawInfo;
        property OnInsertRow: TtsInsertRowEvent read FOnInsertRow write FOnInsertRow;
        property OnInvalidMaskValue: TtsInvalidCellValueEvent read FOnInvalidMaskValue write FOnInvalidMaskValue;
        property OnInvalidMaskEdit: TtsInvalidCellKeysEvent read FOnInvalidMaskEdit write FOnInvalidMaskEdit;
        property OnPaintCell: TtsPaintCellEvent read FOnPaintCell write FOnPaintCell;
        property OnRowChanged: TtsRowChangedEvent read FOnRowChanged write FOnRowChanged;
        property OnRowLoaded: TtsRowLoadedEvent read FOnRowLoaded write FOnRowLoaded;
        property OnStartCellEdit: TtsCellEditingEvent read FOnStartCellEdit write FOnStartCellEdit;
        property OnStartRowEdit: TtsRowEditingEvent read FOnStartRowEdit write FOnStartRowEdit;
        property OnTopLeftChanged: TtsTopLeftChangedEvent read FOnTopLeftChanged write FOnTopLeftChanged;
        property OnUndoCellEdit: TtsUndoCellEditEvent read FOnUndoCellEdit write FOnUndoCellEdit;
        property OnUndoRowEdit: TtsUndoRowEditEvent read FOnUndoRowEdit write FOnUndoRowEdit;
        property OnPrintRow : TtsPrintRowEvent read FOnPrintRow write FOnPrintRow;
        property OnPrintCell : TtsPrintCellEvent read FOnPrintCell write FOnPrintCell;

    public
        procedure Print; override;
        procedure PrintPreview; override;
        procedure ExportGrid; override;
        procedure ExportCSV(toFile : String); virtual;
        procedure ExportXML(toFile : String); virtual;

        property GridReport;
        property XMLMetaData : String read GetXMLMetaData;
        property XMLData : String read GetXMLData;        
    end;

    TtsGridStreamComponent = class(TComponent)
    protected
        FGrid: TtsBaseGrid;
        FSavePropKinds: TtsPropKinds;
        FProperties: TtsProperties;
        FGridCopied: Boolean;
        FSaveData: Boolean;
        FColMatch: TtsColMatch;
        FAllProperties: Boolean;

        procedure WriteGrid(Stream: TStream);
        procedure ReadGrid(Stream: TStream);
        procedure WriteData(Stream: TStream);
        procedure ReadData(Stream: TStream);
        procedure WriteColCount(Writer: TWriter);
        procedure ReadColCount(Reader: TReader);
        procedure WriteDefaultColwidth(Writer: TWriter);
        procedure ReadDefaultColwidth(Reader: TReader);
        procedure WriteColumns(Writer: TWriter);
        procedure ReadColumns(Reader: TReader);
        procedure WriteRowCount(Writer: TWriter);
        procedure ReadRowCount(Reader: TReader);
        procedure WriteDefaultRowHeight(Writer: TWriter);
        procedure ReadDefaultRowHeight(Reader: TReader);
        procedure WriteRows(Writer: TWriter);
        procedure ReadRows(Reader: TReader);
        procedure WriteCells(Writer: TWriter);
        procedure ReadCells(Reader: TReader);
        procedure WriteResetProps(Writer: TWriter);
        procedure ReadResetProps(Reader: TReader);
        procedure ReadProperties(Reader: TReader);
        procedure WriteProperties(Writer: TWriter);
        procedure ReadAllProperties(Reader: TReader);
        procedure WriteAllProperties(Writer: TWriter);
        function  DoColCount: Boolean;
        function  DoRowCount: Boolean;
        function  DoDefaultColWidth: Boolean;
        function  DoDefaultRowHeight: Boolean;
        procedure DefineProperties(Filer: TFiler); override;
        procedure CopyGrid(PropKinds: TtsPropKinds);
        procedure ResetGrid(PropKinds: TtsPropKinds; Properties: TtsProperties);
        procedure SetAllProperties(Value: Boolean);

    public
        constructor Create(AOwner: TComponent); override;
        destructor  Destroy; override;

        property Properties: TtsProperties read FProperties write FProperties;
        property AllProperties: Boolean read FAllProperties write SetAllProperties;

    published
        property SavePropKinds: TtsPropKinds read FSavePropKinds write FSavePropKinds;
        property SaveData: Boolean read FSaveData write FSaveData;
    end;

    {TtsCombo}
    {Combo box wrapper class for TtsBaseGrid}

    TtsCombo = class(TPersistent)
    protected
        FGrid: TtsBaseGrid;

        function  GetDropDownRows: Longint; virtual;
        function  GetDropDownCols: Longint; virtual;
        function  GetValueCol: Longint; virtual;
        function  GetComboDisplayCol: Longint; virtual;
        function  GetValueColSorted: Boolean; virtual;
        function  GetCompareType: TtsComboCompareType; virtual;
        function  GetAutoSearch: TtsComboAutoSearchType; virtual;
        function  GetAutoFill: Boolean; virtual;
        function  GetAutoFillConvertCase: TtsConvertCase; virtual;
        function  GetAutoLookup: Boolean; virtual;
        function  GetDropDownStyle: TtsDropDownStyle; virtual;
        function  GetGrid: TtsComboGrid;
        procedure SetDropDownRows(Value: Longint); virtual;
        procedure SetDropDownCols(Value: Longint); virtual;
        procedure SetValueCol(Value: Longint); virtual;
        procedure SetComboDisplayCol(Value: Longint); virtual;
        procedure SetValueColSorted(Value: Boolean); virtual;
        procedure SetCompareType(Value: TtsComboCompareType); virtual;
        procedure SetAutoSearch(value: TtsComboAutoSearchType); virtual;
        procedure SetAutoFill(Value: Boolean); virtual;
        procedure SetAutoFillConvertCase(Value: TtsConvertCase); virtual;
        procedure SetAutoLookup(Value: Boolean); virtual;
        procedure SetDropDownStyle(Value: TtsDropDownStyle); virtual;

    public
        constructor Create(ParentGrid: TtsBaseGrid);
        destructor  Destroy; override;

        procedure Assign(Source: TPersistent); override;
        procedure Reset; virtual;

        property AutoFill: Boolean read GetAutoFill write SetAutoFill default False;
        property AutoFillConvertCase: TtsConvertCase read GetAutoFillConvertCase write SetAutoFillConvertCase default afcOnEdit;
        property AutoLookup: Boolean read GetAutoLookup write SetAutoLookup default False;
        property AutoSearch: TtsComboAutoSearchType read GetAutoSearch write SetAutoSearch default asNone;
        property CompareType: TtsComboCompareType read GetCompareType write SetCompareType default ctCaseInsensitive;
        property DropDownCols: Longint read GetDropDownCols write SetDropDownCols default 1;
        property DropDownRows: Longint read GetDropDownRows write SetDropDownRows default 4;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property Grid: TtsComboGrid read GetGrid;
        property ValueCol: Longint read GetValueCol write SetValueCol default 1;
        property ComboDisplayCol: Longint read GetComboDisplayCol write SetComboDisplayCol default 1;
        property ValueColSorted: Boolean read GetValueColSorted write SetValueColSorted default False;
    end;

    {TtsComboGrid}
    {Combo box class for TtsBaseGrid}

    TtsComboGrid = class(TtsCustomGrid)
    protected
        FGrid: TtsBaseGrid;
        FCombo: TtsCombo;
        FParentGrid: TtsBaseGrid;
        FDropDownRows: Integer;
        FDropDownCols: Integer;
        FValueCol: Longint;
        FComboDisplayCol: Longint;
        FValueColSorted: Boolean;
        FDisplayColSorted: Boolean;
        FCompareType: TtsComboCompareType;
        FAutoSearch: TtsComboAutoSearchType;
        FAutoFill: Boolean;
        FAutoFillConvertCase: TtsConvertCase;
        FDropDownStyle: TtsDropDownStyle;

        function  GetDropDownRows: Longint; override;
        function  GetDropDownCols: Longint; override;
        function  GetValueCol: Longint; override;
        function  GetComboDisplayCol: Longint;
        function  GetValueColSorted: Boolean; override;
        function  GetCompareType: TtsComboCompareType; override;
        function  GetAutoSearch: TtsComboAutoSearchType; override;
        function  GetAutoFill: Boolean; override;
        function  GetAutoFillConvertCase: TtsConvertCase;
        function  GetAutoLookup: Boolean; override;
        function  GetDropDownStyle: TtsDropDownStyle; override;
        function  GetGrid: TtsComboGrid;
        procedure SetDropDownRows(Value: Longint); override;
        procedure SetDropDownCols(Value: Longint); override;
        procedure SetValueCol(Value: Longint); override;
        procedure SetComboDisplayCol(Value: Longint);
        procedure SetValueColSorted(Value: Boolean); override;
        procedure SetCompareType(Value: TtsComboCompareType); override;
        procedure SetAutoSearch(value: TtsComboAutoSearchType); override;
        procedure SetAutoFill(Value: Boolean); override;
        procedure SetAutoFillConvertCase(Value: TtsConvertCase);
        procedure SetAutoLookup(Value: Boolean); override;
        procedure SetDropDownStyle(Value: TtsDropDownStyle); override;
        function  GetParentGrid: TtsBaseGrid; override;
        procedure SetParentGrid(Value: TtsBaseGrid); override;
        function  GetParentGridCombo: TtsCombo; override;
        procedure SetParentGridCombo(Value: TtsCombo); override;

    public
        constructor Create(AOwner: TComponent); override;
        destructor Destroy; override;

        property AlwaysShowEditor;
        property AlwaysShowFocus;
        property AutoLookup;
        property Canvas;
        property Cell;
        property CellAlign;
        property CellAlignment;
        property CellButtonType;
        property CellCenterPicture;
        property CellColor;
        property CellCheckBoxState;
        property CellControlType;
        property CellDropDownStyle;
        property CellEditing;
        property CellFont;
        property CellHorzAlignment;
        property CellIs3D;
        property CellKeepAspectRatio;
        property CellMaskName;
        property CellParentFont;
        property CellPText;
        property CellReadOnly;
        property CellShrinkPicture;
        property CellSpinIncrement;
        property CellSpinOptions;
        property CellStretchPicture;
        property CellTextHeight;
        property CellTextWidth;
        property CellTextLines;
        property CellVertAlignment;
        property CellWordWrap;
        property CheckBoxGrayedBitmap;
        property CheckBoxOffBitmap;
        property CheckBoxOnBitmap;
        property Col;
        property CurrentCell;
        property CurrentDataCol;
        property CurrentDataRow;
        property DataColnr;
        property DataRownr;
        property DisplayColnr;
        property DisplayRownr;
        property EnablePaint;
        property EnableRedraw;
        property FastAssign;
        property FocusBorder;
        property FocusColor;
        property FocusBorderColor;
        property FocusFontColor;
        property Grid: TtsComboGrid read GetGrid;
        property GridData;
        property GridHeight;
        property GridStatus;
        property GridWidth;
        property HeadingAlignment;
        property HeadingTextHeight;
        property HeadingTextLines;
        property HorzScrollBarHeight;
        property HorzScrollBarVisible;
        property InsertionRow;
        property LeftCol;
        property MaxLeftCol;
        property MaxTopRow;
        property MouseStatus;
        property RowAlign;
        property RowAlignment;
        property RowButtonType;
        property RowCenterPicture;
        property RowChanged;
        property RowChangedIndicator;
        property RowColor;
        property RowControlType;
        property RowEditing;
        property RowFont;
        property RowHeight;
        property RowHorzAlignment;
        property RowId;
        property RowIs3D;
        property RowKeepAspectRatio;
        property RowMaskName;
        property RowParentCombo;
        property RowParentFont;
        property RowReadOnly;
        property RowSelected;
        property RowShrinkPicture;
        property RowSpinIncrement;
        property RowSpinOptions;
        property RowStretchPicture;
        property RowVertAlignment;
        property RowVisible;
        property RowWordWrap;
        property SelectedCells;
        property SelectedCols;
        property SelectedRows;
        property SpinButtonHeight;
        property SpinButtonWidth;
        property SpinRepeatDelay;
        property SpinStartDelay;
        property TopRow;
        property VertScrollBarVisible;
        property VertScrollBarWidth;
        property VisibleCols;
        property VisibleRows;

        property OnCellChanged;
        property OnCellLoaded;
        property OnClick;
        property OnClickCell;
        property OnColChanged;
        property OnColCountChanged;
        property OnColMoved;
        property OnColResized;
        property OnDblClick;
        property OnDblClickCell;
        property OnDeleteCol;
        property OnDeleteRow;
        property OnGetDrawInfo;
        property OnGridStatusChanged;
        property OnHeadingClick;
        property OnHeadingDown;
        property OnHeadingUp;
        property OnInsertCol;
        property OnInsertRow;
        property OnKeyDown;
        property OnKeyPress;
        property OnKeyUp;
        property OnMouseDown;
        property OnMouseMove;
        property OnMouseStatusChanged;
        property OnMouseUp;
        {$IFDEF TSVER_V4}
        property OnMouseWheel;
        property OnMouseWheelDown;
        property OnMouseWheelUp;
        {$ENDIF}
        property OnPaint;
        property OnPaintCell;
        property OnResize;
        property OnRowChanged;
        property OnRowCountChanged;
        property OnRowLoaded;
        property OnRowMoved;
        property OnRowResized;
        property OnSelectChanged;
        property OnTopLeftChanged;

    published
        property AutoFill: Boolean read GetAutoFill write SetAutoFill default False;
        property AutoFillConvertCase: TtsConvertCase read GetAutoFillConvertCase write SetAutoFillConvertCase default afcOnEdit;
        property AutoSearch: TtsComboAutoSearchType read GetAutoSearch write SetAutoSearch default asNone;
        property CompareType: TtsComboCompareType read GetCompareType write SetCompareType default ctCaseInsensitive;
        property DropDownRows;
        property DropDownCols;
        property DropDownStyle: TtsDropDownStyle read GetDropDownStyle write SetDropDownStyle default ddDropDown;
        property ValueCol: Longint read GetValueCol write SetValueCol default 1;
        property ComboDisplayCol: Longint read GetComboDisplayCol write SetComboDisplayCol default 1;
        property ValueColSorted: Boolean read GetValueColSorted write SetValueColSorted default False;

        property AlwaysShowScrollBar;
        property BorderStyle;
        property CenterPicture;
        property CheckBoxStyle;
        property CheckBoxValues;
        property Color;
        property Cols;
        property Ctl3D;
        property DefaultColWidth;
        property DefaultRowHeight;
        property DrawOverlap;
        property FixedColCount;
        property FixedLineColor;
        property FixedRowCount;
        property Font;
        property GridLines;
        property Heading3D;
        property HeadingColor;
        property HeadingFont;
        property HeadingHeight;
        property HeadingHorzAlignment;
        property HeadingOn;
        property HeadingParentFont;
        property HeadingVertAlignment;
        property HeadingWordWrap;
        property HorzAlignment;
        property Is3D;
        property KeepAspectRatio;
        property LineColor;
        property ParentColor;
        property ParentCtl3D;
        property ParentFont;
        property ParentShowHint;
        property ResizeCols;
        property ResizeColsInGrid;
        property ResizeRows;
        property ResizeRowsInGrid;
        property RowBarAlignment;
        property RowBarIndicator;
        property RowBarOn;
        property RowBarWidth;
        property Rows;
        property ScrollBars;
        property ScrollSpeed;
        property SelectionColor;
        property SelectionFontColor;
        property SelectionType;
        property ShowHint;
        property ShrinkPicture;
        property StoreData;
        property StretchPicture;
        property ThumbTracking;
        property TransparentColor;
        property Version;
        property VertAlignment;
        property WordWrap;

        {$IFNDEF TSVER_V3}
        property ColProperties;
        property RowProperties;
        property CellProperties;
        {$ENDIF}
    end;

    {TtsGrid}
    {Non data-aware grid component which can be used as a visual component.
     Inherits all of its functionality from the base class TtsCustomGrid, and
     only sets properties and event public and published.}

    TtsGrid = class(TtsCustomGrid)
    public
        property Canvas;
        property Cell;
        property CellTag;
        property CellData;
        property CellAlign;
        property CellAlignment;
        property CellButtonType;
        property CellDateTimeDef;
        property CellCenterPicture;
        property CellColor;
        property CellCheckBoxState;
        property CellCombo;
        property CellControlType;
        property CellDropDownStyle;
        property CellEditing;
        property CellFont;
        property CellHorzAlignment;
        property CellIs3D;
        property CellKeepAspectRatio;
        property CellMaskName;
        property CellParentCombo;
        property CellParentFont;
        property CellPText;
        property CellReadOnly;
        property CellShrinkPicture;
        property CellSpinIncrement;
        property CellSpinOptions;
        property CellStretchPicture;
        property CellTextHeight;
        property CellTextWidth;
        property CellTextLines;
        property CellVertAlignment;
        property CellWordWrap;
        property CheckBoxGrayedBitmap;
        property CheckBoxOffBitmap;
        property CheckBoxOnBitmap;
        property Col;
        property Combo;
        property CurrentCell;
        property CurrentDataCol;
        property CurrentDataRow;
        property DataColnr;
        property DataRownr;
        property DisplayColnr;
        property DisplayRownr;
        property EditMode;
        property EnablePaint;
        property EnableRedraw;
        property FastAssign;
        property GridData;
        property GridHeight;
        property GridStatus;
        property GridWidth;
        property HeadingAlignment;
        property HeadingTextHeight;
        property HeadingTextLines;
        property HorzScrollBarHeight;
        property HorzScrollBarVisible;
        property IdDataCol;
        property IdDataRow;
        property InsertionRow;
        property LeftCol;
        property MaxLeftCol;
        property MaxTopRow;
        property MouseStatus;
        property RowAlign;
        property RowAlignment;
        property RowButtonType;
        property RowDateTimeDef;
        property RowCenterPicture;
        property RowChanged;
        property RowColor;
        property RowCombo;
        property RowControlType;
        property RowDropDownStyle;
        property RowEditing;
        property RowFont;
        property RowHeight;
        property RowHorzAlignment;
        property RowId;
        property RowIs3D;
        property RowKeepAspectRatio;
        property RowMaskName;
        property RowParentCombo;
        property RowParentFont;
        property RowReadOnly;
        property RowSelected;
        property RowShrinkPicture;
        property RowSpinIncrement;
        property RowSpinOptions;
        property RowStretchPicture;
        property RowVertAlignment;
        property RowVisible;
        property RowWordWrap;
        property SelectedCells;
        property SelectedCols;
        property SelectedRows;
        property TopRow;
        property VertScrollBarVisible;
        property VertScrollBarWidth;
        property VisibleCols;
        property VisibleRows;

    published
        property Align;
        property AlwaysShowEditor;
        property AlwaysShowFocus;
        property AlwaysShowScrollBar;
        {$IFDEF TSVER_V4}
        property Anchors;
        {$ENDIF}
        property AutoScale;
        property BorderStyle;
        property ButtonEdgeWidth;
        property DateTimeDef;
        property CellSelectMode;
        property CenterPicture;
        property CheckBoxStyle;
        property CheckBoxValues;
        property CheckMouseFocus;
        property ColMoving;
        property Color;
        property Cols;
        property ColSelectMode;
        {$IFDEF TSVER_V4}
        property Constraints;
        {$ENDIF}
        property Ctl3D;
        property DefaultButtonHeight;
        property DefaultButtonWidth;
        property DefaultColWidth;
        property DefaultRowHeight;
        property DragCursor;
        {$IFDEF TSVER_V4}
        property DragKind;
        {$ENDIF}
        property DragMode;
        property DrawOverlap;
        property EditColor;
        property EditFontColor;
        property Enabled;
        property ExportDelimiter;
        property FixedColCount;
        property FixedLineColor;
        property FixedRowCount;
        property FocusBorder;
        property FocusColor;
        property FocusBorderColor;
        property FocusFontColor;
        property FlatButtons;
        property Font;
        property GridLines;
        property GridMode;
        property Heading3D;
        property HeadingHorzAlignment;
        property HeadingButton;
        property HeadingColor;
        property HeadingFont;
        property HeadingHeight;
        property HeadingOn;
        property HeadingParentFont;
        property HeadingVertAlignment;
        property HeadingWordWrap;
        property HorzAlignment;
        property ImageList;
        property InactiveButtonState;
        property Is3D;
        property KeepAspectRatio;
        property LineColor;
        property MaskDefs;
        property ParentColor;
        property ParentCtl3D;
        property ParentFont;
        property ParentShowHint;
        property PopupMenu;
        property PrintTitle;
        property PrintTotals;
        property PrintCols;
        property PrintWithGridFormats;
        property ProvideGridMenu;
        property AlwaysDetectButton;
        property GridReport;
        property PrintLinesPerPage;
        property PrintOrientation;
        property ReadOnlyButton;
        property ResizeCols;
        property ResizeColsInGrid;
        property ResizeRows;
        property ResizeRowsInGrid;
        property RowBarAlignment;
        property RowBarIndicator;
        property RowBarOn;
        property RowBarWidth;
        property RowChangedIndicator;
        property RowMoving;
        property Rows;
        property RowSelectMode;
        property ScrollBars;
        property ScrollSpeed;
        property SelectionColor;
        property SelectionFontColor;
        property SelectionType;
        property SelectedAreaCursor;
        property SelectFixed;
        property ShowHint;
        property ShrinkPicture;
        property SkipReadOnly;
        property SpinButtonHeight;
        property SpinButtonWidth;
        property SpinRepeatDelay;
        property SpinStartDelay;
        property StoreData;
        property StretchPicture;
        property TabOrder;
        property TabRowWrap;
        property ThumbTracking;
        property TransparentColor;
        property Version;
        property VertAlignment;
        property Visible;
        property WantTabs;
        property WordWrap;
        property XMLExport;

        {$IFNDEF TSVER_V3}
        property ColProperties;
        property RowProperties;
        property CellProperties;
        {$ENDIF}

        property OnButtonClick;
        property OnButtonDown;
        property OnButtonUp;
        property OnDateTimeDropDown;
        property OnDateTimeGetValue;
        property OnDateTimeInit;
        property OnDateTimeRollUp;
        property OnCanStartDrag;
        property OnCellChanged;
        property OnCellEdit;
        property OnCellLoaded;
        property OnClick;
        property OnClickCell;
        {$IFDEF TSVER_V5}
        property OnContextPopup;
        {$ENDIF}
        property OnColChanged;
        property OnColCountChanged;
        property OnColMoved;
        property OnColResized;
        property OnComboCellLoaded;
        property OnComboCompareValue;
        property OnComboLCompareValue;
        property OnComboDropDown;
        property OnComboGetValue;
        property OnComboInit;
        property OnComboRollUp;
        property OnDblClick;
        property OnDblClickCell;
        property OnDeleteCol;
        property OnDeleteRow;
        property OnDragDrop;
        property OnDragOver;
        property OnEditTextResized;
        property OnEndCellEdit;
        {$IFDEF TSVER_V4}
        property OnEndDock;
        {$ENDIF}
        property OnEndDrag;
        property OnEndRowEdit;
        property OnEnter;
        property OnExit;
        property OnGetDrawInfo;
        property OnGridStatusChanged;
        property OnHeadingClick;
        property OnHeadingDown;
        property OnHeadingUp;
        property OnInsertCol;
        property OnInsertRow;
        property OnInvalidMaskValue;
        property OnInvalidMaskEdit;
        property OnKeyDown;
        property OnKeyPress;
        property OnKeyUp;
        property OnMouseDown;
        property OnMouseMove;
        property OnMouseStatusChanged;
        property OnMouseUp;
        {$IFDEF TSVER_V4}
        property OnMouseWheel;
        property OnMouseWheelDown;
        property OnMouseWheelUp;
        {$ENDIF}
        property OnPrintRow;
        property OnPrintCell;
        property OnPaint;
        property OnPaintCell;
        property OnResize;
        property OnRowChanged;
        property OnRowCountChanged;
        property OnRowLoaded;
        property OnRowMoved;
        property OnRowResized;
        property OnSelectChanged;
        property OnShowEditor;
        property OnSpinButtonClick;
        property OnSpinButtonDown;
        property OnSpinButtonUp;
        property OnSpinIncrement;
        property OnSpinRepeat;
        property OnStartCellEdit;
        {$IFDEF TSVER_V4}
        property OnStartDock;
        {$ENDIF}
        property OnStartDrag;
        property OnStartRowEdit;
        property OnTopLeftChanged;
        property OnUndoCellEdit;
        property OnUndoRowEdit;

        property OnPrintGrid;
    end;


function TranslateColor(aColor : TColor) : TColor;
function ColorToHex(Color: TColor): string; 
function VariantToBitmap(Value: Variant): TBitmap;
function BitmapToVariant(Value: TBitmap): Variant;

var
    CursorArrowRev: HCursor;
    CursorHorArrowRight: HCursor;
    CursorVertArrowDown: HCursor;

const
    StsColOutOfRange = 'Column index %d out of range';
    StsRowOutOfRange = 'Row index %d out of range';
    StsInCellLoaded = 'Cannot get Cell property value while in OnCellLoaded event';
    StsInvalidString = 'Invalid cell value. A text column requires a value of type string';
    StsInvalidCheck = 'Invalid cell value. A checkbox column requires a value of type TCheckBoxState or string';
    StsInvalidBitmap = 'Invalid cell value. A picture column requires a value of type TBitmap or string';
    StsCreateCombo   = 'Cannot create combo box. Method CreateCombo has not been not implemented in derived class';
    StsCreateComboGrid = 'Cannot create combo box. Method CreateComboGrid has not been not implemented in derived class';
    StsInvalidAssign = 'Cannot assign %s to %s';
    StsUnknownField = 'Unknown field name ''%s''';
    StsInvalidCheckBoxValues = 'Invalid CheckBoxValues. CheckBoxValues have the format ''Checked|Unchecked|Grayed''. The Grayed value is optional';
    StsHTMLFontStyle = ' style="font-family: ''FONTNAME''; font-size: FNSIZE; background: BGCOLOR; color: FNCOLOR; font-weight: FNBOLD; height: HDHEIGHTpx;"';
    StsHTMLTable     = '<Table cellspacing=CELLSPACE cellpadding=CELLPAD border="BORDERWIDTH" frame="TABFRAME" width=TABWIDTH FONTSTYLE>';
    StsHTMLCellStyle = ' style="background-color: BGCOLOR; color: FNCOLOR;"';

    tsStretchId = 1;
    tsShrinkId = 2;
    tsCenterId = 3;
    tsRatioId = 4;

implementation

{$R *.RES}
{$R *.dcr}

uses
    Clipbrd, TypInfo, TSMbcs {$IFDEF TSVER_V7} ,Themes {$ENDIF};

const
    VersionNumber = '2.20.26';
    DefaultCheckBoxWidth = 13;
    DefaultCheckBoxHeight = 13;
    CheckBoxOnOffset = 0;
    CheckBoxOffOffset = 1;
    CheckBoxGrayedOffset = 2;
    CheckBoxBitmapCount = 9;
    DefaultCheckBoxMaskColor = clWhite;
    DefaultCheckBoxMaskToColor = clSilver;
    KeyScrollPerc = 0.25;
    SmallAllocSize = 256;

    ResizeRange = 4;
    MinWaitingTime = 0;
    MaxWaitingTime = 200;
    DefaultScrollRange = 30;
    HeadButWidth = 14;
    HeadButHeight = 14;
    ComboSearchTimeOut = 2000;
    ButtonTimerID = 1;
    SpinTimerID = 2;
    MinSpinButtonExtent = 3;

    HeadingShadeColor = clGray;
    HeadingLineColor = clBlack;
    CellShadeColor = clGray;
    PATAND = $A000C9;

type
    TWinControl_ = class(TWinControl) end;
    Tts2DStorage_ = class(Tts2DStorage) end;
    TReader_ = class(TReader) end;

var
    FGridMemoryCanvas: TtsMemoryCanvas = nil;
    FControlMemoryCanvas: TtsMemoryCanvas = nil;
    FCheckBoxBitmaps: TBitmap = nil;
    FPictureMonoMask: TBitmap = nil;
    FSkipDouble: Boolean = False;

    BitMapArrowRight: TBitMap;
    BitMapInsertRow: TBitmap;
    BitMapChangedRow: TBitmap;
    BitMapCombo: TBitmap;
    BitMapButtonDetail: TBitmap;
    BitMapSortUp: TBitmap;
    BitMapSortDown: TBitmap;
    BitMapSortBullet: TBitmap;
    BitmapSpinUp: TBitmap;
    BitmapSpinDown: TBitmap;
    BitmapSpinLeft: TBitmap;
    BitmapSpinRight: TBitmap;

{Helper routines}

function ColorToHex(Color: TColor): string;
var r,g,b: byte;
begin
  r:=GetRValue(Integer(Color));
  g:=GetGValue(Integer(Color));
  b:=GetBValue(Integer(Color));
  Result:=IntToHex(r,2)+IntToHex(g,2)+IntToHex(b,2);
end;

function TranslateColor(aColor : TColor) : TColor;
begin
  Result := aColor;
  case aColor of    //
    clBackGround    : Result := clAqua;
    clBtnFace       : Result := clSilver;
    clActiveCaption : Result := clBlack;
    clInActiveCaption : Result := clBlue;
    clMenu            : Result := clDkGray;
    clWindow          : Result := clWhite;
    clWindowFrame     : Result := clGray;
    clMenuText        : Result := clGreen ;
    clWindowText      : Result := clLime;
    clCaptionText     : Result := clLtGray ;
    clActiveBorder    : Result := clMaroon;
    clInactiveBorder  : Result := clNavy;
    clAppWorkSpace    : Result := clOlive;
    clHighlight       : Result := clPurple;
    clHighlightText    : Result := clRed;
    clBtnShadow       : Result := clTeal;
    clGrayText        : Result := clWhite;
    clBtnText         : Result := clBlack;
    clInactiveCaptionText  : Result := clYellow;
    clBtnHighlight    : Result := clYellow;
    cl3DdkShadow      : Result := clYellow;
    cl3DLight         : Result := clYellow;
    clInfoText        : Result := clYellow;
    clInfoBk          : Result := clYellow;
  end;    // case
end;

function VariantToBitmap(Value: Variant): TBitmap;
begin
    Result := TBitmap(VariantToObject(Value));
end;

function BitmapToVariant(Value: TBitmap): Variant;
begin
    Result := ObjectToVariant(Value);
end;

function GridRect(Left, Top, Right, Bottom: Longint): TGridRect;
var
    AGridRect: TGridRect;
begin
    AGridRect.Left := Left;
    AGridRect.Top := Top;
    AGridRect.Right := Right;
    AGridRect.Bottom := Bottom;
    Result := AGridRect;
end;

function DefaultPropValue(Prop: TtsProperty): Variant;
var
    Options: TtsSpinOptions;
begin
    Result := Unassigned;
    case Prop of
        prColor: Result := clNone;
        prFont: Result := ObjectToVariant(nil);
        prIs3D: Result := False;
        prAlign: Result := False;
        prAlignment: Result := taLeftJustify;
        prHorzAlignment: Result := htaDefault;
        prVertAlignment: Result := vtaDefault;
        prReadOnly: Result := False;
        prSelected: Result := False;
        prWordWrap: Result := wwDefault;
        prButtonType: Result := btDefault;
        prDropDownStyle: Result := ddDropDown;
        prCellReadOnly: Result := roDefault;
        prParentFont: Result := True;
        prMask: Result := '';
        prCombo: Result := ObjectToVariant(nil);
        prParentCombo: Result := True;
        prPicture: Result := dopDefault;
        prControlType: Result := ctDefault;
        prSpinOptions: begin Options := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit]; Result := Byte(Options); end;
        prSpinIncrement: Result := 1;
        prDateTime: Result := ObjectToVariant(nil);
        prTag  : Result := 0;
        prData : Result := ObjectToVariant(nil);
    end;
end;

function ReadAlignment(Reader: TReader): TAlignment;
var
    Value: string;
begin
    Value := LowerCase(Reader.ReadIdent);
    if Value = 'taleftjustify' then
        Result := taLeftJustify
    else if Value = 'tarightjustify' then
        Result := taRightJustify
    else if Value = 'tacenter' then
        Result := taCenter
    else
        Result := taLeftJustify;
end;

//Implementation of class TtsGridControl

constructor TtsGridControl.Create(AOwner : TComponent);
begin
    inherited Create(AOwner);

    FLastLButtonTime := 0;
    FDblClickPos := Point(0,0);
    FOnEndKeyDown := nil;
    FOnEndKeyUp := nil;
    FOnEndKeyPress := nil;
    FOnEdit := nil;
    FOnCanChange := nil;
    FOnNotifyChanged := nil;
    FOnChanged := nil;
    FOnUndoChanged := nil;
    FOnKillFocus := nil;
    FDoubleClickOk := false;
    FAlignment := taLeftJustify;
    FVertAlignment := vtaDefault;
    FLeftMargin := 0;
    ShowHint := False;
    ParentShowHint := False;
    FClickOnMouseUp := False;
    FMouseDownOccured := False;
    FKeyEdit := True;
    FMouseSelect := True;
    FCanDblClick := True;
    FWantTabs := True;
    FDcPrepared := False;
end;

destructor TtsGridControl.Destroy;
begin
    ResetControlDc;
    inherited Destroy;
end;

procedure TtsGridControl.WMKillFocus(var Message : TMessage);
begin
    inherited;
    if csDestroying in ComponentState then Exit;
    if Assigned(FOnKillFocus) then FOnKillFocus(Self);
end;

procedure TtsGridControl.WMLButtonUp(var Message: TWMLButtonUp);
begin
    if csClicked in ControlState then
    begin
        ControlState := ControlState - [csClicked];
        FClickOnMouseUp := FMouseDownOccured or Focused;
    end;

    inherited;
end;

procedure TtsGridControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
    FLastLButtonTime := 0;

    if FDoubleClickOk then
    begin
        FDoubleClickOk := False;
        inherited;
    end
    else
        SendMessage(Handle, WM_LBUTTONDOWN, TMessage(Message).WParam, TMessage(Message).LParam);
end;

procedure TtsGridControl.WMLButtonDown(var Message: TWMLButtonDown);
begin
    FDoubleClickOk := (KeyEdit or MouseSelect) and FCanDblClick and ((Message.Keys and MK_LBUTTON) <> 0);
    FMouseDownOccured := True;

    if FDoubleClickOk and not FSkipDouble and
       (GetTickCount >= FLastLButtonTime) and
       (GetTickCount - FLastLButtonTime <= GetDoubleClickTime) and
       (Message.XPos = FDblClickPos.X) and (Message.YPos = FDblClickPos.Y) then
    begin
        SendMessage(Handle, WM_LBUTTONDBLCLK, TMessage(Message).WParam, TMessage(Message).LParam);
        FLastLButtonTime := 0;
    end
    else
    begin
        FSkipDouble := ((Message.Keys and MK_LBUTTON) = 0);
        FLastLButtonTime := GetTickCount;
        FDblCLickPos.X := Message.XPos;
        FDblCLickPos.Y := Message.YPos;
        inherited;
    end;
end;

procedure TtsGridControl.CMShowingChanged(var Message: TMessage);
const
    ShowFlags: array[Boolean] of Word = (
        SWP_NOREDRAW + SWP_NOSIZE + SWP_NOZORDER + SWP_NOACTIVATE + SWP_NOMOVE + SWP_HIDEWINDOW,
        SWP_NOREDRAW + SWP_NOSIZE + SWP_NOZORDER + SWP_NOACTIVATE + SWP_NOMOVE + SWP_SHOWWINDOW);
begin
    SetWindowPos(Handle, 0, 0, 0, 0, 0, ShowFlags[Showing]);
end;

procedure TtsGridControl.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
    inherited;
    Message.Result := Message.Result or DLGC_WANTARROWS or DLGC_WANTCHARS;

    if WantTabs and (GetKeyState(VK_CONTROL) >= 0) then
        Message.Result := Message.Result or DLGC_WANTTAB;

    if WantKey(VK_ESCAPE) and (GetKeyState(VK_ESCAPE) < 0) then
        Message.Result := Message.Result or DLGC_WANTALLKEYS;

    if GetKeyState(VK_RETURN) < 0 then
        Message.Result := Message.Result or DLGC_WANTALLKEYS;
end;

procedure TtsGridControl.WMMove(var Message: TWMMove);
begin
    FLastLButtonTime := 0;
    inherited;
end;

procedure TtsGridControl.WMEraseBkGnd(var Message: TWMEraseBkGnd);
begin
    if (csDesigning in ComponentState) then
    begin
        inherited;
        Exit;
    end;
end;

procedure TtsGridControl.WMPaint(var Message: TWMPaint);
begin
    if (csDesigning in ComponentState) then
    begin
        inherited;
        Exit;
    end;

    PaintHandler(Message);
end;

procedure TtsGridControl.CMFontChanged(var Message: TMessage);
begin
    inherited;
    if HandleAllocated then Canvas.Font := Font;
end;

procedure TtsGridControl.WndProc(var Message: TMessage);
begin
    case Message.Msg of
        WM_SETFOCUS:
            begin
                if (GetParentForm(Self) = nil) or GetParentForm(Self).SetFocusedControl(Grid) then Dispatch(Message);
                Exit;
            end;
    end;
    inherited WndProc(Message);
end;

procedure TtsGridControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    if FClickOnMouseUp then Click;
    FClickOnMouseUp := False;
    FMouseDownOccured := False;

    inherited MouseUp(Button, Shift, X, Y);
end;

procedure TtsGridControl.PaintWindow(DC : HDC);
var
    Rect : TRect;
begin
    FControlMemoryCanvas.Lock(Self);
    try
        SetControlDc(Dc);
        GetClipBox(DC, Rect);
        FControlMemoryCanvas.SetObjects(Rect);

        inherited PaintWindow(FControlMemoryCanvas.Dc);

        BitBlt(DC, Rect.Left, Rect.Top, Rect.Right - Rect.Left, Rect.Bottom - Rect.Top,
               FControlMemoryCanvas.Dc, Rect.Left, Rect.Top, cmSrcCopy);
    finally
        FControlMemoryCanvas.Unlock;
    end;
end;

procedure TtsGridControl.SetControlDc(Dc: Hdc);
begin
    if not FDcPrepared then
    begin
        FControlMemoryCanvas.Prepare(Dc, Width, Height);
        FDcPrepared := True;
    end
    else
        FControlMemoryCanvas.Resize(Dc, Width, Height);
end;

procedure TtsGridControl.ResetControlDc;
begin
    if FDcPrepared then
    begin
        FControlMemoryCanvas.Lock(Self);
        try
            FControlMemoryCanvas.Release;
            FDcPrepared := False;
        finally
            FControlMemoryCanvas.Unlock;
        end;
    end;
end;

procedure TtsGridControl.SetFocus;
begin
    if Focused then Exit;
    inherited;
end;

procedure TtsGridControl.SetAlignment(Align : TAlignment);
begin
    FAlignment := Align;
end;

procedure TtsGridControl.SetVertAlignment(Value : TtsVertAlignment);
begin
    FVertAlignment := Value;
end;

procedure TtsGridControl.SetWordWrap(Value: TtsWordWrap);
begin
    FWordWrap := Value;
end;

function TtsGridControl.CheckCanChange(Edit: Boolean): Boolean;
var
    Cancel: Boolean;
begin
    Cancel := False;
    if Assigned(FOnCanChange) then FOnCanChange(Self, Edit, Cancel);
    Result := not Cancel;
end;

function TtsGridControl.CheckCanEdit(CheckKeyEdit: Boolean): Boolean;
var
    Cancel: Boolean;
begin
    Result := (not CheckKeyEdit) or KeyEdit;
    if Result then
    begin
        Cancel := False;
        if Assigned(FOnEdit) then FOnEdit(Self, Cancel);
        Result := not Cancel;
    end;
    if Result then Result := CheckCanChange(True);
end;

function TtsGridControl.WantKey(Key: Word): Boolean;
begin
    Result := False;
    if Assigned(FOnWantKey) then FOnWantKey(Self, Key, Result);
end;

function TtsGridControl.IsEditKey(Key: Char): Boolean;
begin
    Result := False;
end;

procedure TtsGridControl.ChangeScale(M, D: Integer);
begin
end;

//End implementation of class TtsGridControl

//Implementation of class TtsEditMaskLink

constructor TtsEditMaskLink.Create(EditBox: TtsGridEditBox);
begin
    inherited Create;
    FEditBox := EditBox;
end;

procedure TtsEditMaskLink.MaskChanged(Mask: TtsMaskItem);
begin
    FEditBox.ResetEditMask;
end;

procedure TtsEditMaskLink.MaskDefsDeleted;
begin
    FEditBox.ResetEditMask;
end;

//End implementation of class TtsEditMaskLink

//Implementation of class TtsGridEditBox

constructor TtsGridEditBox.Create(AOwner : TComponent);
begin
    inherited Create(AOwner);

    FText := '';
    FTextLines := TtsIntegerList.Create;
    FTextLines.AddItem(0);

    FOldText := '';
    FOldTextSaved := false;
    FOldLineCount := FTextLines.Count;
    FSelStart := 0;
    FSelLength := 0;
    FSelByteStart := 0;
    FSelByteLength := 0;
    FTextPos := 0;
    FCaretRow := 0;
    FCaretOffset := 0;
    FCaretBeforePos := true;
    FStartDisplayChar := 0;
    FFirstDisplayRow := 0;
    FTextRows := 1;
    FCaretPos := Point(0, 0);
    FCaretVisible := false;
    FCanSetCaret := true;
    FSetCaretVisible := false;
    FMouseButtonDown := false;
    FMouseStartPos := 0;
    FMouseDownPos := Point(0,0);
    FCheckMouseDownPos := false;
    FKeyRepeated := false;
    Cursor := crDefault;
    FRightMargin := 0;
    FCaretBitmap := nil;
    FMaxLength := 0;
    FLeadByte := #0;

    FEditMask := nil;
    FMaskLink := TtsEditMaskLink.Create(Self);
    FMaskName := '';
end;

destructor TtsGridEditBox.Destroy;
begin
    FMaskLink.Free;
    FTextLines.Free;
    DestroyCaretBitmap;
    inherited Destroy;
end;

procedure TtsGridEditBox.SelectAll;
begin
    if IsMultiLine or (Alignment <> taRightJustify)
        then MoveToStartOfText(False)
        else MoveToEndOfText(False);

    SetSelByteStart(0);
    SetSelByteLength(Length(FText));
    Invalidate;
end;

function TtsGridEditBox.AllSelected : Boolean;
begin
    Result := false;
    if (FSelByteStart = 0) and (FSelByteLength = Length(FText)) then
    begin
        Result := true;
    end;
end;

function TtsGridEditBox.LineCount: Integer;
begin
    Result := FTextLines.Count;
end;

procedure TtsGridEditBox.DisplayEditText;
begin
    GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    if Alignment in [taLeftJustify, taCenter] then
        FStartDisplayChar := 0
    else
        FStartDisplayChar := Length(FText);
    SetCaretRowAndOffset(FTextPos, FCaretBeforePos);
    FCaretPos := GetTextCaretPos;
    MoveCaretIntoView(true, KeyScrollPerc);
end;

function TtsGridEditBox.EditTextResized(ByUser: Boolean): Boolean;
var
    OldHeight: Integer;
begin
    OldHeight := Height;
    if Assigned(FOnNotifyChanged) then OnNotifyChanged(Self, True);
    if Assigned(FOnEditTextResized) then FOnEditTextResized(Self, ByUser);
    Result := OldHeight <> Height;
end;

procedure TtsGridEditBox.SetTextValue(Value : string; Edit, ByUser: Boolean);
var
    Dc: Hdc;
begin
    Dc := Canvas.Handle;

    if ByUser and Edit and (KeyEdit or MouseSelect)
        then SaveOldText
        else FOldTextSaved := False;

    FText := Value;
    GetTextLines(Dc, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    SetTextPosition(0, True);
    SetSelByteStart(0);
    if Edit then
    begin
        if EditTextResized(ByUser) then
        begin
            Dc := Canvas.Handle;
            GetTextLines(Dc, PChar(FText), Height, Width, Alignment,
                         (WordWrap <> wwOff), FTextLines, 0);
        end;
    end;

    if Alignment in [taLeftJustify, taCenter]
        then FStartDisplayChar := 0
        else FStartDisplayChar := Length(FText);

    SetSelByteStart(0);
    if IsMultiLine or (Alignment <> taRightJustify)
        then MoveToStartOfText(False)
        else MoveToEndOfText(False);
    Invalidate;

    if Assigned(FOnNotifyChanged) then OnNotifyChanged(Self, True);
    if Assigned(FOnChanged) then FOnChanged(Self, Edit, ByUser, False);
end;

procedure TtsGridEditBox.SetText(Value : string);
begin
    if not CheckCanChange(False) then Exit;
    SetTextValue(Value, False, False);
end;

procedure TtsGridEditBox.SetEditText(Value: string; ByUser: Boolean);
begin
    if not CheckCanEdit(False) then Exit;
    SetTextValue(Value, True, ByUser);
end;

procedure TtsGridEditBox.SetAlignment(Align : TAlignment);
begin
    if Alignment = Align then Exit;

    inherited SetAlignment(Align);

    if Alignment in [taLeftJustify, taCenter] then
        FRightMargin := 0
    else
        FRightMargin := RIGHT_PRINT_MARGIN;

    DisplayEditText;
    Invalidate;
end;

procedure TtsGridEditBox.SetVertAlignment(Value : TtsVertAlignment);
begin
    if VertAlignment = Value then Exit;
    inherited SetVertAlignment(Value);
    DisplayEditText;
    Invalidate;
end;

procedure TtsGridEditBox.SetWordWrap(Value: TtsWordWrap);
begin
    if WordWrap = Value then Exit;

    inherited SetWordWrap(Value);
    DisplayEditText;
    Invalidate;
end;

procedure TtsGridEditBox.SetSelByteStart(Value : Integer);
begin
    if (Value >= 0) and (Value <= Length(FText)) then
    begin
        if (FSelByteStart <> Value) or (FSelByteLength <> 0) then
        begin
            FSelByteStart := Value;
            FSelByteLength := 0;
            FSelStart := 0;
            FSelLength := 0;

            Invalidate;
            if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, False);
        end;
    end;
end;

procedure TtsGridEditBox.SetSelByteLength(Value : Integer);
begin
    if Value >= 0 then
    begin
        if Value + FSelByteStart > Length(FText) then
        begin
            Value := Length(FText) - Value;
        end;

        if FSelByteLength <> Value then
        begin
            FSelLength := 0;
            FSelByteLength := Value;
            Invalidate;
            if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, False);
        end;
    end;
end;

procedure TtsGridEditBox.SetSelStart(Value: Integer);
var
    Chars, Bytes: Integer;
begin
    PCountChars(PChar(FText), Value, Length(FText), Chars, Bytes, False);
    SetSelByteStart(Bytes);
end;

procedure TtsGridEditBox.SetSelLength(Value: Integer);
var
    Chars, Bytes: Integer;
begin
    PCountChars(PChar(FText) + FSelByteStart, Value, Length(FText) - FSelByteStart, Chars, Bytes, False);
    SetSelByteLength(Bytes);
end;

function TtsGridEditBox.GetSelStart: Integer;
var
    Chars, Bytes: Integer;
begin
    if FSelByteStart = 0 then
        Result := FSelByteStart
    else if FSelStart <> 0 then
        Result := FSelStart
    else
    begin
        PCountChars(PChar(FText), FSelByteStart, FSelByteStart, Chars, Bytes, False);
        FSelStart := Chars;
        Result := FSelStart;
    end;
end;

function TtsGridEditBox.GetSelLength: Integer;
var
    Chars, Bytes: Integer;
begin
    if FSelByteLength = 0 then
        Result := FSelByteLength
    else if FSelLength <> 0 then
        Result := FSelLength
    else
    begin
        PCountChars(PChar(FText) + FSelByteStart, FSelByteLength, FSelByteLength, Chars, Bytes, False);
        FSelLength := Chars;
        Result := FSelLength;
    end;
end;

procedure TtsGridEditBox.ReplaceSelText(Value: string);
begin
    if FSelByteLength <> 0 then System.Delete(FText, FSelByteStart + 1, FSelByteLength);
    Insert(Value, FText, FSelByteStart + 1);

    if FSelByteStart < FStartDisplayChar then
    begin
        if FSelByteStart + FSelByteLength - 1 < FStartDisplayChar then
            FStartDisplayChar := FStartDisplayChar - FSelByteLength + Length(Value)
        else
            FStartDisplayChar := FSelByteStart;
    end;

    GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    SetTextPosition(FSelByteStart + Length(Value), FCaretBeforePos);
    SetSelByteStart(FSelByteStart + Length(Value));

    if EditTextResized(True) then
    begin
        GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                     (WordWrap <> wwOff), FTextLines, 0);
    end;

    MoveCaretIntoView(False, KeyScrollPerc);
    Invalidate;
end;

procedure TtsGridEditBox.SetSelText(Value : string);
begin
    if (Value = '') and (FSelByteLength = 0) then Exit;
    if not CheckCanEdit(False) then Exit;

    ReplaceSelText(Value);

    if Assigned(FOnNotifyChanged) then OnNotifyChanged(Self, True);
    if Assigned(FOnChanged) then FOnChanged(Self, True, False, False);
end;

function TtsGridEditBox.GetSelText: string;
begin
    Result := Copy(FText, FSelByteStart + 1, FSelByteLength);
end;

procedure TtsGridEditBox.SetTextPosition(TextPos : Integer; CaretBeforePos : Boolean);
begin
    FTextPos := TextPos;
    FCaretBeforePos := CaretBeforePos;
    SetCaretRowAndOffset(FTextPos, FCaretBeforePos);
    FCaretPos := GetTextCaretPos;
end;

procedure TtsGridEditBox.SetCaretRowAndOffset(TextPos : Integer;
                                              CaretBeforePos : Boolean);
var
    I : Integer;
    Chars : Integer;
    AtEofLine : Boolean;
begin
    FCaretRow := 0;
    FCaretOffset := 0;

    Chars := 0;
    for I := 0 to FTextLines.Count - 1 do
    begin
        if Chars + TextLineLength(I) >= TextPos then Break;

        Chars := Chars + TextLineLength(I);
        FCaretRow := FCaretRow + 1;
    end;

    FCaretOffset := TextPos - Chars;
    AtEofLine := (FCaretOffset = TextLineLength(FCaretRow));

    if (FCaretRow < FTextLines.Count - 1) and AtEofLine and
       (CaretBeforePos or LastCharIsEofLine(PChar(FText), TextPos)) then
    begin
        FCaretRow := FCaretRow + 1;
        FCaretOffset := 0;
    end;
end;

procedure TtsGridEditBox.SetCaretVisible(Value : Boolean);
begin
    FCaretVisible := Value;
    if FCaretVisible then
        ShowCaret
    else
        HideCaret;
end;

function TtsGridEditBox.GetTextCaretPosLeft : TPoint;
var
    I: Integer;
    APoint: TPoint;
    Chars: Integer;
    PText: PChar;
    TextHeight: Integer;
    TextWidth: Integer;
    LineSpacing, TopOffset: Integer;
    CharOffset: Integer;
    Metric: TTextMetric;
begin
    GetTextMetrics(Canvas.Handle, Metric);
    LineSpacing := TextLineSpacing(Metric);
    TopOffset := LineSpacing;
    TextHeight := Metric.tmHeight + LineSpacing;

    TopOffset := GetVertTopOffset(TopOffset, GetDrawRect, FTextLines, LineSpacing, VertAlignment, Metric);
    APoint.X := TextStartOffset(PChar(FText), Length(FText));
    APoint.Y := TopOffset;

    if FTextLines = nil then
    begin
        Result := APoint;
        Exit;
    end;

    if not IsMultiLine then
    begin
        PText := PChar(FText);
        if FStartDisplayChar > Length(FText) then
            FStartDisplayChar := 0;

        if FStartDisplayChar < FTextPos then
        begin
            GetPrintCharWidth(Canvas, Metric, PText + FStartDisplayChar,
                              FTextPos - FStartDisplayChar, False, False, TextWidth);
            APoint.X := APoint.X + TextWidth;
        end
        else
        begin
            GetPrintCharWidth(Canvas, Metric, PText + FTextPos,
                              FStartDisplayChar - FTextPos, False, False, TextWidth);
            APoint.X := APoint.X - TextWidth;
        end;
    end
    else
    begin
        Chars := 0;
        if FFirstDisplayRow > FTextLines.Count - 1 then FFirstDisplayRow := 0;

        I := 0;
        while I < FCaretRow do
        begin
            Chars := Chars + TextLineLength(I);
            I := I + 1;
        end;

        PText := PChar(FText) + Chars;
        APoint.X := TextStartOffset(PText, TextLineLength(I));
        APoint.Y := (FCaretRow - FFirstDisplayRow) * TextHeight + TopOffset;

        CharOffset := FCaretOffset;
        GetPrintCharWidth(Canvas, Metric, PText, CharOffset, True, False, TextWidth);
        while (APoint.X + TextWidth >= Width) and (CharOffset > 0) do
        begin
            CharOffset := CharOffset - PrevCharCount(PText, CharOffset);
            if not IsSpaceChar(PText, CharOffset) then Break;
            GetPrintCharWidth(Canvas, Metric, PText, CharOffset, True, False, TextWidth);
        end;
        APoint.X := APoint.X + TextWidth;
    end;

    Result := APoint;
end;

function TtsGridEditBox.GetTextCaretPosRight : TPoint;
var
    I : Integer;
    APoint : TPoint;
    Chars : Integer;
    PText : PChar;
    TextHeight : Integer;
    TextWidth : Integer;
    LineSpacing, TopOffset: Integer;
    CharOffset: Integer;
    Metric: TTextMetric;
begin
    GetTextMetrics(Canvas.Handle, Metric);
    LineSpacing := TextLineSpacing(Metric);
    TopOffset := LineSpacing;
    TextHeight := Metric.tmHeight + LineSpacing;

    TopOffset := GetVertTopOffset(TopOffset, GetDrawRect, FTextLines, LineSpacing, VertAlignment, Metric);
    APoint.X := Width - FRightMargin - Metric.tmOverhang;
    APoint.Y := TopOffset;

    if FTextLines = nil then
    begin
        Result := APoint;
        Exit;
    end;

    if not IsMultiLine then
    begin
        PText := PChar(FText);
        if FStartDisplayChar > Length(FText) then
            FStartDisplayChar := Length(FText);

        if FStartDisplayChar < FTextPos then
        begin
            GetPrintCharWidth(Canvas, Metric, PText + FStartDisplayChar,
                              FTextPos - FStartDisplayChar, False, False, TextWidth);
            APoint.X := APoint.X + TextWidth;
        end
        else
        begin
            GetPrintCharWidth(Canvas, Metric, PText + FTextPos,
                              FStartDisplayChar - FTextPos, False, False, TextWidth);
            APoint.X := APoint.X - TextWidth;
        end;
    end
    else
    begin
        Chars := 0;
        if FFirstDisplayRow > FTextLines.Count - 1 then
            FFirstDisplayRow := FTextLines.Count - 1;
        for I := 0 to FCaretRow - 1 do Chars := Chars + TextLineLength(I);

        APoint.Y := (FCaretRow - FFirstDisplayRow) * TextHeight + TopOffset;

        PText := PChar(FText) + Chars;
        CharOffset := FCaretOffset;
        GetPrintCharWidth(Canvas, Metric, PText + CharOffset,
                          TextLineLength(FCaretRow) - CharOffset, True, False, TextWidth);
        while (APoint.X - TextWidth < 0) and (CharOffset < TextLineLength(FCaretRow)) do
        begin
            if not IsSpaceChar(PText, CharOffset) then Break;
            CharOffset := CharOffset + NextCharCount(PText, CharOffset);
            GetPrintCharWidth(Canvas, Metric, PText + CharOffset,
                              TextLineLength(FCaretRow) - CharOffset, True, False, TextWidth);
        end;
        APoint.X := APoint.X - TextWidth;
    end;

    Result := APoint;
end;

function TtsGridEditBox.GetTextCaretPos : TPoint;
var
    APoint : TPoint;
begin
    APoint.X := 0;
    APoint.Y := 0;
    Result := APoint;

    case Alignment of
        taLeftJustify : Result := GetTextCaretPosLeft;
        taCenter : Result := GetTextCaretPosLeft;
        taRightJustify : Result := GetTextCaretPosRight;
    end;
end;

function TtsGridEditBox.TextLineLength(Row : Integer) : Integer;
begin
    if Row < FTextLines.Count - 1 then
        Result := FTextLines.Item[Row + 1] - FTextLines.Item[Row]
    else
        Result := Length(FText) - FTextLines.Item[Row];
end;

function TtsGridEditBox.GetPointCaretPos(WinPos : TPoint;
                                         var BeforeTextPos : Boolean) : Integer;
var
    TextPos : Integer;
    Chars : Integer;
    PText : PChar;
    TextHeight : Integer;
    Row : Integer;
    CaretPosX : Integer;
    Metric : TTextMetric;
    Offset : Integer;
    MaxOffset : Integer;
    Top, LineSpacing: Integer;
begin
    GetTextMetrics(Canvas.Handle, Metric);
    TextHeight := Metric.tmHeight;

    if not IsMultiLine then
    begin
        if Alignment in [taLeftJustify, taCenter] then
        begin
            PText := PChar(FText) + FStartDisplayChar;
            Chars := Length(FText) - FStartDisplayChar;
        end
        else
        begin
            PText := PChar(FText);
            Chars := FStartDisplayChar;
        end;

        TextPos := LineCaretPos(PText, Chars, WinPos.X, CaretPosX);
        BeforeTextPos := TextPos < Length(Text);
    end
    else
    begin
        LineSpacing := TextLineSpacing(Metric);
        Top := GetVertTopOffset(0, GetDrawRect, FTextLines, LineSpacing, VertAlignment, Metric);
        TextPos := 0;
        Chars := 0;

        for Row := 0 to FTextLines.Count - 1 do
        begin
            Chars := TextLineLength(Row);
            if WinPos.Y < Top + (Row - FFirstDisplayRow + 1) * TextHeight then Break;
            TextPos := TextPos + Chars;
        end;

        if Row <= FtextLines.Count - 1 then
        begin
            PText := PChar(FText) + TextPos;
            MaxOffset := Chars;
            if LastCharIsEofLine(PText, Chars) then
                MaxOffset := MaxOffset - PrevCharCount(PText, Chars);

            Offset := LineCaretPos(PText, MaxOffset, WinPos.X, CaretPosX);
            TextPos := TextPos + Offset;
            BeforeTextPos := (Offset < Chars);
        end
        else
        begin
            BeforeTextPos := true;
        end;
    end;

    if Alignment in [taLeftJustify, taCenter] then
        Result := TextPos + FStartDisplayChar
    else
        Result := TextPos;
end;

function TtsGridEditBox.TextStartOffset(PText : PChar; Chars : Integer) : Integer;
var
    CharWidth : Integer;
    LeftOffset : Integer;
    Metric: TTextMetric;
begin
    if Alignment = taLeftJustify then
        Result := 0
    else if Alignment = taRightJustify then
        Result := Width
    else
    begin
        GetTextMetrics(Canvas.Handle, Metric);
        GetPrintCharWidth(Canvas, Metric, PText, Chars, IsMultiLine, True, CharWidth);
        LeftOffset := (Width + FLeftMargin - CharWidth) div 2;
        if LeftOffset < FLeftMargin then
            Result := 0
        else
            Result := LeftOffset - FLeftMargin;
    end;
end;

function TtsGridEditBox.LineCaretPosLeft(PText : PChar; Chars : Integer; XPos : Integer; var CaretPosX : Integer) : Integer;
var
    Position : Integer;
    PrevX : Integer;
    NextChars : Integer;
    TextWidth : Integer;
    CharWidth : Integer;
    Metric: TTextMetric;
begin
    CaretPosX := TextStartOffset(PText, Chars);
    Position := 0;
    TextWidth := CaretPosX;
    PrevX := 0;
    NextChars := 0;

    GetTextMetrics(Canvas.Handle, Metric);

    while (TextWidth < XPos) and (Position < Chars) do
    begin
        if EndOfText(PText, Position) then Break;

        PrevX := TextWidth;

        NextChars := NextCharCount(PText, Position);
        GetPrintCharWidth(Canvas, Metric, PText + Position, NextChars,
                          IsMultiLine, False, CharWidth);

        Position := Position + NextChars;
        TextWidth := TextWidth + CharWidth;
    end;

    if Position > 0 then
    begin
        CaretPosX := TextWidth;
        if (XPos - PrevX) < (TextWidth - XPos) then
        begin
            Position := Position - NextChars;
            CaretPosX := PrevX;
        end;
    end;

    Result := Position;
end;

function TtsGridEditBox.LineCaretPosRight(PText : PChar; Chars : Integer; XPos : Integer; var CaretPosX : Integer) : Integer;
var
    Position : Integer;
    PrevX : Integer;
    PrevChars : Integer;
    TextWidth : Integer;
    CharWidth : Integer;
    Metric : TTextMetric;
begin
    GetTextMetrics(Canvas.Handle, Metric);

    CaretPosX := Width - FRightMargin - Metric.tmOverhang;
    Position := Chars;
    TextWidth := 0;
    PrevX := CaretPosX;
    PrevChars := 0;

    while (CaretPosX - TextWidth > XPos) and (Position > 0) do
    begin
        PrevX := CaretPosX - TextWidth;

        PrevChars := PrevCharCount(PText, Position);
        GetPrintCharWidth(Canvas, Metric, PText + Position - PrevChars, PrevChars,
                          IsMultiLine, False, CharWidth);
        Position := Position - PrevChars;
        TextWidth := TextWidth + CharWidth;
    end;

    if Position < Chars then
    begin
        CaretPosX := CaretPosX - TextWidth;
        if (PrevX - XPos) < (XPos - (Width - FRightMargin - Metric.tmOverhang - TextWidth)) then
        begin
            Position := Position + PrevChars;
            CaretPosX := PrevX;
        end;
    end;

    Result := Position;
end;

function TtsGridEditBox.LineCaretPos(PText : PChar; Chars : Integer; XPos : Integer; var CaretPosX : Integer) : Integer;
begin
    Result := 0;
    CaretPosX := 0;

    case Alignment of
        taLeftJustify : Result := LineCaretPosLeft(PText, Chars, XPos, CaretPosX);
        taCenter : Result := LineCaretPosLeft(PText, Chars, XPos, CaretPosX);
        taRightJustify : Result := LineCaretPosRight(PText, Chars, XPos, CaretPosX);
    end;
end;

procedure TtsGridEditBox.SetCaretPos;
begin
    if not FHasCaret then Exit;
    if FCaretBitmap = nil then
        Windows.SetCaretPos(FCaretPos.X, FCaretPos.Y)
    else
        Windows.SetCaretPos(FCaretPos.X, FCaretPos.Y);
end;

procedure TtsGridEditBox.ShowCaret;
begin
    if (not FHasCaret) or (not FCaretVisible) then Exit;
    SetCaretPos;
    Windows.ShowCaret(Handle);
end;

procedure TtsGridEditBox.HideCaret;
begin
    if not FHasCaret then Exit;
    Windows.HideCaret(Handle);
end;

function TtsGridEditBox.GetTextHeight: Integer;
var
    Metric : TTextMetric;
begin
    GetTextMetrics(Canvas.Handle, Metric);
    Result := Metric.tmHeight + TextLineSpacing(Metric);
end;

function TtsGridEditBox.IsMultiLine : Boolean;
var
    Metric : TTextMetric;
    TopOffset, LineSpacing: Integer;
begin
    Result := (WordWrap <> wwOff);
    if Result then
    begin
        GetTextMetrics(Canvas.Handle, Metric);
        LineSpacing := TextLineSpacing(Metric);
        TopOffset := LineSpacing;
        Result := IsMultiLineText(Height - TopOffset, Metric.tmHeight + LineSpacing);
    end;
end;

function TtsGridEditBox.MoveCaretUpIntoView(Redraw : Boolean) : Boolean;
var
    TextHeight : Integer;
begin
    Result := false;

    TextHeight := GetTextHeight;
    if (FCaretPos.Y + TextHeight > Height) then
    begin
        Result := true;
        while (FCaretPos.Y + TextHeight > Height) do
        begin
            FCaretPos.Y := FCaretPos.Y - TextHeight;
            FFirstDisplayRow := FFirstDisplayRow + 1;
        end;

        if Redraw then Repaint;
    end;
end;

function TtsGridEditBox.MoveCaretDownIntoView(Redraw : Boolean) : Boolean;
var
    TextHeight : Integer;
begin
    Result := false;

    TextHeight := GetTextHeight;
    if (FCaretPos.Y < 0) then
    begin
        Result := true;

        while (FCaretPos.Y < 0) do
        begin
            FCaretPos.Y := FCaretPos.Y + TextHeight;
            FFirstDisplayRow := FFirstDisplayRow - 1;
        end;

        if Redraw then Repaint;
    end;
end;

function TtsGridEditBox.MoveCaretLeftIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
var
    ScrollPos : Integer;
    CharWidth : Integer;
    Chars : Integer;
    Metric : TTextMetric;
begin
    Result := false;
    GetTextMetrics(Canvas.Handle, Metric);

    if (FCaretPos.X + Metric.tmOverhang >= Width) then
    begin
        Result := true;
        ScrollPos := Trunc( (1 - ScrollPerc) * Width );

        while (FCaretPos.X + Metric.tmOverhang >= ScrollPos) and
              (FCaretPos.X > 0) and (FStartDisplayChar < Length(FText)) do
        begin
            Chars := NextCharCount(PChar(FText), FStartDisplayChar);
            GetPrintCharWidth(Canvas, Metric, PChar(FText) + FStartDisplayChar,
                              Chars, IsMultiLine, False, CharWidth);

            FCaretPos.X := FCaretPos.X - CharWidth;
            FStartDisplayChar := FStartDisplayChar + Chars;
        end;
    end;

    if Redraw then Repaint;
end;

function TtsGridEditBox.MoveCaretRightIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
var
    ScrollPos : Integer;
    CharWidth : Integer;
    Chars : Integer;
    Metric : TTextMetric;
begin
    Result := false;

    if (FCaretPos.X < 0) then
    begin
        Result := true;
        ScrollPos := Trunc( ScrollPerc * Width );

        GetTextMetrics(Canvas.Handle, Metric);
        while (FCaretPos.X < ScrollPos) and (FStartDisplayChar > 0) do
        begin
            Chars := PrevCharCount(PChar(FText), FStartDisplayChar);
            GetPrintCharWidth(Canvas, Metric,
                              PChar(FText) + FStartDisplayChar - Chars,
                              Chars, IsMultiLine, False, CharWidth);

            FCaretPos.X := FCaretPos.X + CharWidth;
            FStartDisplayChar := FStartDisplayChar - Chars;
        end;

        if Redraw then Repaint;
    end;
end;

function TtsGridEditBox.MoveCaretIntoView(Redraw : Boolean; ScrollPerc : Double) : Boolean;
var
    Metric: TTextMetric;
begin
    Result := false;

    if not IsMultiLine then
    begin
        GetTextMetrics(Canvas.Handle, Metric);
        if (FCaretPos.X + Metric.tmOverhang >= Width) and (FCaretPos.X > 0) then
            Result := MoveCaretLeftIntoView(Redraw, ScrollPerc)
        else if FCaretPos.X < 0 then
            Result := MoveCaretRightIntoView(Redraw, ScrollPerc);
    end
    else
    begin
        if FCaretPos.Y + GetTextHeight > Height then
            Result := MoveCaretUpIntoView(Redraw)
        else if FCaretPos.Y < 0 then
            Result := MoveCaretDownIntoView(Redraw);
    end;

    SetCaretPos;
end;

procedure TtsGridEditBox.MoveSelectionRight(OldTextPos : Integer);
var
    SelLen : Integer;
begin
    if (FSelByteStart = OldTextPos) and (FSelByteLength > 0) then
    begin
        if FTextPos < FSelByteStart + FSelByteLength then
        begin
            SelLen := FSelByteLength - (FTextPos - OldTextPos);
            SetSelByteStart(FTextPos);
            SetSelByteLength(SelLen);
        end
        else
        begin
            SelLen := FTextPos - (FSelByteStart + FSelByteLength);
            SetSelByteStart(FSelByteStart + FSelByteLength);
            SetSelByteLength(SelLen);
        end;
    end
    else
    begin
        SetSelByteLength(FSelByteLength + FTextPos - OldTextPos);
    end;
end;

procedure TtsGridEditBox.MoveSelectionLeft(OldTextPos : Integer);
var
    SelLen : Integer;
begin
    if (FSelByteStart = OldTextPos) then
    begin
        SelLen := FSelByteLength + (OldTextPos - FTextPos);
        SetSelByteStart(FTextPos);
        SetSelByteLength(SelLen);
    end
    else if FSelByteStart < FTextPos then
    begin
        SetSelByteLength(FSelByteLength - (OldTextPos - FTextPos));
    end
    else
    begin
        SelLen := FSelByteStart - FTextPos;
        SetSelByteStart(FTextPos);
        SetSelByteLength(SelLen);
    end;
end;

function TtsGridEditBox.MoveRightSingleLine(Redraw : Boolean; MoveWord : Boolean; ScrollPerc : Double) : Boolean;
var
    Chars : Integer;
    Width : Integer;
    Metric : TTextMetric;
begin
    if MoveWord then
        Chars := NextWordCount(PChar(FText), FTextPos)
    else
        Chars := NextCharCount(PChar(FText), FTextPos);

    GetTextMetrics(Canvas.Handle, Metric);
    GetPrintCharWidth(Canvas, Metric, PChar(FText) + FTextPos, Chars,
                      IsMultiLine, False, Width);

    FCaretPos.X := FCaretPos.X + Width;
    FTextPos := FTextPos + Chars;
    FCaretOffset := FCaretOffset + Chars;
    FCaretBeforePos := (FTextPos < Length(Text));

    Result := MoveCaretIntoView(Redraw, ScrollPerc);
end;

function TtsGridEditBox.MoveRightMultiLine(Redraw : Boolean; MoveWord : Boolean) : Boolean;
var
    Chars : Integer;
begin
    if FCaretOffset = TextLineLength(FCaretRow) then
    begin
        if FCaretRow < FTextLines.Count - 1 then
        begin
            SetTextPosition(FTextPos, true);

            if MoveWord and IsSpaceChar(PChar(FText), FTextPos) then
                MoveRightMultiLine(Redraw, MoveWord);
        end;
    end
    else
    begin
        if MoveWord then
            Chars := NextWordCount(PChar(FText), FTextPos)
        else
            Chars := NextCharCount(PChar(FText), FTextPos);

        FCaretBeforePos := (FCaretOffset + Chars <> TextLineLength(FCaretRow));
        SetTextPosition(FTextPos + Chars, FCaretBeforePos);

        if MoveWord and (FCaretOffset = TextLineLength(FCaretRow)) then
            MoveRightMultiLine(true, false);
    end;

    Result := MoveCaretIntoView(Redraw, 0);
end;

function TtsGridEditBox.MoveRight(ShiftPressed : Boolean; MoveWord : Boolean; FKeyRepeated : Boolean) : Boolean;
var
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;

    Result := FKeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FTextPos = Length(Text) then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    if not IsMultiLine then
        Redraw := MoveRightSingleLine(false, MoveWord, KeyScrollPerc)
    else
        Redraw := MoveRightMultiLine(false, MoveWord);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionRight(OldTextPos);
        end
    end
    else
        SetSelByteStart(FTextPos);

    if Redraw then Refresh;
    Result := true;
end;

function TtsGridEditBox.MoveLeftSingleLine(Redraw : Boolean; MoveWord : Boolean; ScrollPerc : Double) : Boolean;
var
    Chars : Integer;
    Width : Integer;
    Metric : TTextMetric;
begin
    if MoveWord then
        Chars := PrevWordCount(PChar(FText), FTextPos)
    else
        Chars := PrevCharCount(PChar(FText), FTextPos);

    GetTextMetrics(Canvas.Handle, Metric);
    GetPrintCharWidth(Canvas, Metric, PChar(FText) + FTextPos - Chars, Chars,
                      IsMultiLine, False, Width);

    FCaretPos.X := FCaretPos.X - Width;
    FTextPos := FTextPos - Chars;
    FCaretOffset := FCaretOffset - Chars;
    FCaretBeforePos := (FTextPos < Length(FText));

    Result := MoveCaretIntoView(Redraw, ScrollPerc);
end;

function TtsGridEditBox.MoveLeftMultiLine(Redraw : Boolean; MoveWord : Boolean) : Boolean;
var
    Chars : Integer;
begin
    if not MoveWord and (FCaretOffset = 0) then
    begin
        if FCaretRow > 0 then
        begin
            if not LastCharIsEofLine(PChar(FText), FTextPos) then
                SetTextPosition(FTextPos, false)
            else
            begin
                Chars := PrevCharCount(PChar(FText), FTextPos);
                SetTextPosition(FTextPos - Chars, true);
            end;
        end;
    end
    else
    begin
        if MoveWord then
            Chars := PrevWordCount(PChar(FText), FTextPos)
        else
            Chars := PrevCharCount(PChar(FText), FTextPos);

        SetTextPosition(FTextPos - Chars, true);
    end;

    Result := MoveCaretIntoView(Redraw, 0);
end;

function TtsGridEditBox.MoveLeft(ShiftPressed : Boolean; MoveWord : Boolean; FKeyRepeated : Boolean) : Boolean;
var
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;

    Result := FKeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FTextPos = 0 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    if not IsMultiLine then
        Redraw := MoveLeftSingleLine(false, MoveWord, KeyScrollPerc)
    else
        Redraw := MoveLeftMultiLine(false, MoveWord);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionLeft(OldTextPos);
        end
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Refresh;
    Result := true;
end;

function TtsGridEditBox.MoveDown(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
var
    TextPos : Integer;
    CaretBeforePos : Boolean;
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if not (LineCount > 1) then Exit;

    Result := KeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FCaretRow = FTextLines.Count - 1 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    FCaretPos.Y := FCaretPos.Y + GetTextHeight;

    TextPos := GetPointCaretPos(FCaretPos, CaretBeforePos);
    SetTextPosition(TextPos, CaretBeforePos);
    Redraw := MoveCaretIntoView(true, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionRight(OldTextPos);
        end
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := True;
end;

function TtsGridEditBox.MoveUp(ShiftPressed : Boolean; KeyRepeated : Boolean) : Boolean;
var
    TextPos : Integer;
    CaretBeforePos : Boolean;
    Redraw : Boolean;
    OldTextPos : Integer;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if not (LineCount > 1) then Exit;

    Result := KeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FCaretRow = 0 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    FCaretPos.Y := FCaretPos.Y - GetTextHeight;

    TextPos := GetPointCaretPos(FCaretPos, CaretBeforePos);
    SetTextPosition(TextPos, CaretBeforePos);
    Redraw := MoveCaretIntoView(true, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionLeft(OldTextPos);
        end
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := true;
end;

function TtsGridEditBox.MovePageDown(ShiftPressed : Boolean; KeyRepeated: Boolean) : Boolean;
var
    Rows : Integer;
    TextHeight : Integer;
    TextPos : Integer;
    CaretBeforePos : Boolean;
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if not IsMultiLine then Exit;

    Result := KeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FCaretRow = FTextLines.Count - 1 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    TextHeight := GetTextHeight;
    Rows := Height div TextHeight;

    if Rows + FCaretRow > FTextLines.Count - 1 then
        Rows := (FTextLines.Count - 1) - FCaretRow;

    FFirstDisplayRow := FFirstDisplayRow + Rows;
    if FFirstDisplayRow > FTextLines.Count - 1 then
    begin
        FCaretPos.Y := FCaretPos.Y - ((FFirstDisplayRow - (FTextLines.Count - 1)) * TextHeight);
        FFirstDisplayRow := FTextLines.Count - 1;
    end;

    TextPos := GetPointCaretPos(FCaretPos, CaretBeforePos);
    SetTextPosition(TextPos, CaretBeforePos);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionRight(OldTextPos);
        end
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := True;
end;

function TtsGridEditBox.MovePageUp(ShiftPressed : Boolean; KeyRepeated: Boolean) : Boolean;
var
    Rows : Integer;
    TextHeight : Integer;
    TextPos : Integer;
    CaretBeforePos : Boolean;
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if not IsMultiLine then Exit;

    Result := KeyRepeated;
    if not ShiftPressed then SetSelByteStart(FTextPos);
    if FCaretRow = 0 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    TextHeight := GetTextHeight;
    Rows := Height div TextHeight;

    if FCaretRow - Rows < 0 then Rows := FCaretRow;

    FFirstDisplayRow := FFirstDisplayRow - Rows;
    if FFirstDisplayRow < 0 then
    begin
        FCaretPos.Y := FCaretPos.Y + (FFirstDisplayRow * TextHeight);
        FFirstDisplayRow := 0;
    end;

    TextPos := GetPointCaretPos(FCaretPos, CaretBeforePos);
    SetTextPosition(TextPos, CaretBeforePos);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionLeft(OldTextPos);
        end
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := True;
end;

procedure TtsGridEditBox.MoveToStartOfText(ShiftPressed: Boolean);
var
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    if not ShiftPressed then SetSelByteStart(FTextPos);

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    SetTextPosition(0, true);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionLeft(OldTextPos);
        end
    end
    else
        SetSelByteStart(FTextPos);

    if Redraw then Invalidate;
end;

procedure TtsGridEditBox.MoveToEndOfText(ShiftPressed: Boolean);
var
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    if not ShiftPressed then SetSelByteStart(FTextPos);

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    SetTextPosition(Length(FText), false);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionRight(OldTextPos);
        end
    end
    else
        SetSelByteStart(FTextPos);

    if Redraw then Invalidate;
end;

function TtsGridEditBox.CtrlMoveHome(ShiftPressed : Boolean; KeyPress : Boolean) : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if (FTextPos = 0) and KeyPress then Exit;

    MoveToStartOfText(ShiftPressed);
    Result := true;
end;

function TtsGridEditBox.CtrlMoveEnd(ShiftPressed : Boolean) : Boolean;
begin
    Result := false;
    if (not ShiftPressed) and AllSelected then Exit;
    if FTextPos = Length(FText) then Exit;

    MoveToEndOfText(ShiftPressed);
    Result := True;
end;

function TtsGridEditBox.MoveHome(ShiftPressed : Boolean) : Boolean;
var
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := true;
    if not ShiftPressed then SetSelByteStart(FSelByteStart);
    if FCaretOffset = 0 then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    SetTextPosition(FTextPos - FCaretOffset, true);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionLeft(OldTextPos);
        end;
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := true;
end;

function TtsGridEditBox.MoveEnd(ShiftPressed : Boolean) : Boolean;
var
    Chars : Integer;
    OldTextPos : Integer;
    Redraw : Boolean;
begin
    Result := true;
    if not ShiftPressed then SetSelByteStart(FSelByteStart);
    if FCaretOffset = TextLineLength(FCaretRow) then Exit;

    OldTextPos := FTextPos;
    if (FSelByteStart + FSelByteLength <> FTextPos) and (FSelByteStart <> FTextPos) then SetSelByteStart(FTextPos);

    Chars := TextLineLength(FCaretRow) - FCaretOffset;
    FCaretBeforePos := false;

    if LastCharIsEofLine(PChar(FText) + FTextPos, Chars) and IsMultiLine then
    begin
        Chars := Chars - PrevCharCount(PChar(FText) + FTextPos, Chars);
        FCaretBeforePos := true;
    end;

    SetTextPosition(FTextPos + Chars, FCaretBeforePos);
    Redraw := MoveCaretIntoView(false, 0);

    if ShiftPressed then
    begin
        if FTextPos <> OldTextPos then
        begin
            Redraw := true;
            MoveSelectionRight(OldTextPos);
        end;
    end
    else
    begin
        SetSelByteStart(FTextPos);
    end;

    if Redraw then Invalidate;
    Result := true;
end;

procedure TtsGridEditBox.SaveOldText;
begin
    if not FOldTextSaved then
    begin
        FOldText := FText;
        FOldTextSaved := true;
    end;
end;

function TtsGridEditBox.UndoEdit(var Key: Word): Boolean;
var
    Cancel: Boolean;
begin
    Result := False;
    if FOldTextSaved then
    begin
        Key := 0;
        Cancel := False;
        if Assigned(FOnUndoChanged) then FOnUndoChanged(Self, True, Cancel);
        Result := not Cancel;
        if Result then RestoreOldText;
    end;
end;

function TtsGridEditBox.RestoreOldText : Boolean;
begin
    Result := False;
    if FOldTextSaved then
    begin
        SetTextValue(FOldText, False, False);
        EditTextResized(True);
        FOldTextSaved := False;
        Result := True;
    end;
end;

function TtsGridEditBox.NewLengthOk(InsertText: string): Boolean;
var
    NewLength: Integer;
begin
    Result := True;
    if MaxLength > 0 then
    begin
        NewLength := PByteToCharLen(PChar(FText), Length(FText), Length(FText)) -
                     SelLength +
                     PByteToCharLen(PChar(InsertText), Length(InsertText), Length(InsertText));

        if InsertText = Chr(VK_RETURN) then Inc(NewLength);
        if NewLength > MaxLength then Result := False;
    end;
end;

function TtsGridEditBox.CanInsertText(var InsertChars: string): Boolean;
//var newText : String;
begin
    Result := True;
    if EditMask = nil then Exit;
    if not (mcOnEdit in EditMask.Evaluate) then Exit;

    with EditMask do
       //if (Self.SelLength = 0) then
          Result := ValidInput(FText, InsertChars, FSelByteStart + 1, False,
                               mcOnEdit in AutoFill);
       {else
       begin
         newText := Copy(FText, 1, SelStart) + Copy(FText, SelStart+SelLength+1, Length(FText));
         Result := ValidInput(newText, InsertChars, FSelByteStart + 1, False,
                               mcOnEdit in AutoFill);
       end;}
    if not Result then OnInvalidMaskEdit(Self, InsertChars, Result);
end;

procedure TtsGridEditBox.AddCharToText(Keys : string; var Changed : Boolean);
var
    I, Count: Integer;
    InsertPos: Integer;
begin
    Changed := false;
    if not NewLengthOk(Keys) then Exit;
    if not CheckCanEdit(True) then Exit;
    if not CanInsertText(Keys) then Exit;

    if FSelByteLength <> 0 then DelSelectedText(Changed, false);
    Changed := True;
    SaveOldText;

    InsertPos := FtextPos + 1;
    for I := 1 to Length(Keys) do
    begin
        Insert(Keys[I], FText, InsertPos);
        if Keys[I] = Chr(VK_RETURN) then
        begin
            Inc(InsertPos);
            Insert(Chr(CH_LINEFEED), FText, InsertPos);
        end;
        Inc(InsertPos);
    end;

    if FTextPos < FStartDisplayChar then
    begin
        Inc(FStartDisplayChar, Length(Keys));
        if Keys = Chr(VK_RETURN) then Inc(FStartDisplayChar);
    end;

    GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    SetTextPosition(FTextPos, FCaretBeforePos);
    SetSelByteStart(FTextPos);

    if EditTextResized(True) then
    begin
        GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                     (WordWrap <> wwOff), FTextLines, 0);
    end;

    MoveCaretIntoView(false, KeyScrollPerc);

    Count := 0;
    while Count < Length(Keys) do
    begin
        Count := Count + NextCharCount(PChar(Keys), Count);
        if FCaretOffset = TextLineLength(FCaretRow) then MoveRight(false, false, false);
        MoveRight(false, false, false);
    end;
    Refresh;
end;

procedure TtsGridEditBox.DeleteSelText(var Changed: Boolean);
var
    CaretBeforePos : Boolean;
begin
    CaretBeforePos := True;
    if ((FSelByteStart = FTextPos) and (FCaretOffset = TextLineLength(FCaretRow) - FSelByteLength)) or
       ((FSelByteStart < FTextPos) and (FTextPos = TextLineLength(FCaretRow))) then
    begin
        CaretBeforePos := False;
    end;

    Changed := True;
    System.Delete(FText, FSelByteStart + 1, FSelByteLength);

    GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    SetTextPosition(FSelByteStart, CaretBeforePos);
    SetSelByteStart(FSelByteStart);

    if EditTextResized(True) then
    begin
        GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                     (WordWrap <> wwOff), FTextLines, 0);
    end;
end;

procedure TtsGridEditBox.DelSelectedText(var Changed : Boolean; CheckCancelEdit : Boolean);
begin
    Changed := False;
    if CheckCancelEdit then
    begin
        if not CheckCanEdit(True) then Exit;
    end;

    SaveOldText;
    DeleteSelText(Changed);
    MoveCaretIntoView(False, KeyScrollPerc);
    Invalidate;
end;

procedure TtsGridEditBox.DelNextCharFromText(var Changed : Boolean; CheckCancelEdit : Boolean);
var
    Chars : Integer;
    CaretBeforePos : Boolean;
begin
    Changed := false;

    if FSelByteLength <> 0 then
    begin
        DelSelectedText(Changed, CheckCancelEdit);
        Exit;
    end;

    if FTextPos = Length(FText) then Exit;

    if CheckCancelEdit then
    begin
        if not CheckCanEdit(True) then Exit;
    end;

    SaveOldText;
    Chars := NextCharCount(PChar(FText), FTextPos);

    CaretBeforePos := true;
    if FCaretOffset = TextLineLength(FCaretRow) - Chars then
    begin
        CaretBeforePos := false;
    end;

    Changed := true;
    System.Delete(FText, FTextPos + 1, Chars);

    GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                 (WordWrap <> wwOff), FTextLines, 0);
    SetTextPosition(FTextPos, CaretBeforePos);
    SetSelByteStart(FTextPos);

    if EditTextResized(True) then
    begin
        GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                     (WordWrap <> wwOff), FTextLines, 0);
    end;

    MoveCaretIntoView(false, KeyScrollPerc);
    Refresh;
end;

procedure TtsGridEditBox.DelPrevCharFromText(var Changed : Boolean; CheckCancelEdit : Boolean);
begin
    Changed := false;
    if FSelByteLength <> 0 then
    begin
        DelSelectedText(Changed, CheckCancelEdit);
        Exit;
    end;

    if FTextPos = 0 then Exit;

    if CheckCancelEdit then
    begin
        if not CheckCanEdit(True) then Exit;
    end;

    MoveLeft(false, false, false);
    if FCaretOffset = TextLineLength(FCaretRow) then MoveLeft(false, false, false);
    DelNextCharFromText(Changed, false);
end;

procedure TtsGridEditBox.CreateCaretBitmap;
var
    Metric: TTextMetric;
    Overhang: Integer;
begin
    DestroyCaretBitmap;

    Overhang := 0;
    GetTextMetrics(Canvas.Handle, Metric);
    if fsItalic in Canvas.Font.Style then Overhang := Metric.tmOverhang;
    if (Overhang > 0) and (fsBold in Canvas.Font.Style) then Dec(Overhang);
    if Overhang = 0 then Exit;

    FCaretBitmap := TBitmap.Create;

    with FCaretBitmap do
    begin
        Width := Overhang + 1;
        Height := Metric.tmHeight;

        Canvas.Brush.Color := clBlack;
        Canvas.FillRect(Rect(0, 0, Width, Height));

        Canvas.Pen.Color := clWhite;
        Canvas.Pen.Width := 1;
        Canvas.MoveTo(0, FCaretBitmap.Height - 1);
        Canvas.LineTo(FCaretBitmap.Width - 1, 0);
    end;
end;

procedure TtsGridEditBox.DestroyCaretBitmap;
begin
    FCaretBitmap.Free;
    FCaretBitmap := nil;
end;

procedure TtsGridEditBox.WMKillFocus(var Message : TMessage);
begin
    inherited;
    if csDestroying in ComponentState then Exit;
    
    SetCaretVisible(False);
    DestroyCaret;
    DestroyCaretBitmap;
    FHasCaret := False;
    FKeyRepeated := False;
    FMouseButtonDown := False;
    if FSelByteLength <> 0 then Invalidate;
end;

procedure TtsGridEditBox.WMSetFocus(var Message : TMessage);
var
    Metric: TTextMetric;
begin
    inherited;
    CreateCaretBitmap;
    if FCaretBitmap = nil then
    begin
        GetTextMetrics(Canvas.Handle, Metric);
        CreateCaret(Handle, 0, 1, Metric.tmHeight)
    end
    else
        CreateCaret(Handle, FCaretBitmap.Handle, 0, 0);
    FHasCaret := true;
    if FCanSetCaret then SetCaretVisible(True)
                    else FSetCaretVisible := True;
    if FSelByteLength <> 0 then Invalidate;
end;

procedure TtsGridEditBox.WMSize(var Message : TWMSize);
begin
    DisplayEditText;
    inherited;
end;

procedure TtsGridEditBox.CMFontChanged(var Message: TMessage);
begin
    inherited;
    if HandleAllocated then
    begin
        GetTextLines(Canvas.Handle, PChar(FText), Height, Width, Alignment,
                     (WordWrap <> wwOff), FTextLines, 0);
        SetTextPosition(FTextPos, FCaretBeforePos);
    end;
end;

procedure TtsGridEditBox.WMSetCursor(var Msg: TWMSetCursor);
begin
    if Screen.Cursor = crDefault then
    begin
        if KeyEdit or MouseSelect then
            SetCursor(Screen.Cursors[crIBeam])
        else
            SetCursor(Screen.Cursors[Cursor]);
    end
    else
        inherited;
end;

procedure TtsGridEditBox.WMPaste(var Msg: TWMPaste);
begin
    PasteFromClipboard(False);
end;

procedure TtsGridEditBox.WMCopy(var Msg: TWMPaste);
begin
    CopyToClipboard;
end;

procedure TtsGridEditBox.WMCut(var Msg: TWMPaste);
begin
    CutToClipboard(False);
end;

procedure TtsGridEditBox.WMLButtonUp(var Message: TWMLButtonUp);
begin
    FClickOnMouseUp := FMouseDownOccured or Focused;
    inherited;
end;

procedure TtsGridEditBox.MouseDownSetPosition(X, Y: Integer);
var
    TextPos : Integer;
    CaretBeforePos : Boolean;
begin
    TextPos := GetPointCaretPos(Point(X, Y), CaretBeforePos);
    SetTextPosition(TextPos, CaretBeforePos);
    SetSelByteStart(FTextPos);

    MoveCaretIntoView(True, 0);
    ShowCaret;

    FCheckMouseDownPos := True;
    FMouseDownPos.X := X;
    FMouseDownPos.Y := Y;
    FMouseStartPos := FTextPos;
end;

procedure TtsGridEditBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    FSetCaretVisible := False;
    if not (csDesigning in ComponentState) then
    begin
        FCanSetCaret := False;
        try
            if not (ssDouble in Shift) then
            begin
                if CanFocus then SetFocus;
                if not Focused then Windows.SetFocus(Handle);
            end;
        finally
            FCanSetCaret := True
        end;
    end;

    if (Button = mbLeft) and (KeyEdit or MouseSelect) and not (ssDouble in Shift) then
    begin
        MouseDownSetPosition(X, Y);
        FMouseButtonDown := MouseCapture;
    end;

    if FSetCaretVisible then SetCaretVisible(True);
    FKeyRepeated := False;
    if FMouseButtonDown then FMouseButtonDown := MouseCapture;

    inherited MouseDown(Button, Shift, X, Y);
end;

procedure TtsGridEditBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    if Button = mbLeft then
    begin
        MouseCapture := False;
        FMouseButtonDown := False;
    end;

    if FMouseButtonDown then FMouseButtonDown := MouseCapture;
    inherited MouseUp(Button, Shift, X, Y);
end;

procedure TtsGridEditBox.MouseMove(Shift: TShiftState; X, Y: Integer);
var
    TextPos : Integer;
    CaretBeforePos : Boolean;
    SelPos : Integer;
    SelLen : Integer;
    YPos : Integer;
    TextHeight : Integer;
    Moved : Boolean;
    Message : TWMMouseMove;
    Msg: TMsg;
    SelChanged : Boolean;
    OldTextPos : Integer;
    TopOffset, LineSpacing: Integer;
    Metric: TTextMetric;
begin
    if FMouseButtonDown then FMouseButtonDown := MouseCapture;

    if FMouseButtonDown and (KeyEdit or MouseSelect) and
       ((not FCheckMouseDownPos) or
        (FCheckMouseDownPos and ((FMouseDownPos.X <> X) or (FMouseDownPos.Y <> Y)))) then
    begin
        FCheckMouseDownPos := false;
        FMouseDownPos := Point(0,0);

        GetTextMetrics(Canvas.Handle, Metric);
        LineSpacing := TextLineSpacing(Metric);
        TopOffset := GetVertTopOffset(0, GetDrawRect, FTextLines, LineSpacing, VertAlignment, Metric);
        TextHeight := GetTextHeight;

        YPos := Y;
        if YPos > TopOffset + (TextHeight * (FTextLines.Count - 1 - FFirstDisplayRow)) then
            YPos := TopOffset + (TextHeight * (FTextLines.Count - 1 - FFirstdisplayRow));

        if (X < 0) and not IsMultiLine then
        begin
            OldTextPos := FTextPos;
            MoveLeftSingleLine(false, false, 0);
            Moved := (OldTextPos <> FTextPos);
        end
        else if (X > Width) and not IsMultiLine then
        begin
            OldTextPos := FTextPos;
            MoveRightSingleLine(false, false, 0);
            Moved := (OldTextPos <> FTextPos);
        end
        else
        begin
            TextPos := GetPointCaretPos(Point(X, YPos), CaretBeforePos);
            SetTextPosition(TextPos, CaretBeforePos);

            Moved := MoveCaretIntoView(false, 0);
            ShowCaret;
        end;

        SelPos := FMouseStartPos;
        SelLen := FTextPos - FMouseStartPos;
        if SelLen < 0 then
        begin
            SelPos := FTextPos;
            SelLen := FMouseStartPos - FTextPos;
        end;

        SelChanged := False;
        if (FSelByteStart <> SelPos) or (FSelByteLength <> SelLen) then
        begin
            SetSelByteStart(SelPos);
            SetSelByteLength(SelLen);
            SelChanged := True;
        end;

        if Moved or SelChanged then Repaint;

        if Moved and MouseCapture then
        begin
            if not PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then
            begin
                Message.Msg := WM_MOUSEMOVE;
                Message.Keys := MK_LBUTTON;
                Message.XPos := X;
                Message.YPos := Y;
                Message.Result := 0;
                PostMessage(Handle, WM_MOUSEMOVE, TMessage(Message).WParam, TMessage(Message).LParam);
            end;
        end;
    end;

    inherited MouseMove(Shift, X, Y);
end;

procedure TtsGridEditBox.DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                                     Left, Top : Integer);
var
    DisplaySelStart, DisplaySelLength: Integer;
begin
    DisplaySelStart := FSelByteStart;
    DisplaySelLength := FSelByteLength;

    if (not Focused) and (not Grid.Focused) and (not AlwaysShowFocus) then
    begin
        DisplaySelStart := 0;
        DisplaySelLength := 0;
    end;

    DisplayTextLines(Canvas, PChar(FText), Height, ARect, Left, Top,
                     FStartDisplayChar, FFirstDisplayRow, FTextLines,
                     DisplaySelStart, DisplaySelLength, clHighLight,
                     clHighLightText, Alignment, VertAlignment, (WordWrap <> wwOff));
end;

function TtsGridEditBox.GetDrawRect: TRect;
begin
    Result := Rect(-FLeftMargin, 0, Width, Height);
end;

procedure TtsGridEditBox.Paint;
var
    ARect : TRect;
begin
    inherited Paint;

    if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
    Canvas.Font := Font;
    ARect := GetDrawRect;
    DrawControl(Canvas, Height, ARect, 0, ARect.Top);
end;

procedure TtsGridEditBox.KeyDown(var Key: Word; Shift: TShiftState);
var
    Changed : Boolean;
    UndoChanged : Boolean;
begin
    inherited KeyDown(Key, Shift);
    if Key = 0 then Exit;

    Changed := false;
    UndoChanged := false;

    if KeyEdit or MouseSelect then
    begin
        if Shift = [] then
        begin
            case Key of
                VK_LEFT : if MoveLeft(false, false, FKeyRepeated) then Key := 0;
                VK_RIGHT : if MoveRight(false, false, FKeyRepeated) then Key := 0;
                VK_HOME : begin MoveHome(false); Key := 0; end;
                VK_END : begin MoveEnd(false); Key := 0; end;
                VK_DELETE : begin DelNextCharFromText(Changed, true); Key := 0; end;
                VK_BACK : begin DelPrevCharFromText(Changed, true); Key := 0; end;
                VK_UP : if MoveUp(false, FKeyRepeated) then Key := 0;
                VK_DOWN : if MoveDown(false, FKeyRepeated) then Key := 0;
                VK_PRIOR : if MovePageUp(false, FKeyRepeated) then Key := 0;
                VK_NEXT : if MovePageDown(false, FKeyRepeated) then Key := 0;
                VK_F2 : begin SetSelByteStart(FTextPos); Key := 0; end;
                VK_ESCAPE : UndoChanged := UndoEdit(Key);
                VK_RETURN : ;
            end;
        end;

        if Shift = [ssShift] then
        begin
            case Key of
                VK_RIGHT : begin MoveRight(true, false, false); Key := 0; end;
                VK_LEFT : begin MoveLeft(true, false, false); Key := 0; end;
                VK_DOWN : begin MoveDown(true, false); Key := 0; end;
                VK_UP : begin MoveUp(true, false); Key := 0; end;
                VK_END : begin MoveEnd(true); Key := 0; end;
                VK_HOME : begin MoveHome(true); Key := 0; end;
                VK_NEXT : begin MovePageDown(true, false); Key := 0; end;
                VK_PRIOR : begin MovePageUp(true, false); Key := 0; end;
                VK_INSERT: begin ClipboardPaste(True); Key := 0; end;
                VK_DELETE: begin ClipboardCut(True); Key := 0; end;
            end;
        end;

        if Shift = [ssCtrl] then
        begin
            case Key of
                VK_HOME : if CtrlMoveHome(false, true) then Key := 0;
                VK_END : if CtrlMoveEnd(false) then Key := 0;
                VK_RIGHT : if MoveRight(false, true, FKeyRepeated) then Key := 0;
                VK_LEFT : if MoveLeft(false, true, FKeyRepeated) then Key := 0;
                VK_RETURN: begin AddCharToText(Chr(Key), Changed); Key := 0; end;
                VK_INSERT: begin ClipboardCopy; Key := 0; end;
                VK_X: begin ClipboardCut(True); Key := 0; end;
                VK_C: begin ClipboardCopy; Key := 0; end;
                VK_V: begin ClipboardPaste(True); Key := 0; end;
                VK_Z: UndoChanged := UndoEdit(Key);
                VK_A: begin SelectAll; Key := 0; end;
            end;
        end;

        if Shift = [ssShift, ssCtrl] then
        begin
            case Key of
                VK_HOME : if CtrlMoveHome(true, true) then Key := 0;
                VK_END : if CtrlMoveEnd(true) then Key := 0;
                VK_RIGHT : if MoveRight(true, true, FKeyRepeated) then Key := 0;
                VK_LEFT : if MoveLeft(true, true, FKeyRepeated) then Key := 0;
            end;
        end;
    end;

    FKeyRepeated := True;
    if (Key <> 0) and Assigned(FOnEndKeyDown) then
        FOnEndKeyDown(Self, Key, Shift);

    if Changed or UndoChanged then
        if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, True);

    if Changed then
        if Assigned(FOnChanged) then FOnChanged(Self, True, True, Key = VK_RETURN);
end;

procedure TtsGridEditBox.KeyUp(var Key: Word; Shift: TShiftState);
begin
    inherited KeyUp(Key, Shift);

    FKeyRepeated := False;
    if (Key <> 0) and Assigned(FOnEndKeyUp) then FOnEndKeyUp(Self, Key, Shift);
end;

procedure TtsGridEditBox.KeyPress(var Key: Char);
var
    Changed : Boolean;
    PrevChar: Char;
begin
    PrevChar := FLeadByte;
    FLeadByte := #0;
    inherited KeyPress(Key);

    Changed := False;
    if (Key <> #0) then
    begin
        if PrevChar <> #0 then
            AddCharToText(PrevChar + Key, Changed)
        else
        begin
            case Key of
                Chr(VK_BACK), Chr(VK_ESCAPE), Chr(VK_TAB), Chr(VK_RETURN),
                Chr(10), Chr(CTRL_X), Chr(CTRL_C), Chr(CTRL_V), Chr(CTRL_A),
                Chr(CTRL_Z):;
            else
                if IsLeadByte(Key)
                    then FLeadByte := Key
                    else AddCharToText(Key, Changed);
            end;
        end;
    end;

    if (Key <> #0) and Assigned(FOnEndKeyPress) then FOnEndKeyPress(Self, Key);

    if Changed then
    begin
        if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, True);
        if Assigned(FOnChanged) then FOnChanged(Self, True, True, True);
    end;
end;

procedure TtsGridEditBox.Click;
begin
    inherited Click;
end;

procedure TtsGridEditBox.DblClick;
begin
    SelectAll;
    inherited DblClick;
end;

procedure TtsGridEditBox.TextPosToSelStart;
begin
    if FTextPos <> FSelByteStart then
    begin
        SetTextPosition(FSelByteStart, True);
        MoveCaretIntoView(True, KeyScrollPerc);
    end;
end;

function TtsGridEditBox.ClipboardPaste(ByUser: Boolean): Boolean;
var
    ClipbrdText: string;
begin
    Result := Clipboard.HasFormat(CF_TEXT);
    if Result then
    begin
        ClipbrdText := Clipboard.AsText;
        if not NewLengthOk(ClipbrdText) then Exit;
        if not CheckCanEdit(ByUser) then Exit;
        if not CanInsertText(ClipbrdText) then Exit;

        SaveOldText;
        ReplaceSelText(ClipbrdText);

        if Assigned(FOnNotifyChanged) then OnNotifyChanged(Self, True);
        if Assigned(FOnChanged) then OnChanged(Self, True, ByUser, True);
    end;
end;

procedure TtsGridEditBox.ClipboardCut(ByUser: Boolean);
begin
    if SelText <> '' then
    begin
        if not CheckCanEdit(ByUser) then Exit;

        SaveOldText;
        Clipboard.AsText := SelText;
        ReplaceSelText('');

        if Assigned(FOnNotifyChanged) then OnNotifyChanged(Self, True);
        if Assigned(FOnChanged) then OnChanged(Self, True, ByUser, False);
    end;
end;

procedure TtsGridEditBox.ClipboardCopy;
begin
    if SelText <> '' then Clipboard.AsText := SelText;
end;

procedure TtsGridEditBox.CutToClipboard(ByUser: Boolean);
begin
    ClipboardCut(ByUser);
end;

procedure TtsGridEditBox.CopyToClipboard;
begin
    ClipboardCopy;
end;

procedure TtsGridEditBox.PasteFromClipboard(ByUser: Boolean);
begin
    ClipboardPaste(ByUser);
end;

procedure TtsGridEditBox.SetMaxLength(Value: Integer);
begin
    Value := CalcMax(0, Value);
    if FMaxLength <> Value then FMaxLength := Value;
end;

function TtsGridEditBox.GetEditMask: TtsMaskItem;
begin
    if FEditMask = nil then FEditMask := FMaskLink.Mask[MaskName];
    Result := FEditMask;
end;

procedure TtsGridEditBox.ResetEditMask;
begin
    FEditMask := nil;
end;

procedure TtsGridEditBox.SetMaskDefs(Value: TtsMaskDefsComponent);
begin
    if MaskDefs <> Value then
    begin
        FMaskLink.MaskDefs := Value;
        ResetEditMask;
    end;
end;

function TtsGridEditBox.GetMaskDefs: TtsMaskDefsComponent;
begin
    Result := FMaskLink.MaskDefs;
end;

procedure TtsGridEditBox.SetMaskName(Value: string);
begin
    if FMaskName <> Value then
    begin
        FMaskName := Value;
        ResetEditMask;
    end;
end;

function TtsGridEditBox.GetMaskName: string;
begin
    Result := FMaskName;
end;

function TtsGridEditBox.IsEditKey(Key: Char): Boolean;
begin
    Result := Key in [^H, #32..#255];
end;

//End implementation of class TtsGridEditBox

//Implementation of class TtsGridCheckBox

constructor TtsGridCheckBox.Create(AOwner : TComponent);
begin
    inherited Create(AOwner);

    FCheckBoxState := cbUnchecked;
    FCheckBoxValue := cbUnchecked;
    FCheckBoxMaskColor := clWhite;
    FCheckBoxMaskToColor := clSilver;
    FMouseMask := false;
    FSpaceKeyMask := false;
    FLButtonDown := false;
    FOldState :=  cbUnchecked;
    FOldValue := cbUnchecked;
    FOldStateSaved := false;
    FMouseEditCanceled := false;
    FKeyEditCanceled := false;
    FAllowGrayed := False;
    FCanDblClick := False;
    Cursor := crDefault;

    CreateCheckBoxBitmaps;
end;

destructor TtsGridCheckBox.Destroy;
begin
    DeleteCheckBoxBitmaps;
    inherited Destroy;
end;

procedure TtsGridCheckBox.WMSetCursor(var Msg: TWMSetCursor);
begin
    if Screen.Cursor = crDefault then
        SetCursor(Screen.Cursors[Cursor])
    else
        inherited;
end;

procedure TtsGridCheckBox.CreateCheckBoxBitmaps;
begin
    FCheckBoxWinNTIndex := 0;
    FCheckBoxWin95Index := 3;
    FCheckBoxFlatIndex := 6;

    if not Assigned(FCheckBoxBitmaps) then
    begin
        FCheckBoxBitmaps := TBitmap.Create;
        FCheckBoxBitmaps.Width := DefaultCheckBoxWidth;
        FCheckBoxBitmaps.Height := 2 * CheckBoxBitmapCount * DefaultCheckBoxHeight;

        AddCheckBoxWinNTOn(FCheckBoxWinNTIndex);
        AddCheckBox3DOff(FCheckBoxWinNTIndex + 1);
        AddCheckBoxWinNTGrayed(FCheckBoxWinNTIndex + 2);

        AddCheckBoxWin95On(FCheckBoxWin95Index);
        AddCheckBox3DOff(FCheckBoxWin95Index + 1);
        AddCheckBoxWin95Grayed(FCheckBoxWin95Index + 2);

        AddCheckBoxFlatOn(FCheckBoxFlatIndex);
        AddCheckBoxFlatOff(FCheckBoxFlatIndex + 1);
        AddCheckBoxFlatGrayed(FCheckBoxFlatIndex + 2);

        AddCheckBoxBitmapMasks;
    end;

    FCheckBoxStyle := cbWin95;
    FCheckBoxOn := FCheckBoxWin95Index + CheckBoxOnOffset;
    FCheckBoxOff := FCheckBoxWin95Index + CheckBoxOffOffset;
    FCheckBoxGrayed := FCheckBoxWin95Index + CheckBoxGrayedOffset;

    FCustomCheckBoxBitmaps := TList.Create;
    FCustomCheckBoxBitmaps.Add(nil);
    FCustomCheckBoxBitmaps.Add(nil);
    FCustomCheckBoxBitmaps.Add(nil);
end;

procedure TtsGridCheckBox.AddCheckBoxBitmapMasks;
var
    I : Integer;
begin
    for I := 0 to CheckBoxBitmapCount - 1 do
    begin
        AddBitmapMask(FCheckBoxBitmaps, CheckBoxBitmapCount, I);
    end;
end;

procedure TtsGridCheckBox.AddBitmapMask(Bitmap: TBitmap; PictureCount, Index: Integer);
var
    BmpRect, MaskRect : TRect;
    MaskIndex: Integer;
    MaskColor : TColor;
    MaskToColor : TColor;
    PictureHeight: Integer;
    CheckBoxBmp: TBitmap;
    CheckBoxRect: TRect;
begin
    if Bitmap = nil then Exit;

    MaskIndex := Index + PictureCount;
    PictureHeight := Trunc(Bitmap.Height / (PictureCount * 2));
    BmpRect := Rect(0, Index * PictureHeight, Bitmap.Width, (Index + 1) * PictureHeight);
    MaskRect := Rect(0, MaskIndex * PictureHeight, Bitmap.Width, (MaskIndex + 1) * PictureHeight);

    Bitmap.Canvas.CopyRect(MaskRect, Bitmap.Canvas, BmpRect);
    if (Index >= FCheckBoxFlatIndex) and (Index < FCheckBoxFlatIndex + 3) then
    begin
        MaskRect := Rect(MaskRect.Left + 1, MaskRect.Top + 1,
                         MaskRect.Right - 1, MaskRect.Bottom - 1);
        DrawEdge(Bitmap.Canvas.Handle, MaskRect, BDR_RAISEDOUTER, BF_MONO + BF_RECT);
    end
    else
    begin
        MaskColor := DefaultCheckBoxMaskColor;
        MaskToColor := DefaultCheckBoxMaskToColor;

        if Bitmap <> FCheckBoxBitmaps then
        begin
            MaskColor := FCheckBoxMaskColor;
            MaskToColor := FCheckBoxMaskToColor;
        end;

        CheckBoxBmp := TBitmap.Create;
        try
            CheckBoxBmp.Width := BmpRect.Right - BmpRect.Left;
            CheckBoxBmp.Height := BmpRect.Bottom - BmpRect.Top;

            CheckBoxRect := Rect(0, 0, CheckBoxBmp.Width, CheckBoxBmp.Height);
            CheckBoxBmp.Canvas.CopyRect(CheckBoxRect, Bitmap.Canvas, BmpRect);

            MaskRect := Rect(MaskRect.Left + 1, MaskRect.Top + 1,
                             MaskRect.Right - 1, MaskRect.Bottom - 1);
            CheckBoxRect := Rect(CheckBoxRect.Left + 1, CheckBoxRect.Top + 1,
                                 CheckBoxRect.Right - 1, CheckBoxRect.Bottom - 1);

            Bitmap.Canvas.Brush.Color := MaskToColor;
            Bitmap.Canvas.BrushCopy(MaskRect, CheckBoxBmp, CheckBoxRect, MaskColor);
        finally
            CheckBoxBmp.Free;
        end;
    end;
end;

procedure TtsGridCheckBox.DeleteCheckBoxBitmaps;
var
    I : Integer;
begin
    for I := 0 to FCustomCheckBoxBitmaps.Count - 1 do
    begin
        TObject(FCustomCheckBoxBitmaps.Items[I]).Free;
    end;

    FCustomCheckBoxBitmaps.Free;
end;

procedure TtsGridCheckBox.AddCheckBoxWinNTOn(Index: Integer);
var
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;
    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Style := psSolid;
    Bitmap.Canvas.Pen.Width := 1;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_RECT);

    ARect := Rect(ARect.Left + 2, ARect.Top + 2, ARect.Right - 2, ARect.Bottom - 2);
    Bitmap.Canvas.FillRect(ARect);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 1);
    Bitmap.Canvas.LineTo(Arect.Right - 1, ARect.Bottom - 1);
    Bitmap.Canvas.MoveTo(ARect.Left + 2, ARect.Top + 1);
    Bitmap.Canvas.LineTo(Arect.Right - 1, ARect.Bottom - 2);
    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 2);
    Bitmap.Canvas.LineTo(Arect.Right - 2, ARect.Bottom - 1);

    Bitmap.Canvas.MoveTo(ARect.Right - 2, ARect.Top + 1);
    Bitmap.Canvas.LineTo(Arect.Left, ARect.Bottom - 1);
    Bitmap.Canvas.MoveTo(ARect.Right - 3, ARect.Top + 1);
    Bitmap.Canvas.LineTo(Arect.Left, ARect.Bottom - 2);
    Bitmap.Canvas.MoveTo(ARect.Right - 2, ARect.Top + 2);
    Bitmap.Canvas.LineTo(Arect.Left + 1, ARect.Bottom - 1);
end;

procedure TtsGridCheckBox.AddCheckBoxWin95On(Index: Integer);
var
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;
    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Style := psSolid;
    Bitmap.Canvas.Pen.Width := 1;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_RECT);

    ARect := Rect(ARect.Left + 2, ARect.Top + 2, ARect.Right - 2, ARect.Bottom - 2);
    Bitmap.Canvas.FillRect(ARect);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 3);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 4);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 4);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 3);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top + 1);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 5);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 2);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top + 2);
end;

procedure TtsGridCheckBox.AddCheckBox3DOff(Index: Integer);
var
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_RECT);

    ARect := Rect(ARect.Left+2, ARect.Top+2, ARect.Right-2, ARect.Bottom-2);
    Bitmap.Canvas.FillRect(ARect);
end;

procedure TtsGridCheckBox.AddCheckBoxWinNTGrayed(Index: Integer);
var
    I : Integer;
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_RECT);

    ARect := Rect(ARect.Left+2, ARect.Top+2, ARect.Right-2, ARect.Bottom-2);
    Bitmap.Canvas.FillRect(ARect);

    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Style := psSolid;

    Bitmap.Canvas.MoveTo( ARect.Left + 1, ARect.Top + 1);
    Bitmap.Canvas.LineTo( ARect.Right - 1, ARect.Bottom - 1);

    for I := 0 to 3 do
    begin
        Bitmap.Canvas.MoveTo( ARect.Left + 1 + (I * 2), ARect.Top + 1);
        Bitmap.Canvas.LineTo( ARect.Right - 1, ARect.Bottom - 1 - (I * 2));

        Bitmap.Canvas.MoveTo( ARect.Left + 1, ARect.Top + 1 + (I * 2));
        Bitmap.Canvas.LineTo( ARect.Right - 1 - (I * 2), ARect.Bottom - 1);
    end;
end;

procedure TtsGridCheckBox.AddCheckBoxWin95Grayed(Index: Integer);
var
    I : Integer;
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_RECT);

    ARect := Rect(ARect.Left+2, ARect.Top+2, ARect.Right-2, ARect.Bottom-2);
    Bitmap.Canvas.FillRect(ARect);

    Bitmap.Canvas.Pen.Color := clSilver;
    Bitmap.Canvas.Pen.Style := psSolid;

    for I := 0 to 4 do
    begin
        Bitmap.Canvas.MoveTo( ARect.Left + 1 + (I * 2), ARect.Top);
        Bitmap.Canvas.LineTo( ARect.Right, ARect.Bottom - 1 - (I * 2));

        Bitmap.Canvas.MoveTo( ARect.Left, ARect.Top + 1 + (I * 2));
        Bitmap.Canvas.LineTo( ARect.Right - 1 - (I * 2), ARect.Bottom);
    end;

    Bitmap.Canvas.Pen.Color := clGray;
    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 3);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 4);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 4);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 3);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top + 1);

    Bitmap.Canvas.MoveTo(ARect.Left + 1, ARect.Top + 5);
    Bitmap.Canvas.LineTo(ARect.Right - 6, ARect.Bottom - 2);
    Bitmap.Canvas.LineTo(ARect.Right - 1, ARect.Top + 2);
end;

procedure TtsGridCheckBox.AddCheckBoxFlatOn(Index: Integer);
var
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;
    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Style := psSolid;
    Bitmap.Canvas.Pen.Width := 1;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, BDR_RAISEDOUTER, BF_MONO + BF_RECT);

    Bitmap.Canvas.MoveTo(ARect.Left, ARect.Top);
    Bitmap.Canvas.LineTo(Arect.Right-1, ARect.Bottom-1);

    Bitmap.Canvas.MoveTo(Arect.Left, ARect.Bottom-1);
    Bitmap.Canvas.LineTo(ARect.Right-1, ARect.Top);
end;

procedure TtsGridCheckBox.AddCheckBoxFlatOff(Index: Integer);
var
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;
    Bitmap.Canvas.Pen.Color := clBlack;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_MONO + BF_RECT);
end;

procedure TtsGridCheckBox.AddCheckBoxFlatGrayed(Index: Integer);
var
    I : Integer;
    Bitmap : TBitmap;
    ARect : TRect;
begin
    Bitmap := FCheckBoxBitmaps;
    Bitmap.Canvas.Brush.Color := clWhite;
    Bitmap.Canvas.Pen.Color := clBlack;

    ARect.Top := Index * DefaultCheckBoxHeight;
    ARect.Left := 0;
    ARect.Right := Bitmap.Width;
    ARect.Bottom := ARect.Top + DefaultCheckBoxHeight;

    DrawEdge(Bitmap.Canvas.Handle, ARect, EDGE_SUNKEN, BF_MONO + BF_RECT);

    Bitmap.Canvas.Pen.Color := clBlack;
    Bitmap.Canvas.Pen.Style := psSolid;

    for I := 0 to 5 do
    begin
        Bitmap.Canvas.MoveTo( ARect.Left + 1 + (I * 2), ARect.Top);
        Bitmap.Canvas.LineTo( ARect.Right, ARect.Bottom - 1 - (I * 2));

        Bitmap.Canvas.MoveTo( ARect.Left, ARect.Top + 1 + (I * 2));
        Bitmap.Canvas.LineTo( ARect.Right - 1 - (I * 2), ARect.Bottom);
    end;
end;

procedure TtsGridCheckBox.WMKillFocus(var Message : TMessage);
begin
    inherited;
    if csDestroying in ComponentState then Exit;
    if Visible then Repaint;
end;

procedure TtsGridCheckBox.WMSetFocus(var Message : TMessage);
begin
    inherited;
    Repaint;
    FKeyEditCanceled := False;
end;

procedure TtsGridCheckBox.WMLButtonUp(var Message: TWMLButtonUp);
begin
    FClickOnMouseUp := True;
    inherited;
end;

procedure TtsGridCheckBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    if not (csDesigning in ComponentState) and CanFocus then
    begin
        SetFocus;
    end;

    if (Button = mbLeft) and KeyEdit then
    begin
        FLButtonDown := MouseCapture;
        if FLButtonDown then
        begin
            FMouseEditCanceled := not CheckCanEdit(True);
            if not FMouseEditCanceled then
            begin
                FMouseMask := True;
                Repaint;
            end
            else
            begin
                FLButtonDown := False;
                FMouseEditCanceled := False;
            end;
        end;
    end;

    inherited MouseDown(Button, Shift, X, Y);
end;

procedure TtsGridCheckBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
    Changed : Boolean;
begin
    Changed := False;

    if FLButtonDown and (Button = mbLeft) then
    begin
        FLButtonDown := False;

        if FMouseMask then
        begin
            ResetSelectState;
            if not FMouseEditCanceled then
            begin
                Changed := True;
                ToggleCheckBoxState;
                Invalidate;
            end;
        end;

        FMouseEditCanceled := False;
    end;

    if (Button = mbLeft) then MouseCapture := False;
    if FLButtonDown then
    begin
        FLButtonDown := MouseCapture;
        if not FLButtonDown then ResetSelectState;
    end;

    if Changed then
    begin
        if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, True);
        if Assigned(FOnChanged) then FOnChanged(Self, True, True, False);
    end;

    inherited MouseUp(Button, Shift, X, Y);
end;

procedure TtsGridCheckBox.MouseMove(Shift: TShiftState; X, Y: Integer);
begin
    if FLButtonDown then
    begin
        FLButtonDown := MouseCapture;
        if not FLButtonDown then ResetSelectState;
    end;

    if FLButtonDown and not FMouseEditCanceled then
    begin
        if FMouseMask then
        begin
            if (X < -3) or (X >= Width) or
               (Y < 0) or (Y >= Height) then
            begin
                FMouseMask := false;
                Repaint;
            end;
        end
        else
        begin
            if (X >= -3) and (X < Width) and
               (Y >= 0) and (Y < Height) then
            begin
                FMouseMask := true;
                Repaint;
            end;
        end;
    end;

    inherited MouseMove(Shift, X, Y);
end;

procedure TtsGridCheckBox.Paint;
var
    ARect : TRect;
begin
    inherited Paint;

    if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
    ARect := Rect(0, 0, Width, Height);
    DrawCheck(Canvas, ARect, (Focused or FGrid.Focused) or AlwaysShowFocus);
end;

procedure TtsGridCheckBox.DrawCheck(Canvas : TCanvas; ARect : TRect; DrawFocus: Boolean);
var
    CheckRect : TRect;
    Bitmap : TBitmap;
    BmpRect: TRect;
    CellBitmap : TBitmap;
    CellRect : TRect;
    CopyMode : TCopyMode;
    Focusrect : TRect;
    Offset3D : Integer;
begin
    CellRect.Left := 0;
    CellRect.Top := 0;
    CellRect.Right := ARect.Right - ARect.Left;
    CellRect.Bottom := ARect.Bottom - ARect.Top;

    CellBitmap := TBitmap.Create;
    try
        CellBitmap.Width := CellRect.Right;
        CellBitmap.Height := CellRect.Bottom;

        CellBitmap.Canvas.Brush := Canvas.Brush;
        CellBitmap.Canvas.Pen := Canvas.Pen;
        CellBitmap.Canvas.FillRect(CellRect);

        Bitmap := GetCheckBoxBitmap(FCheckBoxState, CopyMode, BmpRect, True);

        Offset3D := 0;
        if Ctl3D then Offset3D := 1;

        CheckRect.Left := ((CellRect.Right - (BmpRect.Right - BmpRect.Left)) div 2) - 1;
        CheckRect.Top := ((CellRect.Bottom - (BmpRect.Bottom - BmpRect.Top)) div 2) + Offset3D;
        CheckRect.Right := CheckRect.Left + (BmpRect.Right - BmpRect.Left);
        CheckRect.Bottom := CheckRect.Top + (BmpRect.Bottom - BmpRect.Top);

        if DrawFocus then
        begin
            FocusRect := Rect(CheckRect.Left - 5, CheckRect.Top - 2, CheckRect.Right + 5, CheckRect.Bottom + 2);
            if FocusRect.Left < CellRect.Left then FocusRect.Left := CellRect.Left;
            if FocusRect.Top < CellRect.Top then FocusRect.Top := CellRect.Top;
            if FocusRect.Bottom > CellRect.Bottom then FocusRect.Bottom := CellRect.Bottom;
            if FocusRect.Right > CellRect.Right then FocusRect.Right := CellRect.Right;

            if Ctl3D then
            begin
                if FocusRect.Left = CellRect.Left then Inc(FocusRect.Left);
                if FocusRect.Top = CellRect.Top then Inc(FocusRect.Top);
            end;

            if FocusRect.Right - CheckRect.Right > CheckRect.Left - FocusRect.Left then
                FocusRect.Right := CheckRect.Right + CheckRect.Left - FocusRect.Left;
            if FocusRect.Bottom - CheckRect.Bottom > CheckRect.Top - FocusRect.Top then
                FocusRect.Bottom := CheckRect.Bottom + CheckRect.Top - FocusRect.Top;

            CellBitmap.Canvas.DrawFocusRect(FocusRect);
        end;

        if CheckRect.Left < CellRect.Left then CheckRect.Left := CellRect.Left;
        if CheckRect.Top < CellRect.Top then CheckRect.Top := CellRect.Top;
        if CheckRect.Right > CellRect.Right then CheckRect.Right := CellRect.Right;
        if CheckRect.Bottom > CellRect.Bottom then CheckRect.Bottom := CellRect.Bottom;

        BmpRect.Right := BmpRect.Left + (CheckRect.Right - CheckRect.Left);
        BmpRect.Bottom := BmpRect.Top + (CheckRect.Bottom - CheckRect.Top);

        CellBitmap.Canvas.CopyMode := CopyMode;
        CellBitmap.Canvas.CopyRect(CheckRect, Bitmap.Canvas, BmpRect);

        Canvas.CopyRect(ARect, CellBitmap.Canvas, CellRect);
        if Ctl3D then DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_TOP);
    finally
        CellBitmap.Free;
    end;
end;

function TtsGridCheckBox.CheckBoxMasked : Boolean;
begin
    if FLButtonDown then
    begin
        if FMouseMask then Result := true
                      else Result := false;
    end
    else
    begin
        if FSpaceKeyMask then Result := true
                         else Result := false;
    end;
end;

procedure TtsGridCheckBox.ResetSelectState;
begin
    FMouseMask := False;
    Invalidate;
end;

procedure TtsGridCheckBox.ToggleCheckBoxState;
begin
    if not FOldStateSaved then
    begin
        FOldStateSaved := True;
        FOldState := FCheckBoxState;
        FOldValue := FCheckBoxValue;
    end;

    case FCheckBoxState of
        cbUnchecked : FCheckBoxState := cbChecked;
        cbChecked   : if AllowGrayed then FCheckBoxState := cbGrayed
                                     else FCheckBoxState := cbUnchecked;
    else
        FCheckBoxState := cbUnchecked;
    end;

    if (CheckBoxValues <> '') then
    begin
        FCheckBoxValue := CheckBoxToVariant(FCheckBoxState, CheckBoxValues);
        FCheckBoxState := VariantToCheckBox(FCheckBoxValue, CheckBoxValues);
    end
    else
        FCheckBoxValue := Integer(FCheckBoxState);
end;

procedure TtsGridCheckBox.SpaceKeyDown;
begin
    if not FSpaceKeyMask and not FKeyEditCanceled then
    begin
        FKeyEditCanceled := True;
        if not CheckCanEdit(True) then Exit;

        FKeyEditCanceled := False;
        FSpaceKeyMask := True;
        Repaint;
    end;
end;

function TtsGridCheckBox.UndoEdit(var Key: Word): Boolean;
var
    Cancel: Boolean;
begin
    Result := False;
    if FOldStateSaved then
    begin
        Key := 0;
        Cancel := False;
        if Assigned(FOnUndoChanged) then FOnUndoChanged(Self, True, Cancel);
        Result := not Cancel;
        if Result then RestoreOldState;
    end;
end;

function TtsGridCheckBox.RestoreOldState : Boolean;
begin
    Result := false;

    if FOldStateSaved then
    begin
        SetCheckBoxValue(FOldValue, False, False);
        FOldStateSaved := False;
        Result := true;
    end;
end;

function TtsGridCheckBox.GetCheckBoxBitmap(State : TCheckBoxState; var CopyMode : TCopyMode;
                                           var ARect: TRect; Mask : Boolean)  : TBitmap;
var
    Bitmap : TBitmap;
    Index, Offset : Integer;
    CheckBoxHeight: Integer;
begin
    case State of
        cbChecked   : Index := FCheckBoxOn;
        cbUnchecked : Index := FCheckBoxOff;
    else
        Index := FCheckBoxGrayed;
    end;

    if (Index < FCustomCheckBoxBitmaps.Count) and
       (FCustomCheckBoxBitmaps.Items[Index] <> nil) then
    begin
        Bitmap := FCustomCheckBoxBitmaps.Items[Index];
        Offset := 0;
        if CheckBoxMasked and Mask then Inc(Offset);

        CheckBoxHeight := Bitmap.Height div 2;
        ARect := Rect(0, Offset * CheckBoxHeight, Bitmap.Width, (Offset + 1) * CheckBoxHeight);
        CopyMode := cmSrcCopy;
    end
    else
    begin
        Bitmap := FCheckBoxBitmaps;
        Offset := Index;
        if CheckBoxMasked and Mask then Offset := Offset + CheckBoxBitmapCount;
        ARect := Rect(0, Offset * DefaultCheckBoxHeight, Bitmap.Width, (Offset + 1) * DefaultCheckBoxHeight);

        CopyMode := cmSrcCopy;
        if (Index >= FCheckBoxFlatIndex) and (Index < FCheckBoxFlatIndex + 3) then
            CopyMode := cmMergeCopy;
    end;

    Result := Bitmap;
end;

procedure TtsGridCheckBox.SetCheckBoxBitmap(State : TCheckBoxState; Bitmap : TBitmap);
var
    NewBitmap : TBitmap;
    BitmapRect : TRect;
    Index : Integer;
begin
    Index := 0;
    case State of
        cbChecked   : Index := CheckBoxOnOffset;
        cbUnchecked : Index := CheckBoxOffOffset;
        cbGrayed    : Index := CheckBoxGrayedOffset;
    end;

    TBitmap(FCustomCheckBoxBitmaps.Items[Index]).Free;
    FCustomCheckBoxBitmaps.Items[Index] := nil;

    if Bitmap <> nil then
    begin
        NewBitmap := TBitmap.Create;
        NewBitmap.Width := Bitmap.Width;
        NewBitmap.Height := 2 * Bitmap.Height;

        BitmapRect := Rect(0, 0, Bitmap.Width, Bitmap.Height);
        NewBitmap.Canvas.CopyRect(BitmapRect, Bitmap.Canvas, BitmapRect);

        FCustomCheckBoxBitmaps.Items[Index] := NewBitmap;
        AddBitmapMask(NewBitmap, 1, 0);
    end;

    if Bitmap <> nil then
    begin
        case State of
            cbChecked   : FCheckBoxOn := Index;
            cbUnchecked : FCheckBoxOff := Index;
            cbGrayed    : FCheckBoxGrayed := Index;
        end;
    end
    else
        SetCheckBoxStyle(FCheckBoxStyle);
end;

procedure TtsGridCheckBox.SetCheckBoxStyle(Value : TtsGridCheckBoxStyle);
var
    ToIndex : Integer;
begin
    ToIndex := 0;
    case Value of
        cbWin95  : ToIndex := FCheckBoxWin95Index;
        cbWinNT  : ToIndex := FCheckBoxWinNTIndex;
        cbFlat   : ToIndex := FCheckBoxFlatIndex;
    end;

    if FCustomCheckBoxBitmaps.Items[CheckBoxOnOffset] = nil then
        FCheckBoxOn := ToIndex + CheckBoxOnOffset;

    if FCustomCheckBoxBitmaps.Items[CheckBoxOffOffset] = nil then
        FCheckBoxOff := ToIndex + CheckBoxOffOffset;

    if FCustomCheckBoxBitmaps.Items[CheckBoxGrayedOffset] = nil then
        FCheckBoxGrayed := ToIndex + CheckBoxGrayedOffset;

    FCheckBoxStyle := Value;
end;

procedure TtsGridCheckBox.SetCheckBoxValue(Value: Variant; Edit, ByUser: Boolean);
begin
    FOldState := cbUnchecked;
    FOldStateSaved := False;

    if VarIsNull(Value) or VarIsEmpty(Value) or (VarType(Value) = varString) then
    begin
        FCheckBoxValue := Value;
        FCheckBoxState := VariantToCheckBox(Value, CheckBoxValues);
    end
    else if FCheckBoxValues <> '' then
    begin
        FCheckBoxValue := CheckBoxToVariant(Value, CheckBoxValues);
        FCheckBoxState := Value;
    end
    else
    begin
        FCheckBoxValue := Value;
        FCheckBoxState := Value;
    end;

    Invalidate;

    if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, True);
    if Assigned(FOnChanged) then FOnChanged(Self, Edit, ByUser, False);
end;

procedure TtsGridCheckBox.SetCheckBoxState(State : TCheckBoxState);
begin
    if not CheckCanChange(False) then Exit;
    SetCheckBoxValue(State, False, False);
end;

procedure TtsGridCheckBox.SetEditCheckBoxState(State: TCheckBoxState; ByUser: Boolean);
begin
    if not CheckCanEdit(False) then Exit;
    SetCheckBoxValue(State, True, ByUser);
end;

procedure TtsGridCheckBox.SetValue(Value : Variant);
begin
    if not CheckCanChange(False) then Exit;
    SetCheckBoxValue(Value, False, False);
end;

procedure TtsGridCheckBox.SetEditValue(Value: Variant; ByUser: Boolean);
begin
    if not CheckCanEdit(False) then Exit;
    SetCheckBoxValue(Value, True, ByUser);
end;

procedure TtsGridCheckBox.Click;
begin
    inherited Click;
end;

procedure TtsGridCheckBox.DblClick;
begin
    inherited DblClick;
end;

procedure TtsGridCheckBox.KeyDown(var Key: Word; Shift: TShiftState);
var
    UndoChanged : Boolean;
begin
    inherited KeyDown(Key, Shift);
    if Key = 0 then Exit;

    if FSpaceKeyMask or FMouseMask or FKeyEditCanceled or FMouseEditCanceled then
    begin
        Key := 0;
        Exit;
    end;

    UndoChanged := False;

    if Shift = [] then
    begin
        case Key of
            VK_ESCAPE : UndoChanged := UndoEdit(Key);
        end;
    end
    else if Shift = [ssCtrl] then
    begin
        case Key of
            VK_Z : UndoChanged := UndoEdit(Key);
        end;
    end;

    if (Key <> 0) and Assigned(FOnEndKeyDown) then FOnEndKeyDown(Self, Key, Shift);
    if UndoChanged and Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, true);
end;

procedure TtsGridCheckBox.KeyPress(var Key: Char);
begin
    inherited KeyPress(Key);

    if FSpaceKeyMask or FMouseMask or FKeyEditCanceled or FMouseEditCanceled then
    begin
        Key := #0;
        Exit;
    end;

    case Ord(Key) of
        VK_SPACE : begin SpaceKeyDown; Key := #0; end;
    end;

    if (Key <> #0) and Assigned(FOnEndKeyPress) then FOnEndKeyPress(Self, Key);
end;

procedure TtsGridCheckBox.KeyUp(var Key: Word; Shift: TShiftState);
var
    Changed : Boolean;
begin
    inherited KeyUp(Key, Shift);

    Changed := False;
    if (Key = VK_SPACE) and FSpaceKeyMask then
    begin
        FSpaceKeyMask := False;
        if not FKeyEditCanceled then
        begin
            Changed := True;
            ToggleCheckBoxState;
            Invalidate;
            Click;
        end;
    end;

    if (Key = VK_SPACE) and FKeyEditCanceled then
        FKeyEditCanceled := false;

    if (Key <> 0) and Assigned(FOnEndKeyUp) then FOnEndKeyUp(Self, Key, Shift);
    if Changed then
    begin
        if Assigned(FOnNotifyChanged) then FOnNotifyChanged(Self, True);
        if Assigned(FOnChanged) then FOnChanged(Self, True, True, False);
    end;
end;

function TtsGridCheckBox.IsEditKey(Key: Char): Boolean;
begin
    Result := (Key = Chr(VK_SPACE));
end;

//End implementation of class TtsGridCheckBox

//Implementation of class TtsCustomGridControl

constructor TtsCustomGridControl.Create;
begin
    inherited Create;
end;

destructor TtsCustomGridControl.Destroy;
begin
    FControl.Free;
    inherited Destroy;
end;

function TtsCustomGridControl.GetLeft: Integer;
begin
    Result := FControl.Left;
end;

function TtsCustomGridControl.GetWidth: Integer;
begin
    Result := FControl.Width;
end;

function TtsCustomGridControl.GetTop: Integer;
begin
    Result := FControl.Top;
end;

function TtsCustomGridControl.GetHeight: Integer;
begin
    Result := FControl.Height;
end;

procedure TtsCustomGridControl.SetLeft(Value: Integer);
begin
    if FControl.Left <> Value then FControl.Left := Value;
end;

procedure TtsCustomGridControl.SetWidth(Value: Integer);
begin
    if FControl.Width <> Value then FControl.Width := Value;
end;

procedure TtsCustomGridControl.SetTop(Value: Integer);
begin
    if FControl.Top <> Value then FControl.Top := Value;
end;

procedure TtsCustomGridControl.SetHeight(Value: Integer);
begin
    if FControl.Height <> Value then FControl.Height := Value;
end;

function TtsCustomGridControl.GetVisible: Boolean;
begin
    Result := FControl.Visible;
end;

procedure TtsCustomGridControl.SetVisible(Value: Boolean);
begin
    if FControl.Visible <> Value then
        FControl.Visible := Value;
end;

function TtsCustomGridControl.GetParent: TWinControl;
begin
    Result := FControl.Parent;
end;

procedure TtsCustomGridControl.SetParent(Value: TWinControl);
begin
    if FControl.Parent <> Value then FControl.Parent := Value;
end;

function TtsCustomGridControl.GetParentWindow: HWnd;
begin
    {$IFDEF TSVER_V3}
    Result := FControl.ParentWindow;
    {$ELSE}
    Result := 0;
    {$ENDIF}
end;

procedure TtsCustomGridControl.SetParentWindow(Value: HWnd);
begin
    {$IFDEF TSVER_V3}
    if FControl.ParentWindow <> Value then FControl.ParentWindow := Value;
    {$ENDIF}
end;

function TtsCustomGridControl.GetCtl3D : Boolean;
begin
    Result := TtsGridControl(FControl).Ctl3D;
end;

procedure TtsCustomGridControl.SetCtl3D(Ctl3D : Boolean);
begin
    TtsGridControl(FControl).Ctl3D := Ctl3D;
end;

procedure TtsCustomGridControl.SetFocus;
begin
    FControl.SetFocus;
end;

function TtsCustomGridControl.CanFocus: Boolean;
begin
    Result := FControl.CanFocus;
end;

procedure TtsCustomGridControl.Hide;
begin
    FControl.Visible := false;
end;

procedure TtsCustomGridControl.Show;
begin
    FControl.Show;
end;

procedure TtsCustomGridControl.Repaint;
begin
    FControl.Repaint;
end;

procedure TtsCustomGridControl.Invalidate;
begin
    FControl.Invalidate;
end;

function TtsCustomGridControl.ScreenToClient(const Point: TPoint): TPoint;
begin
    Result := FControl.ScreenToClient(Point);
end;

function TtsCustomGridControl.GetHandle: HWND;
begin
    Result := 0;
    if Assigned(FControl.Parent) then Result := FControl.Handle;
end;

procedure TtsCustomGridControl.SetMouseCapture(Value: Boolean);
begin
    TtsGridControl(FControl).MouseCapture := Value;
end;

function TtsCustomGridControl.GetMouseCapture;
begin
    Result := TtsGridControl(FControl).MouseCapture;
end;

function TtsCustomGridControl.Focused : Boolean;
begin
    Result := FControl.Focused;
end;

function TtsCustomGridControl.MultiLine: Boolean;
begin
    Result := False;
end;

function TtsCustomGridControl.IsEditKey(Key: Char): Boolean;
begin
    Result := FControl.IsEditKey(Key);
end;

procedure TtsCustomGridControl.CutToClipboard(ByUser: Boolean);
begin
end;

procedure TtsCustomGridControl.CopyToClipboard;
begin
end;

procedure TtsCustomGridControl.PasteFromClipboard(ByUser: Boolean);
begin
end;

function TtsCustomGridControl.ComponentState : TComponentState;
begin
    Result := FControl.ComponentState;
end;

procedure TtsCustomGridControl.SetEnter(EnterProc : TNotifyEvent);
begin
    TtsGridControl(FControl).OnEnter := EnterProc;
end;

procedure TtsCustomGridControl.SetExit(ExitProc : TNotifyEvent);
begin
    TtsGridControl(FControl).OnExit := ExitProc;
end;

procedure TtsCustomGridControl.SetKillFocus(KillFocusProc : TNotifyEvent);
begin
    TtsGridControl(FControl).OnKillFocus := KillFocusProc;
end;

procedure TtsCustomGridControl.SetKeyDown(KeyDown : TKeyEvent);
begin
    TtsGridControl(FControl).OnKeyDown := KeyDown;
end;

procedure TtsCustomGridControl.SetKeyUp(KeyUp : TKeyEvent);
begin
    TtsGridControl(FControl).OnKeyUp := KeyUp;
end;

procedure TtsCustomGridControl.SetKeyPress(KeyPress : TKeyPressEvent);
begin
    TtsGridControl(FControl).OnKeyPress := KeyPress;
end;

procedure TtsCustomGridControl.SetEndKeyDown(EndKeyDown : TKeyEvent);
begin
    TtsGridControl(FControl).OnEndKeyDown := EndKeyDown;
end;

procedure TtsCustomGridControl.SetEndKeyUp(EndKeyUp : TKeyEvent);
begin
    TtsGridControl(FControl).OnEndKeyUp := EndKeyUp;
end;

procedure TtsCustomGridControl.SetEndKeyPress(EndKeyPress : TKeyPressEvent);
begin
    TtsGridControl(FControl).OnEndKeyPress := EndKeyPress;
end;

procedure TtsCustomGridControl.SetClick(Click : TNotifyEvent);
begin
    TtsGridControl(FControl).OnClick := Click;
end;

procedure TtsCustomGridControl.SetDblClick(DblClick : TNotifyEvent);
begin
    TtsGridControl(FControl).OnDblClick := DblClick;
end;

procedure TtsCustomGridControl.SetDragDrop(DragDrop : TDragDropEvent);
begin
    TtsGridControl(FControl).OnDragDrop := DragDrop;
end;

procedure TtsCustomGridControl.SetDragOver(DragOver : TDragOverEvent);
begin
    TtsGridControl(FControl).OnDragOver := DragOver;
end;

procedure TtsCustomGridControl.SetEndDrag(EndDrag : TEndDragEvent);
begin
    TtsGridControl(FControl).OnEndDrag := EndDrag;
end;

procedure TtsCustomGridControl.SetMouseDown(MouseDown : TMouseEvent);
begin
    TtsGridControl(FControl).OnMouseDown := MouseDown;
end;

procedure TtsCustomGridControl.SetMouseMove(MouseMove : TMouseMoveEvent);
begin
    TtsGridControl(FControl).OnMouseMove := MouseMove;
end;

procedure TtsCustomGridControl.SetMouseUp(MouseUp : TMouseEvent);
begin
    TtsGridControl(FControl).OnMouseUp := MouseUp;
end;

procedure TtsCustomGridControl.SetStartDrag(StartDrag : TStartDragEvent);
begin
    TtsGridControl(FControl).OnStartDrag := StartDrag;
end;

procedure TtsCustomGridControl.SetNotifyChanged(Changed : TtsNotifyChangedEvent);
begin
    TtsGridControl(FControl).OnNotifyChanged := Changed;
end;

procedure TtsCustomGridControl.SetChanged(Changed : TtsChangedEvent);
begin
    TtsGridControl(FControl).OnChanged := Changed;
end;

procedure TtsCustomGridControl.SetEdit(Edit : TtsEditEvent);
begin
    TtsGridControl(FControl).OnEdit := Edit;
end;

procedure TtsCustomGridControl.SetCanChange(CanChange : TtsChangeEvent);
begin
    TtsGridControl(FControl).OnCanChange := CanChange;
end;

procedure TtsCustomGridControl.SetUndoChanged(UndoChanged : TtsUndoChangedEvent);
begin
    TtsGridControl(FControl).OnUndoChanged := UndoChanged;
end;

procedure TtsCustomGridControl.SetWantKey(WantKey : TtsWantKeyEvent);
begin
    TtsGridControl(FControl).OnWantKey := WantKey;
end;

procedure TtsCustomGridControl.SetInvalidKeys(Value: TtsInvalidEditEvent);
begin
    TtsGridControl(FControl).OnInvalidMaskEdit := Value;
end;

procedure TtsCustomGridControl.SetEditTextResized(Value: TtsEditTextResizedEvent);
begin
    TtsGridControl(FControl).OnEditTextResized := Value;
end;

procedure TtsCustomGridControl.SetAlignment(Align : TAlignment);
begin
    TtsGridControl(FControl).Alignment := Align;
end;

procedure TtsCustomGridControl.SetVertAlignment(Value : TtsVertAlignment);
begin
    TtsGridControl(FControl).VertAlignment := Value;
end;

procedure TtsCustomGridControl.SetWordWrap(Value: TtsWordWrap);
begin
    TtsGridControl(FControl).WordWrap := Value;
end;

procedure TtsCustomGridControl.SetLeftMargin(Margin : Integer);
begin
    TtsGridControl(FControl).LeftMargin := Margin;
end;

procedure TtsCustomGridControl.SetSelStart(Value: Integer);
begin
end;

procedure TtsCustomGridControl.SetSelLength(Value: Integer);
begin
end;

procedure TtsCustomGridControl.SetSelText(Value: string);
begin
end;

procedure TtsCustomGridControl.SetKeyEdit(Value: Boolean);
begin
    TtsGridControl(FControl).KeyEdit := Value;
end;

procedure TtsCustomGridControl.SetMouseSelect(Value: Boolean);
begin
    TtsGridControl(FControl).MouseSelect := Value;
end;

procedure TtsCustomGridControl.SetCursor(Value: TCursor);
begin
    TtsGridControl(FControl).Cursor := Value;
end;

procedure TtsCustomGridControl.SetMaxLength(Value: Integer);
begin
end;

procedure TtsCustomGridControl.SetWantTabs(Value: Boolean);
begin
    TtsGridControl(FControl).WantTabs := Value;
end;

procedure TtsCustomGridControl.SetMaskDefs(Value: TtsMaskDefsComponent);
begin
end;

procedure TtsCustomGridControl.SetMaskName(Value: string);
begin
end;

procedure TtsCustomGridControl.SetAlwaysShowFocus(Value: Boolean);
begin
    TtsGridControl(FControl).AlwaysShowFocus := Value;
end;

procedure TtsCustomGridControl.SelectAll;
begin
end;

procedure TtsCustomGridControl.DblClick;
begin
    FControl.DblClick;
end;

function TtsCustomGridControl.GetEnter : TNotifyEvent;
begin
    Result := TtsGridControl(FControl).OnEnter;
end;

function TtsCustomGridControl.GetExit : TNotifyEvent;
begin
    Result := TtsGridControl(FControl).OnExit;
end;

function TtsCustomGridControl.GetKillFocus : TNotifyEvent;
begin
    Result := TtsGridControl(FControl).OnKillFocus;
end;

function TtsCustomGridControl.GetKeyDown : TKeyEvent;
begin
    Result := TtsGridControl(FControl).OnKeyDown;
end;

function TtsCustomGridControl.GetKeyUp : TKeyEvent;
begin
    Result := TtsGridControl(FControl).OnKeyUp;
end;

function TtsCustomGridControl.GetKeyPress : TKeyPressEvent;
begin
    Result := TtsGridControl(FControl).OnKeyPress;
end;

function TtsCustomGridControl.GetEndKeyDown : TKeyEvent;
begin
    Result := TtsGridControl(FControl).OnEndKeyDown;
end;

function TtsCustomGridControl.GetEndKeyUp : TKeyEvent;
begin
    Result := TtsGridControl(FControl).OnEndKeyUp;
end;

function TtsCustomGridControl.GetEndKeyPress : TKeyPressEvent;
begin
    Result := TtsGridControl(FControl).OnEndKeyPress;
end;

function TtsCustomGridControl.GetClick : TNotifyEvent;
begin
    Result := TtsGridControl(FControl).OnClick;
end;

function TtsCustomGridControl.GetDblClick : TNotifyEvent;
begin
    Result := TtsGridControl(FControl).OnDblClick;
end;

function TtsCustomGridControl.GetDragDrop : TDragDropEvent;
begin
    Result := TtsGridControl(FControl).OnDragDrop;
end;

function TtsCustomGridControl.GetDragOver : TDragOverEvent;
begin
    Result := TtsGridControl(FControl).OnDragOver;
end;

function TtsCustomGridControl.GetEndDrag : TEndDragEvent;
begin
    Result := TtsGridControl(FControl).OnEndDrag;
end;

function TtsCustomGridControl.GetMouseDown : TMouseEvent;
begin
    Result := TtsGridControl(FControl).OnMouseDown;
end;

function TtsCustomGridControl.GetMouseMove : TMouseMoveEvent;
begin
    Result := TtsGridControl(FControl).OnMouseMove;
end;

function TtsCustomGridControl.GetMouseUp : TMouseEvent;
begin
    Result := TtsGridControl(FControl).OnMouseUp;
end;

function TtsCustomGridControl.GetStartDrag : TStartDragEvent;
begin
    Result := TtsGridControl(FControl).OnStartDrag;
end;

function TtsCustomGridControl.GetNotifyChanged : TtsNotifyChangedEvent;
begin
    Result := TtsGridControl(FControl).OnNotifyChanged;
end;

function TtsCustomGridControl.GetChanged : TtsChangedEvent;
begin
    Result := TtsGridControl(FControl).OnChanged;
end;

function TtsCustomGridControl.GetEdit : TtsEditEvent;
begin
    Result := TtsGridControl(FControl).OnEdit;
end;

function TtsCustomGridControl.GetCanChange : TtsChangeEvent;
begin
    Result := TtsGridControl(FControl).OnCanChange;
end;

function TtsCustomGridControl.GetUndoChanged : TtsUndoChangedEvent;
begin
    Result := TtsGridControl(FControl).OnUndoChanged;
end;

function TtsCustomGridControl.GetWantKey : TtsWantKeyEvent;
begin
    Result := TtsGridControl(FControl).OnWantKey;
end;

function TtsCustomGridControl.GetInvalidKeys: TtsInvalidEditEvent;
begin
    Result := TtsGridControl(FControl).OnInvalidMaskEdit;
end;

function TtsCustomGridControl.GetEditTextResized: TtsEditTextResizedEvent;
begin
    Result := TtsGridControl(FControl).OnEditTextResized;
end;

function TtsCustomGridControl.GetAlignment : TAlignment;
begin
    Result := TtsGridControl(FControl).Alignment;
end;

function TtsCustomGridControl.GetVertAlignment : TtsVertAlignment;
begin
    Result := TtsGridControl(FControl).VertAlignment;
end;

function TtsCustomGridControl.GetWordWrap : TtsWordWrap;
begin
    Result := TtsGridControl(FControl).WordWrap;
end;

function TtsCustomGridControl.GetLeftMargin : Integer;
begin
    Result := TtsGridControl(FControl).LeftMargin;
end;

function TtsCustomGridControl.GetSelStart: Integer;
begin
    Result := 0;
end;

function TtsCustomGridControl.GetSelLength: Integer;
begin
    Result := 0;
end;

function TtsCustomGridControl.GetSelText: string;
begin
    Result := '';
end;

function TtsCustomGridControl.GetKeyEdit: Boolean;
begin
    Result := TtsGridControl(FControl).KeyEdit;
end;

function TtsCustomGridControl.GetMouseSelect: Boolean;
begin
    Result := TtsGridControl(FControl).MouseSelect;
end;

function TtsCustomGridControl.GetCursor: TCursor;
begin
    Result := TtsGridControl(FControl).Cursor;
end;

function TtsCustomGridControl.GetMaxLength: Integer;
begin
    Result := 0;
end;

function TtsCustomGridControl.GetWantTabs: Boolean;
begin
    Result := TtsGridControl(FControl).WantTabs;
end;

function TtsCustomGridControl.GetMaskDefs: TtsMaskDefsComponent;
begin
    Result := nil;
end;

function TtsCustomGridControl.GetMaskName: string;
begin
    Result := '';
end;

function TtsCustomGridControl.GetAlwaysShowFocus: Boolean;
begin
    Result := TtsGridControl(FControl).AlwaysShowFocus;
end;

procedure TtsCustomGridControl.SaveCurrentState;
begin
end;

//End implementation of class TtsCustomGridControl

//Implementation of class TtsDefaultGridControl

constructor TtsDefaultGridControl.Create(AOwner: TComponent);
begin
    inherited Create;
    FControl := TtsGridControl.Create(AOwner);
    FControl.Visible := False;
end;

function TtsDefaultGridControl.GetGrid: TWinControl;
begin
    Result := FControl.Grid;
end;

procedure TtsDefaultGridControl.SetGrid(Value: TWinControl);
begin
    FControl.Grid := Value;
end;

function TtsDefaultGridControl.GetColor : TColor;
begin
    Result := clNone;
end;

procedure TtsDefaultGridControl.SetColor(Color : TColor);
begin
end;

function TtsDefaultGridControl.GetFont : TFont;
begin
    Result := TtsGridControl(FControl).Font
end;

procedure TtsDefaultGridControl.SetFont(Font : TFont);
begin
end;

procedure TtsDefaultGridControl.SetValue(Value: Variant);
begin
end;

procedure TtsDefaultGridControl.SetEditValue(Value: Variant; ByUser: Boolean);
begin
end;

function TtsDefaultGridControl.GetValue: Variant;
begin
    Result := Unassigned;
end;

procedure TtsDefaultGridControl.DrawControl(Canvas : TCanvas; Height : Integer; ARect : TRect;
                                            Left, Top : Integer; DrawFocus: Boolean);
begin
end;

function TtsDefaultGridControl.IsEditControl : Boolean;
begin
    Result := False;
end;

//End implementation of class TtsDefaultGridControl

//Implementation of class TtsEditGridControl

constructor TtsEditGridControl.Create(AOwner: TComponent);
begin
    inherited Create;
    FControl := TtsGridEditBox.Create(AOwner);
    TtsGridEditBox(FControl).ParentCtl3D := false;
    TtsGridEditBox(FControl).Ctl3D := false;
    TtsGridEditBox(FControl).Visible := false;
    TtsGridEditBox(FControl).Width := 1;
    TtsGridEditBox(FControl).Height := 1;
end;

function TtsEditGridControl.GetValue: Variant;
begin
    Result := Text;
end;

procedure TtsEditGridControl.SetValue(Value: Variant);
begin
    Text := Value;
end;

procedure TtsEditGridControl.SetEditValue(Value: Variant; ByUser: Boolean);
begin
    SetEditText(Value, ByUser);
end;

function TtsEditGridControl.GetGrid: TWinControl;
begin
    Result := TtsGridEditBox(FControl).Grid;
end;

procedure TtsEditGridControl.SetGrid(Value: TWinControl);
begin
    TtsGridEditBox(FControl).Grid := Value;
end;

function TtsEditGridControl.GetText : string;
begin
    Result := PChar(TtsGridEditBox(FControl).Text);
end;

procedure TtsEditGridControl.SetText(Value: string);
begin
    TtsGridEditBox(FControl).Text := Value;
end;

procedure TtsEditGridControl.SetEditText(Value: string; ByUser: Boolean);
begin
    TtsGridEditBox(FControl).SetEditText(Value, ByUser);
end;

function TtsEditGridControl.GetSelStart: Integer;
begin
    Result := TtsGridEditBox(FControl).SelStart;
end;

procedure TtsEditGridControl.SetSelStart(Value: Integer);
begin
    TtsGridEditBox(FControl).SelStart := Value;
    TtsGridEditBox(FControl).TextPosToSelStart;
end;

function TtsEditGridControl.GetSelLength: Integer;
begin
    Result := TtsGridEditBox(FControl).SelLength;
end;

procedure TtsEditGridControl.SetSelLength(Value: Integer);
begin
    TtsGridEditBox(FControl).SelLength := Value;
end;

function TtsEditGridControl.GetSelText: string;
begin
    Result := TtsGridEditBox(FControl).SelText;
end;

procedure TtsEditGridControl.SetSelText(Value: string);
begin
    TtsGridEditBox(FControl).SelText := Value;
end;

function TtsEditGridControl.GetMaxLength: Integer;
begin
    Result := TtsGridEditBox(FControl).MaxLength;
end;

procedure TtsEditGridControl.SetMaxLength(Value: Integer);
begin
    TtsGridEditBox(FControl).MaxLength := Value;
end;

function TtsEditGridControl.GetMaskDefs: TtsMaskDefsComponent;
begin
    Result := TtsGridEditBox(FControl).MaskDefs;
end;

procedure TtsEditGridControl.SetMaskDefs(Value: TtsMaskDefsComponent);
begin
    TtsGridEditBox(FControl).MaskDefs := Value;
end;

function TtsEditGridControl.GetMaskName: string;
begin
    Result := TtsGridEditBox(FControl).MaskName;
end;

procedure TtsEditGridControl.SetMaskName(Value: string);
begin
    TtsGridEditBox(FControl).MaskName := Value;
end;

procedure TtsEditGridControl.SelectAll;
begin
    TtsGridEditBox(FControl).SelectAll;
end;

function TtsEditGridControl.GetColor : TColor;
begin
    Result := TtsGridEditBox(FControl).Color;
end;

procedure TtsEditGridControl.SetColor(Color : TColor);
begin
    TtsGridEditBox(FControl).Color := Color;
end;

function TtsEditGridControl.GetFont : TFont;
begin
    Result := TtsGridEditBox(FControl).Font;
end;

procedure TtsEditGridControl.SetFont(Font : TFont);
begin
    TtsGridEditBox(FControl).Font := Font;
end;

function TtsEditGridControl.IsEditControl : Boolean;
begin
    Result := true;
end;

function TtsEditGridControl.MultiLine: Boolean;
begin
    Result := (TtsGridEditBox(FControl).LineCount > 1);
end;

procedure TtsEditGridControl.DrawControl(Canvas : TCanvas; Height : Integer;
                                         ARect : TRect; Left, Top : Integer;
                                         DrawFocus: Boolean);
begin
    TtsGridEditBox(FControl).DrawControl(Canvas, Height, ARect, Left, Top);
end;

procedure TtsEditGridControl.SaveCurrentState;
begin
    SelStart := TtsGridEditBox(FControl).SelStart;
    SelLength := TtsGridEditBox(FControl).SelLength;
end;

procedure TtsEditGridControl.CutToClipboard(ByUser: Boolean);
begin
    TtsGridEditBox(FControl).CutToClipboard(ByUser);
end;

procedure TtsEditGridControl.CopyToClipboard;
begin
    TtsGridEditBox(FControl).CopyToClipboard;
end;

procedure TtsEditGridControl.PasteFromClipboard(ByUser: Boolean);
begin
    TtsGridEditBox(FControl).PasteFromClipboard(ByUser);
end;

//End implementation of class TtsEditGridControl

//Implementation of class TtsCheckGridControl

constructor TtsCheckGridControl.Create(AOwner: TComponent);
begin
    inherited Create;

    FControl := TtsGridCheckBox.Create(AOwner);
    TtsGridCheckBox(FControl).Caption := '';
    TtsGridCheckBox(FControl).ParentCtl3D := false;
    TtsGridCheckBox(FControl).Ctl3D := false;
    TtsGridCheckBox(FControl).Visible := false;
    TtsGridCheckBox(FControl).TabStop := false;
    TtsGridCheckBox(FControl).Width := 1;
    TtsGridCheckBox(FControl).Height := 1;
end;

function TtsCheckGridControl.GetValue: Variant;
begin
    Result := TtsGridCheckBox(FControl).Value;
end;

procedure TtsCheckGridControl.SetValue(Value: Variant);
begin
    TtsGridCheckBox(FControl).Value := Value;
end;

procedure TtsCheckGridControl.SetEditValue(Value: Variant; ByUser: Boolean);
begin
    TtsGridCheckBox(FControl).SetEditValue(Value, ByUser);
end;

function TtsCheckGridControl.GetGrid: TWinControl;
begin
    Result := TtsGridCheckBox(FControl).FGrid;
end;

procedure TtsCheckGridControl.SetGrid(Value: TWinControl);
begin
    TtsGridCheckBox(FControl).Grid := Value;
end;

function TtsCheckGridControl.GetState : TCheckBoxState;
begin
    Result := TtsGridCheckBox(FControl).CheckBoxState;
end;

procedure TtsCheckGridControl.SetState(Value: TCheckBoxState);
begin
    TtsGridCheckBox(FControl).CheckBoxState := Value;
end;

procedure TtsCheckGridControl.SetEditState(Value: TCheckBoxState; ByUser: Boolean);
begin
    TtsGridCheckBox(FControl).SetEditCheckBoxState(Value, ByUser);
end;

function TtsCheckGridControl.GetColor : TColor;
begin
    Result := TtsGridCheckBox(FControl).Color;
end;

procedure TtsCheckGridControl.SetColor(Color : TColor);
begin
    TtsGridCheckBox(FControl).Color := Color;
end;

function TtsCheckGridControl.GetFont : TFont;
begin
    Result := TtsGridCheckBox(FControl).Font;
end;

procedure TtsCheckGridControl.SetFont(Font : TFont);
begin
    TtsGridCheckBox(FControl).Font := Font;
end;

function TtsCheckGridControl.IsEditControl : Boolean;
begin
    Result := false;
end;

procedure TtsCheckGridControl.DrawControl(Canvas : TCanvas; Height : Integer;
                                          ARect : TRect; Left, Top : Integer;
                                          DrawFocus: Boolean);
begin
    ARect.Left := Left;
    ARect.Top := Top;
    TtsGridCheckBox(FControl).DrawCheck(Canvas, ARect, DrawFocus);
end;

function TtsCheckGridControl.GetCheckBoxStyle : TtsGridCheckBoxStyle;
begin
    Result := TtsGridCheckBox(FControl).CheckBoxStyle;
end;

procedure TtsCheckGridControl.SetCheckBoxStyle(Value : TtsGridCheckBoxStyle);
begin
    TtsGridCheckBox(FControl).CheckBoxStyle := Value;
end;

function TtsCheckGridControl.GetCheckBoxBitmap(State : TCheckBoxState; var CopyMode : TCopyMode; var ARect: TRect; Mask : Boolean) : TBitmap;
begin
    Result := TtsGridCheckBox(FControl).GetCheckBoxBitmap(State, CopyMode, ARect, Mask);
end;

procedure TtsCheckGridControl.SetCheckBoxBitmap(State : TCheckBoxState; Bitmap : TBitmap);
begin
    TtsGridCheckBox(FControl).SetCheckBoxBitmap(State, Bitmap);
end;

function TtsCheckGridControl.GetCheckBoxMaskColor : TColor;
begin
    Result := TtsGridCheckBox(FControl).CheckBoxMaskColor;
end;

procedure TtsCheckGridControl.SetCheckBoxMaskColor(Value : TColor);
begin
    TtsGridCheckBox(FControl).CheckBoxMaskColor := Value;
end;

function TtsCheckGridControl.GetCheckBoxMaskToColor : TColor;
begin
    Result := TtsGridCheckBox(FControl).CheckBoxMaskToColor;
end;

procedure TtsCheckGridControl.SetCheckBoxMaskToColor(Value : TColor);
begin
    TtsGridCheckBox(FControl).CheckBoxMaskToColor := Value;
end;

function TtsCheckGridControl.GetAllowGrayed: Boolean;
begin
    Result := TtsGridCheckBox(FControl).AllowGrayed;
end;

procedure TtsCheckGridControl.SetAllowGrayed(Value: Boolean);
begin
    TtsGridCheckBox(FControl).AllowGrayed := Value;
end;

function TtsCheckGridControl.GetCheckBoxValues: string;
begin
    Result := TtsGridCheckBox(FControl).CheckBoxValues;
end;

procedure TtsCheckGridControl.SetCheckBoxValues(Value: string);
begin
    TtsGridCheckBox(FControl).CheckBoxValues := Value;
end;

procedure TtsCheckGridControl.SetMouseCapture(Value: Boolean);
begin
    inherited SetMouseCapture(Value);
    if not Value then TtsGridCheckBox(FControl).ResetSelectState;
end;

//End TtsCheckGridControl

{TtsCol}

constructor TtsCol.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    Initialize;
    FGrid := Grid;
end;

destructor TtsCol.Destroy;
begin
    FHeading := '';
    FFont.Free;
    FHeadingFont.Free;
    DestroyButton;
    FCombo.Free;
    Grid.RemoveDateTime(FDateTimeDef);

    Grid.ResetComboInit(True);
    Grid.ResetDateTimeInit;

    inherited Destroy;
end;

procedure TtsCol.Initialize;
begin
    FColor := clNone;
    FFont := nil;
    FParentFont := True;
    FHeading := '';
    FControlType := ctDefault;
    FReadOnly := False;
    FVisible := True;
    FIs3D := False;
    FAlignment := taLeftJustify;
    FAlign := False;
    FHorzAlignment := htaDefault;
    FVertAlignment := vtaDefault;
    FWordWrap := wwDefault;
    FButtonType := btDefault;
    FDropDownStyle := ddDropDown;
    FHeadingButton := cbGrid;
    FHeadingAlignment := taLeftJustify;
    FHeadingAlign := False;
    FHeadingHorzAlignment := htaDefault;
    FHeadingVertAlignment := vtaDefault;
    FHeadingWordWrap := wwDefault;
    FHeadingFont := nil;
    FHeadingParentFont := True;
    FHeadingColor := clNone;
    FSortPicture := spNone;
    FSpinOptions := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    FSpinIncrement := 1;
    FAllowGrayed := False;
    FNormalButton := nil;
    FMaxLength := 0;
    FMaskName := '';
    FAutoCreateFont := False;
    FCombo := nil;
    FParentCombo := True;
    FChangeFont := 0;
    FStretchPicture := dopDefault;
    FShrinkPicture := dopDefault;
    FCenterPicture := dopDefault;
    FKeepAspectRatio := dopDefault;
    FDateTimeDef := nil;
    FCheckBoxValues := '';
end;

function TtsCol.DefaultProps: Boolean;
begin
    Result := (DisplayCol = DataCol) and
              (FColor = clNone) and
              (FFont = nil) and
              (FParentFont = True) and
              (FHeading = '') and
              (FControlType = ctDefault) and
              (FReadOnly = False) and
              (FVisible = True) and
              (FIs3D = False) and
              (FAlignment = taLeftJustify) and
              (FAlign = False) and
              (FHorzAlignment = htaDefault) and
              (FVertAlignment = vtaDefault) and
              (FWordWrap = wwDefault) and
              (FButtonType = btDefault) and
              (FDropDownStyle = ddDropDown) and
              (FHeadingButton = cbGrid) and
              (FHeadingAlignment = taLeftJustify) and
              (FHeadingAlign = False) and
              (FHeadingHorzAlignment = htaDefault) and
              (FHeadingVertAlignment = vtaDefault) and
              (FHeadingWordWrap = wwDefault) and
              (FHeadingFont = nil) and
              (FHeadingParentFont = True) and
              (FHeadingColor = clNone) and
              (FSortPicture = spNone) and
              (FSpinOptions = [spoAutoRepeat, spoAutoIncrement, spoKeyEdit]) and
              (FSpinIncrement = 1) and
              (FAllowGrayed = False) and
              (FMaxLength = 0) and
              (FMaskName = '') and
              (FFieldName = '') and
              (FAutoCreateFont = False) and
              (FChangeFont = 0) and
              (FWidth = Grid.DefaultColWidth) and
              (FCombo = nil) and
              (FParentCombo = True) and
              (FStretchPicture = dopDefault) and
              (FShrinkPicture = dopDefault) and
              (FCenterPicture = dopDefault) and
              (FKeepAspectRatio = dopDefault) and
              (FDateTimeDef = nil) and
              (FCheckBoxValues = '');
end;

function TtsCol.Empty: Boolean;
begin
    Result := DefaultProps and
              (FNormalButton = nil);
end;

function TtsCol.StoreSpinIncrement: Boolean;
begin
    Result := FSpinIncrement <> 1;
end;

procedure TtsCol.Reset(Properties: TtsProperties);
begin
    if prColor in Properties then Color := clNone;
    if prColor in Properties then HeadingColor := clNone;
    if prFont in Properties then ResetFont;
    if prIs3D in Properties then Is3D := False;
    if prVisible in Properties then Visible := True;
    if prWidth in Properties then CopyWidth(FOldWidth);
    if prDisplayNumber in Properties then DisplayCol := DataCol;
    if prAlign in Properties then Align := False;
    if prAlignment in Properties then Alignment := taLeftJustify;
    if prHorzAlignment in Properties then HorzAlignment := htaDefault;
    if prVertAlignment in Properties then VertAlignment := vtaDefault;
    if prSortPicture in Properties then SortPicture := spNone;
    if prHeadingButton in Properties then HeadingButton := cbGrid;
    if prMaxLength in Properties then MaxLength := 0;
    if prReadOnly in Properties then ReadOnly := False;
    if prWordWrap in Properties then WordWrap := wwDefault;
    if prMask in Properties then MaskName := '';
    if prButtonType in Properties then ButtonType := btDefault;
    if prCombo in Properties then ResetCombo;
    if prParentCombo in Properties then ParentCombo := True;
    if prPicture in Properties then StretchPicture := dopDefault;
    if prPicture in Properties then ShrinkPicture := dopDefault;
    if prPicture in Properties then CenterPicture := dopDefault;
    if prPicture in Properties then KeepAspectRatio := dopDefault;
    if prSpinOptions in Properties then SpinOptions := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    if prSpinIncrement in Properties then SpinIncrement := 1;
    if prDateTime in Properties then DateTimeDef := nil;
    if prSelected in Properties then Selected := False;
    if prTag in Properties then Tag := 0;
    if prData in Properties then Data := Nil;
end;

procedure TtsCol.CreateButton(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
var
    Invalidated: Boolean;
begin
    if FNormalButton <> nil then FNormalButton.Destroy;
    FNormalButton := nil;

    if Bmp <> nil then
        FNormalButton := TtsNormalButton.Create(FGrid, Bmp, TransparentColor, Width, Height);

    Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
    if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
    begin
        FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.DestroyButton;
var
    Invalidated: Boolean;
begin
    if FNormalButton = nil then Exit;
    if FNormalButton <> nil then FNormalButton.Destroy;
    FNormalButton := nil;

    if not (csDestroying in FGrid.ComponentState) then
    begin
        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsCol.SetButton(Button: TtsNormalButton);
begin
    if Button <> nil
        then CreateButton(Button.Bitmap, Button.TransparentColor, Button.Width, Button.Height)
        else DestroyButton;
end;

procedure TtsCol.SetStretchPicture(Value: TtsDrawOption);
begin
    if (FStretchPicture <> Value) then
    begin
        FStretchPicture := Value;
        FGrid.CheckInvalidateCol(DisplayCol);
    end;
end;

function TtsCol.HTMLCell(forValue : String) : String;
  function AlignString : String;
  begin
    Result := ' align="' + 'left' + '">';
    case Self.Alignment of    //
      taLeftJustify : Result := '>';
      taCenter      : Result := ' align="' + 'center' + '">';
      taRightJustify: Result := ' align="' + 'right' + '">';
    end;    // case
  end;
begin
  Result := '<td' + AlignString + forValue + '</td>';
end;

function TtsCol.HTMLHeader : String;
  function AlignString : String;
  begin
    Result := ' align="' + 'left' + '">';
    case Self.Alignment of    //
      taLeftJustify : Result := '>';
      taCenter      : Result := ' align="' + 'center' + '">';
      taRightJustify: Result := ' align="' + 'right' + '">';
    end;    // case
  end;
begin
  Result := '<th width=' + IntToStr(Self.Width) + AlignString + Self.Heading + '</th>';
end;

function TtsCol.XMLHeading : String;
var sText : String;
    i : Integer;
begin
  // Make sure no underscores...
  if Self.FieldName <> '' then
     sText := FieldName
  else
     sText := Heading;
  Result := '';
  for i := 1 to Length(sText) do
  begin
    if (sText[i] = ' ') then
       Result := Result + '_'
    else
       Result := Result + sText[i];
  end;
end;

procedure TtsCol.SetShrinkPicture(Value: TtsDrawOption);
begin
    if (FShrinkPicture <> Value) then
    begin
        FShrinkPicture := Value;
        FGrid.CheckInvalidateCol(DisplayCol);
    end;
end;

procedure TtsCol.SetCenterPicture(Value: TtsDrawOption);
begin
    if (FCenterPicture <> Value) then
    begin
        FCenterPicture := Value;
        FGrid.CheckInvalidateCol(DisplayCol);
    end;
end;

procedure TtsCol.SetKeepAspectRatio(Value: TtsDrawOption);
begin
    if (FKeepAspectRatio <> Value) then
    begin
        FKeepAspectRatio := Value;
        FGrid.CheckInvalidateCol(DisplayCol);
    end;
end;

procedure TtsCol.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    if Value <> FDateTimeDef then
    begin
        if DisplayCol = Grid.CurDisplayCol
            then Grid.ResetDateTimeInit
            else Grid.CheckLastUsedDateTime(FDateTimeDef);

        Grid.RemoveDateTime(FDateTimeDef);
        FDateTimeDef := Value;
        Grid.AddDateTime(FDateTimeDef);
    end;
end;

procedure TtsCol.AssignProperties(Source: TtsCol);
begin
    FColor := Source.FColor;
    FAlignment := Source.FAlignment;
    FAlign := Source.FAlign;
    FHorzAlignment := Source.FHorzAlignment;
    FVertAlignment := Source.FVertAlignment;
    FHeading := Source.FHeading;
    FWidth := Source.FWidth;
    FOldWidth := Source.FWidth;
    FIs3D := Source.Is3D;
    FVisible := Source.FVisible;
    FReadOnly := Source.FReadOnly;
    FDropDownStyle := Source.FDropDownStyle;
    FHeadingButton := Source.FHeadingButton;
    FSortPicture := Source.FSortPicture;
    FSpinOptions := Source.FSpinOptions;
    FSpinIncrement := Source.FSpinIncrement;
    FWordWrap := Source.FWordWrap;
    FAllowGrayed := Source.FAllowGrayed;
    FHeadingAlignment := Source.FHeadingAlignment;
    FHeadingAlign := Source.FHeadingAlign;
    FHeadingHorzAlignment := Source.FHeadingHorzAlignment;
    FHeadingVertAlignment := Source.FHeadingVertAlignment;
    FHeadingWordWrap := Source.FHeadingWordWrap;
    FHeadingColor := Source.FHeadingColor;
    FMaxLength := Source.FMaxLength;
    FAccelKeyPos := Source.FAccelKeyPos;
    FMaskName := Source.FMaskName;
    FControlType := Source.FControlType;
    FStretchPicture := Source.FStretchPicture;
    FShrinkPicture := Source.FShrinkPicture;
    FCenterPicture := Source.FCenterPicture;
    FKeepAspectRatio := Source.FKeepAspectRatio;
    FParentCombo := Source.FParentCombo;
    FFieldName := Source.FieldName;
    FCheckBoxValues := Source.FCheckBoxValues;

    SetButtonType(Source.FButtonType);
    SetDateTimeDef(Source.DateTimeDef);
    SetCombo(Source.FCombo);
    SetButton(Source.FNormalButton);

    FParentFont := Source.FParentFont;
    if not ParentFont then UpdateFont(Source.Font)
                      else CheckFont;

    FHeadingParentFont := Source.FHeadingParentFont;
    if not HeadingParentFont then UpdateHeadingFont(Source.HeadingFont)
                             else CheckHeadingFont;
end;

procedure TtsCol.Copy(Source: TtsCol);
begin
    FGrid := Source.FGrid;
    FDisplayCol := Source.FDisplayCol;
    AssignProperties(Source);
end;

procedure TtsCol.Assign(Source: TPersistent);
var
    OldWidth: Integer;
    Invalidated: Boolean;
begin
    if Source is TtsCol then
    begin
        OldWidth := FWidth;
        AssignProperties(TtsCol(Source));
        CheckWidth(OldWidth);

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end
    else
        inherited;
end;

procedure TtsCol.AssignCombo;
begin
    if not Assigned(FCombo) then
    begin
        FCombo := Grid.CreateCombo;
        FParentCombo := False;
        FCombo.DropDownStyle := FDropDownStyle;
        FCombo.Grid.InitComboColWidth(Width);
        if (Grid.CurDisplayCol = DisplayCol) then Grid.ResetComboInit(False);
    end;
end;

procedure TtsCol.ResetCombo;
begin
    if Assigned(FCombo) then
    begin
        if (Grid.CurDisplayCol = DisplayCol) then
            Grid.RedisplayControl(True);
        Grid.CheckResetComboInit(FCombo, True);

        FCombo.Free;
        FCombo := nil;
    end;
end;

procedure TtsCol.AssignFont;
begin
    if FFont = nil then SetFont(FGrid.Font);
end;

procedure TtsCol.ResetFont;
begin
    SetFont(nil);
end;

procedure TtsCol.AssignHeadingFont;
begin
    if FHeadingFont = nil then SetHeadingFont(FGrid.HeadingFont);
end;

procedure TtsCol.ResetHeadingFont;
begin
    SetHeadingFont(nil);
end;

procedure TtsCol.FontChange;
var
    Invalidated: Boolean;
begin
    if ChangeFont then
    begin
        FParentFont := False;
        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
        end;

        FGrid.UpdateCellFonts;
    end;
end;

procedure TtsCol.HeadingFontChange;
begin
    if ChangeFont then
    begin
        FHeadingParentFont := False;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

function TtsCol.GetDataCol: Longint;
begin
    Result := FGrid.GetDataCol(DisplayCol);
end;

function TtsCol.GetFixed: Boolean;
begin
    Result := (DisplayCol <= FGrid.InternalFixedCols);
end;

function TtsCol.GetHeading: string;
begin
    Result := FHeading;
    if (Result = '') then Result := FFieldName;
end;

function TtsCol.GetAlignment: TAlignment;
begin
    Result := FAlignment;
end;

function TtsCol.GetHorzAlignment: TtsHorzAlignment;
begin
    Result := FHorzAlignment;
end;

function TtsCol.GetMaxTextWidth : Integer;
var iRow, iWidth : Integer;
begin
  Result := 0;
  for iRow := 1 to Self.Grid.Rows do
  begin
    if (Grid.RowVisible[iRow]) then
    begin
      iWidth := Grid.CellTextWidth[Self.DataCol, iRow];
      if (iWidth > Result) then
         Result := iWidth;
    end;
  end;
end;

function TtsCol.GetFont: TFont;
begin
    Result := FFont;
    if ParentFont and Grid.Writing then
        Result := nil
    else if not Assigned(FFont) and Grid.Reading then
    begin
        UpdateFont(FGrid.Font);
        Result := FFont;
    end
    else if not Assigned(Result) and AutoCreateFont then
    begin
        UpdateFont(FGrid.Font);
        Result := FFont;
    end
    else if Assigned(FFont) and ParentFont and
            (not AutoCreateFont) and (not Grid.Reading) then
    begin
        UpdateFont(nil);
        Result := FFont;
    end;
end;

function TtsCol.GetHeadingFont: TFont;
begin
    Result := FHeadingFont;
    if HeadingParentFont and Grid.Writing then
        Result := nil
    else if not Assigned(FHeadingFont) and Grid.Reading then
    begin
        UpdateHeadingFont(FGrid.HeadingFont);
        Result := FHeadingFont;
    end
    else if not Assigned(Result) and AutoCreateFont then
    begin
        UpdateHeadingFont(FGrid.HeadingFont);
        Result := FHeadingFont;
    end
    else if Assigned(FHeadingFont) and HeadingParentFont and
            (not AutoCreateFont) and (not Grid.Reading) then
    begin
        UpdateHeadingFont(nil);
        Result := FHeadingFont;
    end;
end;

function TtsCol.GetAlign: Boolean;
begin
    Result := FAlign;
end;

function TtsCol.GetReadOnly: Boolean;
begin
    Result := FReadOnly;
end;

function TtsCol.GetAllowGrayed: Boolean;
begin
    Result := FAllowGrayed;
end;

procedure TtsCol.SetColor(Value: TColor);
var
    Invalidated: Boolean;
begin
    if FColor <> Value then
    begin
        FColor := Value;

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsCol.CopyFont(Value: TFont);
begin
    if FFont <> Value then
    begin
        if Value = nil then
        begin
            FFont.Free;
            FFont := nil;
        end
        else
        begin
            if FFont = nil then FFont := TFont.Create;
            FFont.Assign(Value);
            FFont.OnChange := FontChange;
        end;
    end;
end;

procedure TtsCol.UpdateFont(Value: TFont);
begin
    ChangeFont := False;
    try
        CopyFont(Value);
    finally
        ChangeFont := True;
    end;
end;

procedure TtsCol.SetFont(Value: TFont);
var
    Invalidated: Boolean;
begin
    if FFont <> Value then
    begin
        try
            CopyFont(Value);
        finally
            FParentFont := not Assigned(FFont);
        end;

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsCol.SetParentFont(Value: Boolean);
var
    Invalidated: Boolean;
begin
    if FParentFont <> Value then
    begin
        FParentFont := Value;
        if FParentFont then
        begin
            if not AutoCreateFont then
                UpdateFont(nil)
            else if Assigned(FFont) then
                UpdateFont(FGrid.Font);

            Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
            if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
                FGrid.RedisplayControl(True);
        end
        else
            UpdateFont(FGrid.Font);
    end;
end;

procedure TtsCol.SetDisplayCol(Value: Longint);
var
    MaxCol: Longint;
    OldDisplayCol: Longint;
begin
    if FDisplayCol <> Value then
    begin
        if (Value < 1) or (Value > FGrid.Cols) then Exit;

        OldDisplayCol := FDisplayCol;

        FGrid.ChangeDisplayCol(FDisplayCol, Value);
        FGrid.MoveVisibleCol(OldDisplayCol, Value);
        FGrid.ChangeColWidths(OldDisplayCol, Value);
        FGrid.ChangeSelectedCols(OldDisplayCol, Value);
        FGrid.ChangeCurrentColPosition(OldDisplayCol, Value);
        FGrid.DoColMoved(Value, 1, False);

        MaxCol := FGrid.MaxVisibleCol;
        if (OldDisplayCol < FGrid.FixedCols) or
           ((OldDisplayCol >= FGrid.LeftCol) and (OldDisplayCol <= MaxCol)) or
           (Value < FGrid.FixedCols) or
           ((Value >= FGrid.LeftCol) and (Value <= MaxCol)) then
        begin
            FGrid.Invalidate;
        end;

        FGrid.UpdateScrollRange;
        FGrid.CheckTopLeft(False);
        FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetHeading(Value: string);
begin
    TextAccelKey(Value, FAccelKeyPos);
    FHeading := Value;
    FGrid.InvalidateCell(DisplayCol, 0);
end;

procedure TtsCol.SetControlType(Value: TtsControlType);
begin
    if FControlType <> Value then
    begin
        if (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.ClearCurrentFocusRect(False);

        FControlType := Value;
        FGrid.InvalidateCol(DisplayCol);

        if (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
            FGrid.ClearCurrentFocusRect(False);
        end;
        FGrid.CheckGridData(DataCol, -1);
    end;
end;

procedure TtsCol.CheckWidth(OldWidth: Integer);
begin
    if OldWidth <> FWidth then
    begin
        if Visible then
            FGrid.ResizeCol(DisplayCol, FWidth)
        else if FGrid.ColWidths[DisplayCol] <> 0 then
            FGrid.ResizeCol(DisplayCol, 0);

        FGrid.ColResized(DataCol);
        if (DisplayCol = 0) and (not FGrid.FInResizingRowBar) then
            FGrid.FOldRowBarWidth := FWidth;
    end;
end;

procedure TtsCol.CopyWidth(Value: Integer);
var
    OldWidth: Integer;
begin
    if FWidth <> Value then
    begin
        OldWidth := FWidth;
        FWidth := Value;
        CheckWidth(OldWidth);
        FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetWidth(Value: Integer);
begin
    FOldWidth := Value;
    CopyWidth(Value);
end;

procedure TtsCol.UpdateVisibleCols;
begin
    if DisplayCol <= 0 then Exit;
    if Visible
        then FGrid.FVisibleCols.Add(DisplayCol)
        else FGrid.FVisibleCols.Remove(DisplayCol);
end;

procedure TtsCol.SetVisible(Value: Boolean);
begin
    if FVisible <> Value then
    begin
        if (DisplayCol = FGrid.FCurDisplayCol) then
            if not FGrid.CheckEndEdit(0, FGrid.FCurDataRow, False) then Exit;

        FVisible := Value;
        if FVisible then
        begin
            UpdateVisibleCols;
            FGrid.ResizeCol(DisplayCol, Width);
            FGrid.CheckTopLeft(True);
            if FGrid.FCurDisplayCol = 0 then FGrid.MoveToNewCol(0, False, FGrid.CanSkipReadOnly, False);
        end
        else
        begin
            UpdateVisibleCols;
            FGrid.ResizeCol(DisplayCol, 0);
            if DisplayCol > 0 then
            begin
                if FGrid.FSelectedCols[DisplayCol] then
                    FGrid.DeleteColSelection(DisplayCol, DisplayCol);

                if DisplayCol = FGrid.FCurDisplayCol then
                    FGrid.MoveToNewCol(DisplayCol, False, FGrid.CanSkipReadOnly, False);

                if DisplayCol >= FGrid.LeftCol then
                begin
                    FGrid.EnablePaint := False;
                    try
                        FGrid.CheckTopLeft(True)
                    finally
                        FGrid.EnablePaint := True;
                    end;
                end;
            end;
            FGrid.CheckSelectedCellsCol(DisplayCol);
        end;

        FGrid.UpdateScrollRange;
        FGrid.RedisplayControl(True);
        FGrid.SelectionsChanged(False);
        FGrid.GridStatusChanged;
    end;
end;

procedure TtsCol.SetAllowGrayed(Value: Boolean);
begin
    if FAllowGrayed <> Value then
    begin
        FAllowGrayed := Value;
        FGrid.InvalidateCol(DisplayCol);
        if (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetReadOnly(Value: Boolean);
begin
    if FReadOnly <> Value then
    begin
        FReadOnly := Value;
        FGrid.InvalidateCol(DisplayCol);

        if (DisplayCol = FGrid.FCurDisplayCol) or (FGrid.FCurDisplayCol = 0) then
        begin
            FGrid.MoveToNewCol(FGrid.FCurDisplayCol, True, FGrid.CanSkipReadOnly, False);
        end;
    end;
end;

function TtsCol.GetSelected: Boolean;
begin
    Result := FGrid.FSelectedCols[DisplayCol];
end;

procedure TtsCol.SetSelected(Value: Boolean);
begin
    if FGrid.FSelectedCols[DisplayCol] <> Value then
    begin
        FGrid.SelectCols(DisplayCol, DisplayCol, Value);
    end;
end;

procedure TtsCol.SetIs3D(Value: Boolean);
begin
    if FIs3D <> Value then
    begin
        FIs3D := Value;
        FGrid.InvalidateCol(DisplayCol);

        if (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsCol.SetAlignment(Value: TAlignment);
var
    Invalidated: Boolean;
begin
    if FAlignment <> Value then
    begin
        FAlignment := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetAlign(Value: Boolean);
var
    Invalidated: Boolean;
begin
    if FAlign <> Value then
    begin
        FAlign := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetHorzAlignment(Value: TtsHorzAlignment);
var
    Invalidated: Boolean;
begin
    if FHorzAlignment <> Value then
    begin
        FHorzAlignment := Value;
        FAlignment := HorzAlignmentToAlignment(FHorzAlignment);
        FAlign := HorzAlignmentToAlign(FHorzAlignment);

        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetVertAlignment(Value: TtsVertAlignment);
var
    Invalidated: Boolean;
begin
    if FVertAlignment <> Value then
    begin
        FVertAlignment := Value;
        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetButtonType(Value: TtsButtonType);
begin
    if FGrid.FAsCombo then Exit;

    if (FButtonType <> Value) then
    begin
        FButtonType := Value;
        if (Value = btCombo) then FGrid.CheckComboCreated;
        FGrid.InvalidateCol(DisplayCol);
        if (FGrid.FCurDisplayCol = DisplayCol) then
        begin
            FGrid.RedisplayControl(True);
            if (FButtonType in [btDateTimeDropDown, btDateTimePopup]) then
                Grid.ResetDateTimeInit
        end;
    end;
end;

procedure TtsCol.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    if DropDownStyle <> Value then
    begin
        FDropDownStyle := Value;
        if Assigned(Combo) then Combo.DropDownStyle := Value;
        if (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

function TtsCol.GetDropDownStyle: TtsDropDownStyle;
begin
    if Assigned(FCombo)
        then Result := FCombo.DropDownStyle
        else Result := FDropDownStyle;
end;

procedure TtsCol.SetHeadingButton(Value: TtsColHeadingButton);
begin
    if FHeadingButton <> Value then
    begin
        FHeadingButton := Value;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingAlignment(Value: TAlignment);
begin
    if FHeadingAlignment <> Value then
    begin
        FHeadingAlignment := Value;
        FHeadingHorzAlignment := AlignmentToHorzAlignment(FHeadingAlignment, FHeadingAlign);
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingAlign(Value: Boolean);
begin
    if FHeadingAlign <> Value then
    begin
        FHeadingAlign := Value;
        FHeadingHorzAlignment := AlignmentToHorzAlignment(FHeadingAlignment, FHeadingAlign);
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingHorzAlignment(Value: TtsHorzAlignment);
begin
    if FHeadingHorzAlignment <> Value then
    begin
        FHeadingHorzAlignment := Value;
        FHeadingAlignment := HorzAlignmentToAlignment(FHeadingHorzAlignment);
        FHeadingAlign := HorzAlignmentToAlign(FHeadingHorzAlignment);
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingVertAlignment(Value: TtsVertAlignment);
begin
    if FHeadingVertAlignment <> Value then
    begin
        FHeadingVertAlignment := Value;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingWordWrap(Value: TtsWordWrap);
begin
    if FHeadingWordWrap <> Value then
    begin
        FHeadingWordWrap := Value;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingColor(Value: TColor);
begin
    if FHeadingColor <> Value then
    begin
        FHeadingColor := Value;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.CopyHeadingFont(Value: TFont);
begin
    if FHeadingFont <> Value then
    begin
        if Value = nil then
        begin
            FHeadingFont.Free;
            FHeadingFont := nil;
        end
        else
        begin
            if FHeadingFont = nil then FHeadingFont := TFont.Create;
            FHeadingFont.Assign(Value);
            FHeadingFont.OnChange := HeadingFontChange;
        end;
    end;
end;

procedure TtsCol.UpdateHeadingFont(Value: TFont);
begin
    ChangeFont := False;
    try
        CopyHeadingFont(Value);
    finally
        ChangeFont := True;
    end;
end;

procedure TtsCol.SetHeadingFont(Value: TFont);
begin
    if FHeadingFont <> Value then
    begin
        try
            CopyHeadingFont(Value);
        finally
            FHeadingParentFont := not Assigned(FHeadingFont);
        end;
        FGrid.CheckInvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetHeadingParentFont(Value: Boolean);
begin
    if FHeadingParentFont <> Value then
    begin
        FHeadingParentFont := Value;
        if FHeadingParentFont then
        begin
            if not AutoCreateFont then
                UpdateHeadingFont(nil)
            else if Assigned(FHeadingFont) then
                UpdateHeadingFont(FGrid.HeadingFont);

            FGrid.CheckInvalidateCell(DisplayCol, 0);
        end
        else
            UpdateHeadingFont(FGrid.HeadingFont);
    end;
end;

procedure TtsCol.SetSortPicture(Value: TtsSortPicture);
begin
    if FSortPicture <> Value then
    begin
        FSortPicture := Value;
        FGrid.InvalidateCell(DisplayCol, 0);
    end;
end;

procedure TtsCol.SetMaxLength(Value: Integer);
begin
    Value := CalcMax(0, Value);
    if FMaxLength <> Value then
    begin
        FMaxLength := Value;
        FGrid.SetMaxTextLength(DisplayCol, Value);
    end;
end;

procedure TtsCol.SetFieldName(Value: string);
begin
    FFieldName := Value;
end;

procedure TtsCol.SetWordWrap(Value: TtsWordWrap);
var
    Invalidated: Boolean;
begin
    if FWordWrap <> Value then
    begin
        FWordWrap := Value;
        Invalidated := FGrid.CheckInvalidateCol(DisplayCol);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsCol.SetMaskName(Value: string);
begin
    if FMaskName <> Value then
    begin
        FMaskName := Value;
        if DataCol = FGrid.FCurDataCol then FGrid.SetControlMask;
    end;
end;

procedure TtsCol.RemoveFonts;
begin
    if ParentFont and Assigned(FFont) then UpdateFont(nil);
    if HeadingParentFont and Assigned(FHeadingFont) then UpdateHeadingFont(nil);
end;

procedure TtsCol.SetAutoCreateFont(Value: Boolean);
begin
    if FAutoCreateFont <> Value then
    begin
        FAutoCreateFont := Value;
        if FAutoCreateFont then
            FGrid.FAutoFontCols.AddItem(DataCol)
        else
        begin
            FGrid.FAutoFontCols.Remove(DataCol);
            RemoveFonts;
        end;
    end;
end;

procedure TtsCol.CheckFont;
begin
    if ParentFont and Assigned(FFont) then UpdateFont(FGrid.Font);
end;

procedure TtsCol.CheckHeadingFont;
begin
    if HeadingParentFont and Assigned(FHeadingFont) then
        UpdateHeadingFont(FGrid.HeadingFont);
end;

procedure TtsCol.SetChangeFont(Value: Boolean);
begin
    if Value and (FChangeFont > 0) then
        Dec(FChangeFont)
    else if not Value then
        Inc(FChangeFont);
end;

function TtsCol.GetChangeFont: Boolean;
begin
    Result := (FChangeFont = 0);
end;

function TtsCol.StoreHeading: Boolean;
begin
    Result := FHeading <> '';
end;

function TtsCol.StoreDisplayCol: Boolean;
begin
    Result := (DisplayCol <> DataCol);
end;

procedure TtsCol.SetCombo(Value: TtsCombo);
begin
    if FGrid.FAsCombo then Exit;
    if FCombo <> Value then
    begin
        if Value = nil then
            ResetCombo
        else
        begin
            AssignCombo;
            FCombo.Assign(Value);
            if DisplayCol = Grid.CurDisplayCol
                then Grid.CheckResetComboInit(FCombo, False)
                else Grid.CheckLastUsedCombo(FCombo);

            if FGrid.InDesignMode and (DisplayCol = FGrid.CurDisplayCol) and
               (FCombo.DropDownStyle = ddDropDownList) then
            begin
                FGrid.CurrentCell.SelectAll;
                FGrid.RedisplayControl(True);
            end;
        end;
    end;
end;

function TtsCol.GetCombo: TtsCombo;
begin
    Result := FCombo;
end;

procedure TtsCol.SetParentCombo(Value: Boolean);
begin
    if FParentCombo <> Value then
    begin
        FParentCombo := Value;
        if FParentCombo then Combo := nil;
    end;
end;

function TtsCol.UseCheckBoxValues: Boolean;
begin
    Result := True;
end;

procedure TtsCol.SetCheckBoxValues(Value: string);
begin
    if FCheckBoxValues <> Value then
    begin
        if not CheckBoxValuesOk(Value) then
            FGrid.InvalidOp(Format(StsInvalidCheckBoxValues, [Value]));
        FCheckBoxValues := Value;
        if DataCol = FGrid.FCurDataCol then
        begin
            Grid.SetControlCheckBoxValues;
            Grid.InvalidateCol(DataCol);
        end;
    end;
end;

procedure TtsCol.ReadCombo(Stream: TStream);
begin
    if not Assigned(Combo)
        then AssignCombo
        else Combo.FGrid.Reset;
    Stream.ReadComponent(Combo.FGrid);
    Combo.FGrid.Name := '';
end;

procedure TtsCol.WriteCombo(Stream: TStream);
begin
    Stream.WriteComponent(Combo.FGrid);
end;

procedure TtsCol.ReadAlignment(Reader: TReader);
begin
    Alignment := TSGrid.ReadAlignment(Reader);
end;

procedure TtsCol.ReadAlign(Reader: TReader);
begin
    Align := Reader.ReadBoolean;
end;

procedure TtsCol.ReadHeadingAlignment(Reader: TReader);
begin
    HeadingAlignment := TSGrid.ReadAlignment(Reader);
end;

procedure TtsCol.ReadHeadingAlign(Reader: TReader);
begin
    HeadingAlign := Reader.ReadBoolean;
end;

procedure TtsCol.DefineProperties(Filer: TFiler);
begin
    inherited;
    with Filer do
    begin
        DefineProperty('Alignment', ReadAlignment, nil, False);
        DefineProperty('Align', ReadAlign, nil, False);
        DefineProperty('HeadingAlignment', ReadHeadingAlignment, nil, False);
        DefineProperty('HeadingAlign', ReadHeadingAlign, nil, False);
        DefineBinaryProperty('Combo', ReadCombo, WriteCombo, (FCombo <> nil) and (FButtonType = btCombo));
    end;
end;

{TtsRow}

constructor TtsRow.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
    Initialize;
end;

destructor TtsRow.Destroy;
begin
    FFont.Free;
    FCombo.Free;
    Grid.RemoveDateTime(FDateTimeDef);

    Grid.ResetComboInit(True);
    Grid.ResetDateTimeInit;

    inherited Destroy;
end;

procedure TtsRow.Initialize;
begin
    FColor := clNone;
    FFont := nil;
    FParentFont := True;
    FVisible := True;
    FAlignment := taLeftJustify;
    FAlign := False;
    FHorzAlignment := htaDefault;
    FVertAlignment := vtaDefault;
    FWordWrap := wwDefault;
    FReadOnly := False;
    FIs3D := False;
    FMaskName := '';
    FAutoCreateFont := False;
    FChangeFont := 0;
    FHeight := FGrid.DefaultRowHeight;
    FOldHeight := FHeight;
    FButtonType := btDefault;
    FDropDownStyle := ddDropDown;
    FCombo := nil;
    FParentCombo := True;
    FStretchPicture := dopDefault;
    FShrinkPicture := dopDefault;
    FCenterPicture := dopDefault;
    FKeepAspectRatio := dopDefault;
    FControlType := ctDefault;
    FSpinOptions := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    FSpinIncrement := 1;
    FDateTimeDef := nil;
end;

function TtsRow.DefaultProps: Boolean;
begin
    Result := (FColor = clNone) and
              (FFont = nil) and
              (FParentFont = True) and
              (FVisible = True) and
              (FAlignment = taLeftJustify) and
              (FAlign = False) and
              (FHorzAlignment = htaDefault) and
              (FVertAlignment = vtaDefault) and 
              (FWordWrap = wwDefault) and
              (FReadOnly = False) and
              (FIs3D = False) and
              (FMaskName = '') and
              (FAutoCreateFont = False) and
              (FHeight = FGrid.DefaultRowHeight) and
              (FOldHeight = FHeight) and
              (FButtonType = btDefault) and
              (FDropDownStyle = ddDropDown) and
              (FCombo = nil) and
              (FParentCombo = True) and
              (FStretchPicture = dopDefault) and
              (FShrinkPicture = dopDefault) and
              (FCenterPicture = dopDefault) and
              (FKeepAspectRatio = dopDefault) and
              (FControlType = ctDefault) and
              (FSpinOptions = [spoAutoRepeat, spoAutoIncrement, spoKeyEdit]) and
              (FSpinIncrement = 1) and
              (FDateTimeDef = nil);
end;

function TtsRow.Empty: Boolean;
begin
    Result := DefaultProps;
end;

function TtsRow.StoreSpinIncrement: Boolean;
begin
    Result := FSpinIncrement <> 1;
end;

function TtsRow.StoreDisplayRow: Boolean;
begin
    Result := (DisplayRow <> DataRow);
end;

procedure TtsRow.AssignProperties(Source: TtsRow);
begin
    FColor := Source.FColor;
    FAlignment := Source.FAlignment;
    FAlign := Source.FAlign;
    FHorzAlignment := Source.FHorzAlignment;
    FVertAlignment := Source.FVertAlignment;
    FWordWrap := Source.FWordWrap;
    FHeight :=  Source.FHeight;
    FOldHeight := Source.FHeight;
    FVisible := Source.FVisible;
    FReadOnly := Source.FReadOnly;
    FIs3D := Source.FIs3D;
    FMaskName := Source.FMaskName;
    FDropDownStyle := Source.FDropDownStyle;
    FControlType := Source.FControlType;
    FStretchPicture := Source.FStretchPicture;
    FShrinkPicture := Source.FShrinkPicture;
    FCenterPicture := Source.FCenterPicture;
    FKeepAspectRatio := Source.FKeepAspectRatio;
    FParentCombo := Source.FParentCombo;
    FSpinOptions := Source.FSpinOptions;
    FSpinIncrement := Source.FSpinIncrement;

    SetButtonType(Source.FButtonType);
    SetDateTimeDef(Source.DateTimeDef);
    SetCombo(Source.FCombo);

    FParentFont := Source.FParentFont;
    if not FParentFont then UpdateFont(Source.Font)
                       else CheckFont;
end;

procedure TtsRow.Copy(Source: TtsRow);
begin
    FGrid := Source.FGrid;
    AssignProperties(Source);
end;

procedure TtsRow.Assign(Source: TPersistent);
var
    OldHeight: Integer;
    Invalidated: Boolean;
begin
    if Source is TtsRow then
    begin
        OldHeight := FHeight;
        DisplayRow := TtsRow(Source).DisplayRow;
        AssignProperties(TtsRow(Source));
        CheckHeight(OldHeight);

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end
    else
        inherited;
end;

procedure TtsRow.AssignFont;
begin
    if FFont = nil then SetFont(FGrid.Font);
end;

procedure TtsRow.Reset(Properties: TtsProperties);
begin
    if prColor in Properties then Color := clNone;
    if prFont in Properties then ResetFont;
    if prIs3D in Properties then Is3D := False;
    if prVisible in Properties then Visible := True;
    if prChanged in Properties then Changed := False;
    if prHeight in Properties then CopyHeight(FOldHeight);
    if prDisplayNumber in Properties then DisplayRow := DataRow;
    if prAlign in Properties then Align := False;
    if prAlignment in Properties then Alignment := taLeftJustify;
    if prHorzAlignment in Properties then HorzAlignment := htaDefault;
    if prVertAlignment in Properties then VertAlignment := vtaDefault;
    if prReadOnly in Properties then ReadOnly := False;
    if prWordWrap in Properties then WordWrap := wwDefault;
    if prMask in Properties then MaskName := '';
    if prButtonType in Properties then ButtonType := btDefault;
    if prCombo in Properties then ResetCombo;
    if prParentCombo in Properties then ParentCombo := True;
    if prPicture in Properties then StretchPicture := dopDefault;
    if prPicture in Properties then ShrinkPicture := dopDefault;
    if prPicture in Properties then CenterPicture := dopDefault;
    if prPicture in Properties then KeepAspectRatio := dopDefault;
    if prSpinOptions in Properties then SpinOptions := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    if prSpinIncrement in Properties then SpinIncrement := 1;
    if prDateTime in Properties then DateTimeDef := nil;
    if prDropDownStyle in Properties then DropDownStyle := ddDropDown;
    //if prTag in Properties then Tag := 0;
    //if prData in Properties then Data := Nil;
end;

procedure TtsRow.ResetFont;
begin
    SetFont(nil);
end;

procedure TtsRow.FontChange;
var
    Invalidated: Boolean;
begin
    if ChangeFont then
    begin
        FParentFont := False;
        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
        end;

        FGrid.UpdateCellFonts;
    end;
end;

function TtsRow.GetDataRow: Longint;
begin
    Result := FDataRow;
end;

function TtsRow.GetFixed: Boolean;
begin
    Result := (DisplayRow <= FGrid.InternalFixedRows);
end;

procedure TtsRow.SetColor(Value: TColor);
var
    Invalidated: Boolean;
begin
    if FColor <> Value then
    begin
        FColor := Value;

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsRow.CopyFont(Value: TFont);
begin
    if FFont <> Value then
    begin
        if Value = nil then
        begin
            FFont.Free;
            FFont := nil;
        end
        else
        begin
            if FFont = nil then FFont := TFont.Create;
            FFont.Assign(Value);
            FFont.OnChange := FontChange;
        end;
    end;
end;

procedure TtsRow.UpdateFont(Value: TFont);
begin
    ChangeFont := False;
    try
        CopyFont(Value);
    finally
        ChangeFont := True;
    end;
end;

procedure TtsRow.SetFont(Value: TFont);
var
    Invalidated: Boolean;
begin
    if FFont <> Value then
    begin
        try
            CopyFont(Value);
        finally
            FParentFont := not Assigned(FFont);
        end;

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

function TtsRow.GetFont: TFont;
begin
    Result := FFont;
    if ParentFont and Grid.Writing then
        Result := nil
    else if not Assigned(FFont) and (Grid.Reading) then
    begin
        UpdateFont(FGrid.Font);
        Result := FFont;
    end
    else if not Assigned(Result) and AutoCreateFont then
    begin
        UpdateFont(FGrid.Font);
        Result := FFont;
    end
    else if Assigned(FFont) and ParentFont and
            (not AutoCreateFont) and (not Grid.Reading) then
    begin
        UpdateFont(nil);
        Result := FFont;
    end;
end;

procedure TtsRow.SetParentFont(Value: Boolean);
var
    Invalidated: Boolean;
begin
    if FParentFont <> Value then
    begin
        FParentFont := Value;
        if FParentFont then
        begin
            if not AutoCreateFont then
                UpdateFont(nil)
            else if Assigned(FFont) then
                UpdateFont(FGrid.Font);

            Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
            if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
                FGrid.RedisplayControl(True);
        end
        else
            UpdateFont(FGrid.Font);
    end;
end;

procedure TtsRow.SetDisplayRow(Value: Longint);
begin
    FGrid.SetDisplayRownr(FDataRow, Value);
end;

function TtsRow.GetDisplayRow: Longint;
begin
    Result := FGrid.GridRows.DisplayRowNumber[FDataRow];
end;

function TtsRow.GetId: Longint;
begin
    Result := FGrid.GridRows.RowId[FDataRow];
end;

procedure TtsRow.CheckHeight(OldHeight: Integer);
begin
    if OldHeight <> FHeight then
    begin
        if Visible then
            FGrid.ResizeRow(DisplayRow, FHeight)
        else if FGrid.RowHeights[DisplayRow] <> 0 then
            FGrid.ResizeRow(DisplayRow, 0);

        FGrid.RowResized(DataRow);
        if (DataRow = 0) and not FGrid.FInResizingHeading then
            FGrid.FOldHeadingHeight := FHeight;
    end;
end;

procedure TtsRow.CopyHeight(Value: Integer);
var
    OldHeight: Integer;
begin
    if FHeight <> Value then
    begin
        OldHeight := FHeight;
        FHeight := Value;
        CheckHeight(OldHeight);
        FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.SetHeight(Value: Integer);
begin
    FOldHeight := Value;
    CopyHeight(Value);
end;

procedure TtsRow.UpdateVisibleRows;
begin
    if DisplayRow <= 0 then Exit;
    if Visible
        then FGrid.FVisibleRows.Add(DisplayRow)
        else FGrid.FVisibleRows.Remove(DisplayRow);
end;

procedure TtsRow.SetVisible(Value: Boolean);
begin
    if FVisible <> Value then
    begin
        if FGrid.IsInsertRow(DisplayRow) then Exit;
        if DisplayRow = FGrid.FCurDisplayRow then
            if not FGrid.CheckEndEdit(FGrid.FCurDataCol, 0, False) then Exit;

        FVisible := Value;
        if FVisible then
        begin
            UpdateVisibleRows;
            FGrid.ResizeRow(DisplayRow, Height);
            FGrid.CheckTopLeft(True);
            if FGrid.FCurDisplayRow = 0 then
                FGrid.MoveToNewRow(0, False, FGrid.CanSkipReadOnly, FGrid.InRowSelectMode);
        end
        else
        begin
            UpdateVisibleRows;
            FGrid.ResizeRow(DisplayRow, 0);
            if DisplayRow > 0 then
            begin
                if FGrid.FSelectedRows[DisplayRow] then
                    FGrid.DeleteRowSelection(DisplayRow, DisplayRow);

                FGrid.EnablePaint := False;
                try
                    if DisplayRow = FGrid.FCurDisplayRow then
                        FGrid.MoveToNewRow(DisplayRow, False, FGrid.CanSkipReadOnly, FGrid.InRowSelectMode);

                    if DisplayRow >= FGrid.TopRow then
                    begin
                        FGrid.CheckTopLeft(True)
                    end;
                finally
                    FGrid.EnablePaint := True;
                end;
            end;
            FGrid.CheckSelectedCellsRow(DisplayRow);
        end;

        FGrid.UpdateScrollRange;
        FGrid.RedisplayControl(True);
        FGrid.CheckRowSelection(False);
        FGrid.SelectionsChanged(False);
        FGrid.GridStatusChanged;
    end;
end;

procedure TtsRow.SetAlignment(Value: TAlignment);
var
    Invalidated: Boolean;
begin
    if FAlignment <> Value then
    begin
        FAlignment := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.SetAlign(Value: Boolean);
var
    Invalidated: Boolean;
begin
    if FAlign <> Value then
    begin
        FAlign := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.SetHorzAlignment(Value: TtsHorzAlignment);
var
    Invalidated: Boolean;
begin
    if FHorzAlignment <> Value then
    begin
        FHorzAlignment := Value;
        FAlignment := HorzAlignmentToAlignment(FHorzAlignment);
        FAlign := HorzAlignmentToAlign(FHorzAlignment);

        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.SetVertAlignment(Value: TtsVertAlignment);
var
    Invalidated: Boolean;
begin
    if FVertAlignment <> Value then
    begin
        FVertAlignment := Value;
        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

function TtsRow.GetSelected: Boolean;
begin
    Result := FGrid.FSelectedRows[DisplayRow];
end;

procedure TtsRow.SetSelected(Value: Boolean);
begin
    if FGrid.FSelectedRows[DisplayRow] <> Value then
    begin
        FGrid.SelectRows(DisplayRow, DisplayRow, Value);
    end;
end;

procedure TtsRow.SetReadOnly(Value: Boolean);
begin
    if FReadOnly <> Value then
    begin
        FReadOnly := Value;
        FGrid.InvalidateRow(DisplayRow);

        if (DisplayRow = FGrid.FCurDisplayRow) or (FGrid.FCurDisplayRow = 0) then
        begin
            FGrid.MoveToNewRow(FGrid.FCurDisplayRow, True, FGrid.CanSkipReadOnly, False);
        end;
    end;
end;

procedure TtsRow.SetIs3D(Value: Boolean);
begin
    if FIs3D <> Value then
    begin
        FIs3D := Value;
        FGrid.InvalidateRow(DisplayRow);
        if (FGrid.FCurDisplayRow = DisplayRow) then FGrid.RedisplayControl(True);
    end;
end;

function TtsRow.GetChanged: Boolean;
begin
    Result := FGrid.GetRowChanged(FDataRow);
end;

procedure TtsRow.SetChanged(Value: Boolean);
begin
    FGrid.SetRowChanged(FDataRow, Value);
end;

procedure TtsRow.SetWordWrap(Value: TtsWordWrap);
var
    Invalidated: Boolean;
begin
    if FWordWrap <> Value then
    begin
        FWordWrap := Value;
        Invalidated := FGrid.CheckInvalidateRow(DisplayRow);
        if Invalidated and (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.SetMaskName(Value: string);
begin
    if FMaskName <> Value then
    begin
        FMaskName := Value;
        if DataRow = FGrid.FCurDataRow then FGrid.SetControlMask;
    end;
end;

procedure TtsRow.SetStretchPicture(Value: TtsDrawOption);
begin
    if (FStretchPicture <> Value) then
    begin
        FStretchPicture := Value;
        FGrid.CheckInvalidateRow(DisplayRow);
    end;
end;

procedure TtsRow.SetShrinkPicture(Value: TtsDrawOption);
begin
    if (FShrinkPicture <> Value) then
    begin
        FShrinkPicture := Value;
        FGrid.CheckInvalidateRow(DisplayRow);
    end;
end;

procedure TtsRow.SetCenterPicture(Value: TtsDrawOption);
begin
    if (FCenterPicture <> Value) then
    begin
        FCenterPicture := Value;
        FGrid.CheckInvalidateRow(DisplayRow);
    end;
end;

procedure TtsRow.SetKeepAspectRatio(Value: TtsDrawOption);
begin
    if (FKeepAspectRatio <> Value) then
    begin
        FKeepAspectRatio := Value;
        FGrid.CheckInvalidateRow(DisplayRow);
    end;
end;

procedure TtsRow.SetControlType(Value: TtsControlType);
begin
    if FControlType <> Value then
    begin
        if (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.ClearCurrentFocusRect(False);
        FControlType := Value;
        FGrid.InvalidateRow(DisplayRow);
        if (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
            FGrid.DrawCurrentFocusRect(False);
        end;
        FGrid.CheckGridData(-1, DataRow);
    end;
end;

procedure TtsRow.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    if Value <> FDateTimeDef then
    begin
        if DisplayRow = Grid.CurDisplayRow
            then Grid.ResetDateTimeInit
            else Grid.CheckLastUsedDateTime(FDateTimeDef);

        Grid.RemoveDateTime(FDateTimeDef);
        FDateTimeDef := Value;
        Grid.AddDateTime(FDateTimeDef);
    end;
end;

procedure TtsRow.RemoveFonts;
begin
    if ParentFont and Assigned(FFont) then UpdateFont(nil);
end;

procedure TtsRow.SetAutoCreateFont(Value: Boolean);
begin
    if FAutoCreateFont <> Value then
    begin
        FAutoCreateFont := Value;
        if FAutoCreateFont then
            FGrid.FAutoFontRows.AddItem(DataRow)
        else
        begin
            FGrid.FAutoFontRows.Remove(DataRow);
            RemoveFonts;
        end;
    end;
end;

procedure TtsRow.SetChangeFont(Value: Boolean);
begin
    if Value and (FChangeFont > 0) then
        Dec(FChangeFont)
    else if not Value then
        Inc(FChangeFont);
end;

function TtsRow.GetChangeFont: Boolean;
begin
    Result := (FChangeFont = 0);
end;

procedure TtsRow.CheckFont;
begin
    if ParentFont and Assigned(FFont) then UpdateFont(FGrid.Font);
end;

procedure TtsRow.AssignCombo;
begin
    if not Assigned(FCombo) then
    begin
        FCombo := Grid.CreateCombo;
        FParentCombo := False;
        Combo.DropDownStyle := FDropDownStyle;
        if (Grid.CurDisplayRow = DisplayRow) then
        begin
            Grid.RedisplayControl(True);
            Grid.ResetComboInit(False);
        end;
    end;
end;

procedure TtsRow.ResetCombo;
begin
    if Assigned(FCombo) then
    begin
        if (Grid.CurDisplayRow = DisplayRow) then
        begin
            Grid.RedisplayControl(True);
            Grid.CheckResetComboInit(FCombo, True);
        end
        else
            Grid.CheckLastUsedCombo(FCombo);

        FCombo.Free;
        FCombo := nil;
    end;
end;

function TtsRow.GetCombo: TtsCombo;
begin
    Result := FCombo;
end;

procedure TtsRow.SetCombo(Value: TtsCombo);
begin
    if FGrid.FAsCombo then Exit;
    if FCombo <> Value then
    begin
        if Value = nil then
            ResetCombo
        else
        begin
            AssignCombo;
            FCombo.Assign(Value);
            if DisplayRow = Grid.CurDisplayRow
                then Grid.CheckResetComboInit(FCombo, False)
                else Grid.CheckLastUsedCombo(FCombo);

            if FGrid.InDesignMode and (DisplayRow = FGrid.CurDisplayRow) and
               (FCombo.DropDownStyle = ddDropDownList) then
            begin
                FGrid.CurrentCell.SelectAll;
                FGrid.RedisplayControl(True);
            end;
        end;
    end;
end;

procedure TtsRow.SetParentCombo(Value: Boolean);
begin
    if FParentCombo <> Value then
    begin
        FParentCombo := Value;
        if FParentCombo then Combo := nil;
    end;
end;

procedure TtsRow.SetButtonType(Value: TtsButtonType);
begin
    if FGrid.FAsCombo then Exit;

    if (FButtonType <> Value) then
    begin
        FButtonType := Value;
        if (Value = btCombo) then FGrid.CheckComboCreated;
        FGrid.InvalidateRow(DisplayRow);
        if (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
            if (FButtonType in [btDateTimeDropDown, btDateTimePopup]) then
                Grid.ResetDateTimeInit;
        end;
    end;
end;

function TtsRow.GetDropDownStyle: TtsDropDownStyle;
begin
    if Assigned(FCombo)
        then Result := FCombo.DropDownStyle
        else Result := FDropDownStyle;
end;

procedure TtsRow.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    if DropDownStyle <> Value then
    begin
        FDropDownStyle := Value;
        if Assigned(Combo) then Combo.DropDownStyle := Value;
        if (FGrid.FCurDisplayRow = DisplayRow) then
            FGrid.RedisplayControl(True);
    end;
end;

procedure TtsRow.ReadCombo(Stream: TStream);
begin
    if not Assigned(Combo)
        then AssignCombo
        else Combo.FGrid.Reset;
    Stream.ReadComponent(Combo.FGrid);
    Combo.FGrid.Name := '';
end;

procedure TtsRow.WriteCombo(Stream: TStream);
begin
    Stream.WriteComponent(Combo.FGrid);
end;

procedure TtsRow.ReadAlignment(Reader: TReader);
begin
    Alignment := TSGrid.ReadAlignment(Reader);
end;

procedure TtsRow.ReadAlign(Reader: TReader);
begin
    Align := Reader.ReadBoolean;
end;

procedure TtsRow.DefineProperties(Filer: TFiler);
begin
    inherited;
    with Filer do
    begin
        DefineProperty('Alignment', ReadAlignment, nil, False);
        DefineProperty('Align', ReadAlign, nil, False);
        DefineBinaryProperty('Combo', ReadCombo, WriteCombo, (FCombo <> nil) and (FButtonType = btCombo));
    end;
end;

{TtsDesignRow}

constructor TtsDesignRow.Create(Grid: TtsBaseGrid; DataRow: Variant);
begin
    inherited Create;
    FGrid := Grid;
    FDataRow := DataRow;
end;

procedure TtsDesignRow.Assign(Source: TPersistent);
var
    SourceRow: TtsDesignRow;
begin
    if Self.ClassType = Source.ClassType then
    begin
        SourceRow := TtsDesignRow(Source);
        if (Grid.GridRows[DataRow] <> nil) or
           (SourceRow.Grid.GridRows[SourceRow.DataRow] <> nil) then
        begin
            if SourceRow.Grid.GridRows[SourceRow.DataRow] = nil then
            begin
                Grid.GridRows[DataRow].Reset(tsAllProperties);
                Grid.GridRows.CheckRemoveDataRow(DataRow);
            end
            else
            begin
                Grid.GridRows.CreateDataRow(DataRow);
                Grid.GridRows[DataRow].Assign(SourceRow.Grid.GridRows[SourceRow.DataRow]);
            end;
        end;
    end;
end;

function TtsDesignRow.GetAlign: Boolean;
begin
    Result := Grid.RowAlign[DataRow];
end;

procedure TtsDesignRow.SetAlign(Value: Boolean);
begin
    Grid.RowAlign[DataRow] := Value;
end;

function TtsDesignRow.GetAlignment: TAlignment;
begin
    Result := Grid.RowAlignment[DataRow];
end;

procedure TtsDesignRow.SetAlignment(Value: TAlignment );
begin
    Grid.RowAlignment[DataRow] := Value;
end;

function TtsDesignRow.GetHorzAlignment: TtsHorzAlignment;
begin
    Result := Grid.RowHorzAlignment[DataRow];
end;

procedure TtsDesignRow.SetHorzAlignment(Value: TtsHorzAlignment );
begin
    Grid.RowHorzAlignment[DataRow] := Value;
end;

function TtsDesignRow.GetVertAlignment: TtsVertAlignment;
begin
    Result := Grid.RowVertAlignment[DataRow];
end;

procedure TtsDesignRow.SetVertAlignment(Value: TtsVertAlignment );
begin
    Grid.RowVertAlignment[DataRow] := Value;
end;

function TtsDesignRow.GetChanged: Boolean;
begin
    Result := Grid.RowChanged[DataRow];
end;

procedure TtsDesignRow.SetChanged(Value: Boolean);
begin
    Grid.RowChanged[DataRow] := Value;
end;

function TtsDesignRow.GetColor: TColor;
begin
    Result := Grid.RowColor[DataRow];
end;

procedure TtsDesignRow.SetColor(Value: TColor);
begin
    Grid.RowColor[DataRow] := Value;
end;

function TtsDesignRow.GetDisplayRow: Longint;
begin
    Result := Grid.DisplayRownr[DataRow];
end;

procedure TtsDesignRow.SetDisplayRow(Value: Longint);
begin
    Grid.DisplayRownr[DataRow] := Value;
end;

function TtsDesignRow.GetFont: TFont;
begin
    Result := Grid.RowFont[DataRow];
end;

procedure TtsDesignRow.SetFont(Value: TFont);
begin
    Grid.RowFont[DataRow] := Value;
end;

function TtsDesignRow.GetCombo: TtsCombo;
begin
    Result := Grid.RowCombo[DataRow];
end;

procedure TtsDesignRow.SetCombo(Value: TtsCombo);
begin
    Grid.RowCombo[DataRow] := Value;
end;

procedure TtsDesignRow.AssignCombo;
begin
    Grid.AssignRowCombo(DataRow);
end;

function TtsDesignRow.GetParentCombo: Boolean;
begin
    Result := Grid.RowParentCombo[DataRow];
end;

procedure TtsDesignRow.SetParentCombo(Value: Boolean);
begin
    Grid.RowParentCombo[DataRow] := Value;
end;

function TtsDesignRow.GetHeight: Integer;
begin
    Result := Grid.RowHeight[DataRow];
end;

procedure TtsDesignRow.SetHeight(Value: Integer);
begin
    Grid.RowHeight[DataRow] := Value;
end;

function TtsDesignRow.GetIs3D: Boolean;
begin
    Result := Grid.RowIs3D[DataRow];
end;

procedure TtsDesignRow.SetIs3D(Value: Boolean);
begin
    Grid.RowIs3D[DataRow] := Value;
end;

function TtsDesignRow.GetMaskName: string;
begin
    Result := Grid.RowMaskName[DataRow];
end;

procedure TtsDesignRow.SetMaskName(Value: string);
begin
    Grid.RowMaskName[DataRow] := Value;
end;

function TtsDesignRow.GetParentFont: Boolean;
begin
    Result := Grid.RowParentFont[DataRow];
end;

procedure TtsDesignRow.SetParentFont(Value: Boolean);
begin
    Grid.RowParentFont[DataRow] := Value;
end;

function TtsDesignRow.GetReadOnly: Boolean;
begin
    Result := Grid.RowReadOnly[DataRow];
end;

procedure TtsDesignRow.SetReadOnly(Value: Boolean);
begin
    Grid.RowReadOnly[DataRow] := Value;
end;

function TtsDesignRow.GetSelected: Boolean;
begin
    Result := Grid.RowSelected[DataRow];
end;

procedure TtsDesignRow.SetSelected(Value: Boolean);
begin
    Grid.RowSelected[DataRow] := Value;
end;

function TtsDesignRow.GetVisible: Boolean;
begin
    Result := Grid.RowVisible[DataRow];
end;

procedure TtsDesignRow.SetVisible(Value: Boolean);
begin
    Grid.RowVisible[DataRow] := Value;
end;

function TtsDesignRow.GetWordWrap: TtsWordWrap;
begin
    Result := Grid.RowWordWrap[DataRow];
end;

procedure TtsDesignRow.SetWordWrap(Value: TtsWordWrap);
begin
    Grid.RowWordWrap[DataRow] := Value;
end;

function TtsDesignRow.GetButtonType: TtsButtonType;
begin
    Result := Grid.RowButtonType[DataRow];
end;

procedure TtsDesignRow.SetButtonType(Value: TtsButtonType);
begin
    Grid.RowButtonType[DataRow] := Value;
end;

function  TtsDesignRow.GetAutoCreateFont: Boolean;
begin
    Result := Grid.RowAutoCreateFont[DataRow];
end;

procedure TtsDesignRow.SetAutoCreateFont(Value: Boolean);
begin
    Grid.RowAutoCreateFont[DataRow] := Value;
end;

function TtsDesignRow.GetId: Longint;
begin
    Result := Grid.RowId[DataRow];
end;

function TtsDesignRow.GetStretchPicture: TtsDrawOption;
begin
    Result := Grid.RowStretchPicture[DataRow];
end;

procedure TtsDesignRow.SetStretchPicture(Value: TtsDrawOption);
begin
    Grid.RowStretchPicture[DataRow] := Value;
end;

function TtsDesignRow.GetShrinkPicture: TtsDrawOption;
begin
    Result := Grid.RowShrinkPicture[DataRow];
end;

procedure TtsDesignRow.SetShrinkPicture(Value: TtsDrawOption);
begin
    Grid.RowShrinkPicture[DataRow] := Value;
end;

function TtsDesignRow.GetCenterPicture: TtsDrawOption;
begin
    Result := Grid.RowCenterPicture[DataRow];
end;

procedure TtsDesignRow.SetCenterPicture(Value: TtsDrawOption);
begin
    Grid.RowCenterPicture[DataRow] := Value;
end;

function TtsDesignRow.GetKeepAspectRatio: TtsDrawOption;
begin
    Result := Grid.RowKeepAspectRatio[DataRow];
end;

procedure TtsDesignRow.SetKeepAspectRatio(Value: TtsDrawOption);
begin
    Grid.RowKeepAspectRatio[DataRow] := Value;
end;

function TtsDesignRow.GetControlType: TtsControlType;
begin
    Result := Grid.RowControlType[DataRow];
end;

procedure TtsDesignRow.SetControlType(Value: TtsControlType);
begin
    Grid.RowControlType[DataRow] := Value;
end;

function TtsDesignRow.GetSpinOptions: TtsSpinOptions;
begin
    Result := Grid.RowSpinOptions[DataRow];
end;

procedure TtsDesignRow.SetSpinOptions(Value: TtsSpinOptions);
begin
    Grid.RowSpinOptions[DataRow] := Value;
end;

function  TtsDesignRow.GetSpinIncrement: Double;
begin
    Result := Grid.RowSpinIncrement[DataRow];
end;

procedure TtsDesignRow.SetSpinIncrement(Value: Double);
begin
    Grid.RowSpinIncrement[DataRow] := Value;
end;

function TtsDesignRow.GetDateTimeDef: TtsDateTimeDefComponent;
begin
    Result := Grid.RowDateTimeDef[DataRow];
end;

procedure TtsDesignRow.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    Grid.RowDateTimeDef[DataRow] := Value;
end;

function TtsDesignRow.GetDropDownStyle: TtsDropDownStyle;
begin
    Result := Grid.RowDropDownStyle[DataRow];
end;

procedure TtsDesignRow.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    Grid.RowDropDownStyle[DataRow] := Value;
end;

function TtsDesignRow.StoreSpinIncrement: Boolean;
begin
    Result := SpinIncrement <> 1;
end;

function TtsDesignRow.StoreDisplayRow: Boolean;
begin
    Result := True;
end;

function TtsDesignRow.StoreHeight: Boolean;
begin
    Result := True;
end;

procedure TtsDesignRow.ReadCombo(Stream: TStream);
begin
    if not Assigned(Combo)
        then AssignCombo
        else Combo.FGrid.Reset;
    Stream.ReadComponent(Combo.FGrid);
    Combo.FGrid.Name := '';
end;

procedure TtsDesignRow.WriteCombo(Stream: TStream);
begin
    Stream.WriteComponent(Combo.FGrid);
end;

procedure TtsDesignRow.DefineProperties(Filer: TFiler);
var
    StoreCombo: Boolean;
begin
    inherited;
    with Filer do
    begin
        StoreCombo := (Combo <> nil) and (ButtonType = btCombo);
        DefineBinaryProperty('Combo', ReadCombo, WriteCombo, StoreCombo);
    end;
end;

{TtsVisibleItems}

constructor TtsVisibleItems.Create;
begin
    inherited;
    FItemCount := 0;
    FItemsCreated := False;
end;

destructor TtsVisibleItems.Destroy;
begin
    inherited;
end;

procedure TtsVisibleItems.Assign(Source: TtsSortIntList);
begin
    if Source is TtsVisibleItems then
    begin
        inherited;
        FItemCount := TtsVisibleItems(Source).FItemCount;
        FItemsCreated := TtsVisibleItems(Source).FItemsCreated;
    end;
end;

procedure TtsVisibleItems.CheckSize(NewSize: Longint; StartValue: Longint);
var
    I: Longint;
begin
    CheckCapacity(NewSize);
    if NewSize > FCount then
    begin
        for I := FCount + 1 to NewSize do
        begin
            FItems[I] := StartValue;
            Inc(StartValue);
        end;
    end;

    FCount := NewSize;
    FItemsCreated := True;
end;

procedure TtsVisibleItems.SetSize(NewSize: Longint; StartValue: Longint);
begin
    if NewSize <> Count then
    begin
        FItemCount := NewSize;
        if FItemsCreated then CheckSize(NewSize, StartValue);
    end;
end;

procedure TtsVisibleItems.MoveItem(OldValue, NewValue: Longint);
var
    I: Longint;
    PosOld, PosNew: Longint;
    OldFound, NewFound: Boolean;
begin
    if not FItemsCreated then Exit;
    if OldValue = NewValue then Exit;

    PosOld := Locate(OldValue, OldFound);
    PosNew := Locate(NewValue, NewFound);

    if OldValue < NewValue then
    begin
        I := PosOld;
        if OldFound then Inc(I);
        while I <= Count do
        begin
            if Item[I] > NewValue then Break;
            if Item[I] >= OldValue then FItems[I] := FItems[I] - 1;
            Inc(I);
        end;

        if OldFound then
        begin
            if (PosOld < Count) and (I - (PosOld + 1) > 0) then
                MoveMemory(@FItems[PosOld], @FItems[PosOld + 1], (I - (PosOld + 1)) * SizeOf(Longint));
            FItems[I-1] := NewValue;
        end;
    end
    else if OldValue > NewValue then
    begin
        I := PosOld;
        if OldFound then Dec(I);
        while I >= 1 do
        begin
            if Item[I] < NewValue then Break;
            if Item[I] <= OldValue then FItems[I] := FItems[I] + 1;
            Dec(I);
        end;

        if OldFound then
        begin
            if (PosNew < Count) and (PosOld - I - 1 > 0) then
                MoveMemory(@FItems[I + 2], @FItems[I + 1], (PosOld - I - 1) * SizeOf(Longint));
            FItems[I+1] := NewValue;
        end;
    end;
end;

function TtsVisibleItems.Locate(Value: Longint; var Found: Boolean): Longint;
begin
    if (Value <= Count) and (Item[Value] = Value) then
    begin
        Result := Value;
        Found := True;
    end
    else if not FItemsCreated then
    begin
        Found := False;
        if Value <= 0 then Result := 1
                      else Result := Count + 1;
    end
    else
        Result := inherited Locate(Value, Found);
end;

procedure TtsVisibleItems.Add(Value: Longint);
begin
    if not FItemsCreated then Exit;
    inherited Add(Value);
    FItemCount := inherited Count;
end;

procedure TtsVisibleItems.Remove(Value: Longint);
begin
    if not FItemsCreated then CheckSize(Count, 1);
    inherited Remove(Value);
    FItemCount := inherited Count;
end;

function TtsVisibleItems.GetItem(Index: Longint): Longint;
begin
    if not FItemsCreated then Result := Index
                         else Result := inherited GetItem(Index);
end;

{TtsGridCols}

constructor TtsGridCols.Create(Size: Longint; Grid: TtsBaseGrid);
begin
    FCols := nil;
    FGrid := Grid;
    FSize := Size;
    FMaxID := 0;
    CreateDefaultValues(0, Size);
end;

destructor TtsGridCols.Destroy;
begin
    FreeColProperties(0, FSize);
    ReAllocMem(FCols, 0);
end;

procedure TtsGridCols.FreeColProperties(FromIndex, ToIndex: Longint);
var
    I: Integer;
begin
    for I := FromIndex to (ToIndex - 1) do
    begin
        FCols[I].Free;
        FCols[I] := nil;
    end;
end;

procedure TtsGridCols.CreateDefaultValues(OldSize, NewSize: Longint);
var
    I: Integer;
begin
    if OldSize = NewSize then Exit;

    if OldSize >= NewSize then
    begin
        FreeColProperties(NewSize, OldSize);
    end;

    ReAllocMem(FCols, NewSize * SizeOf(TtsCol));

    if OldSize < NewSize then
    begin
        for I := OldSize to (NewSize - 1) do
        begin
            FCols[I] := CreateCol;
            FCols[I].FDisplayCol := I;
            FCols[I].FWidth := FGrid.ColWidths[I];
            FCols[I].FOldWidth := FGrid.ColWidths[I];

            FCols[I].FId := FMaxId;
            Inc(FMaxId);
        end;
    end;
end;

procedure TtsGridCols.CntMoveProperties(FromIndex, ToIndex, Count: Longint);
var
    I: Longint;
    StartIndex: Longint;
begin
    if Count = 0 then Exit;
    if FromIndex = ToIndex then Exit;

    if FromIndex < ToIndex then
    begin
        MoveMemory(@FCols[ToIndex], @FCols[FromIndex], Count * SizeOf(TtsCol));
        for I := FromIndex to ToIndex - 1 do
        begin
            if I - FromIndex >= Count then Break;
            FCols[I] := nil;
        end;
    end
    else // Move Col from pos 3 to pos 1 (down)
    begin
        MoveMemory(@FCols[ToIndex], @FCols[FromIndex], Count * SizeOf(TtsCol));
        StartIndex := CalcMax(ToIndex + Count, FromIndex);
        for I := StartIndex to FromIndex  + Count - 1 do
        begin
            if I > FSize - 1 then Break;
            FCols[I] := nil;
        end;
    end;
end;

function TtsGridCols.CreateCol: TtsCol;
begin
    Result := TtsCol.Create(Grid);
end;

function TtsGridCols.FindCol(FieldName: string): TtsCol;
var
    DataCol: Longint;
begin
    Result := nil;
    DataCol := 0;
    while DataCol < Size - 1 do
    begin
        Inc(DataCol);
        if AnsiCompareText(FieldName, Col[DataCol].FieldName) = 0 then
        begin
            Result := Col[DataCol];
            Break;
        end;
    end;
end;

function TtsGridCols.GetCol(DataCol: Variant): TtsCol;
var
    Index: Longint;
begin
    Result := nil;
    case VarType(DataCol) of
        varString:
            Result := FindCol(DataCol);
    else
        if Grid.CheckIndex(itCol, DataCol, 0, FSize) then
        begin
          Index := DataCol;
          Result := FCols[Index];
        end;    
    end;
end;

procedure TtsGridCols.Resize(OldSize: Longint);
begin
    FSize := FGrid.ColCount;
    CreateDefaultValues(OldSize, FSize);
end;

{End TtsGridCols}

{TtsGridRows}

constructor TtsGridRows.Create(Size: Longint; Grid: TtsBaseGrid);
begin
    FRows := nil;
    FDisplayRowNumber := nil;
    FRowId := nil;

    FGrid := Grid;
    FSize := Size;
    FMaxId := 0;
    CreateDefaultValues(0, Size);
end;

destructor TtsGridRows.Destroy;
begin
    FreeRowProperties(0, FSize);
    ReAllocMem(FRows, 0);
    ReAllocMem(FDisplayRowNumber, 0);
    ReAllocMem(FRowId, 0);
end;

procedure TtsGridRows.FreeRowProperties(FromIndex, ToIndex: Longint);
var
    I: Integer;
begin
    for I := FromIndex to (ToIndex - 1) do
    begin
        FRows[I].Free;
        FRows[I] := nil;
    end;
end;

procedure TtsGridRows.CreateDefaultValues(OldSize, NewSize: Longint);
var
    I: Integer;
begin
    if OldSize = NewSize then Exit;

    if OldSize > NewSize then
    begin
        FreeRowProperties(NewSize, OldSize);
    end;

    ReAllocMem(FRows, FGrid.RowCount * SizeOf(TtsRow));
    ReAllocMem(FRowId, FGrid.RowCount * SizeOf(Longint));

    if Assigned(FDisplayRowNumber) then
        ReAllocMem(FDisplayRowNumber, FGrid.RowCount * SizeOf(Longint));

    if OldSize < NewSize then
    begin
        for I := OldSize to (NewSize - 1) do
        begin
            FRows[I] := nil;
            if I = 0 then CreateDataRow(I);

            DisplayRowNumber[I]:= I;
            FRowId[I] := FMaxId;
            Inc(FMaxId);
        end;
    end;
end;

procedure TtsGridRows.CreateDisplayRowNumber;
var
    I: Integer;
begin
    if Assigned(FDisplayRowNumber) then Exit;

    ReAllocMem(FDisplayRowNumber, FGrid.RowCount * SizeOf(Longint));
    for I := 0 to FGrid.RowCount - 1 do
    begin
        FDisplayRowNumber[I]:= I;
    end;
end;

procedure TtsGridRows.CntMoveProperties(FromIndex, ToIndex, Count: Longint);
var
    I: Longint;
    StartIndex: Longint;
begin
    if FromIndex = ToIndex then Exit;

    if FromIndex < ToIndex then
    begin
        MoveMemory(@FRows[ToIndex], @FRows[FromIndex], Count * SizeOf(TtsRow));
        MoveMemory(@FRowId[ToIndex], @FRowId[FromIndex], Count * SizeOf(Longint));
        if Assigned(FDisplayRowNumber) then
            MoveMemory(@FDisplayRowNumber[ToIndex], @FDisplayRowNumber[FromIndex], Count * Sizeof(Longint));

        for I := FromIndex to ToIndex - 1 do
        begin
            if I - FromIndex >= Count then Break;
            FRows[I] := nil;
        end;
    end
    else
    begin
        MoveMemory(@FRows[ToIndex], @FRows[FromIndex], Count * SizeOf(TtsRow));
        MoveMemory(@FRowId[ToIndex], @FRowId[FromIndex], Count * SizeOf(Longint));
        if Assigned(FDisplayRowNumber) then
            MoveMemory(@FDisplayRowNumber[ToIndex], @FDisplayRowNumber[FromIndex], Count * Sizeof(Longint));

        StartIndex := CalcMax(ToIndex + Count, FromIndex);
        for I := StartIndex to FromIndex  + Count - 1 do
        begin
            if I > FSize - 1 then Break;
            FRows[I] := nil;
        end;
    end;
end;

function TtsGridRows.GetRow(DataRow: Longint): TtsRow;
begin
    Result := nil;
    if Grid.CheckIndex(itRow, DataRow, 0, FSize - 1) then
        Result := FRows[DataRow];
end;

function TtsGridRows.GetDisplayRowNumber(DataRow: Longint): Longint;
begin
    if Assigned(FDisplayRowNumber)
        then Result := FDisplayRowNumber[DataRow]
        else Result := DataRow;
end;

procedure TtsGridRows.SetDisplayRowNumber(DataRow: Longint; Value: Longint);
begin
    if not Assigned(FDisplayRowNumber) then Exit;
    FDisplayRowNumber[DataRow] := Value;
end;

function TtsGridRows.GetRowId(DataRow: Longint): Longint;
begin
    Result := FRowId[DataRow];
end;

procedure TtsGridRows.Resize(OldSize: Longint);
begin
    FSize := FGrid.RowCount;
    CreateDefaultValues(OldSize, FSize);
end;

function TtsGridRows.CreateRow: TtsRow;
begin
    Result := TtsRow.Create(Grid);
end;

procedure TtsGridRows.CreateDataRow(DataRow: Longint);
begin
    if Assigned(FRows[DataRow]) then Exit;

    FRows[DataRow] := CreateRow;
    FRows[DataRow].FDataRow := DataRow;
    FRows[DataRow].FHeight := FGrid.RowHeights[FGrid.DisplayRownr[DataRow]];
    FRows[DataRow].FOldHeight := FGrid.RowHeights[DataRow];
end;

procedure TtsGridRows.RemoveDataRow(DataRow: Longint);
begin
    FRows[DataRow].Free;
    FRows[DataRow] := nil;
end;

procedure TtsGridRows.CheckRemoveDataRow(DataRow: Longint);
begin
    if (DataRow = 0) or not Assigned(FRows[DataRow]) then Exit;
    if FRows[DataRow].Empty then RemoveDataRow(DataRow);
end;

function TtsGridRows.GetRowHeight(DataRow: Longint): Integer;
begin
    Result := FGrid.DefaultRowHeight;
    if Assigned(FRows[DataRow]) then
        Result := FRows[DataRow].FHeight;
end;

procedure TtsGridRows.SetRowHeight(DataRow: Longint; Value: Integer);
begin
    if (Value = FGrid.DefaultRowHeight) and
       not Assigned(FRows[DataRow]) then Exit;
    CreateDataRow(DataRow);
    FRows[DataRow].FHeight := Value;
    CheckRemoveDataRow(DataRow);
end;

function TtsGridRows.GetOldRowHeight(DataRow: Longint): Integer;
begin
    Result := FGrid.FOldDefaultRowHeight;
    if Assigned(FRows[DataRow]) then
        Result := FRows[DataRow].FOldHeight;
end;

procedure TtsGridRows.SetOldRowHeight(DataRow: Longint; Value: Integer);
begin
    if (Value = FGrid.FOldDefaultRowHeight) and
       not Assigned(FRows[DataRow]) then Exit;
    CreateDataRow(DataRow);
    FRows[DataRow].FOldHeight := Value;
    CheckRemoveDataRow(DataRow);
end;

procedure TtsGridRows.CopyRowHeight(DataRow: Longint; Height: Integer);
begin
    CreateDataRow(DataRow);
    FRows[DataRow].CopyHeight(Height);
    CheckRemoveDataRow(DataRow);
end;

{End TtsGridRows}

{TtsCoordList}

procedure TtsCoordList.AddCoord(X,Y: Integer);
begin
    AddItem(X);
    AddItem(Y);
end;

procedure TtsCoordList.RemoveCoord(X,Y: Integer);
var
    I: Integer;
begin
    I := 0;
    while I < Count - 1 do
    begin
        if (Item[I] = X) and (Item[I+1] = Y) then
        begin
            Delete(I);
            Delete(I);
            Break;
        end;

        I := I + 2;
    end;
end;

procedure TtsCoordList.UpdateCoord(Index, X, Y: Integer);
begin
    if Index < Count - 1 then
    begin
        Item[Index] := X;
        Item[Index + 1] := Y;
    end;
end;

function TtsCoordList.NextCoord(var Index, X, Y: Integer): Boolean;
begin
    X := 0;
    Y := 0;
    Result := Index < Count - 1;
    if Result then
    begin
        X := Item[Index];
        Y := Item[Index + 1];
        Index := Index + 2;
    end;
end;

{TtsCustomElement}

constructor TtsCustomElement.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
end;

procedure TtsCustomElement.AssignProperties(Source: TtsCustomElement);
begin
end;

procedure TtsCustomElement.Assign(Source: TtsCustomElement);
begin
end;

{TtsCustomPropElement}

constructor TtsCustomPropElement.Create(Grid: TtsBaseGrid);
begin
    inherited Create(Grid);

    FColor := clNone;
    FFont := nil;
    FParentFont := True;
    FAlignment:= taLeftJustify;
    FAlign := False;
    FHorzAlignment := htaDefault;
    FVertAlignment := vtaDefault;
    FIs3D := False;
    FReadOnly := False;
    FWordWrap := wwDefault;
    FButtonType := btDefault;
    FDropDownStyle := ddDropDown;
    FCellReadOnly := roDefault;
    FMaskName := '';
    FCombo := nil;
    FParentCombo := True;
    FStretchPicture := dopDefault;
    FShrinkPicture := dopDefault;
    FCenterPicture := dopDefault;
    FKeepAspectRatio := dopDefault;
    FControlType := ctDefault;
    FSpinOptions := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    FSpinIncrement := 1;
    FDateTimeDef := nil;
end;

destructor TtsCustomPropElement.Destroy;
begin
    Grid.CheckResetComboInit(FCombo, True);
    Grid.CheckResetDateTimeInit(FDateTimeDef);

    FFont.Free;
    FCombo.Free;
    Grid.RemoveDateTime(FDateTimeDef);
    inherited Destroy;
end;

function TtsCustomPropElement.Empty;
begin
    Result := (FColor = clNone) and (FFont = nil) and (not FReadOnly) and
              (FAlignment = taLeftJustify) and (not FAlign) and (FHorzAlignment = htaDefault) and
              (FVertAlignment = vtaDefault) and (not FIs3D) and (FWordWrap = wwDefault) and
              (FButtonType = btDefault) and (FDropDownStyle = ddDropDown) and (FCellReadOnly = roDefault) and
              (FParentFont = True) and (FMaskName = '') and (FAutoCreateFont = False) and
              (FCombo = nil) and (FParentCombo = True) and (FStretchPicture = dopDefault) and
              (FShrinkPicture = dopDefault) and (FKeepAspectRatio = dopDefault) and
              (FCenterPicture = dopDefault) and (FControlType = ctDefault) and
              (FSpinOptions = [spoAutoRepeat, spoAutoIncrement, spoKeyEdit]) and (FSpinIncrement = 1) and
              (FDateTimeDef = nil) and (FTag = 0) and (FData = Nil);
end;

procedure TtsCustomPropElement.AssignProperties(Source: TtsCustomElement);
var
    SourceProp: TtsCustomPropElement;
begin
    SourceProp := TtsCustomPropElement(Source);
    FColor := SourceProp.FColor;
    FAlignment := SourceProp.FAlignment;
    FAlign := SourceProp.FAlign;
    FHorzAlignment := SourceProp.FHorzAlignment;
    FVertAlignment := SourceProp.FVertAlignment;
    FIs3D := SourceProp.FIs3D;
    FReadOnly := SourceProp.FReadOnly;
    FWordWrap := SourceProp.FWordWrap;
    FDropDownStyle := SourceProp.FDropDownStyle;
    FCellReadOnly := SourceProp.FCellReadOnly;
    FMaskName := SourceProp.FMaskName;
    FStretchPicture := SourceProp.FStretchPicture;
    FShrinkPicture := SourceProp.FShrinkPicture;
    FCenterPicture := SourceProp.FCenterPicture;
    FKeepAspectRatio := SourceProp.FKeepAspectRatio;
    FControlType := SourceProp.FControlType;
    FParentCombo := SourceProp.FParentCombo;
    FSpinOptions := SourceProp.FSpinOptions;
    FSpinIncrement := SourceProp.FSpinIncrement;

    SetButtonType(SourceProp.FButtonType);
    SetDateTimeDef(SourceProp.FDateTimeDef);
    SetCombo(SourceProp.FCombo);

    FParentFont := SourceProp.FParentFont;
    if not FParentFont then UpdateFont(SourceProp.FFont)
                       else CheckFont;
end;

procedure TtsCustomPropElement.Assign(Source: TtsCustomElement);
begin
    if Source is TtsCustomPropElement then
        AssignProperties(TtsCustomPropElement(Source))
    else
        inherited;
end;

procedure TtsCustomPropElement.FontChange(Sender: TObject);
begin
    if ChangeFont then FParentFont := False;
end;

procedure TtsCustomPropElement.CopyFont(Value: TFont);
begin
    if FFont <> Value then
    begin
        if Value = nil then
        begin
            FFont.Free;
            FFont := nil;
        end
        else
        begin
            if FFont = nil then FFont := TFont.Create;
            FFont.Assign(Value);
            FFont.OnChange := FontChange;
        end;
    end;
end;

procedure TtsCustomPropElement.UpdateFont(Value: TFont);
begin
    ChangeFont := False;
    try
        CopyFont(Value);
    finally
        ChangeFont := True;
    end;
end;

procedure TtsCustomPropElement.SetFont(Value: TFont);
begin
    if FFont <> Value then
    begin
        try
            CopyFont(Value);
        finally
            FParentFont := not Assigned(FFont);
        end;
    end;
end;

procedure TtsCustomPropElement.SetParentFont(Value: Boolean);
begin
    FParentFont := Value;
end;

function TtsCustomPropElement.GetPropValue(Prop: TtsProperty; PropId: Integer): Variant;
begin
    case Prop of
        prColor: Result := FColor;
        prAlignment: Result := FAlignment;
        prAlign: Result := FAlign;
        prHorzAlignment: Result := FHorzAlignment;
        prVertAlignment: Result := FVertAlignment;
        prIs3D: Result := FIs3D;
        prFont: Result := ObjectToVariant(FFont);
        prReadOnly: Result := FReadOnly;
        prWordWrap: Result := FWordWrap;
        prButtonType: Result := FButtonType;
        prDropDownStyle: Result := DropDownStyle;
        prCellReadOnly: Result := FCellReadOnly;
        prParentFont: Result := FParentFont;
        prMask: Result := FMaskName;
        prCombo: Result := ObjectToVariant(FCombo);
        prParentCombo: Result := FParentCombo;
        prPicture:
            case PropId of
                tsStretchId: Result := FStretchPicture;
                tsShrinkId: Result := FShrinkPicture;
                tsCenterId: Result := FCenterPicture;
                tsRatioId: Result := FKeepAspectRatio;
            else
                Result := Unassigned;
            end;
        prControlType: Result := FControlType;
        prSpinOptions: Result := Byte(FSpinOptions);
        prSpinIncrement: Result := FSpinIncrement;
        prDateTime: Result := ObjectToVariant(FDateTimeDef);
        prTag: Result := FTag;
        prData: Result := ObjectToVariant(FData);
    else
        Result := Unassigned;
    end;
end;

procedure TtsCustomPropElement.SetPropValue(const Value: Variant; Prop: TtsProperty; PropId: Integer);
var
    Options: Byte;
begin
    case Prop of
        prColor: FColor := Value;
        prAlignment: SetAlignment(Value);
        prAlign: SetAlign(Value);
        prHorzAlignment: SetHorzAlignment(Value);
        prVertAlignment: FVertAlignment := Value;
        prIs3D: FIs3D := Value;
        prFont: SetFont(TFont(VariantToObject(Value)));
        prReadOnly: FReadOnly := Value;
        prWordWrap: FWordWrap := Value;
        prButtonType: SetButtonType(Value);
        prDropDownStyle: DropDownStyle := Value;
        prCellReadOnly: FCellReadOnly := Value;
        prParentFont: SetParentFont(Value);
        prMask: FMaskName := Value;
        prCombo: SetCombo(TtsCombo(VariantToObject(Value)));
        prParentCombo: SetParentCombo(Value);
        prPicture:
            case PropId of
                tsStretchId: FStretchPicture := Value;
                tsShrinkId: FShrinkPicture := Value;
                tsCenterId: FCenterPicture := Value;
                tsRatioId: FKeepAspectRatio := Value;
            end;
        prControlType: FControlType := Value;
        prSpinOptions: begin Options := Value; FSpinOptions := TtsSpinOptions(Options); end;
        prSpinIncrement: FSpinIncrement := Value;
        prDateTime: SetDateTimeDef(TtsDateTimeDefComponent(VariantToObject(Value)));
        prTag: FTag := Value;
        prData: FData := VariantToObject(Value);
    end;
end;

function TtsCustomPropElement.GetChangeFont: Boolean;
begin
    Result := (FChangeFont = 0);
end;

procedure TtsCustomPropElement.SetChangeFont(Value: Boolean);
begin
    if Value and (FChangeFont > 0) then
        Dec(FChangeFont)
    else if not Value then
        Inc(FChangeFont);
end;

procedure TtsCustomPropElement.CheckFont;
begin
    if FParentFont and Assigned(FFont) then UpdateFont(FGrid.Font);
end;

procedure TtsCustomPropElement.AssignCombo;
begin
    if not Assigned(FCombo) then
    begin
        FCombo := FGrid.CreateCombo;
        FParentCombo := False;
        FCombo.DropDownStyle := FDropDownStyle;
    end;
end;

procedure TtsCustomPropElement.ResetCombo;
begin
    if Assigned(FCombo) then
    begin
        FGrid.CheckResetComboInit(FCombo, True);
        FCombo.Free;
        FCombo := nil;
    end;
end;

procedure TtsCustomPropElement.SetCombo(Value: TtsCombo);
begin
    if FCombo <> Value then
    begin
        if Value = nil then
            ResetCombo
        else
        begin
            AssignCombo;
            FCombo.Assign(Value);
            Grid.CheckResetComboInit(FCombo, False);
        end;
    end;
end;

procedure TtsCustomPropElement.SetParentCombo(Value: Boolean);
begin
    if FParentCombo <> Value then
    begin
        FParentCombo := Value;
        if FParentCombo then SetCombo(nil);
    end;
end;

function TtsCustomPropElement.GetDropDownStyle: TtsDropDownStyle;
begin
    if Assigned(FCombo)
        then Result := FCombo.DropDownStyle
        else Result := FDropDownStyle;
end;

procedure TtsCustomPropElement.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    if DropDownStyle <> Value then
    begin
        FDropDownStyle := Value;
        if Assigned(FCombo) then FCombo.DropDownStyle := Value
    end;
end;

procedure TtsCustomPropElement.SetAlignment(Value: TAlignment);
begin
    if FAlignment <> Value then
    begin
        FAlignment := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);
    end;
end;

procedure TtsCustomPropElement.SetAlign(Value: Boolean);
begin
    if FAlign <> Value then
    begin
        FAlign := Value;
        FHorzAlignment := AlignmentToHorzAlignment(FAlignment, FAlign);
    end;
end;

procedure TtsCustomPropElement.SetHorzAlignment(Value: TtsHorzAlignment);
begin
    if FHorzAlignment <> Value then
    begin
        FHorzAlignment := Value;
        FAlignment := HorzAlignmentToAlignment(FHorzAlignment);
        FAlign := HorzAlignmentToAlign(FHorzAlignment);
    end;
end;

procedure TtsCustomPropElement.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    if Value <> FDateTimeDef then
    begin
        Grid.ResetDateTimeInit;
        Grid.RemoveDateTime(FDateTimeDef);
        FDateTimeDef := Value;
        Grid.AddDateTime(FDateTimeDef);
    end;
end;

procedure TtsCustomPropElement.SetButtonType(Value: TtsButtonType);
begin
    if Value <> FButtonType then
    begin
        FButtonType := Value;
        if FButtonType in [btDateTimeDropDown, btDateTimePopup] then
            Grid.ResetDateTimeInit;
    end;
end;

{End TtsCustomPropElement}

{Start TtsCellElement}

procedure TtsCellElement.Assign(Source: TtsCustomElement);
begin
    if Source is TtsCellElement then
    begin
        FDataCol := TtsCellElement(Source).FDataCol;
        FDataRow := TtsCellElement(Source).FDataRow;
    end;
    inherited;
end;

function TtsCellElement.Compare(NodeSet: TtsCustomSet; Value: TtsSetElement): TtsSetOrder;
begin
    Result := CompareKey(NodeSet, [TtsCellElement(Value).FDataCol,
                         TtsCellElement(Value).FDataRow]);
end;

function TtsCellElement.CompareKey(NodeSet: TtsCustomSet; const KeyValue: array of const): TtsSetOrder;
begin
    if KeyValue[1].VInteger > FDataRow then
        Result := ordLarger
    else if KeyValue[1].VInteger < FDataRow then
        Result := ordSmaller
    else if KeyValue[0].VInteger > FDataCol then
        Result := ordLarger
    else if KeyValue[0].VInteger < FDataCol then
        Result := ordSmaller
    else
        Result := ordEqual;
end;

constructor TtsCellElement.Create(Grid: TtsBaseGrid; DataCol, DataRow: Longint);
begin
    inherited Create(Grid);

    FDataCol := DataCol;
    FDataRow := DataRow;
    FChangeFont := 0;
    FAutoCreateFont := False;
    FGrid.ResetLastCell;
end;

destructor TtsCellElement.Destroy;
begin
    FGrid.ResetLastCell;
    inherited;
end;

procedure TtsCellElement.FontChange(Sender: TObject);
var
    DisplayCol, DisplayRow: Longint;
    Invalidated: Boolean;
begin
    if ChangeFont then
    begin
        inherited;
        DisplayCol := FGrid.GetDisplayCol(FDataCol);
        DisplayRow := FGrid.GetDisplayRow(FDataRow);

        Invalidated := FGrid.CheckInvalidateCell(DisplayCol, DisplayRow);
        if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) and
           (FGrid.FCurDisplayRow = DisplayRow) then
        begin
            FGrid.RedisplayControl(True);
        end;
    end;
end;

procedure TtsCellElement.SetParentFont(Value: Boolean);
var
    Invalidated: Boolean;
    DisplayCol, DisplayRow: Longint;
begin
    if FParentFont <> Value then
    begin
        inherited;

        if FParentFont then
        begin
            if not FAutoCreateFont then
                UpdateFont(nil)
            else
            begin
                if Assigned(FFont) then UpdateFont(FGrid.Font);

                DisplayCol := FGrid.GetDisplayCol(FDataCol);
                DisplayRow := FGrid.GetDisplayRow(FDataRow);
                Invalidated := FGrid.CheckInvalidateCell(DisplayCol, DisplayRow);

                if Invalidated and (FGrid.FCurDisplayCol = DisplayCol) and
                   (FGrid.FCurDisplayRow = DisplayRow) then
                begin
                    FGrid.RedisplayControl(True);
                end;
            end;
        end
        else
            UpdateFont(FGrid.Font);
    end;
end;

procedure TtsCellElement.RemoveFonts;
begin
    if FParentFont and Assigned(FFont) then UpdateFont(nil);
end;

procedure TtsCellElement.CheckFont;
begin
    if FParentFont and Assigned(FFont) then
    begin
        UpdateFont(FGrid.GiveCellFont(FDataCol, FDataRow));
    end;
end;

procedure TtsCellElement.SetKey(DataCol, DataRow: Longint);
begin
    FDataCol := DataCol;
    FDataRow := DataRow;
end;

procedure TtsCellElement.AssignCombo;
begin
    if not Assigned(FCombo) then
    begin
        inherited;
        if (FDataCol >= 1) and (FDataCol <= FGrid.Cols) then
            FCombo.FGrid.InitComboColWidth(FGrid.Col[FDataCol].Width);
    end;
end;

{End TtsCellElement}

{TtsCustomPropSet}

constructor TtsCustomPropSet.CreateNew(AGrid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := AGrid;
end;

procedure TtsCustomPropSet.AddElement(Element: TtsCustomElement);
begin
    Add(Element);
end;

function TtsCustomPropSet.SetProperty(const KeyValue: array of const;
                                      var Element: TtsCustomElement; const Value: Variant;
                                      Prop: TtsProperty; PropId: Integer; Redraw: Boolean): Boolean;
var
    NewElement: TtsCustomElement;
    CurPropValue: Variant;
begin
    Result := False;
    if Element <> nil
        then CurPropValue := Element.GetPropValue(Prop, PropId)
        else CurPropValue := DefaultPropValue(Prop);
    if EqualPropValue(CurPropValue, Value) then Exit;

    if Element <> nil then
    begin
        Element.SetPropValue(Value, Prop, PropId);
        if EqualPropValue(DefaultPropValue(Prop), Value) then
            if CheckDelete(Element) then Element := nil;
    end
    else
    begin
        NewElement := CreateElement(KeyValue);
        NewElement.SetPropValue(Value, Prop, PropId);
        AddElement(NewElement);
    end;

    Result := True;
end;

procedure TtsCustomPropSet.ResetElement(Element: TtsCustomElement; Properties: TtsProperties; DoRedraw: Boolean);
var
    Redraw: Boolean;
begin
    Redraw := DoRedraw;
    if (prColor in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prColor), prColor, 0, Redraw) then
            Redraw := False;
    if (prFont in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prFont), prFont, 0, Redraw) then
            Redraw := False;
    if (prIs3D in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prIs3D), prIs3D, 0, Redraw) then
            Redraw := False;
    if (prAlign in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prAlign), prAlign, 0, Redraw) then
            Redraw := False;
    if (prAlignment in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prAlignment), prAlignment, 0, Redraw) then
            Redraw := False;
    if (prHorzAlignment in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prHorzAlignment), prHorzAlignment, 0, Redraw) then
            Redraw := False;
    if (prVertAlignment in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prVertAlignment), prVertAlignment, 0, Redraw) then
            Redraw := False;
    if (prReadOnly in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prReadOnly), prReadOnly, 0, Redraw) then
            Redraw := False;
    if (prWordWrap in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prWordWrap), prWordWrap, 0, Redraw) then
            Redraw := False;
    if (prButtonType in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prButtonType), prButtonType, 0, Redraw) then
            Redraw := False;
    if (prDropDownStyle in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prDropDownStyle), prDropDownStyle, 0, Redraw) then
            Redraw := False;
    if (prCellReadOnly in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prCellReadOnly), prCellReadOnly, 0, Redraw) then
            Redraw := False;
    if (prParentFont in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prParentFont), prParentFont, 0, Redraw) then
            Redraw := False;
    if (prCombo in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prCombo), prCombo, 0, Redraw) then
            Redraw := False;
    if (prParentCombo in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prParentCombo), prParentCombo, 0, Redraw) then
            Redraw := False;

    if (prPicture in Properties) then
    begin
        if Assigned(Element) then
            if SetProperty([0], Element, DefaultPropValue(prPicture), prPicture, tsStretchId, Redraw) then
                Redraw := False;
        if Assigned(Element) then
            if SetProperty([0], Element, DefaultPropValue(prPicture), prPicture, tsShrinkId, Redraw) then
                Redraw := False;
        if Assigned(Element) then
            if SetProperty([0], Element, DefaultPropValue(prPicture), prPicture, tsCenterId, Redraw) then
                Redraw := False;
        if Assigned(Element) then
            if SetProperty([0], Element, DefaultPropValue(prPicture), prPicture, tsRatioId, Redraw) then
                Redraw := False;
    end;

    if (prControlType in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prControlType), prControlType, 0, Redraw) then
            Redraw := False;
    if (prSpinOptions in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prSpinOptions), prSpinOptions, 0, Redraw) then
            Redraw := False;
    if (prSpinIncrement in Properties) and Assigned(Element) then
        if SetProperty([0], Element, DefaultPropValue(prSpinIncrement), prSpinIncrement, 0, Redraw) then
            Redraw := False;
    if (prDateTime in Properties) and Assigned(Element) then
        SetProperty([0], Element, DefaultPropValue(prDateTime), prDateTime, 0, False);
    if (prMask in Properties) and Assigned(Element) then
        SetProperty([0], Element, DefaultPropValue(prMask), prMask, 0, True);
    if (prSelected in Properties) and Assigned(Element) then
        SetProperty([0], Element, DefaultPropValue(prSelected), prSelected, 0, Redraw);
    if (prTag in Properties) and Assigned(Element) then
        SetProperty([0], Element, DefaultPropValue(prTag), prTag, 0, Redraw);
    if (prData in Properties) and Assigned(Element) then
        SetProperty([0], Element, DefaultPropValue(prData), prData, 0, Redraw);
end;

procedure TtsCustomPropSet.ResetProperties(Properties: TtsProperties; DoRedraw: Boolean);
var
    I: Longint;
    AList: TtsSetList;
    Element: TtsCustomElement;
begin
    if Properties = [] then Exit;

    AList := Self.List;
    try
        for I := 1 to AList.Count do
        begin
            Element := TtsCustomElement(AList.Items[I]);
            ResetElement(Element, Properties, DoRedraw);
        end;
    finally
        AList.Free;
    end;
end;

procedure TtsCustomPropSet.SetAutoCreateFont(const KeyValue: array of const;
                                             var Element: TtsCustomElement; Value: Boolean);
var
    CurValue: Boolean;
begin
    CurValue := False;
    if Element <> nil then CurValue := TtsCustomPropElement(Element).FAutoCreateFont;
    if CurValue = Value then Exit;

    if Element <> nil then
    begin
        TtsCustomPropElement(Element).FAutoCreateFont := Value;
        if Value = False then if CheckDelete(Element) then Element := nil;
    end
    else
    begin
        Element := CreateElement(KeyValue);
        TtsCustomPropElement(Element).FAutoCreateFont := Value;
        AddElement(Element);
    end;
end;

function TtsCustomPropSet.NewNode(NodeValue : Pointer) : TtsSetNode;
var
    Element: TtsCustomElement;
begin
    if not Assigning then
    begin
        Result := inherited NewNode(NodeValue);
        Exit;
    end;

    Element := TtsCustomElement(TObject(NodeValue).ClassType.Create);
    Element.FGrid := FGrid;
    Element.Assign(TtsCustomElement(NodeValue));
    Result := inherited NewNode(Element)
end;

{End TtsCustomPropSet}

{TtsCellPropSet}

function TtsCellPropSet.CreateElement(const KeyValue: array of const): TtsCustomElement;
begin
    Result := TtsCellElement.Create(Grid, KeyValue[0].VInteger, KeyValue[1].VInteger);
end;

procedure TtsCellPropSet.AddElement(Element: TtsCustomElement);
begin
    inherited AddElement(Element);
    Grid.AddToPropList(TtsCellElement(Element));
end;

procedure TtsCellPropSet.DeleteElement(Element: TtsCustomElement);
var
    Cell: TtsCellElement;
begin
    Cell := TtsCellElement(Element);
    Grid.DeleteFromPropList(Cell);
    Remove([Cell.FDataCol, Cell.FDataRow]);
end;

function TtsCellPropSet.CheckDelete(Element: TtsCustomElement): Boolean;
begin
    Result := Element.Empty;
    if Result then DeleteElement(Element);
end;

procedure TtsCellPropSet.CheckRedraw(DataCol, DataRow: Longint; CheckInvalidate: Boolean);
var
    DisplayCol, DisplayRow: Longint;
    Invalidated: Boolean;
begin
    if FGrid.FastAssign then Exit;

    if not (csDestroying in Grid.ComponentState) then
    begin
        if (DataCol >= 0) and (DataCol <= Grid.ColCount - 1) and
           (DataRow >= 0) and (DataRow <= Grid.RowCount - 1) then
        begin
            DisplayCol := Grid.GetDisplayCol(DataCol);
            DisplayRow := Grid.GetDisplayRow(DataRow);
            if CheckInvalidate then
                Invalidated := Grid.CheckInvalidateCell(DisplayCol, DisplayRow)
            else
            begin
                Invalidated := True;
                Grid.InvalidateCell(DisplayCol, DisplayRow)
            end;

            if Invalidated and (Grid.CurDisplayCol = DisplayCol) and
               (Grid.CurDisplayRow = DisplayRow) then
            begin
                Grid.RedisplayControl(True);
                Grid.InvalidateFocusRect(DisplayCol, DisplayRow, False);
            end;
        end;
    end;
end;

function TtsCellPropSet.SetProperty(const KeyValue: array of const;
                                    var Element: TtsCustomElement; const Value: Variant;
                                    Prop: TtsProperty; PropId: Integer; Redraw: Boolean): Boolean;
var
    DataCol, DataRow: Longint;
begin
    if Element <> nil then
    begin
        DataCol := TtsCellElement(Element).FDataCol;
        DataRow := TtsCellElement(Element).FDataRow;
    end
    else
    begin
        DataCol := KeyValue[0].VInteger;
        DataRow := KeyValue[1].VInteger;
    end;

    Result := inherited SetProperty(KeyValue, Element, Value, Prop, PropId, Redraw);
    if Result then
    begin
        if Prop = prMask then
            Grid.CheckSetMask(DataCol, DataRow)
        else if Redraw then
            CheckRedraw(DataCol, DataRow, Grid.IsDrawProp(Prop));
    end;
end;

procedure TtsCellPropSet.SetAutoCreateFont(const KeyValue: array of const;
                                           var Element: TtsCustomElement; Value: Boolean);
var
    DataCol, DataRow: Longint;
begin
    if Element <> nil then
    begin
        DataCol := TtsCellElement(Element).FDataCol;
        DataRow := TtsCellElement(Element).FDataRow;
    end
    else
    begin
        DataCol := KeyValue[0].VInteger;
        DataRow := KeyValue[1].VInteger;
    end;

    inherited;

    if (Element <> nil) and TtsCellElement(Element).FAutoCreateFont then
        FGrid.FAutoFontCells.AddCoord(DataCol, DataRow)
    else
    begin
        FGrid.FAutoFontCells.RemoveCoord(DataCol, DataRow);
        if Element <> nil then
        begin
            TtsCellElement(Element).RemoveFonts;
            CheckDelete(Element);
        end;
    end;
end;

{End TtsCellPropSet}

{Start TtsCell}

constructor TtsCell.Create(Grid: TtsBaseGrid; DataCol: Longint; DataRow: Variant);
begin
    FGrid := Grid;
    FDataCol := DataCol;
    FDataRow := DataRow;
end;

procedure TtsCell.Assign(Source: TPersistent);
begin
    if Source is TtsCell then
    begin
        AssignObject(Self, Source, 'Font;ParentFont');
        Combo := TtsCell(Source).Combo;
        ParentFont := TtsCell(Source).ParentFont;
        if not ParentFont then Font := TtsCell(Source).Font;
    end
    else
        inherited;
end;

function TtsCell.GetGrid: TtsCustomGrid;
begin
    Result := TtsCustomGrid(FGrid);
end;

procedure TtsCell.SetGrid(Value: TtsCustomGrid);
begin
    FGrid := Value;
end;

function TtsCell.GetColor: TColor;
begin
    Result := Grid.CellColor[DataCol, DataRow];
end;

procedure TtsCell.SetColor(Value: TColor);
begin
    Grid.CellColor[DataCol, DataRow] := Value;
end;

function TtsCell.GetControlType: TtsControlType;
begin
    Result := Grid.CellControlType[DataCol, DataRow];
end;

procedure TtsCell.SetControlType(Value: TtsControlType);
begin
    Grid.CellControlType[DataCol, DataRow] := Value;
end;

function TtsCell.GetSpinOptions: TtsSpinOptions;
begin
    Result := Grid.CellSpinOptions[DataCol, DataRow];
end;

procedure TtsCell.SetSpinOptions(Value: TtsSpinOptions);
begin
    Grid.CellSpinOptions[DataCol, DataRow] := Value;
end;

function TtsCell.GetSpinIncrement: Double;
begin
    Result := Grid.CellSpinIncrement[DataCol, DataRow];
end;

procedure TtsCell.SetSpinIncrement(Value: Double);
begin
    Grid.CellSpinIncrement[DataCol, DataRow] := Value;
end;

function TtsCell.StoreSpinIncrement: Boolean;
begin
    Result := SpinIncrement <> 1;
end;

function TtsCell.GetFont: TFont;
begin
    Result := Grid.CellFont[DataCol, DataRow];
end;

procedure TtsCell.SetFont(Value: TFont);
begin
    Grid.CellFont[DataCol, DataRow] := Value;
end;

function TtsCell.GetParentFont: Boolean;
begin
    Result := Grid.CellParentFont[DataCol, DataRow];
end;

procedure TtsCell.SetParentFont(Value: Boolean);
begin
    Grid.CellParentFont[DataCol, DataRow] := Value;
end;

function TtsCell.GetAlignment: TAlignment;
begin
    Result := Grid.CellAlignment[DataCol, DataRow];
end;

procedure TtsCell.SetAlignment(Value: TAlignment);
begin
    Grid.CellAlignment[DataCol, DataRow] := Value;
end;

function TtsCell.GetAlign: Boolean;
begin
    Result := Grid.CellAlign[DataCol, DataRow];
end;

procedure TtsCell.SetAlign(Value: Boolean);
begin
    Grid.CellAlign[DataCol, DataRow] := Value;
end;

function TtsCell.GetHorzAlignment: TtsHorzAlignment;
begin
    Result := Grid.CellHorzAlignment[DataCol, DataRow];
end;

procedure TtsCell.SetHorzAlignment(Value: TtsHorzAlignment);
begin
    Grid.CellHorzAlignment[DataCol, DataRow] := Value;
end;

function TtsCell.GetVertAlignment: TtsVertAlignment;
begin
    Result := Grid.CellVertAlignment[DataCol, DataRow];
end;

procedure TtsCell.SetVertAlignment(Value: TtsVertAlignment);
begin
    Grid.CellVertAlignment[DataCol, DataRow] := Value;
end;

function TtsCell.GetIs3D: Boolean;
begin
    Result := Grid.CellIs3D[DataCol, DataRow];
end;

procedure TtsCell.SetIs3D(Value: Boolean);
begin
    Grid.CellIs3D[DataCol, DataRow] := Value;
end;

function TtsCell.GetWordWrap: TtsWordWrap;
begin
    Result := Grid.CellWordWrap[DataCol, DataRow];
end;

procedure TtsCell.SetWordWrap(Value: TtswordWrap);
begin
    Grid.CellWordWrap[DataCol, DataRow] := Value;
end;

function TtsCell.GetButtonType: TtsButtonType;
begin
    Result := Grid.CellButtonType[DataCol, DataRow];
end;

procedure TtsCell.SetButtonType(Value: TtsButtonType);
begin
    Grid.CellButtonType[DataCol, DataRow] := Value;
end;

function TtsCell.GetDropDownStyle: TtsDropDownStyle;
begin
    Result := Grid.CellDropDownStyle[DataCol, DataRow];
end;

procedure TtsCell.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    Grid.CellDropDownStyle[DataCol, DataRow] := Value;
end;

function TtsCell.GetReadOnly: TtsReadOnly;
begin
    Result := Grid.CellReadOnly[DataCol, DataRow];
end;

procedure TtsCell.SetReadOnly(Value: TtsReadOnly);
begin
    Grid.CellReadOnly[DataCol, DataRow] := Value;
end;

function TtsCell.GetMaskName: string;
begin
    Result := Grid.CellMaskName[DataCol, DataRow];
end;

procedure TtsCell.SetMaskName(Value: string);
begin
    Grid.CellMaskName[DataCol, DataRow] := Value;
end;

function TtsCell.GetAutoCreateFont: Boolean;
var
    Element: TtsCellElement;
    Rownr: Longint;
begin
    Result := False;
    if Grid.FCellPropSet.Count = 0 then Exit;

    Rownr := DataRow;
    Element := TtsCellElement(Grid.FCellPropSet.Get([DataCol, Rownr]));
    if Element <> nil then Result := Element.FAutoCreateFont;
end;

procedure TtsCell.SetAutoCreateFont(Value: Boolean);
var
    Element: TtsCustomElement;
    Rownr: Longint;
begin
    Rownr := DataRow;
    Element := TtsCustomElement(Grid.FCellPropSet.Get([DataCol, Rownr]));
    Grid.FCellPropSet.SetAutoCreateFont([DataCol, Rownr], Element, Value);
end;

function TtsCell.GetCombo: TtsCombo;
begin
    Result := Grid.CellCombo[DataCol, DataRow];
end;

procedure TtsCell.SetCombo(Value: TtsCombo);
begin
    Grid.CellCombo[DataCol, DataRow] := Value;
end;

procedure TtsCell.AssignCombo;
begin
    Grid.AssignCellCombo(DataCol, DataRow);
end;

function TtsCell.GetParentCombo: Boolean;
begin
    Result := Grid.CellParentCombo[DataCol, DataRow];
end;

procedure TtsCell.SetParentCombo(Value: Boolean);
begin
    Grid.CellParentCombo[DataCol, DataRow] := Value;
end;

function TtsCell.GetStretchPicture: TtsDrawOption;
begin
    Result := Grid.CellStretchPicture[DataCol, DataRow];
end;

procedure TtsCell.SetStretchPicture(Value: TtsDrawOption);
begin
    Grid.CellStretchPicture[DataCol, DataRow] := Value;
end;

function TtsCell.GetShrinkPicture: TtsDrawOption;
begin
    Result := Grid.CellShrinkPicture[DataCol, DataRow];
end;

procedure TtsCell.SetShrinkPicture(Value: TtsDrawOption);
begin
    Grid.CellShrinkPicture[DataCol, DataRow] := Value;
end;

function TtsCell.GetCenterPicture: TtsDrawOption;
begin
    Result := Grid.CellCenterPicture[DataCol, DataRow];
end;

procedure TtsCell.SetCenterPicture(Value: TtsDrawOption);
begin
    Grid.CellCenterPicture[DataCol, DataRow] := Value;
end;

function TtsCell.GetKeepAspectRatio: TtsDrawOption;
begin
    Result := Grid.CellKeepAspectRatio[DataCol, DataRow];
end;

procedure TtsCell.SetKeepAspectRatio(Value: TtsDrawOption);
begin
    Grid.CellKeepAspectRatio[DataCol, DataRow] := Value;
end;

function TtsCell.GetDateTimeDef: TtsDateTimeDefComponent;
begin
    Result := Grid.CellDateTimeDef[DataCol, DataRow];
end;

procedure TtsCell.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    Grid.CellDateTimeDef[DataCol, DataRow] := Value;
end;

procedure TtsCell.ReadCombo(Stream: TStream);
begin
    if not Assigned(Combo)
        then AssignCombo
        else Combo.FGrid.Reset;
    Stream.ReadComponent(Combo.FGrid);
    Combo.FGrid.Name := '';
end;

procedure TtsCell.WriteCombo(Stream: TStream);
begin
    Stream.WriteComponent(Combo.FGrid);
end;

procedure TtsCell.DefineProperties(Filer: TFiler);
var
    StoreCombo: Boolean;
begin
    inherited;
    with Filer do
    begin
        StoreCombo := (Combo <> nil) and (ButtonType = btCombo);
        DefineBinaryProperty('Combo', ReadCombo, WriteCombo, StoreCombo);
    end;
end;

{End TtsCell}

{Start TtsSelection}

constructor TtsSelection.Create;
begin
    FFirst := -1;
    FLast := -1;
    FCount := 0;
    FBits := TBits.Create;
end;

destructor TtsSelection.Destroy;
begin
    FBits.Free;
    inherited Destroy;
end;

function TtsSelection.Assign(Source: TtsSelection): Boolean;
var
    I, OldCount: Longint;
    Changed: Boolean;
begin
    OldCount := FCount;
    Changed := False;

    FFirst := Source.FFirst;
    FLast := Source.FLast;
    FCount := Source.FCount;
    FBits.Size := Source.Size;

    if (OldCount <> 0) or (Source.FCount <> 0) then
    begin
        for I := 0 to Source.Size - 1 do
        begin
            if FBits[I] <> Source[I] then
            begin
                Changed := True;
                FBits[I] := Source[I];
            end;
        end;
    end;

    Result := Changed;
end;

procedure TtsSelection.Reset;
var
    OldSize: Longint;
begin
    OldSize := FBits.Size;
    FBits.Size := 0;
    FBits.Size := OldSize;

    FCount := 0;
    FFirst := -1;
    FLast := -1;
end;

function TtsSelection.GetSize: Longint;
begin
    Result := FBits.Size;
end;

procedure TtsSelection.SetSize(Value: Longint);
var
    DelCount: Longint;
begin
    if Value = Size then Exit;

    if Value < Size then
    begin
        DelCount := RangeCount(Value, Size - 1);
        if FLast > Value - 1 then FLast := Previous(Value);
        if FFirst > Value - 1 then FFirst := -1;
        FCount := FCount - DelCount;
    end;

    FBits.Size := Value;
end;

procedure TtsSelection.SetSelected(Index: Longint; Value: Boolean);
begin
    if (Index < 1) and (Index > Size - 1) then Exit;

    if FBits[Index] <> Value then
    begin
        FBits[Index] := Value;

        if FBits[Index] then Inc(FCount)
                        else Dec(FCount);

        if (Index = FFirst) and (not FBits[Index]) then
            FFirst := Next(Index)
        else if ((Index < FFirst) or (FFirst < 0)) and (FBits[Index]) then
            FFirst := Index;

        if (Index = FLast) and (not FBits[Index]) then
            FLast := Previous(Index)
        else if (Index > FLast) and (FBits[Index]) then
            FLast := Index;
    end;
end;

function TtsSelection.GetSelected(Index: Longint): Boolean;
begin
    Result := False;
    if (Index >= 1) and (Index <= Size - 1) then Result := FBits[Index];
end;

function TtsSelection.Next(Index: Longint): Longint;
var
    I: Longint;
begin
    if (FCount > 0) and (Index < FLast) then
    begin
        I := Index + 1;
        while not FBits[I] do Inc(I);
        Result := I;
    end
    else
        Result := -1;
end;

function TtsSelection.Previous(Index: Longint): Longint;
var
    I: Longint;
begin
    if (FCount > 0) and (Index > FFirst) then
    begin
        I := Index - 1;
        while not FBits[I] do Dec(I);
        Result := I;
    end
    else
        Result := -1;
end;

function TtsSelection.RangeCount(FromIndex, ToIndex: Longint): Longint;
var
    Count: Integer;
    Index: Longint;
begin
    if FromIndex > ToIndex then SwapLongint(FromIndex, ToIndex);
    if FromIndex < 1 then FromIndex := 1;
    if ToIndex > Size - 1 then ToIndex := Size - 1;

    if (FCount = 0) or (FLast < FromIndex) or (FFirst > ToIndex) then
    begin
        Result := 0;
        Exit;
    end;

    if (FFirst >= FromIndex) and (FLast <= ToIndex) then
    begin
        Result := FCount;
        Exit;
    end;

    Count := 0;
    if FBits[FromIndex] then Inc(Count);

    Index := Next(FromIndex);
    while (Index <= ToIndex) and (Index > 0) do
    begin
        Inc(Count);
        Index := Next(Index);
    end;

    Result := Count;
end;

{TtsCurrentCell}

constructor TtsCurrentCell.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
    FValue := Unassigned;
    FIsObject := False;
    FValueCol := -1;
    FValueRow := -1;
    FStretchPicture := True;
    FTransparentColor := clNone;
    FCenterPicture := True;
    FShrinkPicture := True;
    FKeepAspectRatio := False;
end;

procedure TtsCurrentCell.FreeInstance;
begin
    ClearBuffer;
    inherited FreeInstance;
end;

function TtsCurrentCell.GetDataCol: Longint;
begin
    Result := -1;
    if FGrid.InGridState then
        Result := FGrid.GetDataCol(FGrid.FCurDisplayCol);
end;

function TtsCurrentCell.GetDataRow: Longint;
begin
    Result := -1;
    if FGrid.InGridState then
        Result := FGrid.GetDataRow(FGrid.FCurDisplayRow);
end;

function TtsCurrentCell.GetControlType: TtsControlType;
begin
    Result := ctNone;
    if FGrid.InGridState then
        Result := FGrid.CurCellControlType;
end;

function TtsCurrentCell.GetValue: Variant;
begin
    Result := Unassigned;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FValue;
    end;
end;

function TtsCurrentCell.BufferValue: Variant;
begin
    Result := FValue;
end;

procedure TtsCurrentCell.SelectAll;
begin
    if not FGrid.HandleAllocated then Exit;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        FGrid.FGridControl.SelectAll;
    end;
end;

function TtsCurrentCell.GetSelStart: Integer;
begin
    Result := 0;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FSelStart;
    end;
end;

function TtsCurrentCell.GetSelLength: Integer;
begin
    Result := 0;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FSelLength;
    end;
end;

function TtsCurrentCell.GetSelText: string;
begin
    Result := '';
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FGrid.FGridControl.SelText;
    end;
end;

function  TtsCurrentCell.GetTag : Integer;
begin
  Result := 0;
  if (FGrid.InGridState) then
     Result := FGrid.CellTag[DataCol, DataRow];
end;

function  TtsCurrentCell.GetData : Pointer;
begin
  Result := Nil;
  if (FGrid.InGridState) then
     Result := FGrid.CellData[DataCol, DataRow];
end;

procedure TtsCurrentCell.SetTag(Value : Integer);
begin
  if (FGrid.InGridState) then
     FGrid.CellTag[DataCol, DataRow] := Value;
end;

procedure TtsCurrentCell.SetData(Value : Pointer);
begin
  if (FGrid.InGridState) then
     FGrid.CellData[DataCol, DataRow] := Value;  
end;

function TtsCurrentCell.GetTextWidth: Integer;
begin
    Result := 0;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FGrid.CellTextWidth[DataCol, DataRow];
    end;
end;

function TtsCurrentCell.GetTextHeight: Integer;
begin
    Result := 0;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FGrid.CellTextHeight[DataCol, DataRow];
    end;
end;

function TtsCurrentCell.GetTextLines: Integer;
begin
    Result := 0;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        Result := FGrid.CellTextLines[DataCol, DataRow];
    end;
end;

function TtsCurrentCell.SetEditValue(const Value: Variant; ByUser, Redraw: Boolean): Boolean;
var
    Ok: Boolean;
begin
    Result := False;
    if (FGrid.InEditState) then
    begin
        if not FGrid.CheckVarType(ControlType, Value) then Exit;

        Ok := FGrid.StartEdit;
        if Ok then Ok := FGrid.StartCellChange(DataCol, True);

        if Ok then
        begin
            if ByUser then FGrid.InternalShowEditor(tsAll, False);
            ClearBuffer;
            FGrid.SetControlSelectMode(tsCurrent);
            FGrid.SetControlValue(FGrid.CheckStrValue(ControlType, Value), True, ByUser);
            if Redraw then FGrid.InvalidateCell(DataCol, DataRow);
        end;

        Result := Ok;
    end;
end;

procedure TtsCurrentCell.SetValue(const Value: Variant);
begin
    SetEditValue(Value, False, True);
end;

procedure TtsCurrentCell.SetSelStart(Value: Integer);
begin
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        FGrid.FGridControl.SelStart := Value;
    end;
end;

procedure TtsCurrentCell.SetSelLength(Value: Integer);
begin
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        FGrid.FGridControl.SelLength := Value;
     end;
end;

procedure TtsCurrentCell.SetSelText(Value: string);
begin
    if not FGrid.HandleAllocated then Exit;
    if (FGrid.InEditState) then
    begin
        FetchCellValue;
        FGrid.FGridControl.SelText := Value;
    end;
end;

function TtsCurrentCell.CopyToClipboard: Boolean;
begin
    Result := False;
    if not FGrid.HandleAllocated then Exit;
    if (FGrid.InGridState) and (ControlType = ctText) then
    begin
        FetchCellValue;
        FGrid.FGridControl.CopyToClipboard;
        Result := True;
    end;
end;

function TtsCurrentCell.InternalCutToClipboard(ByUser: Boolean): Boolean;
begin
    Result := False;
    if not FGrid.HandleAllocated then Exit;
    if (FGrid.InEditState) and (ControlType = ctText) then
    begin
        FetchCellValue;
        FGrid.FGridControl.CutToClipboard(ByUser);
        if not FGrid.FControlEnabled then FGrid.InvalidateCell(DataCol, DataRow);
        Result := True;
    end;
end;

function TtsCurrentCell.CutToClipboard: Boolean;
begin
    Result := False;
    if not FGrid.HandleAllocated then Exit;
    if FGrid.StartShowEditor(False) then Result := InternalCutToClipboard(False);
end;

function TtsCurrentCell.InternalPasteFromClipboard(ByUser: Boolean): Boolean;
begin
    Result := False;
    if not FGrid.HandleAllocated then Exit;
    if (FGrid.InEditState) and (ControlType = ctText) then
    begin
        FetchCellValue;
        FGrid.FGridControl.PasteFromClipboard(ByUser);
        if not FGrid.FControlEnabled then FGrid.InvalidateCell(DataCol, DataRow);
        Result := True;
    end;
end;

function TtsCurrentCell.NewlengthOk(InsertText: string): Boolean;
var
    Text: string;
    MaxLen: Integer;
    NewLen: Integer;
begin
    Result := True;
    MaxLen := FGrid.GridCols[DataCol].MaxLength;
    if MaxLen > 0 then
    begin
        Text := FValue;
        NewLen := PByteToCharLen(PChar(Text), Length(Text), Length(Text)) -
                  SelLength +
                  PByteToCharLen(PChar(InsertText), Length(InsertText), Length(InsertText));
        Result := NewLen <= MaxLen;
    end;
end;

function TtsCurrentCell.PasteFromClipboard: Boolean;
begin
    Result := False;
    if not FGrid.HandleAllocated then Exit;
    if (not FGrid.InEditState) or (ControlType <> ctText) then Exit;

    if not Clipboard.HasFormat(CF_TEXT) then Exit;
    if not NewLengthOk(Clipboard.AsText) then Exit;

    if FGrid.StartShowEditor(False) then Result := InternalPasteFromClipboard(False);
end;

function TtsCurrentCell.IsClear: Boolean;
begin
    Result := VarIsEmpty(FValue);
end;

function TtsCurrentCell.AllSelected: Boolean;
begin
    Result := False;
    if ControlType <> ctText then
        Result := True
    else
    begin
        if (SelStart = 0) and (SelLength = Length(string(Value))) then
            Result := True;
    end;
end;

procedure TtsCurrentCell.Refresh;
begin
    if FGrid.InGridState then
    begin
        ClearBuffer;
        FGrid.SetControlSelectMode(tsAll);
        if FGrid.CurDisplayRow > 0 then
            FGrid.InvalidateCell(FGrid.CurDisplayCol, FGrid.CurDisplayRow);
    end;
end;

procedure TtsCurrentCell.MoveTo(DataCol, DataRow : Longint);
begin
    if not FGrid.CheckIndex(itCol, DataCol, 1, FGrid.Cols) then Exit;
    if not FGrid.CheckIndex(itRow, DataRow, 1, FGrid.Rows) then Exit;

    if FGrid.InGridState then
    begin
        FGrid.SetCurrentCell(FGrid.GetDisplayCol(DataCol),
                             FGrid.GetDisplayRow(DataRow));
        FGrid.SetControlSelectMode(tsCurrent);
        if not FGrid.InSetFocus then FGrid.Update;
    end;
end;

procedure TtsCurrentCell.MoveToInsertRow(DataCol: Longint);
var
    Clear: Boolean;
    OldCurrentRow: Longint;
    NewLeftCol: Longint;
begin
    with FGrid do
    begin
        if (GridMode <> gmEditInsert) or (GridStatus <> grNormal) then Exit;
        if IsInsertRow(CurDisplayRow) then Exit;
        if not CheckIndex(itCol, DataCol, 1, Cols) then Exit;
        if not CheckEndEdit(0, -1, False) then Exit;

        Clear := TopRow = MaxTopRow;
        OldCurrentRow := CurDisplayRow;
        ClearCurrent(OldCurrentRow);
        if CheckHideControl(True) then Update;
        DeleteSelections([], True);

        ClearCurrentFocusRect(True);
        SetControlSelectMode(tsAll);
        SetCurrentPosition(GetDisplayCol(DataCol), Rows + 1, Clear, True);
        NewLeftCol := MoveToDisplayCol(LeftCol, GetDisplayCol(DataCol), vpRight);
        MoveTopLeft(NewLeftCol, MaxTopRow);

        ShowGridControl;
        DrawCurrent(CurDisplayRow);
        DrawCurrentFocusRect(False);

        CheckRowColChanged;
        SelectionsChanged(False);
        GridStatusChanged;
        Update;
    end;
end;

procedure TtsCurrentCell.PutInView;
begin
    if (FGrid.FCurDisplayCol < 1) or (FGrid.FCurDisplayCol > FGrid.ColCount - 1) then Exit;
    if (FGrid.FCurDisplayRow < 1) or (FGrid.FCurDisplayRow > FGrid.RowCount - 1) then Exit;

    if (FGrid.InGridState) then
    begin
        FGrid.PutInView(FGrid.FCurDisplayCol, FGrid.FCurDisplayRow, vpNone,
                        True, False, ctlBoth);
        FGrid.Update;
    end;
end;

procedure TtsCurrentCell.SetBuffer(Value: Variant; IsObject: Boolean);
begin
    if not FGrid.InGridState then Exit;

    ClearBuffer;
    FValueCol := DataCol;
    FValueRow := DataRow;
    FStretchPicture := True;
    FShrinkPicture := True;
    FTransparentColor := clNone;
    FCenterPicture := True;
    FKeepAspectRatio := False;
    FValue := Value;
    FIsObject := IsObject;
end;

procedure TtsCurrentCell.ClearBuffer;
begin
    FValueCol := -1;
    FValueRow := -1;
    if FIsObject then VariantToObject(FValue).Free;
    VarClear(FValue);
    FIsObject := False;
end;

function TtsCurrentCell.ValueSet(DataCol, DataRow: Longint): Boolean;
begin
    Result := (not IsClear) and (FValueCol = DataCol) and (FValueRow = DataRow);
end;

procedure TtsCurrentCell.FetchCellValue;
begin
    if not ValueSet(DataCol, DataRow) and
       (DataCol >= 1) and (DataCol <= FGrid.Cols) and
       (DataRow >= 1) and (DataRow <= FGrid.Rows) then
    begin
        FGrid.EnableStartEdit := False;
        try
            FGrid.SetControlValue(FGrid.Cell[DataCol, DataRow], False, False);
        finally
            FGrid.EnableStartEdit := True;
        end;
    end;
end;

function TtsCurrentCell.GetStretchPicture: Boolean;
var
    Value: TtsDrawOption;
begin
    Value := FGrid.GiveCellStretchPicture(FGrid.FCurDataCol, FGrid.FCurDataRow);
    if Value <> dopDefault
        then Result := (Value = dopOn)
        else Result := FStretchPicture;
end;

function TtsCurrentCell.GetShrinkPicture: Boolean;
var
    Value: TtsDrawOption;
begin
    Value := FGrid.GiveCellShrinkPicture(FGrid.FCurDataCol, FGrid.FCurDataRow);
    if Value <> dopDefault
        then Result := (Value = dopOn)
        else Result := FShrinkPicture;
end;

function TtsCurrentCell.GetCenterPicture: Boolean;
var
    Value: TtsDrawOption;
begin
    Value := FGrid.GiveCellCenterPicture(FGrid.FCurDataCol, FGrid.FCurDataRow);
    if Value <> dopDefault
        then Result := (Value = dopOn)
        else Result := FCenterPicture;
end;

function TtsCurrentCell.GetKeepAspectRatio: Boolean;
var
    Value: TtsDrawOption;
begin
    Value := FGrid.GiveCellKeepAspectRatio(FGrid.FCurDataCol, FGrid.FCurDataRow);
    if Value <> dopDefault
        then Result := (Value = dopOn)
        else Result := FKeepAspectRatio;
end;

function TtsCurrentCell.GetTransparentColor: TColor;
var
    Image: TtsImageItem;
    Bmp: TBitmap;
begin
    Result := FTransparentColor;
    if (FGrid.InGridState) then
    begin
        FetchCellValue;
        if ControlType = ctPicture then
        begin
            Image := nil;
            Bmp := nil;
            if VarType(FValue) <> varString then
                Bmp := VariantToBitmap(FValue)
            else
            begin
                Image := FGrid.ImageListPicture(FValue);
                if Assigned(Image) then Bmp := Image.Bitmap;
            end;

            if Assigned(Bmp) then
            begin
                Result := FGrid.PictureTransparentColor(Bmp, Image);
                if Result = clNone then Result := FTransparentColor;
            end;
        end
        else
    end;
end;

{TtsPropCollection}

constructor TtsPropCollection.Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
begin
    inherited Create(ItemClass);
    FGrid := Grid;
end;

{TtsColCollection}

constructor TtsColCollection.Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
begin
    inherited;
    FColMatch := cmaNone;
    FTempGrid := nil;
end;

destructor TtsColCollection.Destroy;
begin
    FTempGrid.Free;
    inherited;
end;

{TtsColItem}

constructor TtsColItem.Create(Collection: TCollection);
begin
    inherited;
    FCol := nil;
end;

procedure TtsColItem.SetDataCol(Value: Longint);
begin
    FDataCol := Value;
    with TtsColCollection(Collection) do
    begin
        if (FColMatch = cmaNone) then
            FCol := Grid.GridCols[FDataCol];
    end;
end;

procedure TtsColItem.SetReadColNumber(ReadColnr: Integer);
begin
    if Assigned(FCol) then
    begin
        with TtsColCollection(Collection) do
        begin
            if not Assigned(Grid.FReadColNumbers) then
                Grid.FReadColNumbers := TList.Create;
            if Grid.FReadColNumbers.Count < FDataCol then
                Grid.FReadColNumbers.Count := FDataCol;
            Grid.FReadColNumbers.Items[FDataCol - 1] := Pointer(ReadColnr);
        end;
    end;
end;

procedure TtsColItem.SetFieldName(Value: string);
begin
    FFieldName := Value;
    with TtsColCollection(Collection) do
    begin
        if FColMatch = cmaFieldName then
        begin
            FCol := Grid.GridCols.FindCol(FFieldName);
            if FCol <> nil then
            begin
                FCol.Reset(FGrid.FReadColProperties);
                SetReadColNumber(FCol.DataCol);
            end
            else
            begin
                GetCol;
                SetReadColNumber(0);
            end;
        end;
    end;
end;

function TtsColItem.GetCol: TtsCol;
begin
    if FCol = nil then
    begin
        with TtsColCollection(Collection) do
        begin
            if FTempGrid = nil then
                FTempGrid := TtsBaseGridClass(Grid.ClassType).Create(Grid.Owner);
            FCol := FTempGrid.GridCols[1];
        end;
    end;
    Result := FCol;
end;

{TtsRowItem}

constructor TtsRowItem.Create(Collection: TCollection);
begin
    inherited;
    FRow := nil;
    FSelected := False;
end;

procedure TtsRowItem.SetDataRow(Value: Longint);
begin
    FDataRow := Value;
    with TtsPropCollection(Collection).Grid do
    begin
        GridRows.CreateDataRow(FDataRow);
        FRow := GridRows[FDataRow];
    end;
end;

procedure TtsRowItem.SetDisplayRow(Value: Longint);
begin
    FDisplayRow := Value;
    TtsPropCollection(Collection).Grid.DisplayRownr[DataRow] := Value;
end;

procedure TtsRowItem.SetSelected(Value: Boolean);
begin
    TtsPropCollection(Collection).Grid.RowSelected[DataRow] := Value;
end;

function TtsRowItem.GetSelected: Boolean;
begin
    Result := TtsPropCollection(Collection).Grid.RowSelected[DataRow];
end;

{TtsCellCollection}

constructor TtsCellCollection.Create(Grid: TtsBaseGrid; ItemClass: TCollectionItemClass);
begin
    inherited Create(Grid, ItemClass);
    FCell := CreateCell(Grid);
end;

function TtsCellCollection.CreateCell(Grid: TtsBaseGrid): TtsCell;
begin
    Result := TtsCell.Create(Grid, 0, 0);
end;

destructor TtsCellCollection.Destroy;
begin
    FCell.Free;
    inherited;
end;

procedure TtsCellCollection.ApplyProps;
begin
end;

{TtsCellItem}

constructor TtsCellItem.Create(Collection: TCollection);
begin
    inherited;
    if (not TtsCellCollection(Collection).Grid.Reading)
        then FCell := TtsCellCollection(Collection).Cell
        else FCell := TtsCellCollection(Collection).CreateCell(TtsCellCollection(Collection).Grid);
    FDataCol := 0;
    FDataRow := 0;
end;

destructor TtsCellItem.Destroy;
begin
    if FCell <> TtsCellCollection(Collection).Cell then
        FCell.Free;
    inherited;
end;

function  TtsCellItem.GetCell: TtsCell;
begin
    FCell.DataCol := FDataCol;
    FCell.DataRow := FDataRow;
    Result := FCell;
end;

{Routines to make sure the ComboGrid and -Form disappear when clicked elsewhere}

type
    PMouseHookStruct = ^TMouseHookStruct;
    TMouseHookStruct = Record
        Pt: TPoint;
        Handle: HWND;
        WHitTestCode: UINT;
        DwExtraInfo: DWORD;
    end;

    PCwpStruct = ^TCwpStruct;
    TCwpStruct = Record
        lParam: LPARAM;
        wParam: WPARAM;
        Message: UINT;
        Handle: HWND;
    end;

var
    MouseHook: HHook;
    CwpHook: HHook;
    HookedGrids: TList;

function GetMouseHook(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT stdcall;
var
    I: Integer;
    Finished: Boolean;
    MouseHookStruct: PMouseHookStruct;
    HookedGrid: TtsBaseGrid;
begin
    Result := CallNextHookEx(MouseHook, nCode, wParam, lParam);
    Finished := False;
    for I := HookedGrids.Count downto 1 do
    begin
        if Finished then Break;
        HookedGrid := TtsBaseGrid(HookedGrids[I-1]);
        if HookedGrid <> nil then
        begin
            if (wParam  = WM_NCLBUTTONDOWN) or (wParam = WM_NCRBUTTONDOWN) or
                (wParam  = WM_LBUTTONDOWN) or (wParam = WM_RBUTTONDOWN) then
            begin
                Finished := True;
                MouseHookStruct := PMouseHookStruct(lParam);
                if (MouseHookStruct.Handle <> HookedGrid.Handle) and
                   (MouseHookStruct.Handle <> HookedGrid.Combo.FGrid.Handle) and
                   (MouseHookStruct.Handle <> HookedGrid.FGridControl.Handle) and
                   (not HookedGrid.IsDateTimeHandle(MouseHookStruct.Handle)) then
                begin
                    if (not HookedGrid.InDesignMode) or HookedGrid.DateTimeVisible then
                    begin
                        HookedGrid.CheckDropDownOff(False);
                        Finished := False;
                    end;
                end;
            end;
        end;
    end;
end;

function GetCallWndProcHook(nCode: Integer; wParam: WPARAM; lParam: LPARAM): LRESULT stdcall;
var
    I: Integer;
    CwpStruct: PCwpStruct;
    HookedGrid: TtsBaseGrid;
begin
    Result := CallNextHookEx(CwpHook, nCode, wParam, lParam);
    if nCode < 0 then Exit;

    for I := HookedGrids.Count downto 1 do
    begin
        HookedGrid := TtsBaseGrid(HookedGrids[I-1]);
        if (HookedGrid <> nil) then
        begin
            CwpStruct := PCwpStruct(lParam);

            if (CwpStruct.Message = WM_NCACTIVATE) then
            begin
                if (not HookedGrid.InDesignMode) or HookedGrid.DateTimeVisible then
                    HookedGrid.CheckDropDownOff(False);
            end;
        end;
    end;
end;

procedure HookDropDownHook(HookedGrid: TtsBaseGrid);
begin
    if MouseHook = 0 then
        MouseHook := SetWindowsHookEx(WH_MOUSE, TFNHookProc(@GetMouseHook), 0, GetCurrentThreadID);
    if CwpHook = 0 then
        CwpHook := SetWindowsHookEx(WH_CALLWNDPROC, TFNHookProc(@GetCallWndProcHook), 0, GetCurrentThreadID);
    HookedGrids.Add(HookedGrid);
end;

procedure UnHookDropDownHook(HookedGrid: TtsBaseGrid);
begin
    HookedGrids.Remove(HookedGrid);
    if HookedGrids.Count = 0 then
    begin
        if MouseHook <> 0 then
        begin
            UnhookWindowsHookEx(MouseHook);
            MouseHook := 0;
        end;
        if CwpHook <> 0 then
        begin
            UnhookWindowsHookEx(CwpHook);
            CwpHook := 0;
        end;
    end;
end;

{TtsDropDownForm}

procedure TtsDropDownForm.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);

  if DropDownForm then
  begin
      with Params do
      begin
        Style := 0;
        WndParent := 0;
        if not (csDesigning in Owner.ComponentState) then
            WndParent := TWinControl(Owner).Handle;
        Style := Style or WS_POPUP;
        WindowClass.Style := CS_DBLCLKS;
      end;
  end;
end;

procedure TtsDropDownForm.CreateWnd;
var
    Style: Longint;
begin
    inherited CreateWnd;

    if DropDownForm then
    begin
        Style := WS_CHILD;
        Windows.SetWindowLong(Handle, GWL_STYLE, Style);
    end;
end;

constructor TtsDropDownForm.Create(AOwner: TComponent);
begin
{$IFDEF TSVER_DELPHI}
    CreateNew(AOwner);
{$ENDIF}

{$IFDEF TSVER_CBUILD}
    CreateNew(AOwner, 1);
{$ENDIF}

    Parent := nil;
{$IFDEF TSVER_V3}
    ParentWindow := 0;
{$ENDIF}

    AutoScroll := False;
    DropDownForm := True;
end;

function TtsDropDownForm.SetChildStyleOff: Integer;
begin
    Result := GetWindowLong(Handle, GWL_STYLE);
    SetWindowLong(Handle, GWL_STYLE, Result and not WS_CHILD);
end;

function TtsDropDownForm.SetChildStyleOn: Integer;
begin
    Result := GetWindowLong(Handle, GWL_STYLE);
    SetWindowLong(Handle, GWL_STYLE, Result or WS_CHILD);
end;

procedure TtsDropDownForm.WMEraseBkGnd(var Message: TWMEraseBkGnd);
begin
end;

procedure TtsDropDownForm.WMWindowPosChanged(var Message: TWMWindowPosChanged);
var
    Style: Integer;
begin
    Style := SetChildStyleOff;
    try
        inherited;
    finally
        SetWindowLong(Handle, GWL_STYLE, Style);
    end;
end;

procedure TtsDropDownForm.WMSize(var Message: TWMSize);
var
    Style: Integer;
begin
    Style := SetChildStyleOff;
    try
        inherited;
    finally
        SetWindowLong(Handle, GWL_STYLE, Style);
    end;
end;

procedure TtsDropDownForm.WMMove(var Message: TWMMove);
var
    Style: Integer;
begin
    Style := SetChildStyleOff;
    try
        inherited;
    finally
        SetWindowLong(Handle, GWL_STYLE, Style);
    end;
end;

{TtsGridStreamComponent}

constructor TtsGridStreamComponent.Create(AOwner: TComponent);
begin
    inherited;
    FGrid := TtsBaseGrid(AOwner);
    FSavePropKinds := [];
    FGridCopied := False;
    FSaveData := False;
end;

destructor TtsGridStreamComponent.Destroy;
begin
    if FGridCopied then FGrid.Free;
    inherited;
end;

procedure TtsGridStreamComponent.WriteGrid(Stream: TStream);
begin
    FGrid.SaveAllProps := False;
    try
        Stream.WriteComponent(FGrid);
    finally
        FGrid.SaveAllProps := True;
    end;
end;

procedure TtsGridStreamComponent.ReadGrid(Stream: TStream);
begin
    Stream.ReadComponent(FGrid);
end;

procedure TtsGridStreamComponent.WriteData(Stream: TStream);
begin
    FGrid.WriteData(Stream);
end;

procedure TtsGridStreamComponent.ReadData(Stream: TStream);
begin
    FGrid.ReadData(Stream);
end;

procedure TtsGridStreamComponent.WriteColCount(Writer: TWriter);
begin
    Writer.WriteInteger(FGrid.Cols);
end;

procedure TtsGridStreamComponent.ReadColCount(Reader: TReader);
var
    Count: Longint;
begin
    Count := Reader.ReadInteger;
    if FColMatch = cmaNone then
        FGrid.Cols := Count;
end;

procedure TtsGridStreamComponent.WriteDefaultColwidth(Writer: TWriter);
begin
    Writer.WriteInteger(FGrid.DefaultColWidth);
end;

procedure TtsGridStreamComponent.ReadDefaultColWidth(Reader: TReader);
begin
    FGrid.DefaultColWidth := Reader.ReadInteger;
end;

procedure TtsGridStreamComponent.WriteColumns(Writer: TWriter);
begin
    FGrid.FWriteCols := FGrid.CreateColCollection(True);
    try
        FGrid.WriteColumns(Writer);
    finally
        FGrid.FWriteCols.Free;
        FGrid.FWriteCols := nil;
    end;
end;

procedure TtsGridStreamComponent.ReadColumns(Reader: TReader);
begin
    FGrid.FReadColProperties := Properties;
    try
        FGrid.ReadColCollection(Reader, FColMatch);
    finally
        FGrid.FReadColProperties := [];
    end;
end;

procedure TtsGridStreamComponent.WriteRowCount(Writer: TWriter);
begin
    Writer.WriteInteger(FGrid.Rows);
end;

procedure TtsGridStreamComponent.ReadRowCount(Reader: TReader);
begin
    FGrid.Rows := Reader.ReadInteger;
end;

procedure TtsGridStreamComponent.WriteDefaultRowHeight(Writer: TWriter);
begin
    Writer.WriteInteger(FGrid.DefaultRowHeight);
end;

procedure TtsGridStreamComponent.ReadDefaultRowHeight(Reader: TReader);
begin
    FGrid.DefaultRowHeight := Reader.ReadInteger;
end;

procedure TtsGridStreamComponent.WriteRows(Writer: TWriter);
begin
    FGrid.FWriteRows := FGrid.CreateRowCollection(True);
    try
        FGrid.WriteRows(Writer);
    finally
        FGrid.FWriteRows.Free;
        FGrid.FWriteRows := nil;
    end;
end;

procedure TtsGridStreamComponent.ReadRows(Reader: TReader);
begin
    FGrid.ReadRows(Reader);
end;

procedure TtsGridStreamComponent.WriteCells(Writer: TWriter);
begin
    FGrid.FCellPropCollection := FGrid.CreateCellCollection(True);
    try
        FGrid.WriteCells(Writer);
    finally
        FGrid.FCellPropCollection.Free;
        FGrid.FCellPropCollection := nil;
    end;
end;

procedure TtsGridStreamComponent.ReadCells(Reader: TReader);
begin
    FGrid.ReadCells(Reader);
end;

procedure TtsGridStreamComponent.WriteResetProps(Writer: TWriter);
begin
    Writer.WriteBoolean(True);
end;

procedure TtsGridStreamComponent.ReadResetProps(Reader: TReader);
begin
    if Reader.ReadBoolean then
    begin
        if Properties <> tsAllProperties then
            ResetGrid(SavePropKinds, Properties)
        else if FColMatch = cmaNone then
            FGrid.ResetPropKinds(SavePropKinds)
        else
        begin
            if SavePropKinds <> [pkCols] then FGrid.ResetPropKinds(SavePropKinds - [pkCols]);
            if pkCols in SavePropKinds then ResetGrid([pkCols], Properties);
        end;
    end;
end;

procedure TtsGridStreamComponent.ReadProperties(Reader: TReader);
var
    EnumName: string;
    PropStr: string;
begin
    if TReader_(Reader).NextValue = vaSet then
    begin
        Properties := tsAllProperties;
        Reader.ReadValue;
        while True do
        begin
            EnumName := Reader.ReadStr;
            if EnumName = '' then Break;
        end;
    end
    else
    begin
        PropStr := Reader.ReadString;
        Properties := [];
        CopyMemory(@Properties, PChar(PropStr), CalcMin(SizeOf(Properties), Length(PropStr)));
    end;
end;

procedure TtsGridStreamComponent.WriteProperties(Writer: TWriter);
var
    PropStr: string;
begin
    SetString(PropStr, PChar(@Properties), SizeOf(Properties));
    Writer.WriteString(PropStr);
end;

procedure TtsGridStreamComponent.ReadAllProperties(Reader: TReader);
begin
    AllProperties := Reader.ReadBoolean;
end;

procedure TtsGridStreamComponent.WriteAllProperties(Writer: TWriter);
begin
    Writer.WriteBoolean(AllProperties);
end;

function TtsGridStreamComponent.DoColCount: Boolean;
begin
    Result := (pkCols in SavePropKinds);
end;

function TtsGridStreamComponent.DoRowCount: Boolean;
begin
    Result := FGrid.StoreRows;
    if Result then
        Result := (not (pkGrid in SavePropKinds)) and (pkRows in SavePropKinds);
end;

function TtsGridStreamComponent.DoDefaultColWidth: Boolean;
begin
    Result := (not (pkGrid in SavePropKinds)) and (pkCols in SavePropKinds) and
              (prWidth in Properties);
end;

function TtsGridStreamComponent.DoDefaultRowHeight: Boolean;
begin
    Result := (not (pkGrid in SavePropKinds)) and (pkRows in SavePropKinds) and
              (prHeight in Properties);
end;

procedure TtsGridStreamComponent.DefineProperties(Filer: TFiler);
var
    WriteCollectionProps: Boolean;
begin
    inherited;
    with Filer do
    begin
        DefineProperty('Properties', ReadProperties, WriteProperties, True);
        DefineProperty('AllProperties', ReadAllProperties, WriteAllProperties, True);
        DefineProperty('ResetProps', ReadResetProps, WriteResetProps, True);
        DefineBinaryProperty('Grid', ReadGrid, WriteGrid, pkGrid in SavePropKinds);

        if csWriting in ComponentState then
        begin
            if Properties <> tsAllProperties then
            begin
                CopyGrid(SavePropKinds);
                ResetGrid(SavePropKinds, tsAllProperties - Properties);
            end;
        end;

        {$IFNDEF TSVER_V3}
        WriteCollectionProps := False;
        {$ELSE}
        WriteCollectionProps := True;
        {$ENDIF}

        DefineProperty('Cols', ReadColCount, WriteColCount, DoColCount);
        DefineProperty('Rows', ReadRowCount, WriteRowCount, DoRowCount);
        DefineProperty('DefaultColWidth', ReadDefaultColWidth, WriteDefaultColWidth, DoDefaultColWidth);
        DefineProperty('DefaultRowHeight', ReadDefaultRowHeight, WriteDefaultRowHeight, DoDefaultRowHeight);

        DefineProperty('ColProperties', ReadColumns, WriteColumns, WriteCollectionProps and (pkCols in SavePropKinds));
        DefineProperty('RowProperties', ReadRows, WriteRows, WriteCollectionProps and (pkRows in SavePropKinds));
        DefineProperty('CellProperties', ReadCells, WriteCells, WriteCollectionProps and (pkCells in SavePropKinds));
        DefineBinaryProperty('Data', ReadData, WriteData, SaveData and FGrid.StoreData);
    end;
end;

procedure TtsGridStreamComponent.CopyGrid(PropKinds: TtsPropKinds);
var
    NewGrid: TtsBaseGrid;
begin
    NewGrid := TtsBaseGridClass(FGrid.ClassType).Create(FGrid.Owner);
    NewGrid.Visible := False;
    NewGrid.Parent := FGrid.Parent;
    NewGrid.AssignPropKinds(FGrid, tsAllPropKinds, SaveData);

    FGrid := NewGrid;
    FGridCopied := True;
end;

procedure TtsGridStreamComponent.ResetGrid(PropKinds: TtsPropKinds; Properties: TtsProperties);
begin
    if (pkCols in PropKinds) and (FGrid.FColMatch = cmaNone) then
        FGrid.ResetColProperties(Properties);
    if pkRows in PropKinds then FGrid.ResetRowProperties(Properties);
    if pkCells in PropKinds then FGrid.ResetCellProperties(Properties);
end;

procedure TtsGridStreamComponent.SetAllProperties(Value: Boolean);
begin
    FAllProperties := Value;
    if Value then Properties := tsAllProperties;
end;

{TtsCombo}

constructor TtsCombo.Create(ParentGrid: TtsBaseGrid);
begin
    inherited Create;

    FGrid := ParentGrid.CreateComboGrid;
    FGrid.Parent := TForm(ParentGrid.ComboForm);
    FGrid.ParentGridCombo := Self;
    FGrid.Visible := False;

    if not FGrid.Reading then
    begin
        ParentGrid.InitializeComboSettings(FGrid);
        ParentGrid.InitCombo(Self);
    end;
end;

destructor TtsCombo.Destroy;
begin
    FGrid.Free;
    inherited Destroy;
end;

procedure TtsCombo.Assign(Source: TPersistent);
begin
    if Source is TtsCombo
        then FGrid.Assign(TtsCombo(Source).FGrid)
        else inherited;
end;

procedure TtsCombo.Reset;
begin
    with Grid.ParentGrid do
    begin
        Grid.EnablePaint := False;
        Grid.SetComboExtents := False;
        try
            CheckResetComboInit(Self, False);
            Grid.Reset;
        finally
            Grid.SetComboExtents := True;
            Grid.EnablePaint := True;
        end;

        if ComboVisible then
            Grid.AdjustComboGridExtents(Self.DropDownCols, Self.DropDownRows);
    end;
end;

function TtsCombo.GetDropDownRows: Longint;
begin
    Result := Grid.DropDownRows;
end;

function TtsCombo.GetDropDownCols: Longint;
begin
    Result := Grid.DropDownCols;
end;

function TtsCombo.GetComboDisplayCol: Longint;
begin
    Result := Grid.FComboDisplayCol;
end;

function TtsCombo.GetValueCol: Longint;
begin
    Result := Grid.ValueCol;
end;

function TtsCombo.GetValueColSorted: Boolean;
begin
    Result := Grid.ValueColSorted;
end;

function TtsCombo.GetCompareType: TtsComboCompareType;
begin
    Result := Grid.CompareType;
end;

function TtsCombo.GetAutoSearch: TtsComboAutoSearchType;
begin
    Result := Grid.AutoSearch;
end;

function TtsCombo.GetAutoFill: Boolean;
begin
    Result := Grid.AutoFill;
end;

function TtsCombo.GetAutoFillConvertCase: TtsConvertCase;
begin
    Result := Grid.AutoFillConvertCase;
end;

function TtsCombo.GetAutoLookup: Boolean;
begin
    Result := Grid.AutoLookup;
end;

function TtsCombo.GetDropDownStyle: TtsDropDownStyle;
begin
    Result := Grid.DropDownStyle;
end;

function TtsCombo.GetGrid: TtsComboGrid;
begin
    Result := TtsComboGrid(FGrid);
end;

procedure TtsCombo.SetDropDownRows(Value: Longint);
begin
    if Value <> Grid.DropDownRows then Grid.DropDownRows := Value;
end;

procedure TtsCombo.SetDropDownCols(Value: Longint);
begin
    if Value <> Grid.DropDownCols then Grid.DropDownCols := Value;
end;

procedure TtsCombo.SetComboDisplayCol(Value: Longint);
begin
    if Value <> Grid.ComboDisplayCol then Grid.FComboDisplayCol := Value;
end;

procedure TtsCombo.SetValueCol(Value: Longint);
begin
    if Value <> Grid.ValueCol then Grid.ValueCol := Value;
end;

procedure TtsCombo.SetValueColSorted(Value: Boolean);
begin
    if Value <> Grid.ValueColSorted then Grid.ValueColSorted := Value;
end;

procedure TtsCombo.SetCompareType(Value: TtsComboCompareType);
begin
    if Value <> Grid.CompareType then Grid.CompareType := Value;
end;

procedure TtsCombo.SetAutoSearch(Value: TtsComboAutoSearchType);
begin
    if Value <> Grid.AutoSearch then Grid.AutoSearch := Value;
end;

procedure TtsCombo.SetAutoFill(Value: Boolean);
begin
    if Value <> Grid.AutoFill then Grid.AutoFill := Value;
end;

procedure TtsCombo.SetAutoFillConvertCase(Value: TtsConvertCase);
begin
    if Value <> Grid.AutoFillConvertCase then Grid.AutoFillConvertCase := Value;
end;

procedure TtsCombo.SetAutoLookup(Value: Boolean);
begin
    if Value <> Grid.AutoLookup then Grid.AutoLookup := Value;
end;

procedure TtsCombo.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    if Value <> Grid.DropDownStyle then Grid.DropDownStyle := Value;
end;

{TtsComboGrid}

constructor TtsComboGrid.Create(AOwner: TComponent);
begin
    inherited Create(AOwner);

    FAsCombo := True;
    FGrid := Self;
    Parent := TWinControl(AOwner);
    ParentGrid := TtsBaseGrid(Parent.Owner);

    if not Reading then
    begin
        Ctl3D := False;
        ParentCtl3D := False;
    end;

    FDropDownRows := 4;
    FDropDownCols := 1;
    FDropDownStyle := ddDropDown;
    FValueCol := 1;
    FComboDisplayCol := 1;
    FCompareType := ctCaseInsensitive;
    FAutoSearch := asNone;
    FAutoFill := False;
    FAutoFillConvertCase := afcOnedit;
end;

destructor TtsComboGrid.Destroy;
begin
    FGrid := nil;
    inherited Destroy;
end;

function TtsComboGrid.GetDropDownRows: Longint;
begin
    Result := FDropDownRows;
end;

function TtsComboGrid.GetDropDownCols: Longint;
begin
    Result := FDropDownCols;
end;

function TtsComboGrid.GetComboDisplayCol : Longint;
begin
    Result := FComboDisplayCol;
end;

function TtsComboGrid.GetValueCol: Longint;
begin
    Result := FValueCol;
end;

function TtsComboGrid.GetValueColSorted: Boolean;
begin
    Result := FValueColSorted;
end;

function TtsComboGrid.GetCompareType: TtsComboCompareType;
begin
    Result := FCompareType;
end;

function TtsComboGrid.GetAutoSearch: TtsComboAutoSearchType;
begin
    Result := FAutoSearch;
end;

function TtsComboGrid.GetAutoFill: Boolean;
begin
    Result := FAutoFill;
end;

function TtsComboGrid.GetAutoFillConvertCase: TtsConvertCase;
begin
    Result := FAutoFillConvertCase;
end;

function TtsComboGrid.GetAutoLookup: Boolean;
begin
    Result := False;
end;

function TtsComboGrid.GetDropDownStyle: TtsDropDownStyle;
begin
    Result := FDropDownStyle;
end;

function TtsComboGrid.GetGrid: TtsComboGrid;
begin
    Result := TtsComboGrid(FGrid);
end;

procedure TtsComboGrid.SetDropDownRows(Value: Longint);
begin
    if Value <> FDropDownRows then
    begin
        FDropDownRows := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

procedure TtsComboGrid.SetDropDownCols(Value: Longint);
begin
    if Value <> FDropDownCols then
    begin
        FDropDownCols := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

procedure TtsComboGrid.SetComboDisplayCol(Value: Longint);
begin
    if Value <> FComboDisplayCol then FComboDisplayCol := Value;
end;

procedure TtsComboGrid.SetValueCol(Value: Longint);
begin
    if Value <> FValueCol then FValueCol := Value;
end;

procedure TtsComboGrid.SetValueColSorted(Value: Boolean);
begin
    if Value <> FValueColSorted then FValueColSorted := Value;
end;

procedure TtsComboGrid.SetCompareType(Value: TtsComboCompareType);
begin
    if Value <> FCompareType then FCompareType := Value;
end;

procedure TtsComboGrid.SetAutoSearch(Value: TtsComboAutoSearchType);
begin
    if Value <> FAutoSearch then FAutoSearch := Value;
end;

procedure TtsComboGrid.SetAutoFill(Value: Boolean);
begin
    if Value <> FAutoFill then
    begin
        FAutoFill := Value;
        if FAutoFill and not (csLoading in ComponentState) then
        begin
            if (AutoSearch = asNone) then AutoSearch := asTop;
        end;
    end;
end;

procedure TtsComboGrid.SetAutoFillConvertCase(Value: TtsConvertCase);
begin
    if FAutoFillConvertCase <> Value then FAutoFillConvertCase := Value;
end;

procedure TtsComboGrid.SetAutoLookup(Value: Boolean);
begin
end;

procedure TtsComboGrid.SetDropDownStyle(Value: TtsDropDownStyle);
begin
    if FDropDownStyle <> Value then
    begin
        FDropDownStyle := Value;
        ParentGrid.RedisplayControl(True);
    end;
end;

function TtsComboGrid.GetParentGrid: TtsBaseGrid;
begin
    Result := FParentGrid;
end;

procedure TtsComboGrid.SetParentGrid(Value: TtsBaseGrid);
begin
    FParentGrid := Value;
end;

function TtsComboGrid.GetParentGridCombo: TtsCombo;
begin
    Result := FCombo;
end;

procedure TtsComboGrid.SetParentGridCombo(Value: TtsCombo);
begin
    FCombo := Value;
end;

{TtsCustomButton}

constructor TtsCustomButton.Create(Grid: TtsBaseGrid; Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    FGrid := Grid;
    FBitmap := Bmp;
    FTransparentColor := TransparentColor;
    FHeight := Height;
    FWidth := Width;
end;

function TtsCustomButton.GetBitmap: TBitmap;
begin
    Result := FBitmap;
end;

function TtsCustomButton.GetHeight: Integer;
begin
    Result := FHeight;
end;

function TtsCustomButton.GetWidth: Integer;
begin
    Result := FWidth;
end;

function TtsCustomButton.GetTransparentColor: TColor;
begin
    Result := FTransparentColor;
end;

procedure TtsCustomButton.SetBitmap(Value: TBitmap);
begin
    FBitmap := Value;
end;

procedure TtsCustomButton.SetHeight(Value: Integer);
begin
    FHeight := Value;
end;

procedure TtsCustomButton.SetWidth(Value: Integer);
begin
    FWidth := Value;
end;

procedure TtsCustomButton.SetTransparentColor(Value: TColor);
begin
    FTransparentColor := Value;
end;

function TtsCustomButton.FullWidth: Integer;
begin
    Result := FWidth + (2 * FGrid.ButtonEdgeWidth);
end;

function TtsCustomButton.FullHeight: Integer;
begin
    Result := FHeight + (2 * FGrid.ButtonEdgeWidth)
end;

function TtsCustomButton.IsDefault: Boolean;
begin
    Result := True;
end;

{TtsComboButton}

constructor TtsComboButton.Create(Grid: TtsBaseGrid; Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    inherited Create(Grid, nil, TransparentColor, Width, Height);

    FBitmap := nil;
    if Bmp <> BitMapCombo then
    begin
        FBitmap := TBitmap.Create;
        FBitmap.Assign(bmp);
    end;
end;

destructor TtsComboButton.Destroy;
begin
    if FBitmap <> nil then
    begin
        if FBitmap.Handle <> BitmapCombo.Handle then
        begin
            FBitmap.Free;
            FBitmap := nil;
        end;
    end;
    inherited Destroy;
end;

function TtsComboButton.GetBitmap: TBitmap;
begin
    if FBitmap = nil
        then Result := BitmapCombo
        else Result := FBitmap;
end;

function TtsComboButton.IsDefault: Boolean;
begin
    Result := Bitmap = BitmapCombo;
end;

{TtsNormalButton}

constructor TtsNormalButton.Create(Grid: TtsBaseGrid; Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    inherited Create(Grid, nil, TransparentColor, Width, Height);

    FBitmap := nil;
    if Bmp <> BitMapButtonDetail then
    begin
        FBitmap := TBitmap.Create;
        FBitmap.Assign(Bmp);
    end;
end;

destructor TtsNormalButton.Destroy;
begin
    if FBitmap <> nil then
    begin
        if FBitmap.Handle <> BitMapButtonDetail.Handle then
        begin
            FBitmap.Free;
            FBitmap := nil;
        end;
    end;
    inherited Destroy;
end;

function TtsNormalButton.GetBitmap: TBitmap;
begin
    if FBitmap = nil
        then Result := BitMapButtonDetail
        else Result := FBitmap;
end;

function TtsNormalButton.IsDefault: Boolean;
begin
    Result := Bitmap = BitMapButtonDetail;
end;

{TtsVertSpinButton}

function TtsVertSpinButton.FullHeight: Integer;
begin
    Result := (2 * FHeight) + 1;
end;

{TtsHorzSpinButton}

function TtsHorzSpinButton.FullWidth: Integer;
begin
    Result := (2 * FWidth) + 1;
end;

{TtsDateTimeButton}

constructor TtsDateTimeButton.Create(Grid: TtsBaseGrid; Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    inherited Create(Grid, nil, TransparentColor, Width, Height);

    FBitmap := nil;
    if Bmp = BitMapButtonDetail then
        FDetailButton := True
    else if Bmp = BitMapCombo then
        FDetailButton := False
    else
    begin
        FDetailButton := False;
        FBitmap := TBitmap.Create;
        FBitmap.Assign(Bmp);
    end;
end;

destructor TtsDateTimeButton.Destroy;
begin
    if FBitmap <> nil then
    begin
        if (FBitmap.Handle <> BitMapButtonDetail.Handle) and
           (FBitmap.Handle <> BitMapCombo.Handle) then
        begin
            FBitmap.Free;
            FBitmap := nil;
        end;
    end;
    inherited Destroy;
end;

function TtsDateTimeButton.GetBitmap: TBitmap;
begin
    if FBitmap <> nil then
        Result := FBitmap
    else if FDetailButton then
        Result := BitMapButtonDetail
    else
        Result := BitmapCombo;
end;

function TtsDateTimeButton.IsDefault: Boolean;
begin
    Result := (Bitmap = BitMapButtonDetail) or (Bitmap = BitmapCombo);
end;

{TtsGridMaskLink}

constructor TtsGridMaskLink.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
end;

{TtsGridImageLink}

constructor TtsGridImageLink.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
end;

procedure TtsGridImageLink.ImageChanged(Image: TtsImageItem);
begin
    FGrid.ImageChanged(Image);
end;

procedure TtsGridImageLink.ImageListDeleted;
begin
    FGrid.ImageListDeleted;
end;

{TtsGridDateTimeLink}

constructor TtsGridDateTimeLink.Create(Grid: TtsBaseGrid);
begin
    inherited Create;
    FGrid := Grid;
end;

procedure TtsGridDateTimeLink.DateTimeDefDeleted(DateTimeDef: TtsDateTimeDefComponent);
begin
    inherited;
    FGrid.DateTimeDefDeleted(DateTimeDef);
end;

{TtsBaseGrid}

{$INCLUDE TSChkVer}

constructor TtsBaseGrid.Create(AOwner: TComponent);
begin
    CheckVersion;
    inherited Create(AOwner);

    //ControlStyle := ControlStyle + [csNeedsBorderPaint];
    FDesigning := False;
    FSetComboExtents := 0;
    FSaveAllProps := 0;
    FReading := False;
    FWriting := False;
    FSaveTtsBaseGridProp := True;
    ResetLastCell;
    FWriteCols := nil;
    FWriteRows := nil;
    FCellPropCollection := nil;
    FColMatch := cmaNone;
    FReadColProperties := [];
    FReadColNumbers := nil;
    FExportDelimiter := ',';
    FPrintLinesPerPage := 40;
    FPrintOrientation := pmLandscape;
    FPrintTotals := True;
    FPrintWithGridFormats := True;
    FProvideGridMenu := False;
    FAlwaysDetectButton := False;
    FXMLExport := TosXMLExport.Create;

    {$IFNDEF TSVER_V3}
    FStoredPropKinds := [];
    FStoredCols := TtsColCollection.Create(Self, TtsColItem);
    FStoredRows := TtsPropCollection.Create(Self, TtsRowItem);
    FStoredCells := TtsCellCollection.Create(Self, TtsCellItem);
    {$ENDIF}

    CreateDefaultColNumber(0);
    CreateDefaultRowNumber(0);
    FGridCols := CreateCols;
    FGridRows := CreateRows;
    FCurrentCell := CreateCurrentCell;
    FColCells := TtsIntegerSetList.Create;
    FRowCells := TtsIntegerSetList.Create;
    ResizeCellPropArrays(0,0);
    FCellPropSet := TtsCellPropSet.CreateNew(Self);
    FMaskLink := TtsGridMaskLink.Create(Self);
    FImageLink := TtsGridImageLink.Create(Self);
    FImageListIds := TStringList.Create;
    FPictureColorMask := nil;
    FDateTimeDef := nil;
    FDateTimeLink := TtsGridDateTimeLink.Create(Self);
    FMouseOverGrid := False;

    FAutoFontCols := TtsIntegerList.Create;
    FAutoFontRows := TtsIntegerList.Create;
    FAutoFontCells := TtsCoordList.Create;
    CreateDefaultValues;
    CreateRowColSelections;
    CreateGridControls;

    FVisibleCols := TtsVisibleItems.Create;
    FVisibleRows := TtsVisibleItems.Create;
    ResizeVisibleCols(0);
    ResizeVisibleRows(0);

    FGridStatus := grNormal;
    FMouseStatus := msNormal;
    FOldGridStatus := FGridStatus;
    FOldMouseStatus := FMouseStatus;
    FResizeDoubleClicked := False;
    FFirstTimePainted := False;
    FSkipReadOnly := True;
    FRowChangedIndicator := riOn;
    FAlwaysShowEditor := True;
    FAlwaysShowFocus := False;
    FControlSet := False;
    FControlHidden := True;
    FControlEnabled := FAlwaysShowEditor;
    FEditSelect := tsNone;
    FInPutInView := False;
    FInUpdateScrollRange := False;
    
    FSetBounds := False;
    FInCellLoaded := False;
    FInDoCellLoaded := False;
    FDcPrepared := False;
    FDoInitCanvas := True;
    FInPaintWindow := False;
    FSetGridControlVisible := False;
    FMouseDownToControl := False;
    CreateNullRect;
    FGridControl := FEditControl;
    FGridControl.Parent := Self;
    FChangedRows := TBits.Create;
    FChangedRows.Size := RowCount;
    FCurRowChanged := False;
    FCellEditing := False;
    FRowEditing := False;
    FRowEdited := False;
    FInsertRowEdit := False;
    FInUndoEdit := False;
    FSelectionColor := clHighlight;
    FSelectionFontColor := clHighlightText;
    FSelectionType := sltDefault;
    FPictureMaskRGBColor := 0;
    FFocusBorder := fbDot;
    FFocusColor := clNone;
    FFocusBorderColor := clNone;
    FFocusFontColor := clNone;
    FCheckMouseFocus := True;
    FCheckBoxValues := '';
    FAlwaysShowScrollBar := ssNone;
    FAutoScale := False;
    CheckPictureMask(False);

    inherited ScrollBars := ssNone;
    FIsHorzVisible := False;
    FIsVertVisible := False;
    FScrollBars := ssBoth;
    FWordWrap := wwDefault;
    FReadOnlyButton := True;
    FTabRowWrap := True;
    FWantTabs := True;
    FFlatButtons := True;
    FRowBarIndicator := True;
    FRaiseErrors := True;
    FStoreData := False;

    FDrawBitmap := nil;
    FDrawFont := nil;
    FComboButton := nil;
    FNormalButton := nil;
    FVertSpinButton := nil;
    FHorzSpinButton := nil;
    FDateTimeDropDownButton := nil;
    FDateTimePopupButton := nil;

    FStretchPicture := True;
    FShrinkPicture := True;
    FTransparentColor := clNone;
    FCenterPicture := True;
    FKeepAspectRatio := False;
    FLastUsedCombo := nil;
    FLastUsedDateTime := nil;
    FGridData := nil;
    FMouseDownOccured := False;
end;

destructor TtsBaseGrid.Destroy;
begin
    if not (csDestroying in ComponentState) then Destroying;

    StopTimer(FButtonTimer);
    CheckDropDownOff(False);
    if Assigned(FCombo) and (HookedGrids.IndexOf(FCombo.FGrid) >= 0) then
        UnHookDropDownHook(FCombo.FGrid);

    FAutoFontCols.Free;
    FAutoFontRows.Free;
    FAutoFontCells.Free;
    FMaskLink.Free;
    FImageLink.Free;
    FImageListIds.Free;
    FEditControl.Free;
    FCheckControl.Free;
    FPictureControl.Free;
    FDefaultControl.Free;
    FChangedRows.Free;
    FSelectedRows.Free;
    FSelectedCols.Free;
    FVisibleCols.Free;
    FVisibleRows.Free;
    FPictureColorMask.Free;

    ResetGridDc;
    DeleteRowColProperties;
    DeleteAllCellProperties;
    FComboButton.Free;
    FNormalButton.Free;
    FVertSpinButton.Free;
    FHorzSpinButton.Free;
    FDateTimeDropDownButton.Free;
    FDateTimePopupButton.Free;
    FDrawBitmap.Free;
    FDrawFont.Free;
    FHeadingFont.Free;
    FCombo.Free;
    FGridData.Free;

    DateTimeDef := nil;
    FDateTimeLink.Free;
    FCellPropCollection.Free;

    {$IFNDEF TSVER_V3}
    FStoredCols.Free;
    FStoredRows.Free;
    FStoredCells.Free;
    {$ENDIF}
    FGridMenu.Free;
    FXMLExport.Free;

    inherited Destroy;
end;

function TtsBaseGrid.GetVersion: string;
begin
    Result := VersionNumber;
end;

procedure TtsBaseGrid.SetVersion(Value: string);
begin
end;

procedure TtsBaseGrid.CreateDefaultValues;
begin
    FInStartingMode := True;

    FInsertionRow := 0;
    FOldInsertionRow := 0;
    FDrawOverlap := doDrawColOnTop;
    FInScrollingMode := False;
    Options := [];
    FEditMode := emEdit;
    FGridMode := gmEdit;
    FColSelectMode := csMulti;
    FRowSelectMode := rsMulti;
    FCellSelectMode := cmRange;
    FColMoving := True;
    FRowMoving := True;
    FResizeRows := rrAll;
    FResizeCols := rcSingle;
    FResizeRowsInGrid := False;
    FResizeColsInGrid := False;
    FGridLines := glBoth;
    FFocusLineOnVertFixed := False;
    FFocusLineOnHorzFixed := False;
    FInChangingAllRowHeights := False;
    FInChangingAllColWidths := False;
    FInResizingHeading := False;
    FInResizingRowBar := False;
    FScaledRowHeight := 14;
    DefaultRowHeight := 14;
    FOldDefaultRowHeight := DefaultRowHeight;
    DefaultColWidth := 64;
    FOldDefaultColWidth := 64;
    GridCols[0].Width := 14;
    GridRows[0].Height := 15;
    Cursor := crDefault;
    FCurDisplayCol := 1;
    FCurDisplayRow := 1;
    FPrevDisplayCol := 1;
    FPrevDisplayRow := 1;
    FCurDataCol := 1;
    FCurDataRow := 1;
    FOldDataCol := 1;
    FOldDataRow := 1;
    FOldTopLeft.X := 1;
    FOldTopLeft.Y := 1;
    DefaultDrawing := False;
    FCols := DefaultColCount;
    FRows := DefaultRowCount;
    FCurDeletedCols := 0;
    FCurDeletedRows := 0;
    ColCount := FCols + 1;
    RowCount := FRows + 1;
    FOldRowBarWidth := 14;
    FOldHeadingHeight := 15;
    FLabelOrHeadingChanged := False;
    FixedCols := 1;
    FixedRows := 1;
    FFixedColCount := 0;
    FInternalFixedCols := 0;
    FFixedRowCount := 0;
    FInternalFixedRows := 0;
    FSelectFixed := True;
    FHorzFixedWidth := RowBarWidth;
    FVertFixedHeight := HeadingHeight;
    GridLineWidth := 0;
    FEditColor := clNone;
    FEditFontColor := clNone;
    FLineColor := clSilver;
    FHeadingColor := clBtnFace;
    FSelectedAreaCursor := crDefault;
    FFixedLineColor := clBlack;
    FHorzLineWidth := 1;
    FVertLineWidth := 1;
    FTopLeftChanged := False;
    FInTopLeftChanged := 0;
    FEnablePaintCount := 0;
    FEnableRedrawCount := 0;
    FFocusRectDisabled := 0;
    FFastAssignCount := 0;
    FAssigning := False;
    FEnableStartEditCount := 0;
    FDoUpdateScrollRange := False;
    FForceUpdateScrollRange := False;
    FDoUpdateScrollPos := False;
    FInScrolling := False;
    FInMouseMove := False;
    FInGetCell := False;
    FScrollSpeed := spVariable;
    FScrollDelayStart := 0;
    FMinWaitingTime := MinWaitingTime;
    FMaxWaitingTime := MaxWaitingTime;
    FCellDrawn.X := -1;
    FCellDrawn.Y := -1;
    FDrawSelectCell.X := -1;
    FDrawSelectCell.Y := -1;
    FDrawCellSelected := False;
    FInHidingGridControl := False;
    FSkipColWidthsChanged := False;
    FSkipRowHeightsChanged := False;
    FColMoveVisible := False;
    FRowMoveVisible := False;
    FDisplayAsControl := False;
    FScrollMode := smWindow;
    FThumbTracking := False;
    FIs3D := False;
    FHeading3D := True;
    FButtonUp.X := -1;
    FButtonUp.Y := -1;
    FButtonDown.X := -1;
    FButtonDown.Y := -1;
    FDownSpinButton := spbNone;
    FSpinRepeatCount := 0;
    FButtonClicked := False;
    FSpinButtonClicked := spbNone;
    FDropDownCol := -1;
    FDropDownRow := -1;
    FCombo := nil;
    FComboForm := nil;
    FDateTimeForm := nil;
    FInactiveButtonState := ibsBackGround;
    FButtonEdgeWidth := 2;
    FDefaultButtonWidth := 11;
    FDefaultButtonHeight := 9;
    FSpinButtonWidth := 11;
    FSpinButtonHeight := 9;
    FSpinStartDelay := 500;
    FSpinRepeatDelay := 80;
    FUseSpinStartDelay := True;
    FComboInitialized := False;
    FInComboInit := False;
    FDateTimeInitialized := False;
    FDateTimeDateSelected := False;
    FDateTimeDateCanceled := False;
    FDateTimeDisplayed := False;
    FAsCombo := False;
    FMouseDownToCombo := false;
    FIgnoreScrolling := false;
    FHeadingClicked := -1;
    FHeadingButtonClicked := false;
    FDrawHeadingButtonDown := false;
    FHasKeyFocus := False;
    FComboSearchValue := '';
    FLastIncrSearchTime := 0;
    FButtonTimer := 0;
    FSpinTimer := 0;
    FInCheckEndEdit := False;
    FSetCursor := True;
    FInSetFocus := 0;
    FInDoExit := 0;
    FCanProcessKey := 0;

    FHeadingButton := hbNone;
    FHeadingAlignment := taLeftJustify;
    FHeadingHorzAlignment := htaDefault;
    FHeadingVertAlignment := vtaDefault;
    FHorzAlignment := htaDefault;
    FVertAlignment := vtaDefault;
    FRowBarAlignment := vtaDefault;
    FHeadingWordWrap := wwDefault;
    FHeadingFont := TFont.Create;
    FHeadingFont.Assign(Font);
    FHeadingFont.OnChange := HeadingFontChange;
    FHeadingParentFont := True;

    FInStartingMode := False;
end;

procedure TtsBaseGrid.CreateDefaultColNumber(OldColCount: Longint);
var
    I: Longint;
begin
    ReAllocMem(FDataColNumber, ColCount * SizeOf(Longint));

    if ColCount > OldColCount then
    begin
        for I := OldColCount to ColCount - 1 do
        begin
            FDataColNumber[I] := I;
        end;
    end;
end;

procedure TtsBaseGrid.CreateDefaultRowNumber(OldRowCount: Longint);
var
    I: Longint;
begin
    ReAllocMem(FDataRowNumber, RowCount * SizeOf(Longint));

    if RowCount > OldRowCount then
    begin
        for I := OldRowCount to RowCount - 1 do
        begin
            FDataRowNumber[I] := I;
        end;
    end;
end;

procedure TtsBaseGrid.ResizeVisibleCols(OldSize: Longint);
var
    NewSize, Pos: Longint;
    Found: Boolean;
begin
    if ColCount - 1 > OldSize then
        NewSize := FVisibleCols.Count + ColCount - 1 - OldSize
    else
    begin
        Pos := FVisibleCols.Locate(ColCount, Found);
        NewSize := Pos - 1;
    end;

    FVisibleCols.SetSize(NewSize, OldSize + 1);
end;

procedure TtsBaseGrid.ResizeVisibleRows(OldSize: Longint);
var
    NewSize, Pos: Longint;
    Found: Boolean;
begin
    if RowCount - 1 > OldSize then
        NewSize := FVisibleRows.Count + RowCount - 1 - OldSize
    else
    begin
        Pos := FVisibleRows.Locate(RowCount, Found);
        NewSize := Pos - 1;
    end;

    FVisibleRows.SetSize(NewSize, OldSize + 1)
end;

function TtsBaseGrid.CreateCols: TtsGridCols;
begin
    Result := TtsGridCols.Create(ColCount, Self);
end;

function TtsBaseGrid.CreateRows: TtsGridRows;
begin
    Result := TtsGridRows.Create(RowCount, Self);
end;

function TtsBaseGrid.CreateCurrentCell: TtsCurrentCell;
begin
    Result := TtsCurrentCell.Create(Self);
end;

procedure TtsBaseGrid.CreateRowColSelections;
var
    SelectType: TtsSelectType;
begin
    FSelectedRows := TtsSelection.Create;
    FSelectedRows.SetSize(RowCount);
    FSelectedCols := TtsSelection.Create;
    FSelectedCols.SetSize(ColCount);
    FSelectedCells := Rect(0, 0, 0, 0);
    FInActivateRowChanges := False;
    FInActivateColChanges := False;

    for SelectType := Low(TtsSelectType) to High(TtsSelectType) do
    begin
        FSelectChanged[SelectType] := False;
    end;
end;

procedure TtsBaseGrid.SetGridControlParent;
begin
    if not HandleAllocated then Exit;

    if Parent = nil then
    begin
        if Assigned(FEditControl.Parent) then FEditControl.Parent := nil;
        if FEditControl.ParentWindow <> Handle then FEditControl.ParentWindow := Handle;
        if Assigned(FCheckControl.Parent) then FCheckControl.Parent := nil;
        if FCheckControl.ParentWindow <> Handle then FCheckControl.ParentWindow := Handle;
    end
    else
    begin
        if FEditControl.ParentWindow <> 0 then FEditControl.ParentWindow := 0;
        if FEditControl.Parent <> Self then FEditControl.Parent := Self;
        if FCheckControl.ParentWindow <> 0 then FCheckControl.ParentWindow := 0;
        if FCheckControl.Parent <> Self then FCheckControl.Parent := Self;
    end;
end;

procedure TtsBaseGrid.CreateGridControls;
begin
    FEditControl := TtsEditGridControl.Create(Self);
    FEditControl.Grid := Self;
    FEditControl.Top := -(FEditControl.Height + 1);
    FEditControl.LeftMargin := tsRangeSelectWidth;
    FEditControl.Cursor := Cursor;
    SetControlEvents(FEditControl);

    FCheckControl := TtsCheckGridControl.Create(Self);
    FCheckControl.Grid := Self;
    FCheckControl.Top := -(FEditControl.Height + 1);
    FCheckControl.LeftMargin := tsRangeSelectWidth;
    FCheckControl.Cursor := Cursor;
    FCheckBoxStyle := stCheck;
    FCheckControl.AllowGrayed := False;
    FCheckControl.CheckBoxStyle := TtsGridCheckBoxStyle(FCheckBoxStyle);
    FCheckControl.CheckBoxValues := CheckBoxValues;
    SetControlEvents(FCheckControl);

    FPictureControl := TtsDefaultGridControl.Create(Self);
    FDefaultControl := TtsDefaultGridControl.Create(Self);
end;

procedure TtsBaseGrid.CreateWnd;
begin
    inherited;
    SetGridControlParent;
    SetCurrentPosition(FCurDisplayCol, FCurDisplayRow, True, True);
    FGridControl.Visible := False;
    SetControlSelectMode(tsAll);
    ShowGridControl;
    UpdateScrollRange;
end;

procedure TtsBaseGrid.CreateNullRect;
begin
    FNullRect.Left := 0;
    FNullRect.Top := 0;
    FNullRect.Right := 0;
    FNullRect.Bottom := 0;
end;

function TtsBaseGrid.DefaultColCount: Longint;
begin
    Result := 4;
end;

function TtsBaseGrid.DefaultRowCount: Longint;
begin
    Result := 4;
end;

procedure TtsBaseGrid.SetControlEvents(GridControl: TtsCustomGridControl);
begin
    with GridControl do
    begin
        OnEndKeyDown := CtrlOnEndKeyDown;
        OnEndKeyPress := CtrlOnEndKeyPress;
        OnNotifyChanged := CtrlOnNotifyChanged;
        OnChanged := CtrlOnChanged;
        OnEdit := CtrlOnEdit;
        OnCanChange := CtrlOnCanChange;
        OnUndoChanged := CtrlOnUndoChanged;
        OnKeyDown := CtrlOnKeyDown;
        OnKeyUp := CtrlOnKeyUp;
        OnKeyPress := CtrlOnKeyPress;
        OnClick := CtrlOnClick;
        OnDblClick := CtrlOnDblClick;
        OnMouseDown := CtrlOnMouseDown;
        OnMouseUp := CtrlOnMouseUp;
        OnMouseMove := CtrlOnMouseMove;
        OnDragDrop := CtrlOnDragDrop;
        OnDragOver := CtrlOnDragOver;
        OnEndDrag := CtrlOnEndDrag;
        OnStartDrag := CtrlOnStartDrag;
        OnKillFocus := CtrlOnKillFocus;
        OnWantKey := CtrlOnWantKey;
        OnInvalidMaskEdit := CtrlOnInvalidMaskEdit;
        OnEditTextResized := CtrlOnEditTextResized;
    end;
end;

procedure TtsBaseGrid.AssignProperties(Source: TtsBaseGrid; ExcludeProps: string);
var
    NoAssignProps: string;
begin
    NoAssignProps := ExcludeProps + 'Height;Left;Name;Top;Width;Visible;TabOrder;DefaultColWidth;DefaultRowHeight;Datasource;';
    NoAssignProps := NoAssignProps + 'ColProperties;RowProperties;CellProperties;Constraints';
    if FAsCombo then NoAssignProps := NoAssignProps + ';RowSelectMode;GridMode';
    AssignObject(Self, Source, NoAssignProps);

    ExcludeProps := AnsiLowerCase(ExcludeProps);
    if (DefaultColWidth <> Source.DefaultColWidth) and (Pos('defaultcolwidth', ExcludeProps) = 0) then
        DefaultColWidth := Source.DefaultColWidth;

    if (DefaultRowHeight <> Source.DefaultRowHeight) and (Pos('defaultrowheight', ExcludeProps) = 0) then
        DefaultRowHeight := Source.DefaultRowHeight;

    {$IFDEF TSVER_V4}
    if Pos('constraints', ExcludeProps) = 0 then
        Constraints.Assign(Source.Constraints);
    {$ENDIF}
end;

procedure TtsBaseGrid.AssignGridData(Source: TtsBaseGrid);
var
    I: Longint;
    NewSize: Integer;
    DataRow, DataCol: Longint;
    MaxCol, MaxDataCol: Longint;
    MaxRow, MaxDataRow: Longint;
begin
    StoreData := Source.StoreData;
    if StoreData then
    begin
        FImageListIds.Clear;
        FImageListIds.Assign(Source.FImageListIds);

        if not InDesignMode then
            GridData.Assign(Source.GridData)
        else if Assigned(Source.GridData) then
        begin
            {In designmode, need to swap data numbers with display
             numbers when assigning cell values}

            MaxRow := 0;
            MaxDataRow := Source.GridData.MaxRowSet;
            for I := 1 to MaxDataRow do
                MaxRow := CalcMax(MaxRow, Source.DisplayRownr[I]);

            if MaxRow = 0 then
                GridData.Clear(0, True)
            else
            begin
                GridData.Clear(MaxRow + 1, False);
                NewSize := CalcMax(GridData.RowsAllocSize + 1, MaxRow + 1);
                GridData.ResizeRows(NewSize);
            end;

            for DataRow := 1 to MaxDataRow do
            begin
                MaxCol := 0;
                MaxDataCol := Source.GridData.MaxColValueSet(DataRow);
                for I := 1 to MaxDataCol do
                    MaxCol := CalcMax(MaxCol, Source.DisplayColnr[I]);

                if MaxCol = 0
                    then GridData.ClearRow(Source.DisplayRownr[DataRow], 0)
                    else GridData.ClearRow(Source.DisplayRownr[DataRow], CalcMax(MaxCol, GridData.ColsAllocSize));

                for DataCol := MaxDataCol downto 1 do
                    GridData.SetValue(Source.DisplayColnr[DataCol], Source.DisplayRownr[DataRow], Source.GridData.GetValue(DataCol, DataRow), Source.GridData.GetValueType(DataCol, DataRow));
            end;
        end;
    end;
end;

procedure TtsBaseGrid.CopyData(Source: TtsBaseGrid);
begin
    if Self = Source then Exit; 
    AssignGridData(Source);
    Invalidate;
    if StoreData then
    begin
        if Rows < Source.Rows then DeleteRowData(Rows + 1, Source.Rows);
        if Cols < Source.Rows then DeleteColData(Cols + 1, Source.Cols);
    end;
end;

procedure TtsBaseGrid.AssignPropKinds(Source: TtsBaseGrid; PropKinds: TtsPropKinds; AssignData: Boolean);
var
    ExcludeProps: string;
begin
    FAssigning := True;
    FastAssign := True;
    try
        if pkGrid in PropKinds then
        begin
            ExcludeProps := '';
            if not (pkCols in PropKinds) then ExcludeProps := ExcludeProps + 'Cols;DefaultColWidth;';
            if not (pkRows in PropKinds) then ExcludeProps := ExcludeProps + 'Rows;DefaultRowHeight;';
            if (FColMatch = cmaFieldName) then ExcludeProps := ExcludeProps + 'FieldState;';
            AssignProperties(Source, ExcludeProps);
        end;

        if pkCols in PropKinds then
        begin
            AssignNameValue('Cols', Self, Source);
            if Self.DefaultColWidth <> Source.DefaultColWidth then AssignNameValue('DefaultColWidth', Self, Source);
            AssignColProperties(Source);
        end;

        if pkRows in PropKinds then
        begin
            AssignNameValue('Rows', Self, Source);
            if Self.DefaultColWidth <> Source.DefaultRowHeight then AssignNameValue('DefaultRowHeight', Self, Source);
            AssignRowProperties(Source);
            AssignChangedRows(Source);
        end;

        if pkCells in PropKinds then
        begin
            if (Cols < Source.Cols) then AssignNameValue('Cols', Self, Source);
            if (Rows < Source.Rows) then AssignNameValue('Rows', Self, Source);
            AssignCellProperties(Source);
        end;

        AssignSelections(Source, PropKinds);
        if AssignData then AssignGridData(Source)
                      else CheckGridData(-1, -1);

        CheckRowColPos;
        CheckTopLeft(True);
        UpdateScrollRange;
        CheckRowColChanged;
        CheckRowSelection(True);
        SelectionsChanged(False);
        GridStatusChanged;
    finally
        FAssigning := False;
        FastAssign := False;
    end;
end;

procedure TtsBaseGrid.ResetPropKinds(PropKinds: TtsPropKinds);
var
    InitGrid: TtsBaseGrid;
begin
    InitGrid := TtsBaseGridClass(ClassType).Create(Owner);
    try
        InitGrid.Visible := False;
        InitGrid.Parent := Parent;
        if FAsCombo then
        begin
            if not Reading then
            begin
                ParentGrid.InitializeComboSettings(InitGrid);
                if ParentGrid.FDropDownCol > 0 then
                    InitGrid.InitComboColWidth(ParentGrid.GridCols[ParentGrid.FDropDownCol].Width);
            end;
            AssignPropKinds(InitGrid, PropKinds, True);
            if not Reading then ParentGrid.InitCombo(ParentGridCombo);
        end
        else
        begin
            AssignPropKinds(InitGrid, PropKinds, True);
            ResetCombo;
        end;
    finally
        InitGrid.Free;
    end;

    UpdateScrollRange;
end;

procedure TtsBaseGrid.Assign(Source: TPersistent);
begin
    if Source is TtsBaseGrid then
    begin
        if not InDesignMode then
            FDesigning := TtsBaseGrid(Source).InDesignMode;
        AssignPropKinds(TtsBaseGrid(Source), tsAllPropKinds, True);
        Exit;
    end;

    inherited;
end;

procedure TtsBaseGrid.AssignDisplayCols(Source: TtsBaseGrid);
var
    I: Integer;
begin
    CopyMemory(FDataColNumber, Source.FDataColNumber, ColCount * SizeOf(Longint));
    for I := 1 to Cols do
        GridCols.FCols[I].FDisplayCol := Source.GridCols.FCols[I].FDisplayCol;
end;

procedure TtsBaseGrid.ActivateMovedCols(MovedCols: TBits);
var
    I: Integer;
begin
    if not Assigned(MovedCols) then Exit;

    for I := 1 to MovedCols.Size - 1 do
    begin
        if MovedCols[I] then DoColMoved(Col[I].DisplayCol, 1, False);
    end;
end;

procedure TtsBaseGrid.AssignColWidths;
var
    I, DisplayCol: Integer;
    Visible: Boolean;
    Width: Integer;
begin
    for I := 1 to Cols do
    begin
        Visible := True;
        Width := DefaultColWidth;
        if Assigned(GridCols.FCols[I]) then
        begin
            Visible := GridCols.FCols[I].FVisible;
            Width := GridCols.FCols[I].FWidth;
        end;

        DisplayCol := GridCols.FCols[I].FDisplayCol;
        if Visible and (ColWidths[DisplayCol] <> Width) then
            ResizeCol(DisplayCol, Width)
        else if (not Visible) and (ColWidths[DisplayCol] <> 0) then
            ResizeCol(DisplayCol, 0);
    end;
end;

procedure TtsBaseGrid.AssignColProperties(Source: TtsBaseGrid);
var
    I, SourceColnr: Integer;
    MovedCols: TBits;
    VisibleChanged: Boolean;
begin
    MovedCols := nil;
    try
        VisibleChanged := False;
        for I := 1 to Source.Cols do
        begin
            if I > Source.Cols then Break;

            SourceColnr := I;
            if InDesignMode then
            begin
                {In designmode, need to swap data numbers with display
                 numbers when assigning columns}
                SourceColnr := Source.FDataColNumber[I];
            end;

            if GridCols.FCols[I].DisplayCol <> Source.GridCols.FCols[SourceColnr].DisplayCol then
            begin
                if not Assigned(MovedCols) then
                begin
                    MovedCols := TBits.Create;
                    MovedCols.Size := ColCount;
                end;
                MovedCols[I] := True;
            end;

            VisibleChanged := VisibleChanged or (GridCols.FCols[I].FVisible <> Source.GridCols.FCols[SourceColnr].Visible);
            GridCols.FCols[I].Assign(Source.GridCols.FCols[SourceColnr]);
        end;

        if VisibleChanged or Assigned(MovedCols) then FVisibleCols.Assign(Source.FVisibleCols);
        if Assigned(MovedCols) and (Cols = Source.Cols) then AssignDisplayCols(Source);
        if VisibleChanged or Assigned(MovedCols) then AssignColWidths;
        if Assigned(MovedCols) and (Cols = Source.Cols) then ActivateMovedCols(MovedCols);
    finally
        MovedCols.Free;
    end;
end;

procedure TtsBaseGrid.AssignDisplayRows(Source: TtsBaseGrid);
begin
    CopyMemory(FDataRowNumber, Source.FDataRowNumber, RowCount * SizeOf(Longint));
    if Assigned(Source.GridRows.FDisplayRowNumber) then
    begin
        if not Assigned(GridRows.FDisplayRowNumber) then
            ReAllocMem(GridRows.FDisplayRowNumber, RowCount * SizeOf(Longint));
        CopyMemory(GridRows.FDisplayRowNumber, Source.GridRows.FDisplayRowNumber, RowCount * SizeOf(Longint));
    end
    else
        ReAllocMem(GridRows.FDisplayRowNumber, 0);
end;

procedure TtsBaseGrid.ActivateMovedRows(MovedRows: TBits);
var
    I: Integer;
begin
    if not Assigned(MovedRows) then Exit;

    for I := 1 to MovedRows.Size - 1 do
    begin
        if MovedRows[I] then DoRowMoved(GetDisplayRow(I), 1, False);
    end;
end;

procedure TtsBaseGrid.AssignRowHeights;
var
    I, DisplayRow: Integer;
    Visible: Boolean;
    Height: Integer;
begin
    for I := 1 to Rows do
    begin
        Visible := True;
        Height := DefaultRowHeight;
        if Assigned(GridRows.FRows[I]) then
        begin
            Visible := GridRows.FRows[I].FVisible;
            Height := GridRows.FRows[I].FHeight;
        end;

        DisplayRow := GridRows.DisplayRowNumber[I];
        if Visible and (RowHeights[DisplayRow] <> Height) then
            ResizeRow(DisplayRow, Height)
        else if (not Visible) and (RowHeights[DisplayRow] <> 0) then
            ResizeRow(DisplayRow, 0);
    end;
end;

procedure TtsBaseGrid.AssignRowProperties(Source: TtsBaseGrid);
var
    I, SourceRownr: Integer;
    MovedRows: TBits;
    EmptyRow: TtsRow;
    VisibleChanged: Boolean;
begin
    MovedRows := nil;
    EmptyRow := nil;
    try
        VisibleChanged := False;
        for I := 1 to Rows do
        begin
            if I > Source.Rows then Break;

            SourceRownr := I;
            if InDesignMode then
            begin
                {In designmode, need to swap data numbers with display
                 numbers when assigning rows}
                SourceRownr := Source.FDataRowNumber[I];
            end;

            if GridRows.DisplayRowNumber[I] <> Source.GridRows.DisplayRowNumber[SourceRownr] then
            begin
                if not Assigned(MovedRows) then
                begin
                    MovedRows := TBits.Create;
                    MovedRows.Size := RowCount;
                end;
                MovedRows[I] := True;
            end;

            if (GridRows.FRows[I] <> nil) or (Source.GridRows.FRows[SourceRownr] <> nil) then
            begin
                if Source.GridRows.FRows[SourceRownr] = nil then
                begin
                    if not Assigned(EmptyRow) then EmptyRow := TtsRow.Create(Self);
                    VisibleChanged := VisibleChanged or (GridRows.FRows[I].FVisible <> EmptyRow.FVisible);
                    GridRows.FRows[I].Assign(EmptyRow);
                    GridRows.RemoveDataRow(I);
                end
                else
                begin
                    GridRows.CreateDataRow(I);
                    VisibleChanged := VisibleChanged or (GridRows.FRows[I].FVisible <> Source.GridRows.FRows[SourceRownr].FVisible);
                    GridRows.FRows[I].Assign(Source.GridRows.FRows[SourceRownr]);
                end;
            end;
        end;

        if VisibleChanged or Assigned(MovedRows) then FVisibleRows.Assign(Source.FVisibleRows);
        if Assigned(MovedRows) and (Rows = Source.Rows) then AssignDisplayRows(Source);
        if VisibleChanged or Assigned(MovedRows) then AssignRowHeights;
        if Assigned(MovedRows) and (Rows = Source.Rows) then ActivateMovedRows(MovedRows);
    finally
        MovedRows.Free;
        EmptyRow.Free;
    end;
end;

procedure TtsBaseGrid.AssignChangedRows(Source: TtsBaseGrid);
var
    I: Integer;
begin
    if csDesigning in ComponentState then Exit;

    FChangedRows.Size := Source.FChangedRows.Size;
    for I := 0 to FChangedRows.Size - 1 do
        FChangedRows[I] := Source.FChangedRows[I];
end;

procedure TtsBaseGrid.AssignCellProperties(Source: TtsBaseGrid);
var
    I: Integer;
    PropList: TtsSetList;
    DataCol, DataRow: Longint;
    Element: TtsCustomElement;
    SourceElement: TtsCellElement;
begin
    DeleteAllCellProperties;
    FCellPropSet := TtsCellPropSet.CreateNew(Self);
    FColCells := TtsIntegerSetList.Create;
    FRowCells := TtsIntegerSetList.Create;
    ResizeCellPropArrays(0,0);

    if not InDesignMode then
    begin
        FCellPropSet.Assign(Source.FCellPropSet);
        FColCells.Assign(Source.FColCells);
        FRowCells.Assign(Source.FRowCells);
    end
    else
    begin
        PropList := Source.FCellPropSet.List;
        try
            for I := 1 to PropList.Count do
            begin
                SourceElement := TtsCellElement(PropList.Items[I]);
                {In designmode, need to swap data numbers with display
                 numbers when assigning cells}
                DataCol := Source.GetDisplayCol(SourceElement.FDataCol);
                DataRow := Source.GetDisplayRow(SourceElement.FDataRow);

                if (DataCol > 0) and (DataRow > 0) then
                begin
                    Element := FCellPropSet.CreateElement([DataCol, DataRow]);
                    Element.AssignProperties(SourceElement);
                    if not Element.Empty
                        then FCellPropSet.AddElement(Element)
                        else Element.Free;
                end;
            end;
        finally
            PropList.Free;
        end;
    end;
end;

procedure TtsBaseGrid.CheckGridStatus;
begin
    if FSelectedCols.Count <> 0 then
        FGridStatus := grColSelect
    else if FSelectedRows.Count <> 0 then
        FGridStatus := grRowSelect
    else if not EqualRect(FSelectedCells, FNullRect) then
        FGridStatus := grCellSelect
    else
        FGridStatus := grNormal;
end;

procedure TtsBaseGrid.AssignColSelections(Source: TtsBaseGrid);
var
    Changed: Boolean;
begin
    Changed := FSelectedCols.Assign(Source.FSelectedCols);
    if Changed then SetSelectChanged(stColSelect);
end;

procedure TtsBaseGrid.AssignRowSelections(Source: TtsBaseGrid);
var
    Changed: Boolean;
begin
    Changed := FSelectedRows.Assign(Source.FSelectedRows);
    if Changed then SetSelectChanged(stRowSelect);
end;

procedure TtsBaseGrid.AssignCellSelections(Source: TtsBaseGrid);
begin
    if not EqualRect(FSelectedCells, Source.FSelectedCells) then
    begin
        SetSelectChanged(stCellSelect);
        FSelectedCells := Source.FSelectedCells;
    end;
end;

procedure TtsBaseGrid.AssignSelections(Source: TtsBaseGrid; PropKinds: TtsPropKinds);
begin
    if InDesignMode or FAsCombo then Exit;

    if pkCols in PropKinds then AssignColSelections(Source);
    if pkRows in PropKinds then AssignRowSelections(Source);
    if pkCells in PropKinds then AssignCellSelections(Source);
    CheckGridStatus;
end;

procedure TtsBaseGrid.DeleteAllCellProperties;
begin
    if FColCells <> nil then
    begin
        FColCells.Free;
        FColCells := nil;
    end;

    if FRowCells <> nil then
    begin
        FRowCells.Free;
        FRowCells := nil;
    end;

    FCellPropSet.Free;
    FCellPropSet := nil;
end;

procedure TtsBaseGrid.DeleteRowColProperties;
begin
    GridCols.Free;
    GridRows.Free;
    FCurrentCell.Free;

    if FDataColNumber <> nil then ReAllocMem(FDataColNumber, 0);
    if FDataRowNumber <> nil then ReAllocMem(FDataRowNumber, 0);
end;

function TtsBaseGrid.CreateCellElement(DataCol: Longint; DataRow: Variant): TtsCustomElement;
var
    Rownr: Integer;
begin
    Rownr := DataRow;
    Result := FCellPropSet.CreateElement([DataCol, Rownr]);
    FCellPropSet.AddElement(Result);
end;

function TtsBaseGrid.ControlDataType(ControlType: TtsControlType; Value: Variant): TtsValueType;
begin
    Result := vtpNone;
    case ControlType of
        ctText:
            Result := vtpString;

        ctCheck:
            if VarType(Value) = varString then
                Result := vtpString
            else if VarIsNull(Value) then
                Result := vtpNull
            else
                Result := vtpInteger;

        ctPicture:
            if VarType(Value) = varString
                then Result := vtpPictureName
                else Result := vtpPicture;
    end;
end;

function TtsBaseGrid.ControlDataTypeOk(ControlType: TtsControlType; DataType: TtsValueType): Boolean;
begin
    Result := False;
    case ControlType of
        ctText: Result := (DataType = vtpString);
        ctCheck: Result := (DataType = vtpInteger) or (DataType = vtpString) or (DataType = vtpNull);
        ctPicture: Result := (DataType in [vtpPicture, vtpPictureName]);
    end;
end;

function TtsBaseGrid.CheckPictureValue(DataCol, DataRow: Longint; ControlType: TtsControlType; Value: Variant): Variant;
var
    GUID: string;
    CheckByName: Boolean;
    Index, ImageId, ComponentId: Integer;
    Image: TtsImageItem;
    ImageName: string;
begin
    CheckByName := True;
    Result := SeparatePictureIds(Value, ComponentId, ImageId);
    if (ControlType <> ctPicture) then Exit;

    if (ImageId >= 0) and (ComponentId >= 0) then
    begin
        GUID := '';
        if Assigned(ImageList) then GUID := ImageList.GUID;
        if FImageListIds[ComponentId] = GUID then
        begin
            Index := ImageList.IdIndex(ImageId);
            if Index >= 0 then
            begin
                CheckByName := False;
                Image := ImageList.Image[Index];
                if Image.SetName = ''
                    then ImageName := Image.Name
                    else ImageName := Image.SetName + '.' + Image.Name;
                if Result <> ImageName then
                begin
                    Result := ImageName;
                    SetDataValue(DataCol, DataRow, ControlType, Result);
                end;
            end
        end;
    end;

    if CheckByName and Assigned(ImageList) and InDesignMode then
    begin
        Index := ImageList.NameIndex(Result);
        if (Index >= 0) then SetDataValue(DataCol, DataRow, ControlType, Result);
    end;
end;

function TtsBaseGrid.GetDataValue(DataCol, DataRow: Longint; ControlType: TtsControlType): Variant;
var
    ValueType: TtsValueType;
begin
    Result := Unassigned;
    if StoreData then
    begin
        Result := FGridData.GetValue(DataCol, DataRow);
        ValueType := FGridData.GetValueType(DataCol, DataRow);
        if (ValueType = vtpPictureName) or
           ((ValueType = vtpString) and (ControlType = ctPicture)) then
        begin
            Result := CheckPictureValue(DataCol, DataRow, ControlType, Result);
        end;
    end;
end;

function TtsBaseGrid.ImageListIndex(ImageList: TtsImageListComponent): Integer;
begin
    if not FImageListIds.Find(ImageList.Guid, Result) then
        Result := FImageListIds.Add(ImageList.Guid);
end;

procedure TtsBaseGrid.SetDataValue(DataCol, DataRow: Longint; ControlType: TtsControlType; Value: Variant);
var
    ValueType: TtsValueType;
    Image: TtsImageItem;
begin
    if StoreData then
    begin
        ValueType := ControlDataType(ControlType, Value);
        if (ControlType = ctPicture) and (ValueType = vtpPictureName) then
        begin
            Image := ImageListPicture(Value);
            if Assigned(Image) and InDesignMode then
                Value := AddPictureIds(Value, ImageListIndex(ImageList), Image.Id);
        end;
        FGridData.SetValue(DataCol, DataRow, Value, ValueType);
    end;
end;

procedure TtsBaseGrid.FreeGridData;
begin
    FGridData.Free;
    FGridData := nil;
    FImageListIds.Clear;
    Invalidate;
end;

procedure TtsBaseGrid.CheckGridData(DataCol, DataRow: Longint);
var
    I, J: Longint;
    MaxCol: Longint;
    DataType: TtsValueType;
    ControlType: TtsControlType;
begin
    if (not StoreData) then Exit;
    if (csLoading in ComponentState) then Exit;

    if (DataCol > 0) and (DataRow > 0) then
    begin
        DataType := GridData.GetValueType(DataCol, DataRow);
        if (DataType <> vtpNone) then
        begin
            ControlType := GiveCellControlType(DataCol, DataRow);
            if not ControlDataTypeOk(ControlType, DataType) then
                GridData.ClearValue(DataCol, DataRow)
        end;
    end
    else if DataCol > 0 then
    begin
        for I := 1 to Rows do
        begin
            DataType := GridData.GetValueType(DataCol, I);
            if (DataType <> vtpNone) then
            begin
                ControlType := GiveCellControlType(DataCol, I);
                if not ControlDataTypeOk(ControlType, DataType) then
                    GridData.ClearValue(DataCol, I);
            end;
        end;
    end
    else if DataRow > 0 then
    begin
        MaxCol := CalcMin(Cols, GridData.MaxColValueSet(DataRow));
        for I := 1 to MaxCol do
        begin
            DataType := GridData.GetValueType(I, DataRow);
            if (DataType <> vtpNone) then
            begin
                ControlType := GiveCellControlType(I, DataRow);
                if not ControlDataTypeOk(ControlType, DataType) then
                    GridData.ClearValue(I, DataRow);
            end;
        end;
    end
    else
    begin
        for J := 1 to Rows do
        begin
            MaxCol := CalcMin(Cols, GridData.MaxColValueSet(J));
            for I := 1 to MaxCol do
            begin
                DataType := GridData.GetValueType(I, J);
                if (DataType <> vtpNone) then
                begin
                    ControlType := GiveCellControlType(I, J);
                    if not ControlDataTypeOk(ControlType, DataType) then
                        GridData.ClearValue(I, J);
                end;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.DeleteColData(FromDataCol, ToDataCol: Longint);
begin
    if StoreData then FGridData.DeleteCols(FromDataCol, ToDataCol);
end;

procedure TtsBaseGrid.DeleteRowData(FromDataRow, ToDataRow: Longint);
begin
    if StoreData then FGridData.DeleteRows(FromDataRow, ToDataRow);
end;

function TtsBaseGrid.DoColWidths: Boolean;
var
    I: Integer;
begin
    Result := False;
    for I := 0 to ColCount - 1 do
    begin
        if ColWidths[I] <> DefaultColWidth then
        begin
            Result := True;
            Break;
        end;
    end;
end;

procedure TtsBaseGrid.WriteColWidths(Writer: TWriter);
var
    I: Integer;
begin
    {Used for backward compatibility with older versions of the TopGrid.
     Replaces WriteColWidths in TCustomGrid}
    with Writer do
    begin
        WriteListBegin;
        for I := 0 to ColCount - 1 do WriteInteger(ColWidths[I]);
        WriteListEnd;
    end;
end;

procedure TtsBaseGrid.WriteRowHeights(Writer: TWriter);
var
    I: Integer;
begin
    {Used for backward compatibility with older versions of the TopGrid.
     Replaces WriteRowHeights in TCustomGrid}
    with Writer do
    begin
        WriteListBegin;
        for I := 0 to RowCount - 1 do WriteInteger(RowHeights[I]);
        WriteListEnd;
    end;
end;

procedure TtsBaseGrid.ReadColWidths(Reader: TReader);
var
    I: Integer;
begin
    {Used for backward compatibility with older versions of the TopGrid.
     Replaces ReadColWidths in TCustomGrid}
    with Reader do
    begin
        I := 0;
        ReadListBegin;
        while not EndOfList do
        begin
            if I <= ColCount - 1 then ColWidths[I] := ReadInteger
                                 else ReadInteger;
            Inc(I);
        end;
        ReadListEnd;
    end;
end;

procedure TtsBaseGrid.ReadRowHeights(Reader: TReader);
var
    I: Integer;
begin
    {Used for backward compatibility with older versions of the TopGrid.
     Replaces ReadRowHeights in TCustomGrid}
    with Reader do
    begin
        I := 0;
        ReadListBegin;
        while not EndOfList do
        begin
            if I <= RowCount - 1 then RowHeights[I] := ReadInteger
                                 else ReadInteger;
            Inc(I);
        end;
        ReadListEnd;
    end;
end;

function TtsBaseGrid.CreateColCollection(Writing: Boolean): TtsColCollection;
var
    I, DataCol: Longint;
    ColItem: TtsColItem;
begin
    Result := TtsColCollection.Create(Self, TtsColItem);
    if not Writing then Exit;

    for I := 1 to Cols do
    begin
        DataCol := DataColnr[I];
        if (not GridCols[DataCol].DefaultProps) then
        begin
            ColItem := TtsColItem(Result.Add);
            ColItem.FDataCol := DataCol;
            ColItem.FFieldName := GridCols[DataCol].FieldName;
            ColItem.Col := GridCols[DataCol];
        end;
    end;
end;

function TtsBaseGrid.CreateRowCollection(Writing: Boolean): TtsPropCollection;
var
    I, DataRow: Longint;
    RowItem: TtsRowItem;
begin
    Result := TtsPropCollection.Create(Self, TtsRowItem);
    if not Writing then Exit;

    for I := 1 to Rows do
    begin
        DataRow := DataRownr[I];
        if (DataRow <> I) or
           (Assigned(GridRows[DataRow]) and (not GridRows[DataRow].DefaultProps)) then
        begin
            RowItem := TtsRowItem(Result.Add);
            RowItem.FDataRow := DataRow;
            RowItem.FDisplayRow := I;
            RowItem.Row := GridRows[DataRow];
        end;
    end;
end;

procedure TtsBaseGrid.AddCellProps(Cells: TtsCellCollection; Node: TtsSetNode);
var
    CellItem: TtsCellItem;
    Element: TtsCellElement;
begin
    if Node = nil then Exit;

    Element := TtsCellElement(TtsObjectSetNode(Node).NodeValue);
    if not Element.Empty then
    begin
        CellItem := TtsCellItem(Cells.Add);
        CellItem.DataCol := Element.FDataCol;
        CellItem.DataRow := Element.FDataRow;
    end;

    AddCellProps(Cells, Node.Left);
    AddCellProps(Cells, Node.Right);
end;

function TtsBaseGrid.CreateCellCollection(Writing: Boolean): TtsCellCollection;
begin
    Result := TtsCellCollection.Create(Self, TtsCellItem);
    if Writing then AddCellProps(Result, FCellPropSet.TopNode);
end;

procedure TtsBaseGrid.WriteColumns(Writer: TWriter);
begin
    Writer.WriteCollection(FWriteCols);
end;

procedure TtsBaseGrid.ReadColCollection(Reader: TReader; ColMatch: TtsColMatch);
var
    Columns: TtsColCollection;
begin
    Columns := CreateColCollection(False);
    try
        Columns.FColMatch := ColMatch;
        {$IFDEF TSVER_V3}
        Reader.ReadValue;
        Reader.ReadCollection(Columns);
        {$ENDIF}
    finally
        Columns.Free;
    end;
end;

procedure TtsBaseGrid.ReadColumns(Reader: TReader);
begin
    ReadColCollection(Reader, cmaNone);
end;

procedure TtsBaseGrid.WriteRows(Writer: TWriter);
begin
    Writer.WriteCollection(FWriteRows);
end;

procedure TtsBaseGrid.ReadRows(Reader: TReader);
var
    Rows: TtsPropCollection;
begin
    Rows := CreateRowCollection(False);
    try
        {$IFDEF TSVER_V3}
        Reader.ReadValue;
        Reader.ReadCollection(Rows);
        {$ENDIF}
    finally
        Rows.Free;
    end;
end;

procedure TtsBaseGrid.WriteCells(Writer: TWriter);
begin
    Writer.WriteCollection(FCellPropCollection);
end;

procedure TtsBaseGrid.ReadCells(Reader: TReader);
begin
    FCellPropCollection := CreateCellCollection(False);
    {$IFDEF TSVER_V3}
    Reader.ReadValue;
    Reader.ReadCollection(FCellPropCollection);
    {$ENDIF}
end;

procedure TtsBaseGrid.ReadEditMode(Reader: TReader);
begin
    EditMode := EditModeStrValue(Reader.ReadIdent);
end;

procedure TtsBaseGrid.ReadHeadingAlignment(Reader: TReader);
begin
    HeadingAlignment := ReadAlignment(Reader);
end;

procedure TtsBaseGrid.WriteImageListIds(Writer: TWriter);
begin
    Writer.WriteString(FImageListIds.CommaText);
end;

procedure TtsBaseGrid.ReadImageListIds(Reader: TReader);
begin
    FImageListIds.Clear;
    FImageListIds.CommaText := Reader.ReadString;
end;

procedure TtsBaseGrid.WriteData(Stream: TStream);
begin
    if not StoreData then Exit;
    GridData.SaveToStream(Stream);
end;

procedure TtsBaseGrid.ReadData(Stream: TStream);
begin
    StoreData := True;
    GridData.LoadFromStream(Stream, FReadColNumbers);
end;

function TtsBaseGrid.DoColProps(Ancestor: TPersistent): Boolean;
var
    AncestorColumns: TtsPropCollection;
begin
    Result := False;
    if (not (csWriting in ComponentState)) or not SaveAllProps then Exit;

    FWriteCols := CreateColCollection(True);
    if (Ancestor <> nil) then
    begin
        AncestorColumns := TtsBaseGrid(Ancestor).CreateColCollection(True);
        try
            {$IFDEF TSVER_V6}
            if CollectionsEqual(AncestorColumns, FWriteCols, Nil, Nil) then
            {$ELSE}
            if CollectionsEqual(AncestorColumns, FWriteCols) then
            {$ENDIF}
                FWriteCols.Clear;
        finally
            AncestorColumns.Free;
        end;
    end;
    Result := FWriteCols.Count <> 0;
end;

function TtsBaseGrid.DoRowProps(Ancestor: TPersistent): Boolean;
var
    AncestorRows: TtsPropCollection;
begin
    Result := False;
    if (not (csWriting in ComponentState)) or not SaveAllProps then Exit;

    FWriteRows := CreateRowCollection(True);
    if (Ancestor <> nil) and (csDesigning in ComponentState) then
    begin
        AncestorRows := TtsBaseGrid(Ancestor).CreateRowCollection(True);
        try
            {$IFDEF TSVER_V6}
            if CollectionsEqual(AncestorRows, FWriteRows, Nil, Nil) then
            {$ELSE}
            if CollectionsEqual(AncestorRows, FWriteRows) then
            {$ENDIF}
                FWriteRows.Clear;
        finally
            AncestorRows.Free;
        end;
    end;
    Result := FWriteRows.Count <> 0;
end;

function TtsBaseGrid.DoCellProps(Ancestor: TPersistent): Boolean;
var
    AncestorCells: TtsPropCollection;
begin
    Result := False;
    if (not (csWriting in ComponentState)) or not SaveAllProps then Exit;

    FCellPropCollection := CreateCellCollection(True);
    if (Ancestor <> nil) and (csDesigning in ComponentState) then
    begin
        AncestorCells := TtsBaseGrid(Ancestor).CreateCellCollection(True);
        try
            {$IFDEF TSVER_V6}
            if CollectionsEqual(AncestorCells, FCellPropCollection, Nil, Nil) then
            {$ELSE}
            if CollectionsEqual(AncestorCells, FCellPropCollection) then
            {$ENDIF}
                FCellPropCollection.Clear;
        finally
            AncestorCells.Free;
        end;
    end;
    Result := FCellPropCollection.Count <> 0;
end;

procedure TtsBaseGrid.DefineProperties(Filer: TFiler);
var
    WriteCollectionProps : Boolean;
begin
    {Turn read/write properties off for TCustomGrid}
    FSaveCellExtents := False;
    inherited;

    if not FSaveCellExtents then
    begin
        with Filer do
        begin
            {Process TCustomGrid properties}
            DefineProperty('ColWidths', ReadColWidths, WriteColWidths, False);
            DefineProperty('RowHeights', ReadRowHeights, WriteRowHeights, False);
        end;
    end;

    if FSaveTtsBaseGridProp then
    begin
        with Filer do
        begin
            {$IFNDEF TSVER_V3}
            WriteCollectionProps := False;
            {$ELSE}
            WriteCollectionProps := True;
            {$ENDIF}

            FWriteCols := nil;
            FWriteRows := nil;
            try
                DefineProperty('EditMode', ReadEditMode, nil, False);
                DefineProperty('HeadingAlignment', ReadHeadingAlignment, nil, False);
                DefineProperty('ImageListIds', ReadImageListIds, WriteImageListIds, FImageListIds.Count > 0);

                DefineProperty('ColProperties', ReadColumns, WriteColumns, WriteCollectionProps and DoColProps(Ancestor));
                DefineProperty('RowProperties', ReadRows, WriteRows, WriteCollectionProps and DoRowProps(Ancestor));
                DefineProperty('CellProperties', ReadCells, WriteCells, WriteCollectionProps and DoCellProps(Ancestor));

                DefineBinaryProperty('Data', ReadData, WriteData, SaveAllProps and StoreData);
            finally
                FreeNil(TObject(FWriteCols));
                FreeNil(TObject(FWriteRows));

                if csWriting in ComponentState then
                    FreeNil(TObject(FCellPropCollection));

                {$IFNDEF TSVER_V3}
                FStoredCols.Clear;
                FStoredRows.Clear;
                FStoredCells.Clear;
                {$ENDIF}
            end;
        end;
    end;
end;

procedure TtsBaseGrid.Loaded;
begin
    inherited;
    FreeNil(TObject(FCellPropCollection));

    {$IFNDEF TSVER_V3}
    FStoredCols.Clear;
    FStoredRows.Clear;
    FStoredCells.Clear;
    {$ENDIF}

    Invalidate;
    PerformFastAssignActions;
end;

procedure TtsBaseGrid.SetSaveAllProps(Value: Boolean);
begin
    if not Value then
        Inc(FSaveAllProps)
    else if FSaveAllProps > 0 then
        Dec(FSaveAllProps);
end;

function TtsBaseGrid.GetSaveAllProps: Boolean;
begin
    Result := FSaveAllProps = 0;
end;

function TtsBaseGrid.StoreCols: Boolean;
begin
    Result := True;
end;

function TtsBaseGrid.StoreRows: Boolean;
begin
    Result := True;
end;

{$IFNDEF TSVER_V3}
function TtsBaseGrid.StoreColProps: Boolean;
begin
    Result := FStoredCols.Count <> 0;
end;

function TtsBaseGrid.StoreRowProps: Boolean;
begin
    Result := FStoredRows.Count <> 0;
end;

function TtsBaseGrid.StoreCellProps: Boolean;
begin
    Result := FStoredCells.Count <> 0;
end;
{$ENDIF}

function TtsBaseGrid.CreateStreamComponent: TtsGridStreamComponent;
begin
    Result := TtsGridStreamComponent.Create(Self);
end;

function TtsBaseGrid.Reading: Boolean;
begin
    Result := FReading or (csReading in ComponentState);
    if not Result and Assigned(ParentGrid) then Result := ParentGrid.Reading;
end;

function TtsBaseGrid.Writing: Boolean;
begin
    Result := FWriting or (csWriting in ComponentState);
    if not Result and Assigned(ParentGrid) then Result := ParentGrid.Writing;
end;

procedure TtsBaseGrid.LoadFromStream(Stream: TStream; ColMatch: TtsColMatch);
var
    StreamComponent: TtsGridStreamComponent;
begin
    StreamComponent := CreateStreamComponent;
    try
        FastAssign := True;
        FReading := True;
        StreamComponent.FColMatch := ColMatch;
        FColMatch := ColMatch;
        try
            Stream.ReadComponent(StreamComponent);
        finally
            FReading := False;
            FastAssign := False;
            FColMatch := cmaNone;
            FreeNil(TObject(FReadColNumbers));
        end;
    finally
        StreamComponent.Free;
    end;
end;

procedure TtsBaseGrid.SavePropToStream(Stream: TStream; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean);
var
    StreamComponent: TtsGridStreamComponent;
begin
    StreamComponent := CreateStreamComponent;
    try
        {$IFNDEF TSVER_V3}
        Include(PropKinds, pkGrid);
        FStoredPropKinds := PropKinds;
        {$ENDIF}

        StreamComponent.SavePropKinds := PropKinds;
        StreamComponent.Properties := Properties;
        StreamComponent.AllProperties := Properties = tsAllProperties;
        if [prAlign, prAlignment, prHorzAlignment] * Properties <> [] then
            StreamComponent.Properties := StreamComponent.Properties + [prAlign, prAlignment, prHorzAlignment];
        StreamComponent.SaveData := SaveData;
        FastAssign := True;
        FWriting := True;
        try
            Stream.WriteComponent(StreamComponent);
        finally
            FWriting := False;
            FastAssign := False;
        end;
    finally
        StreamComponent.Free;
    end;
end;

procedure TtsBaseGrid.SaveToStream(Stream: TStream; SaveData: Boolean);
begin
    SavePropToStream(Stream, tsAllPropKinds, tsAllProperties, SaveData);
end;

procedure TtsBaseGrid.SavePropToRegistry(const Key, ValueName, FileName: string; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean);
var
    Registry: TRegistry;
    Stream: TStream;
    FullName: string;
begin
    Registry := OpenRegistryKey(Key, True);
    try
        if not Assigned(Registry) then
            raise ERegistryException.CreateFmt(ResourceStr(SRegCreateFailed), [Key]);

        if FileName = '' then
        begin
            Stream := TMemoryStream.Create;
            try
                SavePropToStream(Stream, PropKinds, Properties, SaveData);
                Registry.WriteBinaryData(ValueName, TMemoryStream(Stream).Memory^, Stream.Size);
            finally
                Stream.Free;
            end;
        end
        else
        begin
            FullName := ExpandFileName(FileName);
            Stream := TFileStream.Create(FullName, fmCreate or fmShareExclusive);
            try
                SavePropToStream(Stream, PropKinds, Properties, SaveData);
            finally
                Stream.Free;
            end;
            Registry.WriteString(ValueName, FullName);
        end;
    finally
        Registry.Free;
    end;
end;

procedure TtsBaseGrid.SaveToRegistry(const Key, ValueName, FileName: string; SaveData: Boolean);
begin
    SavePropToRegistry(Key, ValueName, FileName, tsAllPropKinds, tsAllProperties, SaveData);
end;

function TtsBaseGrid.ReadStreamFromRegistry(Registry: TRegistry; ValueName: string; ColMatch: TtsColMatch): Boolean;
var
    Stream: TMemoryStream;
begin
    Result := True;
    Stream := TMemoryStream.Create;
    try
        Stream.SetSize(Registry.GetDataSize(ValueName));
        Registry.ReadBinaryData(ValueName, Stream.Memory^, Stream.Size);
        LoadFromStream(Stream, ColMatch);
    finally
        Stream.Free;
    end;
end;

function TtsBaseGrid.ReadFileFromRegistry(Registry: TRegistry; ValueName: string; ColMatch: TtsColMatch): Boolean;
var
    FileName: string;
begin
    Result := False;
    FileName := Registry.ReadString(ValueName);
    if FileName <> '' then
    begin
        LoadFromFile(FileName, ColMatch);
        Result := True;
    end;
end;

function TtsBaseGrid.LoadFromRegistry(const Key, ValueName: string; ColMatch: TtsColMatch): Boolean;
var
    Registry: TRegistry;
begin
    Result := False;
    Registry := OpenRegistryKey(Key, False);
    try
        if Assigned(Registry) then
        begin
            case Registry.GetDataType(ValueName) of
                rdBinary: Result := ReadStreamFromRegistry(Registry, ValueName, ColMatch);
                rdString: Result := ReadFileFromRegistry(Registry, ValueName, ColMatch);
            end;
        end;
    finally
        Registry.Free;
    end;
end;

procedure TtsBaseGrid.SavePropToFile(const FileName: string; PropKinds: TtsPropKinds; Properties: TtsProperties; SaveData: Boolean);
var
    FileStream: TFileStream;
begin
    FileStream := TFileStream.Create(FileName, fmCreate or fmShareExclusive);
    try
        SavePropToStream(FileStream, PropKinds, Properties, SaveData);
    finally
        FileStream.Free;
    end;
end;

procedure TtsBaseGrid.SaveToFile(const FileName: string; SaveData: Boolean);
begin
    SavePropToFile(FileName, tsAllPropKinds, tsAllProperties, SaveData);
end;

procedure TtsBaseGrid.LoadFromFile(const FileName: string; ColMatch: TtsColMatch);
var
    FileStream: TFileStream;
begin
    FileStream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
    try
        LoadFromStream(FileStream, ColMatch);
    finally
        FileStream.Free;
    end;
end;

procedure TtsBaseGrid.CreateDefaultButton(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    if FNormalButton <> nil then FNormalButton.Destroy;
    FNormalButton := TtsNormalButton.Create(Self, Bmp, TransparentColor, Width, Height);
end;

procedure TtsBaseGrid.CreateDefaultCombo(Bmp: TBitmap; TransparentColor: TColor; Width, Height: Integer);
begin
    if FComboButton <> nil then FComboButton.Destroy;
    FComboButton := TtsComboButton.Create(Self, Bmp, TransparentColor, Width, Height);
end;

procedure TtsBaseGrid.DestroyDefaultButton;
begin
    if FNormalButton <> nil then FNormalButton.Destroy;
    FNormalButton := nil;
end;

procedure TtsBaseGrid.DestroyDefaultCombo;
begin
    if FComboButton <> nil then FComboButton.Destroy;
    FComboButton := nil;
end;

procedure TtsBaseGrid.CheckResizeButtons;
var
    DoInvalidate: Boolean;
begin
    DoInvalidate := False;
    if Assigned(FComboButton) then
    begin
        if FComboButton.IsDefault then
        begin
            DestroyDefaultCombo;
            DoInvalidate := True;
        end;
    end;
    if Assigned(FNormalButton) then
    begin
        if FNormalButton.IsDefault then
        begin
            DestroyDefaultButton;
            DoInvalidate := True;
        end;
    end;
    if DoInvalidate then Invalidate;
end;

procedure TtsBaseGrid.CheckResizeSpinButtons;
var
    DoInvalidate: Boolean;
begin
    DoInvalidate := False;
    if Assigned(FVertSpinButton) then
    begin
        if FVertSpinButton.IsDefault then
        begin
            FreeNil(TObject(FVertSpinButton));
            DoInvalidate := True;
        end;
    end;
    if Assigned(FHorzSpinButton) then
    begin
        if FHorzSpinButton.IsDefault then
        begin
            FreeNil(TObject(FHorzSpinButton));
            DoInvalidate := True;
        end;
    end;
    if DoInvalidate then Invalidate;
end;

procedure TtsBaseGrid.CMCursorChanged(var Message: TMessage);
begin
    FEditControl.Cursor := Cursor;
    FCheckControl.Cursor := Cursor;
end;

procedure TtsBaseGrid.CMDesignHitTest(var Msg: TCMDesignHitTest);
var
    State: TtsMouseStatus;
    DisplayCol, DisplayRow: Longint;
begin
    if MouseStatus in [msColResize, msRowBarResize, msRowResize, msHeadingResize] then
        Msg.Result := Longint(BOOL(True))
    else
    begin
        CellFromXY(Msg.Pos.X, Msg.Pos.Y, DisplayCol, DisplayRow);
        State := GetSizingState(Msg.Pos.X, Msg.Pos.Y, DisplayCol, DisplayRow);
        Msg.Result := Longint(BOOL(State <> msNormal));
    end;
end;

procedure TtsBaseGrid.CMDialogChar(var Message: TCMDialogChar);
var
    DataCol: Longint;
begin
    with Message do
    begin
        if CanFocus then
        begin
            DataCol := GetAccelHeading(CharCode);
            if DataCol <> 0 then
            begin
                DoHeadingClick(DataCol);
                Result := 1;
                Exit;
            end;
        end;
    end;

    inherited;
end;

procedure TtsBaseGrid.WMEraseBkGnd(var Message: TWMEraseBkGnd);
begin
    if (csDesigning in ComponentState) then
    begin
        inherited;
        Exit;
    end;
end;

procedure TtsBaseGrid.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
    inherited;
    Message.Result := Message.Result or DLGC_WANTCHARS;
    if InEditMode or FocusRectActive then
    begin
        if WantTabs and (GetKeyState(VK_CONTROL) >= 0) then
            Message.Result := Message.Result or DLGC_WANTTAB;
    end;
end;

procedure TtsBaseGrid.WMHScroll(var Msg: TWMHScroll);
begin
    CheckDropDownOff(False);
    if (Msg.ScrollCode = SB_LINELEFT) or (Msg.ScrollCode = SB_PAGELEFT) then
    begin
        if (LeftCol = FixedCols) then Exit;
    end;

    if (Msg.ScrollCode <> SB_ENDSCROLL) then
        HideControlBeforeScroll(not IsFocused);

    FInScrolling := True;
    try
        ModifyHorzScrollBar(Msg);
        UpdateScrollPos;

        if (Msg.ScrollCode = SB_ENDSCROLL) then
        begin
            ShowControlAfterScroll;
            Update;
        end;
    finally
        FInScrolling := False;
    end;
end;

procedure TtsBaseGrid.WMKillFocus(var Message : TMessage);
begin
    {$IFDEF TSVER_V3}
    ResetIme;
    {$ENDIF}

    if csDestroying in ComponentState then Exit;

    FInScrollingMode := False;
    FHasKeyFocus := False;
    if not AlwaysShowEditor or DisplayFocusRect(FCurDisplayCol, FCurDisplayRow, False) then
        InvalidateFocusRect(FCurDisplayCol, FCurDisplayRow, False);
end;

procedure TtsBaseGrid.WMNCHitTest(var Msg: TWMNCHitTest);
begin
    DefaultHandler(Msg);
    FHitTest := SmallPointToPoint(Msg.Pos);
end;

procedure TtsBaseGrid.WMPaint(var Message: TWMPaint);
begin
    if FInPutInView then Exit;
    if not CanPaint then Exit;

    try
        inherited;
        if FSetGridControlVisible then
        begin
            MakeGridControlVisible(FEditSelect);
            FSetGridControlVisible := False;
        end;
    finally
        if FDoUpdateScrollRange or FForceUpdateScrollRange then UpdateScrollRange;
        FForceUpdateScrollRange := False;

        if FDoUpdateScrollPos then UpdateScrollPos;
    end;
end;

procedure TtsBaseGrid.WMSetCursor(var Msg: TWMSetCursor);
var
    State: TtsMouseStatus;
    Cur: HCursor;
    DisplayCol, DisplayRow: Longint;
begin
    if csDesigning in ComponentState then
    begin
        Cur := 0;
        State := msNormal;
        with Msg do
        begin
            if HitTest = HTCLIENT then
            begin
                FHitTest := ScreenToClient(FHitTest);
                CellFromXY(FHitTest.X, FHitTest.Y, DisplayCol, DisplayRow);

                begin
                    State := GetSizingState(FHitTest.X, FHitTest.Y, DisplayCol, DisplayRow);
                    if (State in [msColResize, msRowBarResize]) then
                        Cur := Screen.Cursors[crHSplit]
                    else if (State in [msRowResize, msHeadingResize]) then
                        Cur := Screen.Cursors[crVSplit]
                    else
                        Cur := Screen.Cursors[crArrow]
                end;
            end;
        end;

        if Cur <> 0 then
        begin
            SetMouseStatus(State);
            Windows.SetCursor(Cur);
        end;
    end
    else
    begin
        Cur := 0;
        if FSetCursor and (Msg.HitTest = HTCLIENT) then
        begin
            if Screen.Cursor = crDefault then
            begin
                GetCursorPos(FHitTest);
                FHitTest := ScreenToClient(FHitTest);
                CellFromXY(FHitTest.X, FHitTest.Y, DisplayCol, DisplayRow);
                Cur := ShapeCursor(FHitTest.X, FHitTest.Y, DisplayCol, DisplayRow);
                if Cur <> 0 then Windows.SetCursor(Cur);
            end;
        end;
    end;

    if (Cur = 0) then inherited;
end;

procedure TtsBaseGrid.WMSetFocus(var Message : TMessage);
begin
    {$IFDEF TSVER_V3}
    SetIme;
    {$ENDIF}

    if csDestroying in ComponentState then Exit;

    if (not FInHidingGridControl) then
    begin
        if not FControlHidden then
        begin
            if not FGridControl.Visible then ShowGridControl
            else if FocusToGridControl then FGridControl.SetFocus;
            DrawCurrentFocusRect(False);
        end;
    end;
end;

procedure TtsBaseGrid.WMSize(var Msg: TWMSize);
begin
    inherited;
    CheckTopLeft(False);
    AdjustComboGridExtents(DropDownCols, DropDownRows);
    if not (csLoading in ComponentState) then DoResize;
    UpdateScrollRange;
end;

procedure TtsBaseGrid.WMTimer(var Msg: TWMTimer);
begin
    case Msg.TimerID of
        ButtonTimerID: CheckMousePosition;
        SpinTimerID: SpinTimerEvent;
    end;
    inherited;
end;

procedure TtsBaseGrid.WMVScroll(var Msg: TWMVScroll);
begin
    CheckDropDownOff(False);
    if (Msg.ScrollCode = SB_LINEUP) or (Msg.ScrollCode = SB_PAGEUP) then
    begin
        if (TopRow = FixedRows) then Exit;
    end;

    if (Msg.ScrollCode <> SB_ENDSCROLL) then
        HideControlBeforeScroll(not IsFocused);

    FInScrolling := True;
    try
        ModifyVertScrollBar(Msg);
        UpdateScrollPos;

        if (Msg.ScrollCode = SB_ENDSCROLL) then
        begin
            ShowControlAfterScroll;
            Update;
        end;

        Update;
    finally
        FInScrolling := False;
    end;
end;

procedure TtsBaseGrid.WMPaste(var Msg: TWMPaste);
begin
    CurrentCell.PasteFromClipboard;
end;

procedure TtsBaseGrid.WMCopy(var Msg: TWMCopy);
begin
    CurrentCell.CopyToClipboard;
end;

procedure TtsBaseGrid.WMCut(var Msg: TWMCut);
begin
    CurrentCell.CutToClipboard;
end;

procedure TtsBaseGrid.CMEnter(var Message: TCMEnter);
begin
    Inc(FInSetFocus);
    try
        inherited;
    finally
        Dec(FInSetFocus);
    end;
end;

procedure TtsBaseGrid.CMFontChanged(var Message: TMessage);
var
    I: Integer;
    Row: TtsRow;
begin
    inherited;
    for I := 0 to FAutoFontCols.Count - 1 do
        GridCols[FAutoFontCols.Item[I]].CheckFont;

    for I := 0 to FAutoFontRows.Count - 1 do
    begin
        Row := GridRows[FAutoFontRows.Item[I]];
        if Assigned(Row) then Row.CheckFont;
    end;

    UpdateCellFonts;
    if Assigned(FDateTimeForm) then FDateTimeForm.Font := Font;
    if Assigned(FComboForm) then FComboForm.Font := Font;
end;

procedure TtsBaseGrid.CMParentFontChanged(var Message: TMessage);
begin
    inherited;
    if HeadingParentFont then
    begin
        if Message.wParam <> 0 then
            HeadingFont.Assign(TFont(Message.lParam))
        else if Assigned(Parent) then
            HeadingFont.Assign(TWinControl_(Parent).Font);
    end;
end;

procedure TtsBaseGrid.InvalidOp(Msg: string);
begin
    if not FAsCombo
        then raise EInvalidGridOperation.Create(Name + ': ' + Msg)
        else raise EInvalidGridOperation.Create(ParentGrid.Name + '.Combo: ' + Msg);
end;

procedure TtsBaseGrid.InvalidMaskOp(Msg: string);
begin
    if not FAsCombo
        then raise EtsMaskError.Create(Name + ': ' + Msg)
        else raise EtsMaskError.Create(ParentGrid.Name + '.Combo: ' + Msg);
end;

procedure TtsBaseGrid.CheckRaise(Msg: string);
begin
    if FRaiseErrors then InvalidOp(Msg);
end;

function TtsBaseGrid.CheckIndex(IndexType: TtsIndexType; Value, Lower,
                                Upper: Longint): Boolean;
var
    Msg: string;
begin
    Result := (Value >= Lower) and (Value <= Upper);
    if (not Result) and FRaiseErrors then
    begin
        Msg := '';
        case IndexType of
            itCol: Msg := Format(StsColOutOfRange, [Value]);
            itRow: Msg := Format(StsRowOutOfRange, [Value]);
        end;
        InvalidOp(Msg);
    end;
end;

function TtsBaseGrid.CheckGetCell: Boolean;
begin
    Result := not FInDoCellLoaded;
    if (not Result) and FRaiseErrors then
        InvalidOp(StsInCellLoaded);
end;

function TtsBaseGrid.CheckVarType(ControlType: TtsControlType; const Value: Variant): Boolean;
begin
    Result := True;
    if InDesignMode then Exit;

    case ControlType of
        ctText: Result := (VarType(Value) = varString) or (VarType(Value) = varOleStr);
        ctCheck: Result := (VarType(Value) = varByte) or (VarType(Value) = varInteger) or (VarType(Value) = varString) or (VarType(Value) = varOleStr) or VarIsNull(Value);
        ctPicture: Result := (VarType(Value) = varInteger) or (VarType(Value) = varString);
    end;

    if (not Result) and FRaiseErrors then
    begin
        case ControlType of
            ctText: InvalidOp(StsInvalidString);
            ctCheck: InvalidOp(StsInvalidCheck);
            ctPicture: InvalidOp(StsInvalidBitmap);
        end;
    end;
end;

function TtsBaseGrid.StopTimer(var TimerHandle: Integer): Boolean;
begin
    Result := TimerHandle <> 0;
    if Result then
    begin
        if HandleAllocated then KillTimer(Handle, TimerHandle);
        TimerHandle := 0;
    end;
end;

procedure TtsBaseGrid.StartTimer(var TimerHandle: Integer; TimerID: Integer;
                                 Interval: Integer; Restart: Boolean);
begin
    if (TimerHandle = 0) or Restart then
    begin
        StopTimer(TimerHandle);
        TimerHandle := SetTimer(Handle, TimerID, Interval, nil);
    end;
end;

procedure TtsBaseGrid.StartButtonTimer;
begin
    StartTimer(FButtonTimer, ButtonTimerID, 50, False);
end;

procedure TtsBaseGrid.StartSpinTimer(UseStartDelay: Boolean);
var
    Delay: Integer;
begin
    if FSpinTimer = 0 then
    begin
        if UseStartDelay
            then Delay := SpinStartDelay
            else Delay := SpinRepeatDelay;
        StartTimer(FSpinTimer, SpinTimerID, Delay, False);
    end;
end;

procedure TtsBaseGrid.CheckRestartSpinTimer;
begin
    if (FSpinTimer <> 0) and (FUseSpinStartDelay) then
    begin
        StopTimer(FSpinTimer);
        FUseSpinStartDelay := False;
        StartSpinTimer(FUseSpinStartDelay);
    end;
end;

function TtsBaseGrid.InSetFocus: Boolean;
begin
    Result := FInSetFocus <> 0;
end;

function TtsBaseGrid.InDoExit: Boolean;
begin
    Result := FInDoExit <> 0;
end;

function TtsBaseGrid.CanActivateEvent: Boolean;
begin
    Result := not (csLoading in ComponentState);
end;

procedure TtsBaseGrid.UpdateDesigner;
begin
    if (not (csReading in ComponentState)) and FFirstTimePainted then
        inherited UpdateDesigner;
end;

function TtsBaseGrid.GetInDesignMode: Boolean;
begin
    if FAsCombo
        then Result := ParentGrid.InDesignMode
        else Result := (csDesigning in ComponentState) or FDesigning;
end;

procedure TtsBaseGrid.SetInDesignMode(Value: Boolean);
begin
    if InDesignMode <> Value then
    begin
        FDesigning := Value;
    end;
end;

procedure TtsBaseGrid.SetStoreData(Value: Boolean);
begin
    if FStoreData <> Value then
    begin
        FStoreData := Value;
        if not FStoreData then
            FreeGridData
        else if not Assigned(FGridData) then
        begin
            FGridData := Tts2DStorage.Create(0, 0);
            Tts2DStorage_(FGridData).FInDesignMode := InDesignMode;
            SetDataAllocSize(Cols, Rows);
            Invalidate;
        end;
    end;
end;

procedure TtsBaseGrid.SetSelectionColor(Value: TColor);
begin
    if FSelectionColor <> Value then
    begin
        FSelectionColor := Value;
        CheckPictureMask(False);
        if GridStatus <> grNormal then Invalidate;
    end;
end;

procedure TtsBaseGrid.SetSelectionFontColor(Value: TColor);
begin
    if FSelectionFontColor <> Value then
    begin
        FSelectionFontColor := Value;
        if GridStatus <> grNormal then Invalidate;
    end;
end;

procedure TtsBaseGrid.SetSelectionType(Value: TtsSelectionType);
begin
    if FSelectionType <> Value then
    begin
        FSelectionType := Value;
        if GridStatus <> grNormal then Invalidate;
    end;
end;

procedure TtsBaseGrid.SetFocusBorder(Value: TtsFocusBorder);
var
    ResetOuter: Boolean;
begin
    if FocusBorder <> Value then
    begin
        ResetOuter := FocusBorder in [fbSingle, fbDouble];
        FFocusBorder := Value;
        FocusChanged(ResetOuter);
    end;
end;

procedure TtsBaseGrid.SetFocusBorderColor(Value : TColor);
begin
  if (FFocusBorderColor <> Value) then
  begin
    FFocusBorderColor := Value;
    FocusChanged(False);
  end;
end;

procedure TtsBaseGrid.SetFocusColor(Value: TColor);
begin
    if FocusColor <> Value then
    begin
        FFocusColor := Value;
        FocusChanged(False);
    end;
end;

procedure TtsBaseGrid.SetFocusFontColor(Value: TColor);
begin
    if FocusFontColor <> Value then
    begin
        FFocusFontColor := Value;
        FocusChanged(False);
    end;
end;

function TtsBaseGrid.GetDrawBitmap: TBitmap;
begin
    if not FAsCombo then
    begin
        if not Assigned(FDrawBitmap) then
        begin
            FDrawBitmap := TBitmap.Create;
            FDrawBitmap.Handle := FDrawBitmap.Handle;
        end;
        Result := FDrawBitmap;
    end
    else
        Result := ParentGrid.DrawBitmap;
end;

function TtsBaseGrid.GetPictureColorMask: TBitmap;
begin
    Result := FPictureColorMask;
    if not Assigned(Result) then
    begin
        CheckPictureMask(True);
        Result := FPictureColorMask;
    end;
end;

procedure TtsBaseGrid.SetDateTimeDef(Value: TtsDateTimeDefComponent);
begin
    if Value <> FDateTimeDef then
    begin
        RemoveDateTime(FDateTimeDef);
        FDateTimeDef := Value;
        AddDateTime(FDateTimeDef);
    end;
end;

procedure TtsBaseGrid.SetCheckBoxValues(Value: string);
begin
    if Value <> FCheckBoxValues then
    begin
        if not CheckBoxValuesOk(Value) then
            InvalidOp(Format(StsInvalidCheckBoxValues, [Value]));
        FCheckBoxValues := Value;
        SetControlCheckBoxValues;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetAlwaysShowScrollBar(Value: TScrollStyle);
begin
    if Value <> FAlwaysShowScrollBar then
    begin
        FAlwaysShowScrollBar := Value;
        UpdateScrollRange;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

function TtsBaseGrid.GetAutoScale: Boolean;
begin
    if FAsCombo
        then Result := ParentGrid.AutoScale
        else Result := FAutoScale;
end;

procedure TtsBaseGrid.SetAutoScale(Value: Boolean);
begin
    if FAsCombo then Exit;
    FAutoScale := Value;
end;

function TtsBaseGrid.GetVisibleColCount: Integer;
var
    Sum, I: Integer;
    LineWidth: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth;
    I := LeftCol - 1;
    while Sum < ClientWidth do
    begin
        Inc(I);
        if I >= ColCount then Break;

        Inc(Sum, ColWidths[I]);
        LineWidth := FVertLineWidth;
        if ColWidths[I] = 0 then LineWidth := 0;
        if Sum - LineWidth <= ClientWidth then Inc(Count);
    end;

    Result := Count;
end;

function TtsBaseGrid.GetVisibleRowCount: Integer;
var
    Sum, I: Integer;
    LineWidth: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FVertFixedHeight;
    I := TopRow - 1;
    while Sum < ClientHeight do
    begin
        Inc(I);
        if I >= RowCount then Break;

        Inc(Sum, RowHeights[I]);
        LineWidth := FHorzLineWidth;
        if RowHeights[I] = 0 then LineWidth := 0;
        if Sum - LineWidth <= ClientHeight then Inc(Count);
    end;

    Result := Count;
end;

function TtsBaseGrid.GetVisibleCols: Double;
var
    Sum, I: Longint;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Sum := 0;
    if RowBarOn then Sum := RowBarWidth;

    Count := 0;
    I := 0;
    while I < FInternalFixedCols do
    begin
        if Sum + ColWidths[I + 1] > ClientWidth then Break;
        Inc(I);
        Sum := Sum + ColWidths[I];
        if GridCols[GetDataCol(I)].Visible then Inc(Count);
    end;

    if I < FInternalFixedCols then
    begin
        Result := Count;
        if GetNextCol(I, False, False, I) then
            Result := Result + (ClientWidth - Sum)/ColWidths[I];
        Exit;
    end;

    I := CalcMax(0, LeftCol - 1);
    while I < ColCount - 1 do
    begin
        if Sum + ColWidths[I + 1] > ClientWidth then Break;
        Inc(I);
        Sum := Sum + ColWidths[I];
        if GridCols[GetDataCol(I)].Visible then Inc(Count);
    end;

    Result := Count;
    if (I < ColCount - 1) and (Sum < ClientWidth) then
    begin
        if GetNextCol(I, False, False, I) then
            Result := Result + (ClientWidth - Sum)/ColWidths[I];
    end;
end;

function TtsBaseGrid.GetVisibleRows: Double;
var
    Sum, I: Longint;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Sum := 0;
    if HeadingOn then Sum := HeadingHeight;

    Count := 0;
    I := 0;
    while I < FInternalFixedRows do
    begin
        if Sum + RowHeights[I + 1] > ClientHeight then Break;
        Inc(I);
        Sum := Sum + RowHeights[I];
        if IsRowVisible(GetDataRow(I)) then Inc(Count);
    end;

    if I < FInternalFixedRows then
    begin
        Result := Count;
        if GetNextRow(I, False, False, I) then
            Result := Result + (ClientHeight - Sum)/RowHeights[I];
        Exit;
    end;

    I := CalcMax(0, TopRow - 1);
    while I < RowCount - 1 do
    begin
        if Sum + RowHeights[I + 1] > ClientHeight then Break;
        Inc(I);
        Sum := Sum + RowHeights[I];
        if IsRowVisible(GetDataRow(I)) then Inc(Count);
    end;

    Result := Count;
    if (I < RowCount - 1) and (Sum < ClientHeight) then
    begin
        if GetNextRow(I, False, False, I) then
            Result := Result + (ClientHeight - Sum)/RowHeights[I];
    end;
end;

function TtsBaseGrid.GetGridRowHeights(Index: Longint): Integer;
begin
    Result := 0;
    if (Index >= 0) and (Index < RowCount) then
        Result := RowHeights[Index];
end;

function TtsBaseGrid.ResizeCol(DisplayCol: Longint; Value: Integer): Boolean;
begin
    Result := False;
    if ColWidths[DisplayCol] = Value then Exit;

    Result := True;
    FSkipColWidthsChanged := True;
    try
        ColWidths[DisplayCol] := Value;
        SingleColWidthChanged(DisplayCol);
    finally
        FSkipColWidthsChanged := False;
    end;
end;

function TtsBaseGrid.ResizeRow(DisplayRow: Longint; Value: Integer; bDeleteInProgress : Boolean): Boolean;
begin
    Result := False;
    if RowHeights[DisplayRow] = Value then Exit;

    Result := True;
    FSkipRowHeightsChanged := True;
    try
        RowHeights[DisplayRow] := Value;
        if not bDeleteInProgress then
           SingleRowHeightChanged(DisplayRow);
    finally
        FSkipRowHeightsChanged := False;
    end;
end;

procedure TtsBaseGrid.ScaleRows(M, D: Integer; Flags: TScalingFlags);
var
    I: Integer;
begin
    if M = D then Exit;

    FSkipRowHeightsChanged := True;
    try
        if sfHeight in Flags then DefaultRowHeight := MulDiv(DefaultRowHeight, M, D);
    finally
        FSkipRowHeightsChanged := False;
    end;

    try
        for I := 1 to Rows do
        begin
            if Assigned(GridRows[I]) then
            begin
                if sfHeight in Flags then
                begin
                    FSkipRowHeightsChanged := True;
                    try
                        GridRows[I].Height := MulDiv(GridRows[I].Height, M, D);
                    finally
                        FSkipRowHeightsChanged := False;
                    end;
                end;

                if (sfFont in Flags) and not GridRows[I].ParentFont then
                    if Assigned(GridRows[I].Font) then GridRows[I].Font.Size := MulDiv(GridRows[I].Font.Size, M, D);

                if GridRows[I].FCombo <> nil then GridRows[I].FCombo.FGrid.ChangeScale(M, D);
            end;
        end;
    finally
        if sfHeight in Flags then RowHeightsChanged;
    end;
end;

procedure TtsBaseGrid.ScaleCols(M, D: Integer; Flags: TScalingFlags);
var
    I: Integer;
begin
    if M = D then Exit;

    FSkipColWidthsChanged := True;
    try
        if sfWidth in Flags then DefaultColWidth := MulDiv(DefaultColWidth, M, D);
    finally
        FSkipColWidthsChanged := False;
    end;

    try
        for I := 1 to Cols do
        begin
            if sfWidth in Flags then
            begin
                FSkipColWidthsChanged := True;
                try
                    GridCols[I].Width := MulDiv(GridCols[I].Width, M, D);
                finally
                    FSkipColWidthsChanged := False;
                end;
            end;

            if (sfFont in Flags) and not GridCols[I].ParentFont then
                if Assigned(GridCols[I].Font) then GridCols[I].Font.Size := MulDiv(GridCols[I].Font.Size, M, D);

            if GridCols[I].FCombo <> nil then GridCols[I].FCombo.FGrid.ChangeScale(M, D);
        end;
    finally
        ColWidthsChanged;
    end;
end;

procedure TtsBaseGrid.ScaleCells(M, D: Integer; Flags: TScalingFlags);
var
    I: Integer;
    List: TtsSetList;
    Element: TtsCustomPropElement;
begin
    List := FCellPropSet.List;
    try
        for I := 1 to List.Count do
        begin
            Element := TtsCustomPropElement(List.Items[I]);
            if (sfFont in Flags) and not Element.FParentFont then
                if Assigned(Element.FFont) then Element.FFont.Size := MulDiv(Element.FFont.Size, M, D);
            if Element.FCombo <> nil then Element.FCombo.Grid.ChangeScale(M, D);
        end;
    finally
        List.Free;
    end;
end;

function TtsBaseGrid.CurrentCellInView : Boolean;
begin
    if ((FCurDisplayRow < TopRow) and not (FCurDisplayRow < FixedRows)) or
       ((FCurDisplayCol < LeftCol) and not (FCurDisplayCol < FixedCols)) or
       (FCurDisplayRow > MaxVisibleRow) or (FCurDisplayCol > MaxVisibleCol) or
       (FCurDisplayRow < 1) or (FCurDisplayCol < 1) then
        Result := False
    else
        Result := True;
end;

function TtsBaseGrid.GridControlActive: Boolean;
begin
    if not (FGridStatus = grNormal) then
        Result := False
    else if not (GridMode in [gmEdit, gmEditInsert]) then
        Result := False
    else if CurCellReadOnly then
        Result := False
    else if CurCellSelected then
        Result := False
    else
        Result := True;
end;

function TtsBaseGrid.CanSetControl: Boolean;
begin
    if (csDesigning in ComponentState) then
        Result := False
    else if not CurrentCellInView then
        Result := False
    else
        Result := GridControlActive;
end;

function TtsBaseGrid.ControlDisplayed: Boolean;
begin
    Result := FControlSet and FControlEnabled;
end;

procedure TtsBaseGrid.DoHideControl(RemoveSelect: Boolean);
var
    ARow : Longint;
    ACol : Longint;
    WasFocused: Boolean;
begin
    if not HandleAllocated then Exit;
    if FastAssign then Exit;

    FInHidingGridControl := True;
    try
        WasFocused := FGridControl.Focused;
        FGridControl.Hide;
        if WasFocused and Visible then
        begin
            SetFocus;
            if not Focused then Windows.SetFocus(Handle);
        end;

        FDisplayAsControl := not RemoveSelect;
        if RemoveSelect then
        begin
            CellFromXY(FGridControl.Left, FGridControl.Top, ACol, ARow);
            if (ARow > 0) and (ACol > 0) then InvalidateCell(ACol, ARow);
        end;
    finally
        FInHidingGridControl := False;
    end;
end;

{function TtsBaseGrid.HTMLText : String;
var hp : TtsHTMLGridProducer;
begin
  Result := '';
  hp := TtsHTMLGridProducer.Create(Self);
  try
    hp.Grid := Self;
    Result := hp.Content;
  finally // wrap up
    hp.Free;
  end;    // try/finally
end;}

function TtsBaseGrid.HTMLFont : String;
begin
  Result := StsHTMLFontStyle;
  Result := StringReplace(Result, 'FONTNAME', Self.Font.Name, []);
  Result := StringReplace(Result, 'BGCOLOR', ColorToString(TranslateColor(HeadingColor)), []);
  Result := StringReplace(Result, 'FNCOLOR', ColorToString(TranslateColor(Font.Color)), []);
  Result := StringReplace(Result, 'FNSIZE', IntToStr(Self.Font.Size), []);
  if fsBold in Self.Font.Style then
     Result := StringReplace(Result, 'FNBOLD', 'BOLD', [])
  else
     Result := StringReplace(Result, 'FNBOLD', 'NORMAL', []);
  Result := StringReplace(Result, 'HDHEIGHT', IntToStr(HeadingHeight), []);
end;

procedure TtsBaseGrid.HideGridControl(RemoveSelect: Boolean);
begin
    if (csDesigning in ComponentState) then Exit;
    if not HandleAllocated then Exit;
    if FastAssign then Exit;

    FControlHidden := True;
    FControlSet := False;
    DoHideControl(RemoveSelect);
end;

function TtsBaseGrid.CheckHideControl(RemoveSelect: Boolean): Boolean;
begin
    Result := FControlSet;
    if FastAssign then Exit;

    if FControlSet or RemoveSelect then HideGridControl(RemoveSelect);
end;

procedure TtsBaseGrid.RedisplayControl(RemoveSelect: Boolean);
begin
    CheckHideControl(RemoveSelect);
    ShowGridControl;
end;

function TtsBaseGrid.EditScrollMode: TtsScrollMode;
begin
    Result := smGridControl;
    if GridCols[GetDataCol(FCurDisplayCol)].ReadOnly and
       (not FocusRectActive) then Result := smRowSelect;
end;

procedure TtsBaseGrid.SetControlSelectMode(SelectMode: TtsTextSelectMode);
begin
    FEditSelect := SelectMode;
end;

procedure TtsBaseGrid.SetLastAddedRow(DisplayRow: Longint);
begin
    FLastAddedRow := DisplayRow;
end;

procedure TtsBaseGrid.SetSelectionStartRow(DisplayRow: Longint);
begin
end;

function TtsBaseGrid.SelectionStartRownr: Integer;
begin
    Result := FCurDisplayRow;
end;

procedure TtsBaseGrid.CheckSetCurrentRow(DisplayRow: Longint);
begin
end;

procedure TtsBaseGrid.SetMaxTextLength(DisplayCol: Longint; MaxLen: Integer);
begin
    if (DisplayCol = FCurDisplayCol) and InEditMode and Assigned(FGridControl) then
    begin
        FGridControl.MaxLength := MaxLen;
    end;
end;

procedure TtsBaseGrid.SetWantTabs(Value: Boolean);
begin
    if FWantTabs <> Value then
    begin
        FWantTabs := Value;
        if Assigned(FGridControl) then FGridControl.WantTabs := Value;
    end;
end;

procedure TtsBaseGrid.SetFlatButtons(Value: Boolean);
begin
    if FFlatButtons <> Value then
    begin
        FFlatButtons := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetRowBarIndicator(Value: Boolean);
begin
    if FRowBarIndicator <> Value then
    begin
        FRowBarIndicator := Value;
        if CurDisplayRow > 0 then InvalidateCell(0, CurDisplayRow);
    end;
end;

procedure TtsBaseGrid.SetControlProperties(CellControl: TtsCustomGridControl);
var
    Rect : TRect;
    IsCell3D: Boolean;
    BrushColor, FontColor : TColor;
    AFont: TFont;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
    ControlWidth, ControlHeight: Integer;
begin
    if not HandleAllocated then Exit;
    if csDesigning in ComponentState then Exit;

    IsCell3D := GiveCell3D(FCurDataCol, FCurDataRow);
    AFont := GiveCellFont(FCurDataCol, FCurDataRow);
    BrushColor := GiveCellColor(FCurDataCol, FCurDataRow, IsCell3D);

    if AFont = Nil then
       FontColor := clNone
    else
       FontColor := AFont.Color;
    if CellControl.IsEditControl then
    begin
        if (FEditColor <> clNone) then BrushColor := FEditColor;
        if (FEditFontColor <> clNone) then FontColor := FEditFontColor;
    end;

    Rect := CellRect(FCurDisplayCol, FCurDisplayRow);
    ControlWidth := ColWidths[FCurDisplayCol] - tsRangeSelectWidth - FVertLineWidth;
    ControlHeight := RowHeights[FCurDisplayRow] - FHorzLineWidth;

    CellControl.KeyEdit := True;
    CellControl.MouseSelect := True;
    ButtonType := GiveCellButton(FCurDataCol, FCurDataRow, DropDownStyle);
    if ButtonType <> btNone then
    begin
        FGridButton := GridCellButton(FCurDisplayCol, ButtonType);
        ControlWidth := CalcMax(ControlWidth - FGridButton.FullWidth, 0);
        if (ButtonType in [btCombo, btDateTimeDropDown, btDateTimePopup]) then
        begin
            CellControl.KeyEdit := DropDownStyle <> ddDropDownList;
            CellControl.MouseSelect := DropDownStyle <> ddDropDownList;
        end
        else if IsSpinButton(ButtonType) then
            CellControl.KeyEdit := spoKeyEdit in GiveCellSpinOptions(FCurDataCol, FCurDataRow);
    end
    else
    begin
        if IsCell3D and (FVertLineWidth = 0) then ControlWidth := ControlWidth - 1;
    end;
    if IsCell3D and (FHorzLineWidth = 0) then ControlHeight := ControlHeight - 1;

    if CanSetControl then
    begin
        CellControl.Left := Rect.Left + tsRangeSelectWidth;
        CellControl.Top := Rect.Top;
        CellControl.Width := ControlWidth;
        CellControl.Height := ControlHeight;
    end;

    CellControl.Color := BrushColor;
    CellControl.Font.Assign(AFont);
    CellControl.Font.Color := FontColor;
    CellControl.Ctl3D := IsCell3D;
    CellControl.Alignment := GiveCellAlignment(FCurDataCol, FCurDataRow);
    CellControl.VertAlignment := GiveCellVertAlignment(FCurDataCol, FCurDataRow);
    CellControl.WordWrap := GiveCellWordWrap(FCurDataCol, FCurDataRow);
    CellControl.MaxLength := GridCols[GetDataCol(FCurDisplayCol)].MaxLength;
    CellControl.WantTabs := WantTabs;
    CellControl.AlwaysShowFocus := AlwaysShowFocus;

    if CellControl = FCheckControl then
    begin
        FCheckControl.AllowGrayed := GridCols[GetDataCol(FCurDisplayCol)].AllowGrayed;
        FCheckControl.CheckBoxValues := CurCellCheckBoxValues;
    end;
end;

procedure TtsBaseGrid.UpdateControlProperties(const DrawData: TtsDrawData);
begin
    if not Assigned(FGridControl) then Exit;

    with DrawData do
    begin
        if FGridControl.Color <> BrushColor then FGridControl.Color := BrushColor;
        if FGridControl.Font <> Font then FGridControl.Font.Assign(Font);
        if FGridControl.Alignment <> Alignment then FGridControl.Alignment := Alignment;
        if FGridControl.VertAlignment <> VertAlignment then FGridControl.VertAlignment := VertAlignment;
        if FGridControl.WordWrap <> WordWrap then FGridControl.WordWrap := WordWrap;
    end;
end;

procedure TtsBaseGrid.SetGridControl(ControlType: TtsControlType);
var
    NewControl : TtsCustomGridControl;
begin
    NewControl := GridCellControl(ControlType);
    if NewControl <> FGridControl then
    begin
        DoHideControl(True);
        FGridControl := NewControl;
        ClearControlBuffer;
    end;
end;

procedure TtsBaseGrid.CheckEnableControl(Enable, Redisplay: Boolean; SelectMode: TtsTextSelectMode);
begin
    if FControlEnabled <> Enable then
    begin
        FControlEnabled := Enable;
        if EditorActive then
        begin
            SetControlSelectMode(SelectMode);
            if SelectMode = tsAll then
                CurrentCell.SelectAll
            else if SelectMode = tsNone then
                CurrentCell.SelLength := 0;
        end;
        if Redisplay then RedisplayControl(True);
    end;
end;

function TtsBaseGrid.InternalShowEditor(SelectMode: TtsTextSelectMode; DoUpdate: Boolean): Boolean;
var
    Cancel: Boolean;
begin
    Result := False;
    if InEditState and not FControlEnabled and GridControlActive then
    begin
        DoShowEditor(FCurDataCol, FCurDataRow, Cancel);
        if not Cancel then
        begin
            ClearCurrentFocusRect(False);
            CheckEnableControl(True, True, SelectMode);
            if DoUpdate then Update;
            Result := FControlEnabled;
        end;
    end;
end;

function TtsBaseGrid.ShowEditor: Boolean;
begin
    Result := InternalShowEditor(tsAll, True);
end;

function TtsBaseGrid.StartShowEditor(DoUpdate: Boolean): Boolean;
begin
    Result := False;
    if GridControlActive and InEditState then
    begin
        Result := StartEdit;
        if Result then Result := StartCellChange(FCurDataCol, True);
        if Result then Result := FControlEnabled or InternalShowEditor(tsAll, DoUpdate);
    end;
end;

function TtsBaseGrid.HideEditor: Boolean;
begin
    Result := False;
    if FControlEnabled and not AlwaysShowEditor then
    begin
        if not CheckEndEdit(GetDataCol(FCurDisplayCol), GetDataRow(FCurDisplayCol), True) then Exit;
        CheckEnableControl(AlwaysShowEditor, True, FEditSelect);
        DrawCurrentFocusRect(False);
        Update;
        Result := not FControlEnabled;
    end;
end;

function TtsBaseGrid.EditorActive: Boolean;
begin
    Result := GridControlActive and FControlEnabled and InEditState;
end;

procedure TtsBaseGrid.ShowGridControl;
var
    OldPoint: TPoint;
    WasVisible: Boolean;
    OldRow, OldCol: Longint;
    OldControlSet: Boolean;
begin
    if (csDesigning in ComponentState) then Exit;
    if not HandleAllocated then Exit;
    if FastAssign then Exit;

    FControlHidden := False;
    if not CanSetControl then
    begin
        FGridControl := GridCellControl(CurCellControlType);
        if Assigned(FGridControl) then
        begin
            FGridControl.Left := -FGridControl.Width;
            FGridControl.Top := -FGridControl.Height;
        end;
        SetControlMask;
        Exit;
    end;

    OldControlSet := FControlSet;
    FControlSet := True;

    SetGridControl(CurCellControlType);
    if (FGridControl.Visible) or (OldControlSet) then
    begin
        WasVisible := True;
        OldPoint.X := FGridControl.Left;
        OldPoint.Y := FGridControl.Top;
        CellFromXY(OldPoint.X, OldPoint.Y, OldCol, OldRow)
    end
    else
        WasVisible := False;

    if WasVisible then DoHideControl(False);
    if WasVisible and not FTopLeftChanged and
       ((OldCol <> FCurDisplayCol) or (OldRow <> FCurDisplayRow)) then
    begin
        InvalidateCell(OldCol, OldRow);
    end;

    SetControlProperties(FGridControl);
    SetControlMask;

    if not FInPaintWindow then InvalidateCell(FCurDisplayCol, FCurDisplayRow);
    FTopLeftChanged := False;
end;

procedure TtsBaseGrid.MakeGridControlVisible(SelectMode: TtsTextSelectMode);
begin
    if (csDesigning in ComponentState) or (not HandleAllocated) then Exit;
    if not (GridMode in [gmEdit, gmEditInsert]) then Exit;
    if not FControlEnabled then Exit;

    if ((FCurDisplayRow < TopRow) and not (FCurDisplayRow < FixedRows)) or
       ((FCurDisplayCol < LeftCol) and not (FCurDisplayCol < FixedCols)) or
       (FCurDisplayRow > MaxVisibleRow) or (FCurDisplayCol > MaxVisibleCol) then Exit;

    FControlSet := True;
    FGridControl.Visible := True;
    if FocusToGridControl and not InSetFocus then FGridControl.SetFocus;
    FGridControl.Repaint;
end;

function TtsBaseGrid.FocusToGridControl: Boolean;
begin
    Result := (IsFocused) and (FGridControl.Visible) and
              (not FInScrollingMode) and (not FMouseDownToControl) and
              (not (csDesigning in ComponentState));
end;

procedure TtsBaseGrid.SetCanProcessKey(Value: Boolean);
begin
    if not Value then
        Inc(FCanProcessKey)
    else if FCanProcessKey > 0 then
        Dec(FCanProcessKey);
end;

function TtsBaseGrid.GetCanProcessKey: Boolean;
begin
    Result := (FCanProcessKey = 0);
end;

procedure TtsBaseGrid.MoveRowIntoView(DisplayRow: Longint; var NewTopRow: Longint);
var
    Sum, I: Longint;
    ARect: TRect;
begin
    if not HandleAllocated then Exit;

    NewTopRow := TopRow;
    if DisplayRow > TopRow + VisibleRowCount - 1 then
    begin
        Sum := 0;
        for I := TopRow + VisibleRowCount to DisplayRow do
            Inc(Sum, RowHeights[I]);

        if TopRow + VisibleRowCount = MaxVisibleRow then
        begin
            ARect := CellRect(0, MaxVisibleRow);
            Dec(Sum, ARect.Bottom - ARect.Top);
        end;

        NewTopRow := TopRow;
        while Sum > 0 do
        begin
            if (NewTopRow = DisplayRow) and
               (FVertFixedHeight + RowHeights[NewTopRow] > ClientHeight) then Break;

            Dec(Sum, RowHeights[NewTopRow]);
            Inc(NewTopRow);
        end;

        if not IsRowVisible(GetDataRow(NewTopRow)) then
            GetNextRow(NewTopRow, False, False, NewTopRow);
    end
    else if (DisplayRow >= FixedRows) and (DisplayRow < TopRow) then
    begin
        NewTopRow := DisplayRow;
    end;
end;

procedure TtsBaseGrid.MoveColToRight(DisplayCol: Longint; var NewLeftCol: Longint);
var
    I, Sum: Integer;
    NewLeft: Longint;
begin
    if not HandleAllocated then Exit;

    Sum := FHorzFixedWidth + ColWidths[DisplayCol];
    I := 0;
    while (DisplayCol - I > FixedCols) do
    begin
        if Sum + ColWidths[DisplayCol-I-1] - FVertLineWidth > ClientWidth then Break;

        Inc(I);
        Inc(Sum, ColWidths[DisplayCol-I]);
    end;

    NewLeftCol := NewLeftCol - I;
    if not GridCols[GetDataCol(NewLeftCol)].Visible then
    begin
        if GetNextCol(NewLeftCol, False, False, NewLeft)
            then NewLeftCol := NewLeft
            else NewLeftCol := DisplayCol;
    end;
end;

procedure TtsBaseGrid.MoveRowToBottom(DisplayRow: Longint; var NewTopRow: Longint);
var
    NewTop: Longint;
    I, Sum: Integer;
begin
    if not HandleAllocated then Exit;

    Sum := FVertFixedHeight + RowHeights[DisplayRow];
    I := 0;
    while DisplayRow - I > FixedRows do
    begin
        if Sum + RowHeights[DisplayRow-I-1] - FHorzLineWidth > ClientHeight then
            Break;

        Inc(I);
        Inc(Sum, RowHeights[DisplayRow - I]);
    end;

    NewTopRow := NewTopRow - I;

    if (DisplayRow = Rows) and (NewTopRow < DisplayRow) and
       (GridMode = gmEditInsert) and (InsertionRow = 1) then
    begin
        if (Sum < ClientHeight) and (Sum + RowHeights[RowCount - 1] > ClientHeight) then
            NewTopRow := NewTopRow + 1;
    end;

    if not IsRowVisible(GetDataRow(NewTopRow)) then
    begin
        if GetNextRow(NewTopRow, False, False, NewTop)
            then NewTopRow := NewTop
            else NewTopRow := DisplayRow;
    end;
end;

function TtsBaseGrid.MoveToDisplayCol(StartCol, DisplayCol: Longint; Position: TtsViewPosition): Longint;
begin
    Result := StartCol;
    if (DisplayCol < StartCol) then
    begin
        if DisplayCol >= FixedCols then Result := DisplayCol
                                   else Result := FixedCols;

        if Position in [vpRight, vpBoth] then MoveColToRight(DisplayCol, Result);
    end
    else
    begin
        if DisplayCol >= MaxVisibleCol then
        begin
            Result := DisplayCol;
            MoveColToRight(DisplayCol, Result);
        end;
    end;
end;

procedure TtsBaseGrid.PutInView(DisplayCol, DisplayRow: Longint; Position: TtsViewPosition;
                                ResetCurrent, SetCurPos: Boolean; ChangeTopLeft: TtsChangeTopLeft);
var
    NewLeftCol, NewTopRow: Longint;
    OldCurrentRow: Longint;
begin
    CheckHideControl(True);
    NewLeftCol := MoveToDisplayCol(LeftCol, DisplayCol, Position);

    NewTopRow := TopRow;
    if (DisplayRow < TopRow) then
    begin
        if DisplayRow >= FixedRows then NewTopRow := DisplayRow
                                   else NewTopRow := FixedRows;
        if Position in [vpBottom, vpBoth] then MoveRowToBottom(DisplayRow, NewTopRow);
    end
    else
    begin
        if DisplayRow >= MaxVisibleRow then
        begin
            NewTopRow := DisplayRow;
            MoveRowToBottom(DisplayRow, NewTopRow);
        end;
    end;

    if SetCurPos then
    begin
        if (DisplayRow <> FCurDisplayRow) or (DisplayCol <> FCurDisplayCol) then
            ClearCurrentFocusRect(False);

        if DisplayRow <> FCurDisplayRow then
        begin
            if TopRow = NewTopRow then
            begin
                ClearCurrent(FCurDisplayRow);
                SetCurrentPositionAndDraw(DisplayCol, DisplayRow, True, True);
            end
            else
            begin
                OldCurrentRow := FCurDisplayRow;
                SetCurrentPosition(DisplayCol, DisplayRow, True, True);
                if ResetCurrent then InvalidateCell(0, OldCurrentRow);
            end;
        end
        else
            SetCurrentPosition(DisplayCol, DisplayRow, True, True);
    end;

    SetControlSelectMode(tsAll);
    if (ChangeTopLeft = ctlBoth) and (LeftCol <> NewLeftCol) and
       (TopRow <> NewTopRow) then
    begin
        EnablePaint := False;
        try
            MoveTopLeft(NewLeftCol, NewTopRow);
        finally
            EnablePaint := True;
        end;
    end
    else if (ChangeTopLeft in [ctlBoth, ctlLeft]) and (LeftCol <> NewLeftCol) then
        LeftCol := NewLeftCol
    else if (ChangeTopLeft in [ctlBoth, ctlTop]) and (TopRow <> NewTopRow) then
    begin
        ScrollGrid(LeftCol, NewTopRow, smGridControl);
    end;

    ShowGridControl;
    DrawCurrentFocusRect(False);
end;

procedure TtsBaseGrid.PutCellInView(DataCol, DataRow: Longint);
begin
    if not CheckIndex(itCol, DataCol, 1, Cols) then Exit;
    if not CheckIndex(itRow, DataRow, 1, Rows) then Exit;

    PutInView(DisplayColnr[DataCol], DisplayRownr[DataRow], vpNone, True, False, ctlBoth);
end;

procedure TtsBaseGrid.ShiftKeyDownVK_Tab;
var
    CurCol, CurRow: Longint;
    NewCurrentCol, NewCurrentRow: Longint;
    NewLeftCol: Longint;
    Clear: Boolean;
    ScrollMode: TtsScrollMode;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    CurCol := FCurDisplayCol;
    CurRow := FCurDisplayRow;
    if GetPrevCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) then
    begin
        if (not FTabRowWrap) and (NewCurrentRow <> FCurDisplayRow) then Exit;
        if not CanMoveToPos(NewCurrentCol, NewCurrentRow) then Exit;
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        if GetPrevCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) then
        begin
            if (NewCurrentCol > FCurDisplayCol) or
               (NewCurrentRow < FCurDisplayRow) then
            begin
                PutInView(NewCurrentCol, NewCurrentRow, vpNone, False, True, ctlBoth);
                if GetPrevCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) then
                begin
                    if (FCurDisplayCol <> NewCurrentCol) or
                       (FCurDisplayRow <> NewCurrentRow) then
                    begin
                        PutInView(NewCurrentCol, NewCurrentRow, vpNone, False, True, ctlBoth);
                    end;
                end;
            end
            else
            begin
                NewLeftCol := LeftCol;
                if NewCurrentCol < NewLeftCol then
                begin
                    if NewCurrentCol >= FixedCols then NewLeftCol := NewCurrentCol
                                                  else NewLeftCol := MinLeftCol;
                end;

                FInScrollingMode := FHasKeyFocus;
                Clear := LeftCol = NewLeftCol;
                HideGridControl(Clear);

                if Clear then ClearCurrentFocusRect(False);
                ScrollMode := smGridControl;
                SetControlSelectMode(tsAll);
                SetCurrentPosition(NewCurrentCol, NewCurrentRow, True, False);
                ScrollGrid(NewLeftCol, TopRow, ScrollMode);
                ShowGridControl;
                DrawCurrentFocusRect(False);
                CheckRowColChanged;
                Update;
            end;

            CheckRowColChanged;
        end;
    end;
end;

procedure TtsBaseGrid.KeyCtrl_Home;
var
    NewCurrentRow, NewCurrentCol: Longint;
    RowsSelected: Boolean;
    OldTopRow: Longint;
begin
    RowsSelected := (FGridStatus = grRowSelect);
    NewCurrentCol := LeftMostCol(CanSkipReadOnly, False);
    NewCurrentRow := TopMostRow(CanSkipReadOnly, RowsSelected);

    if not ((FCurDisplayCol <= NewCurrentCol) and
            (FCurDisplayRow <= NewCurrentRow)) then
    begin
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        OldTopRow := TopRow;
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
        end;

        PutInView(NewCurrentCol, NewCurrentRow, vpBoth, True, True, ctlBoth);
        CheckRowColChanged;
        Update;

        if (OldTopRow = TopRow) then
            InvertSelectedRows(NewCurrentRow, FCurDisplayRow, True);

        //CheckRowColChanged;
    end
    else
    begin
        PutInView(FCurDisplayCol, FCurDisplayRow, vpBoth, True, True, ctlBoth);
        Update;
    end;
end;

procedure TtsBaseGrid.KeyCtrl_End;
var
    NewCurrentRow, NewCurrentCol: Longint;
    RowsSelected: Boolean;
    OldTopRow: Longint;
begin
    RowsSelected := (FGridStatus = grRowSelect);
    NewCurrentCol := RightMostCol(CanSkipReadOnly, False);
    NewCurrentRow := BottomMostRow(CanSkipReadOnly, RowsSelected);

    if not ((FCurDisplayCol >= NewCurrentCol) and
            (FCurDisplayRow >= NewCurrentRow)) then
    begin
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        OldTopRow := TopRow;
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
        end;

        PutInView(NewCurrentCol, NewCurrentRow, vpNone, True, True, ctlBoth);
        CheckRowColChanged;
        Update;

        if OldTopRow = TopRow then
            InvertSelectedRows(NewCurrentRow, NewCurrentRow, True);

        //CheckRowColChanged;
    end
    else
    begin
        PutInView(FCurDisplayCol, FCurDisplayRow, vpNone, True, True, ctlBoth);
        Update;
    end;
end;

procedure TtsBaseGrid.KeyCtrl_Left;
var
    NewCurrentRow, NewCurrentCol: Longint;
    ChangeTopLeft: TtsChangeTopLeft;
begin
    NewCurrentCol := LeftMostCol(CanSkipReadOnly, False);
    NewCurrentRow := FCurDisplayRow;

    if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
        Exit;

    ChangeTopLeft := ctlBoth;
    if GridMode = gmListBox then ChangeTopLeft := ctlLeft;

    PutInView(NewCurrentCol, NewCurrentRow, vpRight, True, True, ChangeTopLeft);
    CheckRowColChanged;
    Update;
end;

procedure TtsBaseGrid.KeyCtrl_Right;
var
    ChangeTopLeft: TtsChangeTopLeft;
    NewCurrentRow, NewCurrentCol: Longint;
begin
    NewCurrentCol := RightMostCol(CanSkipReadOnly, False);
    NewCurrentRow := FCurDisplayRow;

    if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
        Exit;

    ChangeTopLeft := ctlBoth;
    if GridMode = gmListBox then ChangeTopLeft := ctlLeft;

    PutInView(NewCurrentCol, NewCurrentRow, vpNone, True, True, ChangeTopLeft);
    CheckRowColChanged;
    Update;
end;

procedure TtsBaseGrid.KeyCtrl_Up;
var
    NewCurrentRow, NewCurrentCol: Longint;
    OldTopRow: Longint;
    ChangeTopLeft: TtsChangeTopLeft;
    RowsSelected: Boolean;
    OldCurrentRow: Longint;
begin
    RowsSelected := (FGridStatus = grRowSelect);
    ChangeTopLeft := ctlBoth;
    if RowsSelected then ChangeTopLeft := ctlTop;

    NewCurrentCol := FCurDisplayCol;
    NewCurrentRow := TopMostRow(CanSkipReadOnly, RowsSelected);

    if FCurDisplayRow > NewCurrentRow then
    begin
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        OldTopRow := TopRow;
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
        end;

        OldCurrentRow := FCurDisplayRow;
        PutInView(NewCurrentCol, NewCurrentRow, vpBottom, True, True, ChangeTopLeft);
        CheckRowColChanged;
        Update;

        if (OldTopRow = TopRow) or (OldCurrentRow < FixedRows) then
            InvertSelectedRows(NewCurrentRow, NewCurrentRow, True);

        //CheckRowColChanged;
    end
    else
    begin
        PutInView(FCurDisplayCol, FCurDisplayRow, vpNone, True, True, ChangeTopLeft);
        Update;
    end;
end;

procedure TtsBaseGrid.KeyCtrl_Down;
var
    NewCurrentRow, NewCurrentCol: Longint;
    OldTopRow: Longint;
    ChangeTopLeft: TtsChangeTopLeft;
    RowsSelected: Boolean;
begin
    RowsSelected := (FGridStatus = grRowSelect);
    ChangeTopLeft := ctlBoth;
    if RowsSelected then ChangeTopLeft := ctlTop;

    NewCurrentCol := FCurDisplayCol;
    NewCurrentRow := BottomMostRow(CanSkipReadOnly, RowsSelected);

    if FCurDisplayRow < NewCurrentRow then
    begin
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        OldTopRow := TopRow;
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
        end;

        PutInView(NewCurrentCol, NewCurrentRow, vpNone, True, True, ChangeTopLeft);
        CheckRowColChanged;
        Update;

        if OldTopRow = TopRow then
            InvertSelectedRows(NewCurrentRow, NewCurrentRow, True);

        //CheckRowColChanged;
    end
    else
    begin
        PutInView(FCurDisplayCol, FCurDisplayRow, vpNone, True, True, ChangeTopLeft);
        Update;
    end;
end;

procedure TtsBaseGrid.CtrlKeyDown(var Key: Word);
begin
    case Key of
        VK_HOME:  begin KeyCtrl_Home; Key := 0; end;
        VK_END:   begin KeyCtrl_End; Key := 0; end;
        VK_LEFT:  begin KeyCtrl_Left; Key := 0; end;
        VK_RIGHT: begin KeyCtrl_Right; Key := 0; end;
        VK_UP:    begin KeyCtrl_Up; Key := 0; end;
        VK_DOWN:  begin KeyCtrl_Down; Key := 0; end;
    end;
end;

procedure TtsBaseGrid.KeyDownVK_Down;
var
    NewCurrentRow: Longint;
    OldCurrentRow: Longint;
    NewTopRow: Longint;
    ACol: Longint;
    Found: Boolean;
    Clear: Boolean;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    if not InEditMode and not FocusRectActive then
    begin
        VK_DownRowSelect;
        Exit;
    end;

    Found := GetNextRow(FCurDisplayRow, CanSkipReadOnly, False, NewCurrentRow);
    if not Found then
        Found := GetNextDownCell(FCurDisplayCol, FCurDisplayRow, CanSkipReadOnly, ACol, NewCurrentRow);

    if Found then
    begin
        if not CanMoveToPos(FCurDisplayCol, NewCurrentRow) then Exit;
        if not CheckEndEdit(GetDataCol(FCurDisplayCol), GetDataRow(NewCurrentRow), True) then Exit;

        OldCurrentRow := FCurDisplayRow;
        MoveRowIntoView(NewCurrentRow, NewTopRow);

        FInScrollingMode := FHasKeyFocus;
        Clear := TopRow = NewTopRow;
        HideGridControl(Clear);

        if Clear then ClearCurrentFocusRect(False);
        SetControlSelectMode(tsAll);
        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, Clear, True);
        ScrollGrid(LeftCol, NewTopRow, EditScrollMode);

        ShowGridControl;
        DrawCurrentFocusRect(False);
        CheckRowColChanged;
        Update;

        if Clear then ClearCurrent(OldCurrentRow);
        if IsRowSelected(GetDataRow(NewCurrentRow)) then
            DrawCurrentSelected(NewCurrentRow)
        else
            DrawCurrent(NewCurrentRow);
    end;
end;

procedure TtsBaseGrid.VK_DownRowSelect;
var
    NewCurrentRow, NewTopRow: Longint;
    RowsSelected: Boolean;
begin
    if not GetNextRow(FCurDisplayRow, False, True, NewCurrentRow) then Exit;
    if not CanMoveToPos(FCurDisplayCol, NewCurrentRow) then Exit;

    RowsSelected := (FGridStatus = grRowSelect);
    MoveRowIntoView(NewCurrentRow, NewTopRow);
    if NewTopRow <> TopRow then
    begin
        if RowsSelected then
        begin
            InvertSelectedRows(1, FCurDisplayRow - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
            FLastAddedRow := NewCurrentRow;
        end;

        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, True, True);
        ScrollGrid(LeftCol, NewTopRow, smRowSelect);
    end
    else
    begin
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
        end;

        ClearCurrentFocusRect(True);
        ClearCurrent(FCurDisplayRow);
        SetCurrentPositionAndDraw(FCurDisplayCol, NewCurrentRow, True, True);

        if RowsSelected then
        begin
            AddRowSelection(NewCurrentRow, NewCurrentRow);
            InvertSelectedRows(NewCurrentRow, NewCurrentRow, True);
            FLastAddedRow := NewCurrentRow;
        end;
        DrawCurrentFocusRect(True);
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.VK_UpRowSelect;
var
    NewCurrentRow, OldCurrentRow: Longint;
    RowsSelected: Boolean;
begin
    if not GetPrevRow(FCurDisplayRow, False, True, NewCurrentRow) then Exit;

    OldCurrentRow := FCurDisplayRow;
    RowsSelected := (FGridStatus = grRowSelect);
    if (NewCurrentRow < TopRow) and (NewCurrentRow >= FixedRows) then
    begin
        if RowsSelected then
        begin
            InvertSelectedRows(FCurDisplayRow + 1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
            AddRowSelection(NewCurrentRow, NewCurrentRow);
            FLastAddedRow := NewCurrentRow;
        end;

        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, True, True);
        ScrollGrid(LeftCol, NewCurrentRow, smRowSelect);
    end
    else
    begin
        if RowsSelected then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteRowSelection(1, RowCount - 1);
        end;

        ClearCurrentFocusRect(True);
        ClearCurrent(OldCurrentRow);
        SetCurrentPositionAndDraw(FCurDisplayCol, NewCurrentRow, True, True);

        if RowsSelected then
        begin
            AddRowSelection(NewCurrentRow, NewCurrentRow);
            InvertSelectedRows(NewCurrentRow, NewCurrentRow, True);
            FLastAddedRow := NewCurrentRow;
        end;
        DrawCurrentFocusRect(True);
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.KeyDownVK_Up;
var
    NewCurrentRow, OldCurrentRow: Longint;
    NewTopRow: Longint;
    ACol: Longint;
    Found: Boolean;
    Clear: Boolean;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    if not InEditMode and not FocusRectActive then
    begin
        VK_UpRowSelect;
        Exit;
    end;

    Found := GetPrevRow(FCurDisplayRow, CanSkipReadOnly, False, NewCurrentRow);
    if not Found then
        Found := GetNextUpCell(FCurDisplayCol, FCurDisplayRow, CanSkipReadOnly, ACol, NewCurrentRow);

    if Found then
    begin
        if not CheckEndEdit(GetDataCol(FCurDisplayCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        NewTopRow := TopRow;
        OldCurrentRow := FCurDisplayRow;

        if (NewCurrentRow < TopRow) and (TopRow > FixedRows) then
            NewTopRow := CalcMax(NewCurrentRow, MinTopRow);

        FInScrollingMode := FHasKeyFocus;
        Clear := TopRow = NewTopRow;
        HideGridControl(Clear);

        if Clear then ClearCurrentFocusRect(False);
        SetControlSelectMode(tsAll);
        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, True, True);
        ScrollGrid(LeftCol, NewTopRow, EditScrollMode);

        ShowGridControl;
        DrawCurrentFocusRect(False);
        CheckRowColChanged;
        Update;

        if Clear then ClearCurrent(OldCurrentRow);
        if IsRowSelected(GetDataRow(FCurDisplayRow)) then
            DrawCurrentSelected(FCurDisplayRow)
        else
            DrawCurrent(FCurDisplayRow);
    end;
end;

procedure TtsBaseGrid.KeyDownVK_Tab(Key: Word);
var
    NewCurrentRow, NewCurrentCol: Longint;
    NewLeftCol: Longint;
    Sum, I: Integer;
    ARect: TRect;
    Clear: Boolean;
    ScrollMode: TtsScrollMode;
    CurCol, CurRow: Longint;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    CurCol := FCurDisplayCol;
    CurRow := FCurDisplayRow;
    if GetNextCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) and
       (TabRowWrap or (NewCurrentRow = FCurDisplayRow)) then
    begin
        if not CanMoveToPos(NewCurrentCol, NewCurrentRow) then Exit;
        if not CheckEndEdit(GetDataCol(NewCurrentCol), GetDataRow(NewCurrentRow), True) then
            Exit;

        if GetNextCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) then
        begin
            if (NewCurrentCol < FCurDisplayCol) or
               (NewCurrentRow > FCurDisplayRow) then
            begin
                PutInView(NewCurrentCol, NewCurrentRow, vpRight, False, True, ctlBoth);
                if GetNextCell(CurCol, CurRow, CanSkipReadOnly, NewCurrentCol, NewCurrentRow) then
                begin
                    if (FCurDisplayCol <> NewCurrentCol) or
                       (FCurDisplayRow <> NewCurrentRow) then
                    begin
                        PutInView(NewCurrentCol, NewCurrentRow, vpRight, False, True, ctlBoth);
                    end;
                end;
            end
            else
            begin
                NewLeftCol := LeftCol;

                if NewCurrentCol > (LeftCol + VisibleColCount - 1) then
                begin
                    Sum := 0;
                    for I := LeftCol + VisibleColCount to NewCurrentCol do
                        Inc(Sum, ColWidths[I]);

                    if LeftCol + VisibleColCount = MaxVisibleCol then
                    begin
                        ARect := CellRect(MaxVisibleCol, 0);
                        Dec(Sum, ARect.Right - ARect.Left);
                    end;

                    I := LeftCol;
                    while (Sum > 0) and (I < NewCurrentCol) do
                    begin
                        Dec(Sum, ColWidths[I]);
                        Inc(I);
                    end;

                    NewLeftCol := I;
                end
                else
                begin
                    if (NewCurrentCol >= FixedCols) and (NewCurrentCol < LeftCol) then
                        NewLeftCol := NewCurrentCol;
                end;

                FInScrollingMode := FHasKeyFocus;
                Clear := LeftCol = NewLeftCol;
                HideGridControl(Clear);
                SetControlSelectMode(tsAll);

                if Clear then ClearCurrentFocusRect(False);
                ScrollMode := smGridControl;
                SetCurrentPosition(NewCurrentCol, NewCurrentRow, Clear, False);
                ScrollGrid(NewLeftCol, TopRow, ScrollMode);
                ShowGridControl;
                DrawCurrentFocusRect(False);
                CheckRowColChanged;
                Update;
            end;

            CheckRowColChanged;
        end;
    end
    else if Key = VK_RETURN then
    begin
        if not CheckEndEdit(-1, -1, True) then
            Exit;
        InvalidateRow(FCurDisplayRow);
        CurrentCell.SelectAll;
    end;
end;

procedure TtsBaseGrid.KeyDownVK_Prior;
var
    NewCurrentRow: Longint;
    NewTopRow: Longint;
    FirstRow: Longint;
    Clear: Boolean;
    ScrollMode: TtsScrollMode;
    RowsSelected: Boolean;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    RowsSelected := (FGridStatus = grRowSelect);
    FirstRow := TopMostRow(CanSkipReadOnly, RowsSelected);
    if FirstRow >= FCurDisplayRow then Exit;

    if FCurDisplayRow < FixedRows then
    begin
        if FCurDisplayRow - (FixedRows + VisibleRowCount) > FirstRow then
            GetPrevRow(FCurDisplayRow - (FixedRows + VisibleRowCount), CanSkipReadOnly, RowsSelected, NewCurrentRow)
        else
            NewCurrentRow := FirstRow;
    end
    else if (FCurDisplayRow - VisibleRowCount > FirstRow) then
        GetPrevRow(FCurDisplayRow - VisibleRowCount + 1, CanSkipReadOnly, RowsSelected, NewCurrentRow)
    else
        NewCurrentRow := FirstRow;

    if NewCurrentRow < FixedRows then
    begin
        if (FCurDisplayRow - NewCurrentRow) < (FixedRows + VisibleRowCount - 1) then
            NewCurrentRow := FCurDisplayRow - FixedRows - VisibleRowCount - 2;
    end;

    if NewCurrentRow < FirstRow then NewCurrentRow := FirstRow;

    if (NewCurrentRow = FCurDisplayRow) and (NewCurrentRow > FirstRow) then
        Dec(NewCurrentRow);

    if (NewCurrentRow = FCurDisplayRow) then Exit;
    if not CheckEndEdit(GetDataCol(FCurDisplayCol), GetDataRow(NewCurrentRow), True) then
        Exit;

    if (FCurDisplayRow - NewCurrentRow) > VisibleRowCount then
        NewTopRow := CalcMax(TopRow - (FCurDisplayRow - NewCurrentRow), FixedRows)
    else
        NewTopRow := CalcMax(TopRow - VisibleRowCount, FixedRows);

    if RowsSelected then
    begin
        if (NewCurrentRow - NewTopRow) <> (FCurDisplayRow - TopRow) then
            InvertSelectedRows(1, MaxVisibleRow, False);

        DeleteRowSelection(1, RowCount - 1);
        NewRowSelection(NewCurrentRow, NewCurrentRow);
    end;

    Clear := False;
    if (NewCurrentRow - NewTopRow) <> (FCurDisplayRow - TopRow) then
        Clear := True;

    FInScrollingMode := FHasKeyFocus;
    HideGridControl(Clear);
    SetControlSelectMode(tsAll);

    if Clear then
    begin
        ClearCurrentFocusRect(True);
        ClearCurrent(FCurDisplayRow);
        SetCurrentPositionAndDraw(FCurDisplayCol, NewCurrentRow, True, True);
    end
    else
        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, True, True);

    if (NewTopRow <> TopRow) then
    begin
        if InGridMode then ScrollMode := EditScrollMode
                      else ScrollMode := smRowSelect;
        ScrollGrid(LeftCol, NewTopRow, ScrollMode);
    end
    else if RowsSelected then
        InvertRow(NewCurrentRow, True, 0);

    ShowGridControl;
    DrawCurrentFocusRect(False);
    CheckRowColChanged;
    Update;
end;

function TtsBaseGrid.CalcNewTopRowVK_Next(NewCurrentRow: Longint): Longint;
var
    NewTopRow: Longint;
    I, Sum: Integer;
    Offset: Longint;
begin
    Offset := 0;
    if FCurDisplayRow < FixedRows then Offset := FixedRows - FCurDisplayRow;

    if (NewCurrentRow - FCurDisplayRow - Offset) > VisibleRowCount then
        NewTopRow := CalcMin(TopRow + (NewCurrentRow - FCurDisplayRow - Offset), RowCount - 1)
    else
        NewTopRow := CalcMin(TopRow + VisibleRowCount, RowCount - 1);

    I := 0;
    Sum := FVertFixedHeight + RowHeights[NewTopRow];
    while (Sum <= ClientHeight) and (NewTopRow + I < RowCount - 1) do
    begin
        Inc(I);
        Inc(Sum, RowHeights[NewTopRow + I]);
    end;

    if NewTopRow + I >= RowCount - 1 then
    begin
        I := 0;
        while (NewTopRow - I > 1) do
        begin
            if Sum + RowHeights[NewTopRow - (I + 1)] > ClientHeight then Break;

            Inc(I);
            Inc(Sum, RowHeights[NewTopRow - I]);
        end;

        NewTopRow := NewTopRow - I;
    end;

    Result := NewTopRow;
end;

procedure TtsBaseGrid.KeyDownVK_Next;
var
    LastRow: Longint;
    NewCurrentRow: Longint;
    NewTopRow: Longint;
    Clear: Boolean;
    ScrollMode: TtsScrollMode;
    RowsSelected: Boolean;
begin
    if not CanMoveToPos(FCurDisplayCol, FCurDisplayRow) then Exit;

    RowsSelected := (FGridStatus = grRowSelect);
    LastRow := BottomMostRow(CanSkipReadOnly, RowsSelected);
    if LastRow <= FCurDisplayRow then Exit;

    if FCurDisplayRow < FixedRows then
        GetNextRow(FixedRows + VisibleRowCount - 1, CanSkipReadOnly, RowsSelected, NewCurrentRow)
    else if (FCurDisplayRow + VisibleRowCount < LastRow) then
        GetNextRow(FCurDisplayRow + VisibleRowCount - 1, CanSkipReadOnly, RowsSelected, NewCurrentRow)
    else
        NewCurrentRow := LastRow;

    if NewCurrentRow > LastRow then NewCurrentRow := LastRow;

    if (NewCurrentRow = FCurDisplayRow) and  (NewCurrentRow < LastRow) then
        Inc(NewCurrentRow);

    if NewCurrentRow = FCurDisplayRow then Exit;
    if not CheckEndEdit(GetDataCol(FCurDisplayCol), GetDataRow(NewCurrentRow), True) then
        Exit;

    NewTopRow := TopRow;
    if MaxVisibleRow <= (RowCount - 1) then
    begin
        NewTopRow := CalcNewTopRowVK_Next(NewCurrentRow);
        NewTopRow := CalcMax(NewTopRow, FixedRows);
    end;

    if RowsSelected then
    begin
        if (NewCurrentRow - NewTopRow) <> (FCurDisplayRow - TopRow) then
            InvertSelectedRows(TopRow, MaxVisibleRow, False);

        DeleteRowSelection(1, RowCount - 1);
        NewRowSelection(NewCurrentRow, NewCurrentRow);
    end;

    Clear := False;
    if (NewCurrentRow - NewTopRow) <> (FCurDisplayRow - TopRow) then
        Clear := True;

    FInScrollingMode := FHasKeyFocus;
    HideGridControl(Clear);
    SetControlSelectMode(tsAll);

    if Clear then
    begin
        ClearCurrentFocusRect(True);
        ClearCurrent(FCurDisplayRow);
        SetCurrentPositionAndDraw(FCurDisplayCol, NewCurrentRow, True, True);
    end
    else
        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, False, True);

    if NewTopRow <> TopRow then
    begin
        if InGridMode then ScrollMode := EditScrollMode
                      else ScrollMode := smRowSelect;

        ScrollGrid(LeftCol, NewTopRow, ScrollMode);
    end
    else if RowsSelected then
        InvertRow(NewCurrentRow, True, 0);

    ShowGridControl;
    DrawCurrentFocusRect(False);
    CheckRowColChanged;
    Update;
end;

function TtsBaseGrid.KeydownVK_Escape: Boolean;
begin
    Result := False;
    if not InEditMode then Exit;

    if IsInsertRow(CurDisplayRow) then
    begin
        try
            HideGridControl(True);
            ClearCurrentFocusRect(True);
            ClearCurrent(CurDisplayRow);
            SetCurrentPositionAndDraw(CurDisplayCol, Rows - 1, True, True);
            ShowGridControl;
            DrawCurrentFocusRect(False);
        finally
            CheckRowColChanged;
        end;

        Result := True;
    end
    else if not AlwaysShowEditor then
    begin
        HideEditor;
        CurrentCell.SelectAll;
        Result := True;
    end;
end;

function TtsBaseGrid.CurrentPosInView: Boolean;
begin
    Result := True;
    if GridMode <> gmListBox then
    begin
        if (((FCurDisplayCol < LeftCol) or (FCurDisplayCol > MaxVisibleCol)) and
             (FCurDisplayCol > FixedCols - 1)) or
           (((FCurDisplayRow < TopRow) or (FCurDisplayRow > MaxVisibleRow)) and
             (FCurDisplayRow > FixedRows - 1)) then
            Result := False;
    end
    else if RowSelectMode in [rsSingle, rsMulti] then
    begin
        if ((FCurDisplayRow < TopRow) or (FCurDisplayRow > MaxVisibleRow)) and
             (FCurDisplayRow > FixedRows - 1) then
            Result := False;
    end;
end;

function TtsBaseGrid.CanMoveToPos(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := True;
    if ((DisplayRow > MaxVisibleRow) and (MaxVisibleRow <= FixedRows - 1)) then
        Result := False;
    if (GridMode <> gmListBox) and
       ((DisplayCol > MaxVisibleCol) and (MaxVisibleCol <= FixedCols - 1)) then
        Result := False;
end;

procedure TtsBaseGrid.BackToCurrentCell(MoveCol, MoveRow: Boolean);
var
    NewLeftCol, NewTopRow: Longint;
begin
    if MoveCol and not CanMoveToPos(FCurDisplayCol, 0) then Exit;
    if MoveRow and not CanMoveToPos(0, FCurDisplayRow) then Exit;

    NewLeftCol := LeftCol;
    if MoveCol then
    begin
        if (FCurDisplayCol < LeftCol) then
        begin
            if FCurDisplayCol >= FixedCols then NewLeftCol := FCurDisplayCol
                                           else NewLeftCol := FixedCols;
        end
        else if FCurDisplayCol > MaxVisibleCol then
        begin
            NewLeftCol := FCurDisplayCol;
            MoveColToRight(FCurDisplayCol, NewLeftCol);
        end;
    end;

    NewTopRow := TopRow;
    if MoveRow then
    begin
        if (FCurDisplayRow < TopRow) then
        begin
            if FCurDisplayRow >= FixedRows then NewTopRow := FCurDisplayRow
                                           else NewTopRow := FixedRows;
        end
        else if FCurDisplayRow > MaxVisibleRow then
        begin
            NewTopRow := FCurDisplayRow;
            MoveRowToBottom(FCurDisplayRow, NewTopRow);
        end;
    end;

    if (LeftCol <> NewLeftCol) or (TopRow <> NewTopRow) then
    begin
        HideGridControl(True);
        MoveTopLeft(NewLeftCol, NewTopRow);
        ShowGridControl;
        Update;
    end;
end;

function TtsBaseGrid.CheckMoveCol(Shift: TShiftState; Key: Word): Boolean;
begin
    if (Shift = [ssCtrl]) and (Key in [VK_LEFT, VK_RIGHT, VK_HOME, VK_END]) then
        Result := False
    else if InGridMode then
        Result := True
    else
        Result := False;
end;

function TtsBaseGrid.CheckMoveRow(Shift: TShiftState; Key: Word): Boolean;
begin
    if (Shift = [ssCtrl]) and (Key in [VK_UP, VK_DOWN, VK_HOME, VK_END]) then
        Result := False
    else if InGridMode then
        Result := True
    else if Key in [VK_UP, VK_DOWN, VK_PRIOR, VK_NEXT, VK_HOME, VK_END] then
        Result := True
    else
        Result := False;
end;

function TtsBaseGrid.HasHeadingButtons: Boolean;
var
    I: Longint;
begin
    Result := False;
    for I := 1 to Cols do
    begin
        Result := IsColHeadingButton(I) or ButtonInColHeading(I);
        if Result then Break;
    end;
end;

function TtsBaseGrid.GetAccelHeading(var Key: Word): Longint;
var
    DisplayCol, DataCol: Longint;
    ColFound: Boolean;
begin
    Result := 0;
    DisplayCol := 0;
    DataCol := 0;
    ColFound := False;
    while (not ColFound) and (DisplayCol < Cols) do
    begin
        Inc(DisplayCol);
        DataCol := GetDataCol(DisplayCol);
        with GridCols[DataCol] do
        begin
            ColFound := (FAccelKeyPos <> 0) and
                        (AnsiCompareText(Char(Key), Heading[FAccelKeyPos+1]) = 0);
        end;
    end;

    if ColFound then Result := DataCol;
end;

procedure TtsBaseGrid.KeyDown(var Key: Word; Shift: TShiftState);
begin
    DoKeyDown(Key, Shift);
    if Key <> 0 then
    begin
        if DateTimeVisible then
            ProcessKeyDownDateTime(Key, Shift)
        else if CanProcessKey and (Key <> 0) then
            ProcessKeyDown(Key, Shift);
    end
end;

procedure TtsBaseGrid.ProcessKeyDown(var Key: Word; Shift: TShiftState);
var
    Restore, UndoDone: Boolean;
    CanUndoEdit: Boolean;
begin
    FHasKeyFocus := True;

    if Key = 0 then Exit;
    if Key in [VK_Shift, VK_Control, VK_Menu] then Exit;
    if (ssAlt in Shift) and (Key <> VK_UP) and (Key <> VK_DOWN) then Exit;

    if ComboVisible then
    begin
        ProcessKeyDownCombo(Key, Shift);
        if Key = 0 then Exit;
    end;

    if not (FMouseStatus in [msNormal, msButtonDown]) then
    begin
        if Key = VK_ESCAPE then
        begin
            CancelMouseAction;
            Key := 0;
        end;
        Exit;
    end;

    if not CurrentPosInView then
    begin
        BackToCurrentCell(CheckMoveCol(Shift, Key), CheckMoveRow(Shift, Key));
        if Key = VK_ESCAPE then
        begin
            ResetComboSearchValue;
            Key := 0;
            Exit;
        end;
    end;

    if (Key = VK_ESCAPE) then
    begin
        if ResetComboSearchValue then
        begin
            Key := 0;
            Exit;
        end;
    end;

    UndoDone := False;
    CanUndoEdit := True;
    if (Key = VK_ESCAPE) or ((Key = VK_Z) and (Shift = [ssCtrl])) then
        CanUndoEdit := UndoEdit(False, True, Restore, UndoDone);

    try
        if Shift = [ssCtrl] then
        begin
            case Key of
                VK_INSERT, VK_C: if CopyCellToClipboard then Key := 0;
                VK_X: if CutCellToClipboard then Key := 0;
                VK_V: if PasteCellFromClipboard then Key := 0;
            else
                if Key <> VK_Z then
                    CtrlKeyDown(Key)
                else if CanUndoEdit then
                begin
                    KeydownVK_Escape;
                    if UndoDone then Key := 0;
                end;
            end;
        end
        else if Shift = [ssShift] then
            case Key of
                VK_TAB: if InEditMode or FocusRectActive then
                            begin ShiftKeyDownVK_Tab; Key := 0; end;
                VK_INSERT: if PasteCellFromClipboard then Key := 0;
                VK_DELETE: if CutCellToClipboard then Key := 0;
            end
        else if Shift = [] then
        begin
            case Key of
                VK_DOWN:
                    begin KeyDownVK_Down; Key := 0; end;

                VK_UP:
                    begin KeyDownVK_Up; Key := 0; end;

                VK_TAB:
                    if InEditMode or FocusRectActive then
                        begin KeyDownVK_Tab(Key); Key := 0; end;

                VK_RETURN:
                    if InEditMode then begin KeyDownVK_Tab(Key); Key := 0; end;

                VK_RIGHT:
                    begin
                        if InEditMode or FocusRectActive then
                            KeyDownVK_Tab(Key)
                        else if (LeftCol + VisibleColCount < ColCount) and
                                CanMoveToPos(LeftCol + 1, FCurDisplayRow) then
                        begin
                            LeftCol := LeftCol + 1;
                            SetCurrentPosition(CalcMax(FCurDisplayCol + 1, LeftCol), FCurDisplayRow, True, True);
                            CheckRowColChanged;
                        end;
                        Key := 0;
                    end;

                VK_LEFT:
                    begin
                        if InEditMode or FocusRectActive then
                            ShiftKeyDownVK_Tab
                        else if LeftCol > FixedCols then
                        begin
                            LeftCol := LeftCol - 1;
                            SetCurrentPosition(FCurDisplayCol - 1, FCurDisplayRow, True, True);
                            CheckRowColChanged;
                        end;
                        Key := 0;
                    end;

                VK_PRIOR:
                    begin KeyDownVK_Prior; Key := 0; end;

                VK_NEXT:
                    begin KeyDownVK_Next; Key := 0; end;

                VK_ESCAPE:
                    if CanUndoEdit then
                    begin
                        KeydownVK_Escape;
                        if UndoDone then Key := 0;
                    end;

                VK_F2:
                    if not FControlEnabled and InternalShowEditor(tsNone, False) then
                    begin
                        CurrentCell.SelLength := 0;
                        Update;
                        Key := 0;
                    end;

                VK_F4:
                    if KeyDropDown then Key := 0;
            end;
        end
        else if Shift = [ssAlt] then
        begin
            case Key of
                VK_UP, VK_DOWN: if KeyDropDown then Key := 0;
            end;
        end;
    finally
        CheckRowSelection(False);
        SelectionsChanged(True);
        GridStatusChanged;
    end;
end;

procedure TtsBaseGrid.ProcessKeyDownCombo(var Key: Word; Shift: TShiftState);
var
    ACol, ARow: Longint;
    ComboKey: Word;
begin
    if Shift = [ssCtrl] then
    begin
        if CurrentCell.AllSelected or (not FGridControl.MultiLine) then
            Combo.FGrid.ProcessKeyDown(Key, Shift);
        Key := 0;
    end
    else if Shift = [ssShift] then
        case Key of
            VK_TAB:
                begin
                    CheckDropDownOff(False);
                    Combo.FGrid.MouseCapture := False;
                    Combo.FGrid.SetMouseStatus(msNormal);
                end;
        end
    else if Shift = [] then
    begin
        case Key of
            VK_DOWN, VK_UP, VK_PRIOR, VK_NEXT:
                begin
                    if CurrentCell.AllSelected or (not FGridControl.MultiLine) or
                       (not FGridControl.KeyEdit) then
                    begin
                        Combo.FGrid.ProcessKeyDown(Key, Shift);
                    end;
                    Key := 0;
                end;

            VK_RIGHT, VK_LEFT:
                begin
                    if CurrentCell.AllSelected or (not FGridControl.KeyEdit) then
                        Combo.FGrid.ProcessKeyDown(Key, Shift);
                    Key := 0;
                end;

            VK_RETURN:
                begin
                    if not InDesignMode then
                    begin
                        ACol := Combo.FGrid.FCurDataCol;
                        ARow := Combo.FGrid.FCurDataRow;
                        ComboClickCell(Self, ACol, ARow, ACol, ARow);
                    end;
                    Key := 0;
                end;

            VK_ESCAPE:
                begin
                    CheckDropDownOff(False);
                    Combo.FGrid.MouseCapture := False;
                    Combo.FGrid.SetMouseStatus(msNormal);
                    Key := 0
                end;

            VK_TAB:
                begin
                    CheckDropDownOff(False);
                    Combo.FGrid.MouseCapture := False;
                    Combo.FGrid.SetMouseStatus(msNormal);
                end;

            VK_END:
                if (not FGridControl.KeyEdit) then
                begin
                    ComboKey := VK_DOWN;
                    Combo.FGrid.ProcessKeyDown(ComboKey, [ssCtrl]);
                    Key := 0;
                end;

            VK_HOME:
                if (not FGridControl.KeyEdit) then
                begin
                    ComboKey := VK_UP;
                    Combo.FGrid.ProcessKeyDown(ComboKey, [ssCtrl]);
                    Key := 0;
                end;
        end;
    end;
end;

procedure TtsBaseGrid.ProcessKeyDownDateTime(var Key: Word; Shift: TShiftState);
begin
    if Shift = [ssShift] then
        case Key of
            VK_TAB: SendMessage(FDateTimeComponent.Control.Handle, WM_KEYDOWN, VK_ESCAPE, 0);
        else
            Key := 0;
        end
    else if Shift = [] then
    begin
        case Key of
            VK_DOWN, VK_UP, VK_PRIOR, VK_NEXT, VK_RIGHT, VK_LEFT, VK_ESCAPE, VK_RETURN:
                begin
                    SendMessage(FDateTimeComponent.Control.Handle, WM_KEYDOWN, Key, 0);
                    Key := 0;
                end;

            VK_TAB, VK_F4:
                begin
                    SendMessage(FDateTimeComponent.Control.Handle, WM_KEYDOWN, VK_ESCAPE, 0);
                    if Key <> VK_TAB then Key := 0;
                end;
        else
            Key := 0;
        end;
    end
    else if Shift = [ssAlt] then
    begin
        case Key of
            VK_UP, VK_DOWN:
                begin
                    SendMessage(FDateTimeComponent.Control.Handle, WM_KEYDOWN, VK_ESCAPE, 0);
                    Key := 0;
                end;
        end;
    end
    else
        Key := 0;
end;

procedure TtsBaseGrid.ProcessKeyDropDownList(var Key: Char);
var
    NewValue: Variant;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    ButtonType := GiveCellButton(CurDataCol, CurDataRow, DropDownStyle);
    if (ButtonType <> btCombo) then Exit;
    if CellIsReadOnly(CurDataCol, CurDataRow) then Exit;

    if Key = Chr(VK_ESCAPE) then
    begin
        ResetComboSearchValue;
        Exit;
    end;

    ComboInit(CurDataCol, CurDataRow);
    if (DropDownStyle <> ddDropDownList) and not IsLookupCombo(CurDataCol) then Exit;

    NewValue := PositionDropDownList(Key);
    SetComboValue(NewValue);
    // SetCurrentValue(NewValue, True, True);

    Update;
    if ComboVisible then Combo.FGrid.Update;
end;

function TtsBaseGrid.CanDropDown(DataCol, DataRow: Longint; Buttons: TtsButtonTypes): Boolean;
var
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    Result := False;
    ButtonType := GiveCellButton(DataCol, DataRow, DropDownStyle);
    if ButtonType in Buttons then
    begin
        Result := not CellIsReadOnly(DataCol, DataRow) and
                  not (GridMode in [gmBrowse, gmListBox]);

        if Result and (ButtonType in [btDateTimeDropDown, btDateTimePopup]) then
            Result := Assigned(GiveCellDateTime(DataCol, DataRow));
    end;
end;

function TtsBaseGrid.KeyDropDownCombo: Boolean;
begin
    Result := False;
    if CanDropDown(FCurDataCol, FCurDataRow, [btCombo]) then
    begin
        ComboButtonDown(CurrentCell.DataCol, CurrentDataRow);
        Result := True;
    end;
end;

function TtsBaseGrid.KeyDropDownDateTime: Boolean;
begin
    Result := DateTimeButtonDown(FCurDataCol, FCurDataRow);
end;

function TtsBaseGrid.KeyDropDown: Boolean;
begin
    Result := KeyDropDownCombo;
    if not Result then Result := KeyDropDownDateTime;
end;

procedure TtsBaseGrid.KeyUp(var Key: Word; Shift: TShiftState);
begin
    if FInScrollingMode then
    begin
        FInScrollingMode := False;
        if FGridControl.Visible then FGridControl.SetFocus;
    end;

    DoKeyUp(Key, Shift);
end;

procedure TtsBaseGrid.KeyPress(var Key: Char);
begin
    if CanProcessKey and FGridControl.IsEditKey(Key) and FGridControl.KeyEdit then
    begin
        if StartShowEditor(True) then
        begin
            PostMessage(FGridControl.Handle, WM_CHAR, Word(Key), 0);
            Exit;
        end;
    end;
    DoKeyPress(Key);
    if (Key <> #0) and DateTimeVisible then Key := #0;
end;

function TtsBaseGrid.GetCol(DataCol: Variant): TtsCol;
var
    Index: Longint;
begin
    Result := nil;
    case VarType(DataCol) of
      varString:
            begin
                Result := GridCols.FindCol(DataCol);
                if (Result = nil) then CheckRaise(Format(StsUnknownField, [DataCol]));
            end;
    else
            if CheckIndex(itCol, DataCol, 1, ColCount - 1) then
            begin
                Index := DataCol;
                Result := GridCols.FCols[Index];
            end;    
    end;
end;

function TtsBaseGrid.GetRow(DataRow: Longint): TtsRow;
begin
    Result := nil;
    if CheckIndex(itRow, DataRow, 0, RowCount - 1) then
        Result := GridRows.FRows[DataRow];
end;

procedure TtsBaseGrid.SetRowColor(DataRow: Longint; Value: TColor);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = clNone) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Color := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowColor(DataRow: Longint): TColor;
begin
    Result := clNone;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Color;
    end;
end;

function TtsBaseGrid.GetRowFont(DataRow: Longint): TFont;
begin
    Result := nil;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Font;
    end;
end;

procedure TtsBaseGrid.SetRowFont(DataRow: Longint; Value: TFont);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = nil) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Font := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowParentFont(DataRow: Longint): Boolean;
begin
    Result := True;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ParentFont;
    end;
end;

procedure TtsBaseGrid.SetRowParentFont(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = True) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ParentFont := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

procedure TtsBaseGrid.SetRowAutoCreateFont(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = False) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].AutoCreateFont := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function  TtsBaseGrid.GetRowAutoCreateFont(DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].AutoCreateFont;
    end;
end;

procedure TtsBaseGrid.SetRowHeight(DataRow: Longint; Value: Integer);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = DefaultRowHeight) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Height := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowHeight(DataRow: Longint): Integer;
begin
    Result := DefaultRowHeight;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Height;
    end;
end;

function TtsBaseGrid.GetRowId(DataRow: Longint): Longint;
begin
    Result := -1;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
        Result := GridRows.RowId[DataRow];
end;

function TtsBaseGrid.GetIdDataRow(Id: Longint): Longint;
var
    Lower, Middle, Upper: integer;
begin
    Lower := 0;
    Upper := Rows + 1;
    while Lower + 1 <> Upper do
    begin
        Middle := (Lower + Upper) div 2;
        if GridRows.RowId[Middle] < Id then
            Lower := Middle
        else
            Upper := Middle;
    end;

    if Upper > Rows then
        result := -1
    else if GridRows.RowId[Upper] <> Id then
        result := -1
    else
        result := Upper;
end;

function TtsBaseGrid.GetIdDataCol(Id: Longint): Longint;
begin
    for Result := 1 to Cols do
        if Id = GridCols.Col[Result].Id then
            exit;
    Result := -1;
end;

procedure TtsBaseGrid.SetRowVisible(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        if (Value = True) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Visible := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowVisible(DataRow: Longint): Boolean;
begin
    Result := True;
    if CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Visible;
    end;
end;

function TtsBaseGrid.IsRowVisible(DataRow: Longint): Boolean;
begin
    Result := False;
    if (DataRow >= 0) and (DataRow <= RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow])
            then Result := True
            else Result := GridRows[DataRow].Visible;
    end;
end;

procedure TtsBaseGrid.SetRowAlignment(DataRow: Longint; Value: TAlignment);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = taLeftJustify) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Alignment := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowAlignment(DataRow: Longint): TAlignment;
begin
    Result := taLeftJustify;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Alignment;
    end;
end;

procedure TtsBaseGrid.SetRowAlign(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = False) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Align := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowAlign(DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Align;
    end;
end;

procedure TtsBaseGrid.SetRowHorzAlignment(DataRow: Longint; Value: TtsHorzAlignment);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = htaDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].HorzAlignment := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowHorzAlignment(DataRow: Longint): TtsHorzAlignment;
begin
    Result := htaDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].HorzAlignment;
    end;
end;

procedure TtsBaseGrid.SetRowVertAlignment(DataRow: Longint; Value: TtsVertAlignment);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = vtaDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].VertAlignment := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowVertAlignment(DataRow: Longint): TtsVertAlignment;
begin
    Result := vtaDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].VertAlignment;
    end;
end;

procedure TtsBaseGrid.SetRowButtonType(DataRow: Longint; Value: TtsButtonType);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = btDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ButtonType := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowButtonType(DataRow: Longint): TtsButtonType;
begin
    Result := btDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ButtonType;
    end;
end;

procedure TtsBaseGrid.SetRowWordWrap(DataRow: Longint; Value: TtsWordWrap);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = wwDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].WordWrap := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowWordWrap(DataRow: Longint): TtsWordWrap;
begin
    Result := wwDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].WordWrap;
    end;
end;

procedure TtsBaseGrid.SetRowReadOnly(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = False) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ReadOnly := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowReadOnly(DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ReadOnly;
    end;
end;

function TtsBaseGrid.IsRowReadOnly(DataRow: Longint): Boolean;
begin
    Result := False;
    if (DataRow >= 1) and (DataRow <= RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ReadOnly;
    end;
end;

procedure TtsBaseGrid.SetRowIs3D(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = False) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Is3D := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowIs3D(DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Is3D;
    end;
end;

procedure TtsBaseGrid.SetRowMaskName(DataRow: Longint; Value: string);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = '') and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].MaskName := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowMaskName(DataRow: Longint): string;
begin
    Result := '';
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].MaskName;
    end;
end;

procedure TtsBaseGrid.SetRowCombo(DataRow: Longint; Value: TtsCombo);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = nil) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].Combo := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowCombo(DataRow: Longint): TtsCombo;
begin
    Result := nil;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].Combo;
    end;
end;

procedure TtsBaseGrid.SetRowParentCombo(DataRow: Longint; Value: Boolean);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = True) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ParentCombo := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowParentCombo(DataRow: Longint): Boolean;
begin
    Result := True;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ParentCombo;
    end;
end;

procedure TtsBaseGrid.SetRowStretchPicture(DataRow: Longint; Value: TtsDrawOption);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = dopDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].StretchPicture := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowStretchPicture(DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].StretchPicture;
    end;
end;

procedure TtsBaseGrid.SetRowShrinkPicture(DataRow: Longint; Value: TtsDrawOption);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = dopDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ShrinkPicture := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowShrinkPicture(DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ShrinkPicture;
    end;
end;

procedure TtsBaseGrid.SetRowCenterPicture(DataRow: Longint; Value: TtsDrawOption);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = dopDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].CenterPicture := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowCenterPicture(DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].CenterPicture;
    end;
end;

procedure TtsBaseGrid.SetRowKeepAspectRatio(DataRow: Longint; Value: TtsDrawOption);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = dopDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].KeepAspectRatio := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowKeepAspectRatio(DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].KeepAspectRatio;
    end;
end;

procedure TtsBaseGrid.SetRowControlType(DataRow: Longint; Value: TtsControlType);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = ctDefault) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ControlType := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowControlType(DataRow: Longint): TtsControlType;
begin
    Result := ctDefault;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].ControlType;
    end;
end;

procedure TtsBaseGrid.SetRowSpinOptions(DataRow: Longint; Value: TtsSpinOptions);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = [spoAutoRepeat, spoAutoIncrement, spoKeyEdit]) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].SpinOptions := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowSpinOptions(DataRow: Longint): TtsSpinOptions;
begin
    Result := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].SpinOptions;
    end;
end;

procedure TtsBaseGrid.SetRowSpinIncrement(DataRow: Longint; Value: Double);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = 1) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].SpinIncrement := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowSpinIncrement(DataRow: Longint): Double;
begin
    Result := 1;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].SpinIncrement;
    end;
end;

procedure TtsBaseGrid.SetRowDateTimeDef(DataRow: Longint; Value: TtsDateTimeDefComponent);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = nil) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].DateTimeDef := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowDateTimeDef(DataRow: Longint): TtsDateTimeDefComponent;
begin
    Result := nil;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].DateTimeDef;
    end;
end;

procedure TtsBaseGrid.SetRowDropDownStyle(DataRow: Longint; Value: TtsDropDownStyle);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if (Value = ddDropDown) and not Assigned(GridRows[DataRow]) then Exit;
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].DropDownStyle := Value;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetRowDropDownStyle(DataRow: Longint): TtsDropDownStyle;
begin
    Result := ddDropDown;
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if not Assigned(GridRows[DataRow]) then Exit;
        Result := GridRows[DataRow].DropDownStyle;
    end;
end;

function TtsBaseGrid.GetDisplayCol(DataCol: Longint): Longint;
begin
    Result := 0;
    if (DataCol >= 0) and (DataCol <= ColCount - 1) then
        Result := GridCols[DataCol].DisplayCol;
end;

procedure TtsBaseGrid.SetDisplayColnr(DataCol: Longint; Value: Longint);
begin
    if (DataCol >= 1) and (DataCol <= ColCount - 1) then
        GridCols[DataCol].DisplayCol := Value;
end;

function TtsBaseGrid.GetDisplayColnr(DataCol: Longint): Longint;
begin
    Result := -1;
    if (DataCol >= 1) and (DataCol <= ColCount - 1) then
        Result := GridCols[DataCol].DisplayCol;
end;

function TtsBaseGrid.GetDisplayRow(DataRow: Longint): Longint;
begin
    Result := 0;
    if (DataRow >= 0) and (DataRow <= RowCount - 1) then
        Result := GridRows.DisplayRowNumber[DataRow];
end;

procedure TtsBaseGrid.SetDisplayRownr(DataRow: Longint; Value: Longint);
var
    MaxRow: Longint;
    OldDisplayRow: Longint;
begin
    if (DataRow < 1) or (DataRow > Rows) then Exit;
    if (Value < 1) or (Value > Rows) then Exit;

    if GridRows.DisplayRowNumber[DataRow] <> Value then
    begin
        OldDisplayRow := GridRows.DisplayRowNumber[DataRow];

        ChangeDisplayRow(OldDisplayRow, Value);
        MoveVisibleRow(OldDisplayRow, Value);
        ChangeRowHeights(OldDisplayRow, Value);
        ChangeSelectedRows(OldDisplayRow, Value);
        ChangeCurrentRowPosition(OldDisplayRow, Value);
        DoRowMoved(Value, 1, False);

        MaxRow := MaxVisibleRow;
        if (OldDisplayRow < FixedRows) or
           ((OldDisplayRow >= TopRow) and (OldDisplayRow <= MaxRow)) or
           (Value < FixedRows) or
           ((Value >= TopRow) and (Value <= MaxRow)) then
        begin
            Invalidate;
        end;

        UpdateScrollRange;
        CheckTopLeft(False);
        RedisplayControl(True);
    end;
end;

function TtsBaseGrid.GetDisplayRownr(DataRow: Longint): Longint;
begin
    Result := -1;
    if (DataRow >= 1) and (DataRow <= RowCount - 1) then
        Result := GridRows.DisplayRowNumber[DataRow];
end;

procedure TtsBaseGrid.SetRowChanged(DataRow: Longint; Value: Boolean);
var
    DisplayRow: Longint;
begin
    if CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        if FChangedRows[DataRow] <> Value then
            FChangedRows[DataRow] := Value;

        if not Value then
        begin
            DisplayRow := GetDisplayRow(DataRow);
            if DisplayRow = FCurDisplayRow then
            begin
                FCurRowChanged := False;
                InvalidateCell(0, DisplayRow);
            end;
        end;
    end;
end;

function TtsBaseGrid.GetRowChanged(DataRow: Longint): Boolean;
var
    DisplayRow: Longint;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        Result := FChangedRows[DataRow];
        DisplayRow := GetDisplayRow(DataRow);
        if not Result and (DisplayRow = FCurDisplayRow) then
            Result := FCurRowChanged;
    end;
end;

function TtsBaseGrid.IsRowChanged(DataRow: Longint): Boolean;
begin
    Result := False;
    if (DataRow >= 1) and (DataRow <= RowCount - 1) then
        Result := FChangedRows[DataRow];
end;

procedure TtsBaseGrid.SetRowSelected(DataRow: Longint; Value: Boolean);
var
    DisplayRow: Longint;
begin
    if CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        DisplayRow := GetDisplayRow(DataRow);
        if FSelectedRows[DisplayRow] <> Value then
            SelectRows(DisplayRow, DisplayRow, Value);
    end;
end;

function TtsBaseGrid.GetRowSelected(DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itRow, DataRow, 1, Rows) then
        Result := FSelectedRows[GetDisplayRow(DataRow)];
end;

function TtsBaseGrid.IsRowSelected(DataRow: Longint): Boolean;
begin
    Result := False;
    if (DataRow >= 1) and (DataRow <= RowCount - 1) then
        Result := FSelectedRows[GetDisplayRow(DataRow)];
end;

procedure TtsBaseGrid.SetRowMoving(Value: Boolean);
begin
    FRowMoving := Value;
end;

function TtsBaseGrid.GetRowMoving: Boolean;
begin
    Result := FRowMoving;
end;

procedure TtsBaseGrid.AssignRowCombo(DataRow: Longint);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].AssignCombo;
    end;
end;

procedure TtsBaseGrid.ResetRowCombo(DataRow: Longint);
begin
    RowCombo[DataRow] := nil;
end;

procedure TtsBaseGrid.AssignRowFont(DataRow: Longint);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].AssignFont;
    end;
end;

procedure TtsBaseGrid.ResetRowFont(DataRow: Longint);
begin
    if CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        GridRows.CreateDataRow(DataRow);
        GridRows[DataRow].ResetFont;
        GridRows.CheckRemoveDataRow(DataRow);
    end;
end;

function TtsBaseGrid.GetDataCol(DisplayCol: Longint): Longint;
begin
    Result := -1;
    if (DisplayCol < 0) or (DisplayCol > ColCount - 1) then Exit;
    Result := FDataColNumber[DisplayCol];
end;

procedure TtsBaseGrid.SetDataCol(DisplayCol, Value: Longint);
begin
    if (DisplayCol < 1) or (DisplayCol > ColCount - 1) then Exit;
    if FDataColNumber[DisplayCol] <> Value then
        FDataColNumber[DisplayCol] := Value;
end;

function TtsBaseGrid.GetDataColnr(DisplayCol: Longint): Longint;
begin
    Result := -1;
    if (DisplayCol < 1) or (DisplayCol > ColCount - 1) then Exit;
    Result := FDataColNumber[DisplayCol];
end;

function TtsBaseGrid.GetDataRow(DisplayRow: Longint): Longint;
begin
    Result := -1;
    if (DisplayRow < 0) or (DisplayRow > RowCount - 1) then Exit;
    Result := FDataRowNumber[DisplayRow];
end;

procedure TtsBaseGrid.SetDataRow(DisplayRow, Value: Longint);
begin
    if (DisplayRow < 1) or (DisplayRow > RowCount - 1) then Exit;
    if FDataRowNumber[DisplayRow] <> Value then
        FDataRowNumber[DisplayRow] := Value;
end;

function TtsBaseGrid.GetDataRownr(DisplayRow: Longint): Longint;
begin
    Result := -1;
    if (DisplayRow < 1) or (DisplayRow > RowCount - 1) then Exit;
    Result := FDataRowNumber[DisplayRow];
end;

procedure TtsBaseGrid.ResetLastCell;
begin
    FLastCell.Empty := True;
    FLastCell.DataCol := -1;
    FLastCell.DataRow := Unassigned;
    FLastCell.Element := nil;
end;

function TtsBaseGrid.GetCellElement(DataCol, DataRow: Longint; Check: Boolean): TtsCellElement;
begin
    Result := nil;
    if not FLastCell.Empty then
    begin
        if (DataCol = FLastCell.DataCol) and (DataRow = FLastCell.DataRow) then
        begin
            Result := TtsCellElement(FLastCell.Element);
            Exit;
        end;
    end;

    if Check then if not CheckIndex(itCol, DataCol, 1, Cols) or not CheckIndex(itRow, DataRow, 1, RowCount - 1) then Exit;
    if FCellPropSet.Count = 0 then Exit;
    if Check and (not Assigned(FColCells[DataCol])) and (not Assigned(FRowCells[DataRow])) then Exit;

    Result := TtsCellElement(FCellPropSet.Get([DataCol,DataRow]));
    FLastCell.DataCol := DataCol;
    FLastCell.DataRow := DataRow;
    FLastCell.Element := Result;
    FLastCell.Empty := False;
end;

function TtsBaseGrid.GetCellColor(DataCol, DataRow: Longint): TColor;
var
    Element: TtsCellElement;
begin
    Result := clNone;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FColor;
end;

procedure TtsBaseGrid.SetCellColor(DataCol, DataRow: Longint; Value: TColor);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prColor, 0, True);
end;

function TtsBaseGrid.GetCellCheckBoxState(DataCol, DataRow: Longint): TCheckBoxState;
begin
  Result := VariantToCheckBox(Cell[DataCol, DataRow], GiveCellCheckBoxValues(DataCol, DataRow));
end;

procedure TtsBaseGrid.SetCellCheckBoxState(DataCol, DataRow: Longint; Value : TCheckBoxState);
begin
  Cell[DataCol, DataRow] := CheckBoxToVariant(Value, GiveCellCheckBoxValues(DataCol, DataRow));
end;

function TtsBaseGrid.GetCellTag(DataCol, DataRow: Longint): Integer;
var
    Element: TtsCellElement;
begin
    Result := 0;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FTag;
end;

procedure TtsBaseGrid.SetCellTag(DataCol, DataRow: Longint; Value: Integer);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prTag, 0, True);
end;

function TtsBaseGrid.GetCellData(DataCol, DataRow: Longint): Pointer;
var
    Element: TtsCellElement;
begin
    Result := Nil;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FData;
end;

procedure TtsBaseGrid.SetCellData(DataCol, DataRow: Longint; Value: Pointer);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, ObjectToVariant(Value), prData, 0, True);
end;

procedure TtsBaseGrid.SetXMLExport(Value : TosXMLExport);
begin
  FXMLExport.Assign(Value);
end;

function TtsBaseGrid.GetCellControlType(DataCol, DataRow: Longint): TtsControlType;
var
    Element: TtsCellElement;
begin
    Result := ctDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FControlType;
end;

procedure TtsBaseGrid.SetCellControlType(DataCol, DataRow: Longint; Value: TtsControlType);
var
    Element: TtsCustomElement;
begin
    if Value <> CellControlType[DataCol, DataRow] then
    begin
        Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
        FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prControlType, 0, True);
        CheckGridData(DataCol, DataRow)
    end;
end;

function TtsBaseGrid.GetCellSpinOptions(DataCol, DataRow: Longint): TtsSpinOptions;
var
    Element: TtsCellElement;
begin
    Result := [spoAutoRepeat, spoAutoIncrement, spoKeyEdit];
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FSpinOptions;
end;

procedure TtsBaseGrid.SetCellSpinOptions(DataCol, DataRow: Longint; Value: TtsSpinOptions);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Byte(Value), prSpinOptions, 0, True);
end;

function TtsBaseGrid.GetCellSpinIncrement(DataCol, DataRow: Longint): Double;
var
    Element: TtsCellElement;
begin
    Result := 1;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FSpinIncrement;
end;

procedure TtsBaseGrid.SetCellSpinIncrement(DataCol, DataRow: Longint; Value: Double);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prSpinIncrement, 0, True);
end;

function TtsBaseGrid.GetCellFont(DataCol, DataRow: Longint): TFont;
var
    Element: TtsCellElement;
    ParentFont: Boolean;
begin
    Result := nil;
    Element := GetCellElement(DataCol, DataRow, False);
    ParentFont := True;
    if Element <> nil then
    begin
        Result := Element.FFont;
        ParentFont := Element.FParentFont;
        if not Assigned(Result) and Element.FAutoCreateFont then
        begin
            Element.UpdateFont(Font);
            Result := Element.FFont;
        end
        else if Assigned(Result) and Element.FParentFont and
                (not Element.FAutoCreateFont) and (not Reading) then
        begin
            Element.UpdateFont(nil);
            Result := Element.FFont;
        end;
    end;

    if ParentFont and Writing then
        Result := nil
    else if not Assigned(Result) and Reading then
    begin
        SetCellFont(DataCol, DataRow, Font);
        Element := TtsCellElement(FCellPropSet.Get([DataCol, DataRow]));
        if Element <> nil then Result := Element.FFont;
    end
end;

procedure TtsBaseGrid.SetCellFont(DataCol, DataRow: Longint; Value: TFont);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol,DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, ObjectToVariant(Value), prFont, 0, True);
end;

function TtsBaseGrid.GetCellParentFont(DataCol, DataRow: Longint): Boolean;
var
    Element: TtsCellElement;
begin
    Result := True;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FParentFont;
end;

procedure TtsBaseGrid.SetCellParentFont(DataCol, DataRow: Longint; Value: Boolean);
var
    Element: TtsCustomElement;
    CurParentFont: Boolean;
    CellElement: TtsCellElement;
begin
    CurParentFont := True;
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    if Element <> nil then CurParentFont := TtsCellElement(Element).FParentFont;

    if CurParentFont <> Value then
    begin
        FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prParentFont, 0, True);
        if Value then
        begin
            if Assigned(Element) then
            begin
                CellElement := TtsCellElement(Element);
                if not CellElement.FAutoCreateFont then
                    CellElement.UpdateFont(nil)
                else if Assigned(CellElement.FFont) then
                    CellElement.UpdateFont(Font);
            end;
        end
        else if Assigned(Element) then
            TtsCellElement(Element).UpdateFont(GiveCellFont(DataCol, DataRow))
        else
            CellFont[DataCol, DataRow] := GiveCellFont(DataCol, DataRow);
    end;
end;

function TtsBaseGrid.GetCellAlignment(DataCol, DataRow: Longint): TAlignment;
var
    Element: TtsCellElement;
begin
    Result := taLeftJustify;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FAlignment;
end;

procedure TtsBaseGrid.SetCellAlignment(DataCol, DataRow: Longint; Value: TAlignment);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prAlignment, 0, True);
end;

function TtsBaseGrid.GetCellAlign(DataCol, DataRow: Longint): Boolean;
var
    Element: TtsCellElement;
begin
    Result := False;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FAlign;
end;

procedure TtsBaseGrid.SetCellAlign(DataCol, DataRow: Longint; Value: Boolean);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prAlign, 0, True);
end;

function TtsBaseGrid.GetCellHorzAlignment(DataCol, DataRow: Longint): TtsHorzAlignment;
var
    Element: TtsCellElement;
begin
    Result := htaDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FHorzAlignment;
end;

procedure TtsBaseGrid.SetCellHorzAlignment(DataCol, DataRow: Longint; Value: TtsHorzAlignment);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prHorzAlignment, 0, True);
end;

function TtsBaseGrid.GetCellVertAlignment(DataCol, DataRow: Longint): TtsVertAlignment;
var
    Element: TtsCellElement;
begin
    Result := vtaDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FVertAlignment;
end;

procedure TtsBaseGrid.SetCellVertAlignment(DataCol, DataRow: Longint; Value: TtsVertAlignment);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prVertAlignment, 0, True);
end;

function TtsBaseGrid.GetCellIs3D(DataCol, DataRow: Longint): Boolean;
var
    Element: TtsCellElement;
begin
    Result := False;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FIs3D;
end;

procedure TtsBaseGrid.SetCellIs3D(DataCol, DataRow: Longint; Value: Boolean);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prIs3D, 0, True);
end;

function TtsBaseGrid.IsCellReadOnly(DataCol, DataRow: Longint): TtsReadOnly;
var
    P: Pointer;
begin
    Result := roDefault;
    P := FCellPropSet.Get([DataCol,DataRow]);
    if P <> nil then Result := TtsCellElement(P).FCellReadOnly;
end;

function TtsBaseGrid.GetCellReadOnly(DataCol, DataRow: Longint): TtsReadOnly;
var
    Element: TtsCellElement;
begin
    Result := roDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FCellReadOnly;
end;

procedure TtsBaseGrid.SetCellReadOnly(DataCol, DataRow: Longint; Value: TtsReadOnly);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prCellReadOnly, 0, True);
end;

function TtsBaseGrid.GetCellWordWrap(DataCol, DataRow: Longint): TtsWordWrap;
var
    Element: TtsCellElement;
begin
    Result := wwDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FWordWrap;
end;

procedure TtsBaseGrid.SetCellWordWrap(DataCol, DataRow: Longint; Value: TtsWordWrap);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prWordWrap, 0, True);
end;

function TtsBaseGrid.GetCellButtonType(DataCol, DataRow: Longint): TtsButtonType;
var
    Element: TtsCellElement;
begin
    Result := btDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FButtonType;
end;

procedure TtsBaseGrid.SetCellButtonType(DataCol, DataRow: Longint; Value: TtsButtonType);
var
    Element: TtsCustomElement;
begin
    if FAsCombo then Exit;
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prButtonType, 0, True);
    if (Value = btCombo) then CheckComboCreated;
end;

function TtsBaseGrid.GetCellDropDownStyle(DataCol, DataRow: Longint): TtsDropDownStyle;
var
    Element: TtsCellElement;
begin
    Result := ddDropDown;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.DropDownStyle;
end;

procedure TtsBaseGrid.SetCellDropDownStyle(DataCol, DataRow: Longint; Value: TtsDropDownStyle);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prDropDownStyle, 0, True);
end;

function TtsBaseGrid.CalcTextHeight: Integer;
var
    Lines: Integer;
begin
    Result := 0;
    if not HandleAllocated then exit;

    Canvas.Font := Font;
    GetTextHeight(Canvas.Handle, nil, 0, taLeftJustify, False, Lines, Result);
end;

procedure TtsBaseGrid.ComputeTextSize(DataCol: Longint; DrawWidth: Integer; Value: string; Font: TFont; Alignment:
                                      TAlignment; WordWrap: TtsWordWrap; ButtonType: TtsButtonType;
                                      var TextLines, TextHeight: Integer);
var
    OldFont: TFont;
begin
    OldFont := Canvas.Font;
    try
        Canvas.Font := Font;
        GetTextHeight(Canvas.Handle, PChar(Value), DrawWidth, Alignment,
                      (WordWrap <> wwOff), TextLines, TextHeight);
        TextHeight := TextHeight + 1;
    finally
        Canvas.Font := OldFont;
    end;
end;

procedure TtsBaseGrid.GetTextSize(DataCol: Longint; DataRow: Variant;
                                  var TextLines, TextHeight: Integer);
var
    Value: string;
    DrawData: TtsDrawData;
    Button: TtsCustomButton;
    DrawWidth: Integer;
begin
    TextHeight := 0;
    TextLines := 0;

    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, Rows) then
    begin
        if GiveCellControlType(DataCol, DataRow) <> ctText then Exit;
        Value := Cell[DataCol, DataRow];

        GetDrawData(DisplayColnr[DataCol], DisplayRownr[DataRow], True, DrawData);
        with DrawData do
        begin
            DrawWidth := GridCols[DataCol].Width - tsRangeSelectWidth - FVertLineWidth;
            if (ButtonType <> btNone) then
            begin
                Button := GridCellButton(DisplayColnr[DataCol], ButtonType);
                if Assigned(Button) then
                    DrawWidth := DrawWidth - Button.FullWidth;
            end;

            ComputeTextSize(DataCol, DrawWidth, Value, Font, Alignment, WordWrap, ButtonType,
                            TextLines, TextHeight);
        end;
    end;
end;

procedure TtsBaseGrid.GetHeadingTextSize(DataCol: Longint; var TextLines, TextHeight: Integer);
var
    Value: string;
    DrawData: TtsDrawData;
    DrawWidth: Integer;
begin
    TextHeight := 0;
    TextLines := 0;

    if CheckIndex(itCol, DataCol, 1, Cols) then
    begin
        Value := GridCols[DataCol].Heading;

        GetDrawData(DisplayColnr[DataCol], 0, True, DrawData);
        with DrawData do
        begin
            DrawWidth := DrawRect.Right - DrawRect.Left - tsRangeSelectWidth;
            ComputeTextSize(DataCol, DrawWidth, Value, HeadingFont, Alignment, WordWrap, ButtonType,
                            TextLines, TextHeight);
        end;
    end;
end;

function TtsBaseGrid.GetCellTextWidth(DataCol, DataRow: Longint): Integer;
var Value: string;
    Metric: TTextMetric;
    bMultiLine : Boolean;
begin
   GetTextMetrics(Canvas.Handle, Metric);
   Value := Cell[DataCol, DataRow];
   bMultiLine := (CellWordWrap[DataCol, DataRow] = wwOn) or
                 ((Self.WordWrap = wwOn) and (CellWordWrap[DataCol, DataRow] = wwDefault));
   GetPrintCharWidth(Canvas, Metric, Pchar(Value),
                     Length(Value), bMultiLine, False, Result);
end;

function TtsBaseGrid.GetCellTextHeight(DataCol, DataRow: Longint): Integer;
var
    TextLines: Integer;
begin
    GetTextSize(DataCol, DataRow, TextLines, Result);
end;

function TtsBaseGrid.GetCellTextLines(DataCol, DataRow: Longint): Integer;
var
    TextHeight: Integer;
begin
    GetTextSize(DataCol, DataRow, Result, TextHeight);
end;

function TtsBaseGrid.GetHeadingTextHeight(DataCol: Longint): Integer;
var
    TextLines: Integer;
begin
    GetHeadingTextSize(DataCol, TextLines, Result);
end;

function TtsBaseGrid.GetHeadingTextLines(DataCol: Longint): Integer;
var
    TextHeight: Integer;
begin
    GetHeadingTextSize(DataCol, Result, TextHeight);
end;

function TtsBaseGrid.GetCellMaskName(DataCol, DataRow: Longint): string;
var
    Element: TtsCellElement;
begin
    Result := '';
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FMaskName;
end;

procedure TtsBaseGrid.SetCellMaskName(DataCol, DataRow: Longint; Value: string);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prMask, 0, False);
end;

function TtsBaseGrid.GetCellCombo(DataCol, DataRow: Longint): TtsCombo;
var
    Element: TtsCellElement;
begin
    Result := nil;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FCombo;
end;

procedure TtsBaseGrid.SetCellCombo(DataCol, DataRow: Longint; Value: TtsCombo);
var
    Element: TtsCustomElement;
begin
    if FAsCombo then Exit;
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, ObjectToVariant(Value), prCombo, 0, InDesignMode);
    if InDesignMode and (Value <> Nil) and
       (Value.DropDownStyle = ddDropDownList) then
        CurrentCell.SelectAll;
end;

procedure TtsBaseGrid.SetCellParentCombo(DataCol, DataRow: Longint; Value: Boolean);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prParentCombo, 0, False);
end;

function TtsBaseGrid.GetCellParentCombo(DataCol, DataRow: Longint): Boolean;
var
    Element: TtsCellElement;
begin
    Result := True;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FParentCombo;
end;

function TtsBaseGrid.GetCellStretchPicture(DataCol, DataRow: Longint): TtsDrawOption;
var
    Element: TtsCellElement;
begin
    Result := dopDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FStretchPicture;
end;

procedure TtsBaseGrid.SetCellStretchPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prPicture, tsStretchId, True);
end;

function TtsBaseGrid.GetCellShrinkPicture(DataCol, DataRow: Longint): TtsDrawOption;
var
    Element: TtsCellElement;
begin
    Result := dopDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FShrinkPicture;
end;

procedure TtsBaseGrid.SetCellShrinkPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prPicture, tsShrinkId, True);
end;

function TtsBaseGrid.GetCellCenterPicture(DataCol, DataRow: Longint): TtsDrawOption;
var
    Element: TtsCellElement;
begin
    Result := dopDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FCenterPicture;
end;

procedure TtsBaseGrid.SetCellCenterPicture(DataCol, DataRow: Longint; Value: TtsDrawOption);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prPicture, tsCenterId, True);
end;

function TtsBaseGrid.GetCellKeepAspectRatio(DataCol, DataRow: Longint): TtsDrawOption;
var
    Element: TtsCellElement;
begin
    Result := dopDefault;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FKeepAspectRatio;
end;

procedure TtsBaseGrid.SetCellKeepAspectRatio(DataCol, DataRow: Longint; Value: TtsDrawOption);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, Value, prPicture, tsRatioId, True);
end;

function TtsBaseGrid.GetCellDateTimeDef(DataCol, DataRow: Longint): TtsDateTimeDefComponent;
var
    Element: TtsCellElement;
begin
    Result := nil;
    Element := GetCellElement(DataCol, DataRow, False);
    if Element <> nil then Result := Element.FDateTimeDef;
end;

procedure TtsBaseGrid.SetCellDateTimeDef(DataCol, DataRow: Longint; Value: TtsDateTimeDefComponent);
var
    Element: TtsCustomElement;
begin
    Element := TtsCustomElement(GetCellElement(DataCol, DataRow, True));
    FCellPropSet.SetProperty([DataCol, DataRow], Element, ObjectToVariant(Value), prDateTime, 0, False);
end;

function TtsBaseGrid.CheckStrValue(ControlType: TtsControlType; const Value: Variant): Variant;
begin
    if VarType(Value) = varOleStr then
        Result := VarAsType(Value, varString)
    else if (ControlType <> ctText) then
        Result := Value
    else
    begin
        if VarIsEmpty(Value) or VarIsNull(Value) or (VarType(Value) = varString)
            then Result := Value
            else Result := VarAsType(Value, varString)
    end;
end;

procedure TtsBaseGrid.CheckSetMask(DataCol: Longint; DataRow: Variant);
begin
    if not (csDestroying in ComponentState) then
    begin
        if (DataCol >= 0) and (DataCol <= ColCount - 1) and
           (DataRow >= 0) and (DataRow <= RowCount - 1) then
        begin
            if (CurDataCol = DataCol) and (CurDataRow = DataRow) then
                SetControlMask;
        end;
    end;
end;

function TtsBaseGrid.CopyCellToClipboard: Boolean;
begin
    Result := CurrentCell.CopyToClipBoard;
end;

function TtsBaseGrid.CutCellToClipboard: Boolean;
begin
    Result := False;
    if CurrentCell.ControlType <> ctText then Exit;
    if not InEditState or not FGridControl.KeyEdit then Exit;
    if StartShowEditor(False) then Result := CurrentCell.InternalCutToClipboard(True);
end;

function TtsBaseGrid.PasteCellFromClipboard: Boolean;
begin
    Result := False;
    if CurrentCell.ControlType <> ctText then Exit;
    if not InEditState or not FGridControl.KeyEdit then Exit;
    if StartShowEditor(False) then Result := CurrentCell.InternalPasteFromClipboard(True);
end;

procedure TtsBaseGrid.SpinIncrement(DataCol, DataRow: Longint; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean);
begin
    DoSpinIncrement(DataCol, DataRow, SpinButton, Value, Pos, Len, Accept);
end;

function TtsBaseGrid.IncrementPictureValue(DataCol, DataRow: Longint; SpinButton: TtsSpinButton): Variant;
var
    Value: Variant;
    Image: TtsImageItem;
begin
    Result := Unassigned;
    if not Assigned(ImageList) then Exit;

    Value := CurrentCell.Value;
    if VarIsEmpty(Value) then Value := '';
    if VarType(Value) <> varString then Exit;

    if SpinButton = spbIncrement
        then Image := ImageList.Image[ImageList.NextIndex(Value)]
        else Image := ImageList.Image[ImageList.PrevIndex(Value)];
    if Assigned(Image) then
    begin
        Result := Image.Name;
        if Image.SetName <> '' then Result := Image.SetName + '.' + Result;
    end;
end;

procedure TtsBaseGrid.CheckIncrementValue(DataCol, DataRow: Longint; var Value: Variant; var Pos, Len: Integer);
var
    CurLen: Integer;
    Text, NewText, CurText, NumStr: string;
    InsertChars: string;
    Mask: TtsMaskItem;
begin
    Mask := FMaskLink.Mask[GiveCellMaskName(DataCol, DataRow)];
    if Mask = nil then Exit;
    if not (mcOnEdit in Mask.AutoFill) then Exit;

    InsertChars := '';
    Text := Value;

    CurText := CurrentCell.Value;
    CurLen := Len + Length(CurText) - Length(Text);
    NumStr := PadNumber(Copy(CurText, Pos, CurLen), Copy(Text, Pos, Len));

    if (Pos > 1) or (Len <> Length(Text)) then
    begin
        NewText := Copy(Text, 1, Pos - 1) + NumStr;
        if Mask.ValidInput(NewText, InsertChars, Length(NewText) + 1, False, False) then
        begin
            Value := NewText + Copy(Text, Pos + Len, Length(Text));
            Len := Length(NumStr);
            Exit;
        end;
    end;

    if not Mask.ValidInput(Text, InsertChars, Length(Text) + 1, True, False) then
    begin
        Value := Unassigned;
        NewText := Copy(Text, 1, Pos - 1) + NumStr;
        if Mask.ValidInput(NewText, InsertChars, Length(NewText) + 1, True, False) then
        begin
            Value := NewText + Copy(Text, Pos + Len, Length(Text));
            Len := Length(NumStr);
        end
    end;

    if VarIsEmpty(Value) then
    begin
        Value := Text;
        if not Mask.ValidInput(Text, InsertChars, Length(Text) + 1, False, False) then
        begin
            Value := Unassigned;
            NewText := Copy(Text, 1, Pos - 1) + NumStr;
            if Mask.ValidInput(NewText, InsertChars, Length(NewText) + 1, False, False) then
            begin
                Value := NewText + Copy(Text, Pos + Len, Length(Text));
                Len := Length(NumStr);
            end
        end;
    end;
end;

function TtsBaseGrid.IncrementTextValue(DataCol, DataRow: Longint; SpinButton: TtsSpinButton;
                                        var Pos, Len: Integer): Variant;
var
    Value: Variant;
    Increment: Double;
begin
    Result := Unassigned;
    Increment := GiveCellSpinIncrement(DataCol, DataRow);
    if SpinButton = spbIncrement then
    begin
        if CurrentCell.Value = ''
            then Value := IncStrAtPos('0', Increment, CurrentCell.SelStart, Pos, Len)
            else Value := IncStrAtPos(CurrentCell.Value, Increment, CurrentCell.SelStart, Pos, Len)
    end
    else
    begin
        if CurrentCell.Value = ''
            then Value := IncStrAtPos('0', -Increment, CurrentCell.SelStart, Pos, Len)
            else Value := IncStrAtPos(CurrentCell.Value, -Increment, CurrentCell.SelStart, Pos, Len);
    end;

    Result := Value;
    if Value <> CurrentCell.Value then
    begin
        CheckIncrementValue(DataCol, DataRow, Value, Pos, Len);
        Result := Value;
    end;
end;

procedure TtsBaseGrid.CheckSpinIncrement(DataCol, DataRow: Longint; SpinButton: TtsSpinButton);
var
    Value: Variant;
    SpinOptions: TtsSpinOptions;
    ControlType: TtsControlType;
    Accept: Boolean;
    Pos, Len: Integer;
begin
    SpinOptions := GiveCellSpinOptions(DataCol, DataRow);
    if not (spoAutoIncrement in SpinOptions) then Exit;

    ControlType := GiveCellControlType(DataCol, DataRow);
    if ControlType in [ctNone, ctCheck] then Exit;
    if not FControlEnabled then
    begin
        if not InternalShowEditor(tsCurrent, False) then Exit;
        CurrentCell.SelLength := 0;
        if not CellEditing then ClearControlBuffer;
    end;

    Pos := 0;
    Len := 0;
    case ControlType of
        ctText: Value := IncrementTextValue(DataCol, DataRow, SpinButton, Pos, Len);
        ctPicture:
            begin
                Value := IncrementPictureValue(DataCol, DataRow, SpinButton);
                if VarType(Value) = varString then
                begin
                    Pos := 1;
                    if not VariantEqual(CurrentCell.Value, Value) then
                        Len := Length(Value);
                end;
            end;
    end;

    if not VarIsEmpty(Value) and not VariantEqual(CurrentCell.Value, Value) then
    begin
        Accept := True;
        SpinIncrement(DataCol, DataRow, SpinButton, Value, Pos, Len, Accept);

        if Accept and not VariantEqual(CurrentCell.Value, Value) then
        begin
            if StartShowEditor(True) then
            begin
                Value := CheckStrValue(ControlType, Value);
                AssignControlValue(ControlType, Value, True, True);
                if ControlType = ctText then
                    CurrentCell.SelStart := Pos + Len - 1 + Length(CurrentCell.Value) - Length(Value);
            end;
        end;
    end;
end;

function TtsBaseGrid.DrawCell3D(DataCol: Longint; DataRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        Result := GiveCell3D(DataCol, DataRow);
    end;
end;

procedure TtsBaseGrid.AssignCellCombo(DataCol: Longint; DataRow: Longint);
var
    Element: TtsCellElement;
begin
    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        Element := TtsCellElement(FCellPropSet.Get([DataCol,DataRow]));
        if not Assigned(Element) then
            Element := TtsCellElement(CreateCellElement(DataCol, DataRow));
        if Assigned(Element) then
        begin
            Element.AssignCombo;
            if (CurDataCol = DataCol) and (CurDataRow = DataRow) then ResetComboInit(False);
        end;
    end;
end;

procedure TtsBaseGrid.ResetCellCombo(DataCol: Longint; DataRow: Longint);
begin
    CellCombo[DataCol, DataRow] := nil;
end;

procedure TtsBaseGrid.AssignCellFont(DataCol: Longint; DataRow: Longint);
begin
    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, RowCount - 1) then
    begin
        if CellFont[DataCol, DataRow] = nil then
            SetCellFont(DataCol, DataRow, Font);
    end;
end;

procedure TtsBaseGrid.ResetCellFont(DataCol: Longint; DataRow: Longint);
begin
    SetCellFont(DataCol, DataRow, nil);
end;

procedure TtsBaseGrid.ResetCellTag(DataCol: Longint; DataRow: Longint);
begin
  CellTag[DataCol, DataRow] := 0;
end;

procedure TtsBaseGrid.ResetCellData(DataCol: Longint; DataRow: Longint);
begin
  CellData[DataCol, DataRow] := Nil;
end;

procedure TtsBaseGrid.ResetProperties(Properties: TtsProperties);
begin
    ResetColProperties(Properties);
    ResetRowProperties(Properties);
    ResetCellProperties(Properties);
end;

procedure TtsBaseGrid.ResetColProperties(Properties: TtsProperties);
var
    I: Longint;
begin
    if Properties = [] then Exit;

    EnablePaint := False;
    try
        if prSelected in Properties then SelectCols(1, Cols, False);

        for I := 1 to Cols do
        begin
            if ResizeCols = rcAll then GridCols[I].Reset(Properties - [prWidth])
                                  else GridCols[I].Reset(Properties);
        end;

        if (prWidth in Properties) and (ResizeCols = rcAll) then
        begin
            CheckHideControl(True);
            ChangeAllColWidths(FOldDefaultColWidth, False);
            ShowGridControl;
        end;

    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.ResetRowProperties(Properties: TtsProperties);
var
    I: Longint;
begin
    if Properties = [] then Exit;

    EnablePaint := False;
    try
        if prSelected in Properties then SelectRows(1, RowCount - 1, False);

        for I := 1 to Rows do
        begin
            if Assigned(GridRows[I]) then
            begin
                if ResizeRows = rrAll
                    then GridRows[I].Reset(Properties - [prHeight])
                    else GridRows[I].Reset(Properties);
                GridRows.CheckRemoveDataRow(I);
            end
            else
            begin
                if prDisplayNumber in Properties then DisplayRownr[I] := I;
                if prChanged in Properties then RowChanged[I] := False;
            end;
        end;

        if (prHeight in Properties) and (ResizeRows = rrAll) then
        begin
            CheckHideControl(True);
            ChangeAllRowHeights(FOldDefaultRowHeight, False);
            ShowGridControl;
        end;
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.ResetCellProperties(Properties: TtsProperties);
begin
    EnablePaint := False;
    try
        if (prSelected in Properties) and (GridStatus = grCellSelect) then
        begin
            DeleteSelections([grCellSelect], True);
            SelectionsChanged(False);
            ShowGridControl;
        end;

        FCellPropSet.ResetProperties(Properties, True);
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.SetCheckBoxStyle(Value: TtsCheckBoxStyle);
begin
    if FCheckBoxStyle <> Value then
    begin
        FCheckBoxStyle := Value;
        FCheckControl.CheckBoxStyle := TtsGridCheckBoxStyle(Value);

        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.ResizeCellPropArrays(OldColCount, OldRowCount: Longint);
var
    I: Integer;
begin
    if ColCount > OldColCount then
    begin
        FColCells.Count := ColCount;
        for I := OldColCount to (ColCount - 1) do FColCells[I] := nil;
    end
    else if ColCount < OldColCount then
    begin
        if not (csDesigning in ComponentState) then
            for I := ColCount to (OldColCount - 1) do FColCells[I].Free;
        FColCells.Count := ColCount;
    end;

    if RowCount > OldRowCount then
    begin
        FRowCells.Count := RowCount;
        for I := OldRowCount to (RowCount - 1) do FRowCells[I] := nil;
    end
    else if RowCount < OldRowCount then
    begin
        if not (csDesigning in ComponentState) then
            for I := RowCount to (OldRowCount - 1) do FRowCells[I].Free;
        FRowCells.Count := RowCount;
    end;
end;

procedure TtsBaseGrid.Invalidate;
begin
    if FastAssign then Exit;
    inherited;
end;

procedure TtsBaseGrid.InvalidateRow(DisplayRow: Longint);
var
    Rect: TGridRect;
    MaxCol: Longint;
    InvalidRect : TRect;
begin
    if not HandleAllocated then Exit;
    if FastAssign then Exit;

    MaxCol := MaxVisibleCol;
    Rect := GridRect(LeftCol, DisplayRow, MaxCol, DisplayRow);
    InvalidRect := BoxRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom);
    Windows.InvalidateRect(Handle, @InvalidRect, False);

    if (RowBarOn) or (FInternalFixedCols > 0) then
    begin
        //Also invalidate the left border column
        Rect := GridRect(0, DisplayRow, CalcMin(MaxCol, FInternalFixedCols), DisplayRow);
        InvalidRect := BoxRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom);
        Windows.InvalidateRect(Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.InvalidateCol(DisplayCol: Longint);
var
    Rect: TGridRect;
    MaxRow: Longint;
    InvalidRect : TRect;
begin
    if not HandleAllocated then Exit;
    if FastAssign then Exit;

    MaxRow := MaxVisibleRow;
    Rect := GridRect(DisplayCol, TopRow, DisplayCol, MaxRow);
    InvalidRect := BoxRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom);
    Windows.InvalidateRect(Handle, @InvalidRect, False);

    if (HeadingOn) or (FInternalFixedRows > 0) then
    begin
        //Also invalidate the Heading
        Rect := GridRect(DisplayCol, 0, DisplayCol, CalcMin(MaxRow, FInternalFixedRows));
        InvalidRect := BoxRect(Rect.Left, Rect.Top, Rect.Right, Rect.Bottom);
        Windows.InvalidateRect(Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.InvalidateCell(DisplayCol, DisplayRow: Longint);
begin
    if FastAssign then Exit;
    inherited InvalidateCell(DisplayCol, DisplayRow);
end;

function TtsBaseGrid.CellVisible(DisplayCol, DisplayRow: Longint): Boolean;
var
    ARect: TRect;
begin
    Result := False;
    if not HandleAllocated then Exit;

    ARect := CellRect(DisplayCol, DisplayRow);
    Result := ARect.Right > 0;
end;

{$IFDEF TSVER_CBUILD}
procedure TtsBaseGrid.InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom: Longint; const ARect: TRect; Selected: Boolean; Dc: HDCType);
{$ELSE}
procedure TtsBaseGrid.InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom: Longint; const ARect: TRect; Selected: Boolean; Dc: HDC);
{$ENDIF}
var
    DcCreated: Boolean;
begin
    if not HandleAllocated then Exit;

    if (DisplayBottom > FInternalFixedRows) and (DisplayBottom < TopRow) then
        DisplayBottom := FInternalFixedRows;

    if (DisplayRight > FInternalFixedCols) and (DisplayRight < LeftCol) then
        DisplayRight := FInternalFixedCols;

    DcCreated := False;
    try
        if (Dc = 0) and CanPaint then
        begin
            Dc := GetDC(Handle);
            DcCreated := True;
        end;

        GridRectInvert(Dc, GridRect(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom), ARect, Selected);
    finally
        if DcCreated then ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertCell(DisplayCol, DisplayRow: Longint; const ARect: TRect; Selected: Boolean; DC: HDC);
begin
    InvertRange(DisplayCol, DisplayRow, DisplayCol, DisplayRow, ARect, Selected, DC);
end;

{$IFDEF TSVER_CBUILD}
procedure TtsBaseGrid.InvertRow(DisplayRow: Longint; Selected: Boolean; DC: HDCType);
{$ELSE}
procedure TtsBaseGrid.InvertRow(DisplayRow: Longint; Selected: Boolean; DC: HDC);
{$ENDIF}
var
    RowBarRect, Rect: TGridRect;
    DcCreated: Boolean;
begin
    if not HandleAllocated then Exit;

    DcCreated := False;
    try
        if (DC = 0) and CanPaint then
        begin
            DC := GetDC(Handle);
            DcCreated := True;
        end;

        Rect.Left := -1;
        RowBarRect.Left := -1;

        // first invert the rowbar and the fixed cell(s)
        if (RowBarOn) or (FInternalFixedCols > 0) then
        begin
            RowBarRect := GridRect(0, DisplayRow,
                                   CalcMin(FInternalFixedCols, MaxVisibleCol), DisplayRow);
        end;

        // invert the rest of the row
        if (FixedCols > 0) and (FixedCols <= ColCount - 1) and (ColCount > 1) then
        begin
            Rect := GridRect(LeftCol, DisplayRow,
                             CalcMin(LeftCol + VisibleColCount, ColCount - 1), DisplayRow);
            if RowBarRect.Left <> -1 then
            begin
                if RowBarRect.Left < Rect.Left then Rect.Left := RowBarRect.Left;
                if RowBarRect.Right > Rect.Right then Rect.Right := RowBarRect.Right;
            end;
        end
        else
            Rect := RowBarRect;

        if Rect.Left <> -1 then
            GridRectInvert(Dc, Rect, FNullRect, Selected);
    finally
        if DcCreated then ReleaseDC(Handle, DC);
    end;
end;

procedure TtsBaseGrid.InvertCol(DisplayCol: Longint; Invert: TtsInvert; Selected: Boolean; Dc: HDC);
var
    Rect: TGridRect;
    DcCreated: Boolean;
begin
    if not HandleAllocated then Exit;

    DcCreated := False;
    try
        if (Dc = 0) and CanPaint then
        begin
            Dc := GetDC(Handle);
            DcCreated := True;
        end;

        // first invert the heading and the fixed cell(s)
        if (HeadingOn and (Invert in [ivHead, ivBoth])) or (FInternalFixedRows > 0) then
        begin
            if Invert = ivHead then
                Rect := GridRect(DisplayCol, 0, DisplayCol, 0)
            else if Invert = ivBoth then
                Rect := GridRect(DisplayCol, 0, DisplayCol,
                                 CalcMin(FInternalFixedRows, MaxVisibleRow))
            else
                Rect := GridRect(DisplayCol, 1, DisplayCol,
                                 CalcMin(FInternalFixedRows, MaxVisibleRow));
            GridRectInvert(Dc, Rect, FNullRect, Selected);
        end;

        // then invert the rest of the column
        if (FixedRows > 0) and (Invert in [ivData, ivBoth]) and
           (FixedRows <= RowCount - 1) and (RowCount > 0) then
        begin
            Rect := GridRect(DisplayCol, TopRow, DisplayCol,
                             CalcMin(TopRow + VisibleRowCount, RowCount - 1));
            GridRectInvert(Dc, Rect, FNullRect, Selected);
        end;
    finally
        if DcCreated then ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertHeading(Selected: Boolean);
var
    Rect: TGridRect;
    Dc: HDC;
begin
    if not HandleAllocated then Exit;

    if HeadingOn then
    begin
        Dc := 0;
        if CanPaint then Dc := GetDC(Handle);

        try
            if FInternalFixedCols > 0 then
            begin
                Rect := GridRect(1, 0, FInternalFixedCols, 0);
                GridRectInvert(Dc, Rect, FNullRect, Selected);
            end;

            if (FixedCols <= ColCount - 1) and (ColCount > 1) then
            begin
                Rect := GridRect(LeftCol, 0, MaxVisibleCol, 0);
                GridRectInvert(Dc, Rect, FNullRect, Selected);
            end;
        finally
            if Dc <> 0 then ReleaseDC(Handle, Dc);
        end;
    end;
end;

procedure TtsBaseGrid.InvertLabel(Selected: Boolean);
var
    Rect: TGridRect;
    Dc: HDC;
begin
    if not HandleAllocated then Exit;

    if RowBarOn then
    begin
        Dc := 0;
        if CanPaint then Dc := GetDC(Handle);

        try
            if FInternalFixedRows > 0 then
            begin
                Rect := GridRect(0, 1, 0, FInternalFixedRows);
                GridRectInvert(Dc, Rect, FNullRect, Selected);
            end;

            if (FixedRows <= RowCount - 1) and (RowCount > 1) then
            begin
                Rect := GridRect(0, TopRow, 0, MaxVisibleRow);
                GridRectInvert(Dc, Rect, FNullRect, Selected);
            end;
        finally
            if Dc <> 0 then ReleaseDC(Handle, Dc);
        end;
    end;
end;

procedure TtsBaseGrid.InvertGrid(Selected: Boolean);
var
    Rect: TGridRect;
    Dc: HDC;
begin
    if not HandleAllocated then Exit;

    InvertLabel(Selected);
    Dc := 0;
    if CanPaint then Dc := GetDC(Handle);
    try
        Rect := GridRect(1, 1, MaxVisibleCol, MaxVisibleRow);
        GridRectInvert(Dc, Rect, FNullRect, Selected);
    finally
        if Dc <> 0 then ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertNew(NewLeft, NewTop, NewRight, NewBottom: Longint);
begin
    if FGridStatus = grCellSelect then
        InvertNewRangeSelecting(NewLeft, NewTop, NewRight, NewBottom)
    else if FGridStatus = grColSelect then
        InvertNewColSelecting(NewLeft, NewTop, NewRight, NewBottom)
    else if FGridStatus = grRowSelect then
        InvertNewRowSelecting(NewLeft, NewTop, NewRight, NewBottom);
end;

procedure TtsBaseGrid.InvertNewRangeSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
var
    MinBottom, MaxTop: Longint;
begin
    NewLeft := CalcMax(NewLeft, 1);
    NewTop := CalcMax(NewTop, 1);
    NewRight := CalcMin(NewRight, MaxVisibleCol);
    NewBottom := CalcMin(NewBottom, MaxVisibleRow);

    with FSelectedCells do
    begin
        if (Left > NewRight) or (Top > NewBottom) or (Right < NewLeft) or
           (Bottom < NewTop) then
        begin
            InvertRange(Left, Top, Right, Bottom, FNullRect, False, 0);
            InvertRange(NewLeft, NewTop, NewRight, NewBottom, FNullRect, True, 0);
            Exit;
        end
    end;

    if NewLeft > NewRight then Exit;
    if NewTop > NewBottom then Exit;

    MaxTop := CalcMax(FSelectedCells.Top, NewTop);
    MinBottom := CalcMin(FSelectedCells.Bottom, NewBottom);

    with FSelectedCells do
    begin
        if NewTop < Top then
            InvertRange(NewLeft, NewTop, NewRight,
                        CalcMin(Top - 1, MaxVisibleRow), FNullRect, True, 0)
        else if (NewTop > Top) and (NewTop <= Bottom) then
            InvertRange(Left, Top, Right, NewTop - 1, FNullRect, False, 0);

        if NewLeft < Left then
            InvertRange(NewLeft, MaxTop, Left - 1, MinBottom, FNullRect, True, 0)
        else if (NewLeft > Left) and (NewLeft <= Right) then
            InvertRange(Left, MaxTop, NewLeft - 1, MinBottom, FNullRect, False, 0);

        if NewRight > Right then
            InvertRange(Right + 1, MaxTop, NewRight, MinBottom, FNullRect, True, 0)
        else if (NewRight < Right) and (NewRight >= Left) then
            InvertRange(NewRight + 1, MaxTop, Right, MinBottom, FNullRect, False, 0);

        if NewBottom > Bottom then
            InvertRange(NewLeft, Bottom + 1, NewRight, NewBottom, FNullRect, True, 0)
        else if (NewBottom < Bottom) and (NewBottom >= Top) then
            InvertRange(Left, NewBottom + 1, Right, Bottom, FNullRect, False, 0);
    end;
end;

procedure TtsBaseGrid.InvertNewColSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
var
    I: Integer;
begin
    NewLeft := CalcMax(NewLeft, LeftCol);
    NewTop := CalcMax(NewTop, TopRow);
    NewRight := CalcMin(NewRight, MaxVisibleCol);
    NewBottom := CalcMin(NewBottom, MaxVisibleRow);

    if (FSelectedCols.First > MaxVisibleCol) or (FSelectedCols.Last < LeftCol) or
       (ColRangeUnselected(LeftCol, MaxVisibleCol)) then
    begin
        InvertRange(NewLeft, NewTop, NewRight, NewBottom, FNullRect, True, 0);
        Exit;
    end;

    if NewLeft > LeftCol then
        for I := LeftCol to (NewLeft - 1) do
            if FSelectedCols[I] then InvertCol(I, ivBoth, False, 0);

    for I := NewLeft to NewRight do
    begin
        if FSelectedCols[I] then
        begin
            if NewLeft < I then InvertRange(NewLeft, NewTop, I - 1, NewBottom, FNullRect, True, 0);
            InvertCell(I, 0, FNullRect, False, 0);
            if NewTop > TopRow then InvertRange(I, TopRow, I, NewTop - 1, FNullRect, False, 0);
            if NewBottom < MaxVisibleRow then
                InvertRange(I, NewBottom + 1, I, MaxVisibleRow, FNullRect, False, 0);
            NewLeft := I + 1;
        end;
    end;

    if not FSelectedCols[NewRight] then
        InvertRange(NewLeft, NewTop, NewRight, NewBottom, FNullRect, True, 0);

    if NewRight < MaxVisibleCol then
        for I := (NewRight + 1) to MaxVisibleCol do
            if FSelectedCols[I] then InvertCol(I, ivBoth, False, 0);
end;

procedure TtsBaseGrid.InvertNewRowSelecting(NewLeft, NewTop, NewRight, NewBottom: Longint);
var
    I: Integer;
begin
    NewLeft := CalcMax(NewLeft, LeftCol);
    NewTop := CalcMax(NewTop, TopRow);
    NewRight := CalcMin(NewRight, MaxVisibleCol);
    NewBottom := CalcMin(NewBottom, MaxVisibleRow);

    if (FSelectedRows.First > MaxVisibleRow) or (FSelectedRows.Last < TopRow) or
       (RowRangeUnselected(TopRow, MaxVisibleRow)) then
    begin
        InvertRange(NewLeft, NewTop, NewRight, NewBottom, FNullRect, True, 0);
        Exit;
    end;

    if NewTop > TopRow then
        for I := TopRow to (NewTop - 1) do
            if FSelectedRows[I] then InvertRow(I, False, 0);

    for I := NewTop to NewBottom do
    begin
        if FSelectedRows[I] then
        begin
            if NewTop < I then InvertRange(NewLeft, NewTop, NewRight, I - 1, FNullRect, True, 0);
            InvertCell(0, I, FNullRect, False, 0);
            if NewLeft > LeftCol then InvertRange(LeftCol, I, NewLeft - 1, I, FNullRect, False, 0);
            if NewRight < MaxVisibleCol then
                InvertRange(NewRight + 1, I, MaxVisibleCol, I, FNullRect, False, 0);
            NewTop := I + 1;
        end;
    end;

    if not FSelectedRows[NewBottom] then
        InvertRange(NewLeft, NewTop, NewRight, NewBottom, FNullRect, True, 0);

    if NewBottom < MaxVisibleRow then
        for I := (NewBottom + 1) to MaxVisibleRow do
            if FSelectedRows[I] then InvertRow(I, False, 0);
end;

procedure TtsBaseGrid.SetDrawOverlap(Value: TtsDrawOverlap);
begin
    if FDrawOverlap <> Value then
    begin
        FDrawOverlap := Value;
        Invalidate;
        RedisplayControl(True);
        CheckGridData(-1, -1);
    end;
end;

procedure TtsBaseGrid.SetDataAllocSize(ColSize, RowSize: Longint);
begin
    if StoreData then
    begin
        GridData.RowsAllocSize := RowSize;
        if RowSize > SmallAllocSize
            then GridData.ColsAllocSize := CalcMin(ColSize, SmallAllocSize)
            else GridData.ColsAllocSize := ColSize;
    end;
end;

procedure TtsBaseGrid.SizeChanged(OldColCount, OldRowCount: Longint);
begin
    SetDataAllocSize(Cols, Rows);
    if (ColCount <> OldColCount) or (RowCount <> OldRowCount) then
    begin
        CheckResetButtons;
        ResizeCellPropArrays(OldColCount, OldRowCount);
    end;

    if ColCount <> OldColCount then
    begin
        GridCols.Resize(OldColCount);
        FSelectedCols.SetSize(ColCount);

        CreateDefaultColNumber(OldColCount);
        DoColCountChanged(OldColCount - 1, ColCount - 1);
    end;

    if RowCount <> OldRowCount then
    begin
        GridRows.Resize(OldRowCount);
        ResizeRowChanged;
        FSelectedRows.SetSize(RowCount);

        CreateDefaultRowNumber(OldRowCount);
        CheckRowCountChanged(OldRowCount - 1 - FOldInsertionRow,
                             RowCount - 1 - FInsertionRow);
    end;

    UpdateScrollRange;
end;

{$IFDEF TSVER_V3}
procedure TtsBaseGrid.GetChildren(Proc: TGetChildProc; Root: TComponent);
begin
    if not (csWriting in ComponentState) then inherited;
end;
{$ELSE}
procedure TtsBaseGrid.GetChildren(Proc: TGetChildProc);
begin
    if not (csWriting in ComponentState) then inherited;
end;

procedure TtsBaseGrid.WriteState(Writer: TWriter);
begin
    if (InDesignMode or (pkCols in FStoredPropKinds)) and StoreCols then
    begin
        FStoredCols.Free;
        FStoredCols := CreateColCollection(True);
    end
    else
        FStoredCols.Clear;

    if InDesignMode or (pkRows in FStoredPropKinds) then
    begin
        FStoredRows.Free;
        FStoredRows := CreateRowCollection(True);
    end
    else
        FStoredRows.Clear;

    if InDesignMode or (pkCells in FStoredPropKinds) then
    begin
        FStoredCells.Free;
        FStoredCells := CreateCellCollection(True);
    end
    else
        FStoredCells.Clear;

    inherited;
end;

procedure TtsBaseGrid.ReadState(Reader: TReader);
begin
    FStoredCols.Clear;
    FStoredRows.Clear;
    FStoredCells.Clear;
    inherited;
end;
{$ENDIF}

procedure TtsBaseGrid.Update;
begin
    if FastAssign then Exit;
    inherited;
end;

procedure TtsBaseGrid.DrawRowCells(DisplayRow: Longint; YPos: Integer; DrawRect: TRect; LeftColPos: Longint;
                                   var ColBoundary: Integer);
var
    ARect: TRect;
    ColPos, DisplayCol: Longint;
begin
    ARect.Top := YPos;
    ARect.Bottom := YPos + RowHeights[DisplayRow];
    ARect.Left := 0;

    for DisplayCol := 0 to FixedCols - 1 do
    begin
        ARect.Right := ARect.Left + ColWidths[DisplayCol];
        if ARect.Left >= DrawRect.Right then Break;
        if (ARect.Right > DrawRect.Left) and (ARect.Right > ARect.Left) then
            DrawCell(DisplayCol, DisplayRow, ARect, []);
        ARect.Left := ARect.Right;
    end;

    for ColPos := LeftColPos to FVisibleCols.Count do
    begin
        if ARect.Left >= DrawRect.Right then Break;
        DisplayCol := FVisibleCols[ColPos];
        ARect.Right := ARect.Left + ColWidths[DisplayCol];
        if ARect.Right > DrawRect.Left then
            DrawCell(DisplayCol, DisplayRow, ARect, []);
        ARect.Left := ARect.Right;
    end;

    if (ColPos > FVisibleCols.Count) and (ARect.Right < ColBoundary) then
        ColBoundary := ARect.Right;
end;

procedure TtsBaseGrid.DrawCells(DrawRect: TRect; LeftColPos, TopRowPos: Longint; var ColBoundary, RowBoundary: Integer);
var
    DisplayRow: Longint;
    YPos, CurHeight: Integer;
    RowPos: Longint;
begin
    ColBoundary := ClientWidth + 1;
    RowBoundary := ClientHeight + 1;

    YPos := 0;
    for DisplayRow := 0 to FixedRows - 1 do
    begin
        if YPos >= DrawRect.Bottom then Break;
        CurHeight := RowHeights[DisplayRow];
        if (YPos + CurHeight > DrawRect.Top) and (CurHeight > 0) then
            DrawRowCells(DisplayRow, YPos, DrawRect, LeftColPos, ColBoundary);
        YPos := YPos + CurHeight;
    end;

    for RowPos := TopRowPos to FVisibleRows.Count do
    begin
        if YPos >= DrawRect.Bottom then Break;
        DisplayRow := FVisibleRows[RowPos];
        CurHeight := RowHeights[DisplayRow];
        if (YPos + CurHeight > DrawRect.Top) then
            DrawRowCells(DisplayRow, YPos, DrawRect, LeftColPos, ColBoundary);
        YPos := YPos + CurHeight;
    end;

    if (RowPos > FVisibleRows.Count) and (YPos < RowBoundary) then
        RowBoundary := YPos;
end;

procedure TtsBaseGrid.DrawEmptyArea(XPos, YPos: Integer);
begin
    if XPos < ClientWidth then
    begin
        if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
        Canvas.FillRect(Rect(XPos, 0, ClientWidth, YPos));
    end;

    if YPos < ClientHeight then
    begin
        if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
        Canvas.FillRect(Rect(0, YPos, ClientWidth, ClientHeight));
    end;
end;

procedure TtsBaseGrid.DrawHorzLine(DisplayRow: Longint; VertPos: Integer; DrawRect: TRect; DrawFixed: Boolean; LeftColPos: Longint);
var
    CurrentColor : TColor;
    NewColor : TColor;
    LineStart, LineEnd : Integer;
    DisplayCol : Integer;
    IsCell3D : Boolean;
    Current3D : Boolean;
    ColPos: Longint;
    DataCol, DataRow: Longint;
begin
    if FixedCols > 1 then ColPos := 1
                     else ColPos := LeftColPos;
    CurrentColor := LineColor;
    Current3D := False;
    LineStart := ColWidths[0];
    LineEnd := LineStart;

    while (LineEnd < DrawRect.Right) and (ColPos <= FVisibleCols.Count) do
    begin
        DisplayCol := FVisibleCols[ColPos];
        if (DisplayCol >= FixedCols) and (DisplayCol < LeftCol) then
        begin
            ColPos := LeftColPos;
            if ColPos > FVisibleCols.Count then Break;
            DisplayCol := FVisibleCols[ColPos];
        end;

        if DrawFixed then
        begin
            IsCell3D := False;
            NewColor := FFixedLineColor
        end
        else
        begin
            DataCol := FDataColNumber[DisplayCol];
            DataRow := FDataRowNumber[DisplayRow];
            IsCell3D := GiveCell3D(DataCol, DataRow);
            if IsCell3D then NewColor := CellShadeColor
                        else NewColor := LineColor;
        end;

        if (Current3D <> IsCell3D) or (NewColor <> CurrentColor) then
        begin
            if LineStart < LineEnd then
            begin
                if Current3D or (FGridLines in [glHorzLines, glBoth]) then
                begin
                    Canvas.Pen.Color := CurrentColor;
                    Canvas.MoveTo(LineStart, VertPos);
                    Canvas.LineTo(LineEnd, VertPos);
                end;
            end;

            CurrentColor := NewColor;
            Current3D := IsCell3D;
            LineStart := LineEnd;
        end;

        LineEnd := LineEnd + ColWidths[DisplayCol];
        if LineEnd > DrawRect.Right then LineEnd := DrawRect.Right;

        if (DisplayCol < (FixedCols - 1)) or (DisplayCol >= FixedCols)
            then Inc(ColPos)
            else ColPos := LeftColPos;
    end;

    if LineStart < LineEnd then
    begin
        if Current3D or (FGridLines in [glHorzLines, glBoth]) then
        begin
            Canvas.Pen.Color := CurrentColor;
            Canvas.MoveTo(LineStart, VertPos);
            Canvas.LineTo(LineEnd, VertPos);
        end;
    end;
end;

procedure TtsBaseGrid.DrawHorzLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
var
    YPos: Integer;
    CurHeight: Integer;
    RowPos: Longint;
    DisplayRow, MaxFixedVisible: Longint;
    Found, DrawFixed: Boolean;
begin
    DrawRect.Left := CalcMax(DrawRect.Left, ColWidths[0]);
    DrawRect.Top := CalcMax(DrawRect.Top, RowHeights[0]);

    MaxFixedVisible := 0;
    if FixedRows > 1 then
    begin
        RowPos := FVisibleRows.Locate(FixedRows - 1, Found);
        if Found then
            MaxFixedVisible := FVisibleRows[RowPos]
        else if (RowPos - 1 >= 1) and (RowPos - 1 <= FVisibleRows.Count) then
            MaxFixedVisible := FVisibleRows[RowPos - 1];
    end;

    YPos := RowHeights[0];
    for DisplayRow := 1 to FixedRows - 1 do
    begin
        if YPos > DrawRect.Bottom then Break;
        CurHeight := RowHeights[DisplayRow];
        if (YPos + CurHeight >= DrawRect.Top) and (CurHeight > 0) then
        begin
            DrawFixed := (DisplayRow = MaxFixedVisible) and (FFixedLineColor <> clNone) and
                         (FGridLines in [glHorzLines, glBoth]);
            DrawHorzLine(DisplayRow, YPos + CurHeight - 1, DrawRect, DrawFixed, LeftColPos);
        end;
        YPos := YPos + CurHeight;
    end;

    for RowPos := TopRowPos to FVisibleRows.Count do
    begin
        if YPos > DrawRect.Bottom then Break;
        DisplayRow := FVisibleRows[RowPos];
        CurHeight := RowHeights[DisplayRow];
        if (YPos + CurHeight >= DrawRect.Top) then
            DrawHorzLine(DisplayRow, YPos + CurHeight - 1, DrawRect, False, LeftColPos);
        YPos := YPos + CurHeight;
    end;
end;

procedure TtsBaseGrid.DrawVertLine(DisplayCol: Longint; HorzPos: Integer; DrawRect: TRect; DrawFixed: Boolean; TopRowPos: Longint);
var
    CurrentColor : TColor;
    NewColor : TColor;
    LineStart, LineEnd : Integer;
    DisplayRow : Integer;
    IsCell3D : Boolean;
    Current3D : Boolean;
    RowPos: Longint;
    DataCol, DataRow: Longint;
begin
    if FixedRows > 1 then RowPos := 1
                     else RowPos := TopRowPos;
    CurrentColor := LineColor;
    Current3D := False;
    LineStart := RowHeights[0];
    LineEnd := LineStart;

    while (LineEnd < DrawRect.Bottom) and (RowPos <= FVisibleRows.Count) do
    begin
        DisplayRow := FVisibleRows[RowPos];
        if (DisplayRow >= FixedRows) and (DisplayRow < TopRow) then
        begin
            RowPos := TopRowPos;
            if RowPos > FVisibleRows.Count then Break;
            DisplayRow := FVisibleRows[RowPos];
        end;

        if DrawFixed then
        begin
            IsCell3D := False;
            NewColor := FFixedLineColor;
        end
        else
        begin
            DataCol := FDataColNumber[DisplayCol];
            DataRow := FDataRowNumber[DisplayRow];
            IsCell3D := GiveCell3D(DataCol, DataRow);
            if IsCell3D then NewColor := CellShadeColor
                        else NewColor := LineColor;
        end;

        if IsCell3D then
            IsCell3D := True;
        if Current3D then
            Current3D := True;

        if (Current3D <> IsCell3D) or (NewColor <> CurrentColor) then
        begin
            if LineStart < LineEnd then
            begin
                if Current3D or (FGridLines in [glVertLines, glBoth]) then
                begin
                    Canvas.Pen.Color := CurrentColor;
                    Canvas.MoveTo(HorzPos, LineStart);
                    Canvas.LineTo(HorzPos, LineEnd);
                end;
            end;

            CurrentColor := NewColor;
            Current3D := IsCell3D;
            LineStart := LineEnd;
        end;

        LineEnd := LineEnd + RowHeights[DisplayRow];
        if LineEnd > DrawRect.Bottom then LineEnd := DrawRect.Bottom;

        if (DisplayRow < (FixedRows - 1)) or (DisplayRow >= FixedRows) then
            Inc(RowPos)
        else
            RowPos := TopRowPos;
    end;

    if LineStart < LineEnd then
    begin
        if Current3D or (FGridLines in [glVertLines, glBoth]) then
        begin
            Canvas.Pen.Color := CurrentColor;
            Canvas.MoveTo(HorzPos, LineStart);
            Canvas.LineTo(HorzPos, LineEnd);
        end;
    end;
end;

procedure TtsBaseGrid.DrawVertLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
var
    XPos: Integer;
    CurWidth: Integer;
    ColPos: Longint;
    DisplayCol: Longint;
    MaxFixedVisible: Longint;
    Found, DrawFixed: Boolean;
begin
    DrawRect.Left := CalcMax(DrawRect.Left, ColWidths[0]);
    DrawRect.Top := CalcMax(DrawRect.Top, RowHeights[0]);

    MaxFixedVisible := 0;
    if FixedCols > 1 then
    begin
        ColPos := FVisibleCols.Locate(FixedCols - 1, Found);
        if Found then
            MaxFixedVisible := FVisibleCols[ColPos]
        else if (ColPos - 1 >= 1) and (ColPos - 1 <= FVisibleCols.Count) then
            MaxFixedVisible := FVisibleCols[ColPos - 1];
    end;

    XPos := ColWidths[0];
    for DisplayCol := 1 to FixedCols - 1 do
    begin
        if XPos > DrawRect.Right then Break;
        CurWidth := ColWidths[DisplayCol];
        if (XPos + CurWidth >= DrawRect.Left) and (CurWidth > 0) then
        begin
            DrawFixed := (DisplayCol = MaxFixedVisible) and (FFixedLineColor <> clNone) and
                         (FGridLines in [glVertLines, glBoth]);
            DrawVertLine(DisplayCol, XPos + CurWidth - 1, DrawRect, DrawFixed, TopRowPos);
        end;
        XPos := XPos + CurWidth;
    end;

    for ColPos := LeftColPos to FVisibleCols.Count do
    begin
        if XPos > DrawRect.Right then Break;
        DisplayCol := FVisibleCols[ColPos];
        CurWidth := ColWidths[DisplayCol];
        if (XPos + CurWidth >= DrawRect.Left) then
            DrawVertLine(DisplayCol, XPos + CurWidth - 1, DrawRect, False, TopRowPos);
        XPos := XPos + CurWidth;
    end;
end;

procedure TtsBaseGrid.DrawGridLines(DrawRect: TRect; LeftColPos, TopRowPos: Longint);
begin
    Canvas.Pen.Style := psSolid;
    Canvas.Pen.Mode := pmCopy;
    Canvas.Pen.Width := 1;
    Canvas.Pen.Color := LineColor;

    DrawHorzLines(DrawRect, LeftColPos, TopRowPos);
    DrawVertLines(DrawRect, LeftColPos, TopRowPos);
end;

procedure TtsBaseGrid.PaintGrid;
var
    DrawRect: TRect;
    LeftColPos, TopRowPos: Longint;
    ColBoundary, RowBoundary: Integer;
    Found: Boolean;
begin
    DrawRect.Left := CalcMax(0, Canvas.ClipRect.Left);
    DrawRect.Top := CalcMax(0, Canvas.ClipRect.Top);
    DrawRect.Right := CalcMin(ClientWidth, Canvas.ClipRect.Right);
    DrawRect.Bottom := CalcMin(ClientHeight, Canvas.ClipRect.Bottom);

    LeftColPos := FVisibleCols.Locate(LeftCol, Found);
    TopRowPos := FVisibleRows.Locate(TopRow, Found);

    DrawGridLines(DrawRect, LeftColPos, TopRowPos);
    DrawCells(DrawRect, LeftColPos, TopRowPos, ColBoundary, RowBoundary);
    DrawEmptyArea(ColBoundary, RowBoundary);
end;

procedure TtsBaseGrid.Paint;
var
    Dc: Hdc;
    ARect, ClipRect : TRect;
begin
    FInPaintWindow := True;
    try
        if FMetaFileCanvas <> Nil then
           Dc := FMetaFileCanvas.Handle
        else
           Dc := Canvas.Handle;
        if (not FFirstTimePainted) then
        begin
            InitCanvas(Canvas);
            GetClipBox(Dc, ClipRect);
            PaintGrid;
            DoPaint;
            FFirstTimePainted := True;
        end
        else
        begin
            FGridMemoryCanvas.Lock(Self);
            try
                SetGridDc(Dc);
                GetClipBox(Dc, ClipRect);
                FGridMemoryCanvas.SetObjects(ClipRect);
                Canvas.Handle := FGridMemoryCanvas.Dc;

                if FDoInitCanvas then
                begin
                    InitCanvas(Canvas);
                    FDoInitCanvas := False;
                end;

                PaintGrid;
                DoPaint;

                ARect := ClipRect;
                if ARect.Right > ClientWidth then ARect.Right := ClientWidth;
                if ARect.Bottom > ClientHeight then ARect.Bottom := ClientHeight;
                BitBlt(Dc, ARect.Left, ARect.Top, ARect.Right - ARect.Left,
                       ARect.Bottom - ARect.Top, FGridMemoryCanvas.Dc,
                       ARect.Left, ARect.Top, cmSrcCopy);
            finally
                FGridMemoryCanvas.Unlock;
            end;
        end;
    finally
        FInPaintWindow := False;
    end;

{$IFDEF TSVER_V7}
   if ThemeServices.ThemesEnabled and (csNeedsBorderPaint in ControlStyle) then
      ThemeServices.PaintBorder(Self, False);
{$ENDIF}
end;

procedure TtsBaseGrid.Notification(AComponent: TComponent; Operation: TOperation);
begin
    inherited Notification(AComponent, Operation);
    if (Operation = opRemove) then
    begin
      if (AComponent = Self.FGridReport) then
         FGridReport := Nil;
    end;
end;

procedure TtsBaseGrid.SetParent(AParent: TWinControl);
begin
    inherited;
    SetGridControlParent;
end;

procedure TtsBaseGrid.SetName(const Value: TComponentName);
begin
    if not FReading then inherited;
end;

procedure TtsBaseGrid.ChangeScale(M, D: Integer);
var
    Flags: TScalingFlags;
begin
    inherited;
    if M = D then Exit;
    if not AutoScale then Exit;

    Flags := [sfWidth, sfHeight, sfFont];
    if not HeadingParentFont and (sfFont in Flags) then
        HeadingFont.Size := MulDiv(HeadingFont.Size, M, D);

    if sfHeight in Flags then
    begin
        HeadingHeight := MulDiv(HeadingHeight, M, D);
        if not (csDesigning in ComponentState) then
            FScaledRowHeight := MulDiv(FScaledRowHeight, M, D);
    end;

    if sfWidth in Flags then
        RowBarWidth := MulDiv(RowBarWidth, M, D);

    ScaleCols(M, D, Flags);
    ScaleRows(M, D, Flags);
    ScaleCells(M, D, Flags);
    RedisplayControl(True);
end;

procedure TtsBaseGrid.SetGridDc(Dc: Hdc);
begin
    if not FDcPrepared then
    begin
        FGridMemoryCanvas.Prepare(Dc, Width, Height);
        FDcPrepared := True;
    end
    else
        FGridMemoryCanvas.Resize(Dc, Width, Height);
end;

procedure TtsBaseGrid.ResetGridDc;
begin
    if FDcPrepared then
    begin
        FGridMemoryCanvas.Lock(Self);
        try
            FGridMemoryCanvas.Release;
            FDcPrepared := False;
        finally
            FGridMemoryCanvas.Unlock;
        end;
    end;
end;

procedure TtsBaseGrid.MouseMessageToControl(Capture: Boolean);
var
    Point, ScreenPoint: TPoint;
begin
    if FMouseDownToControl then
    begin
        Point.X := FMouseDownMessage.XPos;
        Point.Y := FMouseDownMessage.YPos;
        ScreenPoint := ClientToScreen(Point);
        Point := FGridControl.ScreenToClient(ScreenPoint);

        if (Point.X >= 0) and (Point.Y >= 0) then
        begin
            FMouseDownMessage.Msg := WM_LButtonDown;
            if FDoubleClicked
                then FMouseDownMessage.Keys := 0
                else FMouseDownMessage.Keys := MK_LBUTTON;
            FMouseDownMessage.XPos := Point.X;
            FMouseDownMessage.YPos := Point.Y;
            FMouseDownMessage.Result := 0;

            if FDoubleClicked then FGridControl.OnMouseDown := nil;
            try
                SendMessage(FGridControl.Handle, FMouseDownMessage.Msg,
                            TMessage(FMouseDownMessage).WParam,
                            TMessage(FMouseDownMessage).LParam);
            finally
                FGridControl.OnMouseDown := CtrlOnMouseDown;
            end;

            if FGridControl.Focused then
                FGridControl.MouseCapture := Capture;
        end;

        FMouseDownToControl := False;
        if (not FGridControl.Focused) and FocusToGridControl then
            FGridControl.SetFocus;
    end;
end;

procedure TtsBaseGrid.MouseCaptureToCombo;
var
    ARect: TRect;
begin
    if FMouseDownToCombo then
    begin
        with Combo.FGrid do
        begin
            ARect := CellRect(FCurDisplayCol, FCurDisplayRow);
            MDRowSelect([], ARect.Left, ARect.Top, FCurDisplayCol, FCurDisplayRow);
            SetMouseDownColRow(FCurDisplayCol, FCurDisplayRow);
            MouseCapture := True;
        end;
        FMouseDownToCombo := False;
    end;
end;

function TtsBaseGrid.CompCaseSensitive(Value1, Value2: string; Len: Integer): Integer;
begin
    if (Len = 0) then
    begin
        if (Length(Value1) = 0) and (Length(Value2) = 0) then
            Result := 0
        else if Length(Value1) <> 0 then
            Result := 1
        else
            Result := -1
    end
    else
        Result := AnsiStrLComp(PChar(Value1), PChar(Value2), Len);
end;

function TtsBaseGrid.CompCaseInsensitive(Value1, Value2: string; Len: Integer): Integer;
begin
    if (Len = 0) then
    begin
        if (Length(Value1) = 0) and (Length(Value2) = 0) then
            Result := 0
        else if Length(Value1) <> 0 then
            Result := 1
        else
            Result := -1
    end
    else
        Result := AnsiStrLIComp(PChar(Value1), PChar(Value2), Len);
end;

function TtsBaseGrid.CompOwn(Value1, Value2: string; Len: Integer): Integer;
begin
    Result := 0;
    DoComboCompareValue(Value1, Value2, Result);
    DoComboLCompareValue(Value1, Value2, Len, Result);
end;

procedure TtsBaseGrid.SearchBinary(Top, Bottom: Longint; CmpValue: string;
                                   CmpFunc: TtsCompareFunction;
                                   var MinCmpLen: Integer; var Row: Longint; var Found: Boolean);
var
    Val: string;
    CompareRes: Integer;
    CurCmpLen: Integer;
begin
    if Top <= Bottom then
    begin
        Val := string(Combo.Grid.Cell[Combo.ValueCol, (Top + Bottom) div 2]);
        CurCmpLen := CalcMin(Length(Val), Length(CmpValue));
        CompareRes := CmpFunc(Val, CmpValue, CurCmpLen);

        if CompareRes > 0 then
            SearchBinary(Top, ((Top + Bottom) div 2) - 1, CmpValue, CmpFunc, MinCmpLen, Row, Found)
        else if (CompareRes < 0) or ((CompareRes = 0) and (CurCmpLen < MinCmpLen)) then
            SearchBinary(((Top + Bottom) div 2) + 1, Bottom, CmpValue, CmpFunc, MinCmpLen, Row, Found)
        else
        begin
            Row := (Top + Bottom) div 2;
            Found := True;
            MinCmpLen := CurCmpLen;

            if Length(CmpValue) < Length(Val) then
                SearchBinary(Top, ((Top + Bottom) div 2) - 1, CmpValue, CmpFunc, MinCmpLen, Row, Found)
            else if Length(CmpValue) > Length(Val) then
                SearchBinary(((Top + Bottom) div 2) + 1, Bottom, CmpValue, CmpFunc, MinCmpLen, Row, Found);
        end;
    end
    else if not Found then
        Row := CalcMax(CalcMin(Top - 1, Combo.Grid.Rows), 1);
end;

procedure TtsBaseGrid.SearchLinear(FromRow, ToRow: Longint; SearchValue: string;
                                     var Row: Longint; var Found: Boolean; CmpFunc: TtsCompareFunction);
var
    I: Integer;
    Str1, Str2: string;
    Len1: Integer;
    BestMatchLen, MatchLen: Integer;
begin
    Found := False;
    BestMatchLen := 0;
    Str1 := SearchValue;
    Len1 := Length(Str1);
    for I := FromRow to ToRow do
    begin
        Str2 := string(Combo.Grid.Cell[Combo.ValueCol, I]);
        //Str2 := string(Combo.Grid.Cell[Combo.ComboDisplayCol, I]);
        MatchLen := CalcMin(Len1, Length(Str2));
        if cmpFunc(Str1, Str2, MatchLen) = 0 then
        begin
            if BestMatchLen < MatchLen then
            begin
                Row := I;
                Found := True;
                BestMatchLen := MatchLen;
                if MatchLen = Len1 then Break;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.SetComboRow(DataRow: Longint);
begin
    if Combo.Grid.CurrentDataRow <> DataRow then
    begin
        Combo.Grid.EnablePaint := false;
        try
            Combo.Grid.CurrentDataRow := DataRow;
            case Combo.AutoSearch of
                asTop:      Combo.Grid.TopRow := DataRow;
                asBottom:   Combo.Grid.TopRow := DataRow - Combo.DropDownRows + 1;
                asCenter:   Combo.Grid.TopRow := DataRow - ((Combo.DropDownRows - 1) div 2);
            end;
        finally
            Combo.Grid.EnablePaint := true;
        end;
    end;
end;

function TtsBaseGrid.FindComboRow(SearchValue: string; FullCmpLen: Boolean; var Found: Boolean): Longint;
var
    ComboRow: Longint;
    MinCmpLen: Integer;
begin
    Found := False;
    ComboRow := Combo.Grid.CurrentDataRow;
    if SearchValue = '' then ComboRow := CalcMin(1, Combo.Grid.Rows);

    if Combo.ValueColSorted then
    begin
        if SearchValue <> '' then
        begin
            MinCmpLen := 1;
            if FullCmpLen then MinCmpLen := Length(SearchValue);

            case Combo.CompareType of
                ctCaseSensitive:
                    SearchBinary(1, Combo.Grid.Rows, SearchValue, CompCaseSensitive,
                                 MinCmpLen, ComboRow, Found);
                ctCaseInsensitive:
                    SearchBinary(1, Combo.Grid.Rows, SearchValue, CompCaseInsensitive,
                                 MinCmpLen, ComboRow, Found);
                ctOwn:
                    SearchBinary(1, Combo.Grid.Rows, SearchValue, CompOwn,
                                 MinCmpLen, ComboRow, Found);
            end;
        end;
    end
    else
    begin
        case Combo.CompareType of
            ctCaseSensitive:    SearchLinear(1, Combo.Grid.Rows, SearchValue, ComboRow, Found, CompCaseSensitive);
            ctCaseInsensitive:  SearchLinear(1, Combo.Grid.Rows, SearchValue, ComboRow, Found, CompCaseInsensitive);
            ctOwn:              SearchLinear(1, Combo.Grid.Rows, SearchValue, ComboRow, Found, CompOwn);
        end;
    end;

    Result := ComboRow;
end;

function TtsBaseGrid.FindNextComboRow(SearchValue: string; var Found: Boolean): Longint;
var
    NewRow, ComboRow: Longint;
    ComboValue: string;
begin
    ComboRow := Combo.Grid.CurrentDataRow;
    if Combo.ValueColSorted then
    begin
        if ComboRow = Combo.Grid.Rows then
            Result := FindComboRow(SearchValue, False, Found)
        else
        begin
            ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow + 1];
            if (ComboValue = '') or not ComboValueEqual(ComboValue[1], SearchValue) then
                Result := FindComboRow(SearchValue, False, Found)
            else
            begin
                Result := ComboRow + 1;
                Found := True;
            end;
        end;
    end
    else
    begin
        Result := ComboRow;
        Found := False;
        case Combo.CompareType of
            ctCaseSensitive:    SearchLinear(ComboRow + 1, Combo.Grid.Rows, SearchValue, NewRow, Found, CompCaseSensitive);
            ctCaseInsensitive:  SearchLinear(ComboRow + 1, Combo.Grid.Rows, SearchValue, NewRow, Found, CompCaseInsensitive);
            ctOwn:              SearchLinear(ComboRow + 1, Combo.Grid.Rows, SearchValue, NewRow, Found, CompOwn);
        end;

        if not Found then
        begin
            case Combo.CompareType of
                ctCaseSensitive:    SearchLinear(1, ComboRow - 1, SearchValue, NewRow, Found, CompCaseSensitive);
                ctCaseInsensitive:  SearchLinear(1, ComboRow - 1, SearchValue, NewRow, Found, CompCaseInsensitive);
                ctOwn:              SearchLinear(1, ComboRow - 1, SearchValue, NewRow, Found, CompOwn);
            end;
        end;

        if Found then Result := NewRow;
    end;
end;

function TtsBaseGrid.ComboValueEqual(Value1, Value2: string): Boolean;
begin
    Result := False;
    if Length(Value1) <> Length(Value2) then Exit;

    case Combo.CompareType of
        ctCaseSensitive: Result := CompCaseSensitive(Value1, Value2, Length(Value1)) = 0;
        ctCaseInsensitive: Result := CompCaseInsensitive(Value1, Value2, Length(Value1)) = 0;
        ctOwn: Result := CompOwn(Value1, Value2, Length(Value1)) = 0;
    end;
end;

procedure TtsBaseGrid.PositionComboRow;
var
    ComboRow: Longint;
    CurValue: string;
    Found: Boolean;
begin
    if Combo.AutoSearch <> asNone then
    begin
        CurValue := string(CurrentCell.Value);
        ComboRow := FindComboRow(CurValue, False, Found);
        SetComboRow(ComboRow);
    end;
end;

function TtsBaseGrid.FindComboFirstChar(Key: Char; var Found: Boolean): Integer;
var
    ComboRow: Longint;
    CurValue, ComboValue: string;
begin
    Found := False;
    CurValue := string(CurrentCell.Value);
    if (CurValue = '') or (not ComboValueEqual(CurValue[1], Key)) then
        ComboRow := FindComboRow(Key, False, Found)
    else
    begin
        ComboValue := '';
        ComboRow := Combo.Grid.CurrentDataRow;
        if ComboRow > 0 then ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow];
        //if ComboRow > 0 then ComboValue := Combo.Grid.Cell[Combo.ComboDisplayCol, ComboRow];

        if not ComboValueEqual(CurValue, ComboValue) then
        begin
            ComboRow := FindComboRow(CurValue, False, Found);
            Found := False;
            ComboValue := '';
            if ComboRow > 0 then ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow];
            //if ComboRow > 0 then ComboValue := Combo.Grid.Cell[Combo.ComboDisplayCol, ComboRow];
            if (ComboValue = '') or (not ComboValueEqual(ComboValue[1], Key))
                then ComboRow := FindComboRow(Key, False, Found)
                else ComboRow := FindNextComboRow(Key, Found);
        end
        else
            ComboRow := FindNextComboRow(Key, Found);
    end;
    Result := ComboRow;
end;

function TtsBaseGrid.FindComboString(Key: Char; var Found: Boolean): Integer;
var
    SearchValue: string;
    ComboValue: string;
    ComboRow: Longint;
begin
    Found := False;
    CheckResetComboSearchValue;
    SearchValue := FComboSearchValue;

    if SearchValue = '' then
    begin
        ComboRow := FindComboRow(Key, True, Found);
        if Found then FComboSearchValue := Key;
    end
    else
    begin
        SearchValue := FComboSearchValue + Key;
        ComboRow := FindComboRow(SearchValue, True, Found);
        if Found then
        begin
            ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow];
            //ComboValue := Combo.Grid.Cell[Combo.ComboDisplayCol, ComboRow];
            Found := (Length(SearchValue) <= Length(ComboValue)) and
                     (ComboValueEqual(Copy(ComboValue, 1, Length(SearchValue)), SearchValue));
        end;

        if Found then
            FComboSearchValue := SearchValue
        else if (Length(FComboSearchValue) = 1) and
                ComboValueEqual(FComboSearchValue[1], Key) then
        begin
            ComboRow := FindComboFirstChar(Key, Found);
            if Found then FComboSearchValue := Key;
        end;
    end;

    FLastIncrSearchTime := GetTickCount;
    Result := ComboRow;
end;

function TtsBaseGrid.PositionDropDownList(Key: Char): Variant;
var
    ComboRow: Longint;
    ComboValue: string;
    Found: Boolean;
begin
    Result := Unassigned;
    if Combo.AutoSearch = asNone then Exit;

    Found := False;
    if not Combo.ValueColSorted
        then ComboRow := FindComboFirstChar(Key, Found)
        else ComboRow := FindComboString(Key, Found);

    if (not Found) or (ComboRow = 0) then
        Result := Unassigned
    else
    begin
        SetComboRow(ComboRow);
        Result := Unassigned;
        DoComboGetValue(FCurDataCol, FCurDataRow, Combo.FGrid.CurrentDataRow, Result);
        if VarIsEmpty(Result) then
        begin
            ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow];
            //ComboValue := Combo.Grid.Cell[Combo.ComboDisplayCol, ComboRow];
            if VarIsEmpty(ComboValue) or VarIsNull(ComboValue) then
                Result := Unassigned
            else if ComboValue = '' then
                Result := Unassigned
            else if (not Combo.ValueColSorted) and (not ComboValueEqual(ComboValue[1], Key)) then
                Result := Unassigned
            else
                Result := ComboValue;
        end;
    end;
end;

procedure TtsBaseGrid.CheckSetAutoFillValue;
var
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
    ControlType: TtsControlType;
begin
    ButtonType := GiveCellButton(CurDataCol, CurDataRow, DropDownStyle);
    ControlType := GiveCellControlType(CurDataCol, CurDataRow);
    if (ControlType = ctText) and (ButtonType = btCombo) and (DropDownStyle = ddDropDown) then
        PositionAutoFill(True);
end;

procedure TtsBaseGrid.SetAutoFillValue(Value: Variant; ConvertCase: TtsConvertCase; CellExit: Boolean);
var
    OldValue: Variant;
    OldSelStart: Integer;
begin
    if not VarIsEmpty(Value) and not VarIsNull(Value) then
    begin
        OldValue := CurrentCell.Value;
        if ComboValueEqual(OldValue, Copy(Value, 1, Length(OldValue))) and
           (((Length(Value) <> Length(OldValue)) and (not CellExit)) or
            ((Length(Value) = Length(OldValue)) and (OldValue <> Value) and (CellExit or (ConvertCase = afcOnEdit)))) then
        begin
            OldSelStart := CurrentCell.SelStart;
            if (ConvertCase = afcOnEdit) or CellExit then
                SetCurrentValue(Value, True, True)
            else
                SetCurrentValue(OldValue + Copy(Value, Length(OldValue) + 1, Length(Value)), True, True);
            if Length(Value) <> Length(OldValue) then
            begin
                CurrentCell.SelStart := OldSelStart;
                CurrentCell.SelLength := Length(Value) - OldSelstart;
            end
            else
                CurrentCell.SelStart := OldSelStart;
        end;
    end;
end;

function TtsBaseGrid.PositionAutoFill(CellExit: Boolean): Boolean;
var
    ComboRow: Longint;
    ComboValue: string;
    Found: Boolean;
    NewValue: Variant;
begin
    Result := False;
    ComboInit(CurDataCol, CurDataRow);
    if not Combo.AutoFill then Exit;
    if CellExit and (Combo.AutoFillConvertCase <> afcOnExit) then Exit;
    if Combo.AutoSearch = asNone then Exit;
    if GiveCellControlType(CurDataCol, CurDataRow) <> ctText then Exit;
    if CurrentCell.Value = '' then Exit;

    Found := False;
    ComboRow := FindComboRow(CurrentCell.Value, True, Found);
    Result := Found and (ComboRow <> 0);
    if Result then
    begin
        SetComboRow(ComboRow);
        NewValue := Unassigned;
        DoComboGetValue(FCurDataCol, FCurDataRow, Combo.FGrid.CurrentDataRow, NewValue);
        if VarIsEmpty(NewValue) then
        begin
            ComboValue := Combo.Grid.Cell[Combo.ValueCol, ComboRow];
            //ComboValue := Combo.Grid.Cell[Combo.ComboDisplayCol, ComboRow];
            if VarIsEmpty(ComboValue) or VarIsNull(ComboValue) then
                NewValue := Unassigned
            else if ComboValue = '' then
                NewValue := Unassigned
            else
                NewValue := ComboValue;
        end;
        SetAutoFillValue(NewValue, Combo.AutoFillConvertCase, CellExit);
    end;
end;

function TtsBaseGrid.ResetComboSearchValue: Boolean;
begin
    Result := False;
    if FComboSearchValue <> '' then
    begin
        FComboSearchValue := '';
        FLastIncrSearchTime := 0;
        Result := True;
    end;
end;

procedure TtsBaseGrid.CheckResetComboSearchValue;
begin
    if (GetTickCount - FLastIncrSearchTime) >= ComboSearchTimeOut then
        ResetComboSearchValue;
end;

procedure TtsBaseGrid.ScrollRect(Left, Top, Right, Bottom: Integer; Delta: Integer; Horz: Boolean);
var
    ScrollArea: TRect;
    ScrollFlags: Integer;
begin
    ScrollFlags := SW_INVALIDATE;
    ScrollArea := Rect(Left, Top, Right, Bottom);
    if Horz then ScrollWindowEx(Handle, Delta, 0, @ScrollArea, @ScrollArea, 0, nil, ScrollFlags)
            else ScrollWindowEx(Handle, 0, Delta, @ScrollArea, @ScrollArea, 0, nil, ScrollFlags);
end;

function TtsBaseGrid.GetScrollHeight(Delta: Integer) : Integer;
var
    Height: Integer;
    ARow: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    ARow := TopRow - 1;
    Height := FVertFixedHeight + Abs(Delta);

    while ARow < RowCount - 1 do
    begin
        Inc(ARow);
        if Height + RowHeights[ARow] > ClientHeight then Break;
        Height := Height + RowHeights[ARow];
    end;

    Result := Height;
end;

function TtsBaseGrid.GetScrollWidth(Delta: Integer) : Integer;
var
    Width: Integer;
    ACol: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    ACol := LeftCol - 1;
    Width := FHorzFixedWidth + Abs(Delta);

    while ACol < ColCount - 1 do
    begin
        Inc(ACol);
        if Width + ColWidths[ACol] > ClientWidth then Break;
        Width := Width + ColWidths[ACol];
    end;

    Result := Width;
end;

procedure TtsBaseGrid.ScrollLeft(Delta: Integer);
var
    Right: Integer;
    InvalidRect: TRect;
begin
    if (ClientWidth - FHorzFixedWidth) / 5 > ClientWidth - FHorzFixedWidth - Abs(Delta) then
    begin
        InvalidRect := Rect(FHorzFixedWidth, 0, ClientWidth, ClientHeight);
        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end
    else
    begin
        Right := GetScrollWidth(Delta);
        if Right > ClientWidth then Right := ClientWidth;

        if FFocusLineOnHorzFixed then
        begin
            InvalidRect := Rect(FHorzFixedWidth - 1, 0, FHorzFixedWidth, ClientHeight);
            Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;

        ScrollRect(FHorzFixedWidth, 0, Right, ClientHeight, Delta, True);

        InvalidRect := Rect(Right + Delta, 0, ClientWidth, ClientHeight);
        ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.ScrollRight(Delta: Integer);
var
    InvalidRect: TRect;
begin
    if (ClientWidth - FHorzFixedWidth) / 5 > ClientWidth - FHorzFixedWidth - Abs(Delta) then
    begin
        InvalidRect := Rect(FHorzFixedWidth, 0, ClientWidth, ClientHeight);
        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end
    else
    begin
        ScrollRect(FHorzFixedWidth, 0, ClientWidth, ClientHeight, Delta, True);

        InvalidRect := Rect(FHorzFixedWidth - 1, 0, FHorzFixedWidth + Delta, ClientHeight);
        Windows.ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.ScrollControlHorizontal(Delta: Integer);
var
    InvalidRect: TRect;
begin
    if Delta < 0 then
    begin
        with FGridControlRect do
        begin
            ScrollRect(FHorzFixedWidth, 0, Left - tsRangeSelectWidth, ClientHeight, Delta, True);

            InvalidRect := Rect(Left - tsRangeSelectWidth + Delta, 0, ClientWidth, ClientHeight);
            ValidateRect(Self.Handle, @InvalidRect);
            Update;

            Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;
    end
    else if Delta > 0 then
    begin
        with FGridControlRect do
        begin
            ScrollRect(Right, 0, ClientWidth, ClientHeight, Delta, True);

            InvalidRect := Rect(FHorzFixedWidth, 0, Right + Delta, ClientHeight);
            ValidateRect(Self.Handle, @InvalidRect);
            Update;

            Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;
    end;
end;

function TtsBaseGrid.GetMaxScrollHeight: Integer;
begin
    Result := CellRect(0, MaxVisibleRow).Bottom + FHorzLineWidth;
    if Result > ClientHeight then Result := ClientHeight;
end;

procedure TtsBaseGrid.ScrollUp(Delta: Integer);
var
    Bottom: Integer;
    InvalidRect: TRect;
begin
    if (ClientHeight - FVertFixedHeight) / 5 > ClientHeight - FVertFixedHeight - Abs(Delta) then
    begin
        InvalidRect := Rect(0, FVertFixedHeight, ClientWidth, ClientHeight);
        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end
    else
    begin
        Bottom := GetScrollHeight(Delta);
        if Bottom > ClientHeight then Bottom := ClientHeight;

        if FFocusLineOnVertFixed then
        begin
            InvalidRect := Rect( 0, FVertFixedHeight - 1, ClientWidth, FVertFixedHeight );
            Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;

        ScrollRect(0, FVertFixedHeight, ClientWidth, Bottom, Delta, False);
        InvalidRect := Rect(0, Bottom + Delta, ClientWidth, ClientHeight);
        Windows.ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.ScrollDown(Delta: Integer);
var
    InvalidRect: TRect;
    MaxScrollHeight: Integer;
begin
    if (ClientHeight - FVertFixedHeight) / 5 > ClientHeight - FVertFixedHeight - Abs(Delta) then
    begin
        InvalidRect := Rect(0, FVertFixedHeight, ClientWidth, ClientHeight);
        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end
    else
    begin
        MaxScrollHeight := GetMaxScrollHeight;
        ScrollRect(0, FVertFixedHeight, ClientWidth, MaxScrollHeight, Delta, False);

        InvalidRect := Rect(0, FVertFixedHeight - 1, ClientWidth, FVertFixedHeight + Delta);
        Windows.ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
    end;
end;

procedure TtsBaseGrid.ScrollControlVertical(Delta: Integer);
var
    InvalidRect: TRect;
    MaxScrollHeight: Integer;
begin
    if Delta < 0 then
    begin
        with FGridControlRect do
        begin
            if Bottom + Delta <= FVertFixedHeight then
            begin
                ScrollUp(Delta);
                Update;
                Exit;
            end;

            ScrollRect(0, FVertFixedHeight, ClientWidth, Top, Delta, False);

            InvalidRect := Rect(0, Top + Delta, ClientWidth, ClientHeight);
            ValidateRect(Self.Handle, @InvalidRect);
            Update;

            Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;
    end
    else if Delta > 0 then
    begin
        with FGridControlRect do
        begin
            if Top + Delta >= ClientHeight then
            begin
                ScrollDown(Delta);
                Update;
                Exit;
            end;

            MaxScrollHeight := GetMaxScrollHeight;
            ScrollRect(0, Bottom, ClientWidth, MaxScrollHeight, Delta, False);

            InvalidRect := Rect(0, FVertFixedHeight, ClientWidth, Bottom + Delta);
            ValidateRect(Self.Handle, @InvalidRect);

            InvalidateRect(Self.Handle, @InvalidRect, False);
            Update;
        end;
    end;
end;

procedure TtsBaseGrid.ScrollWindow(DX, DY: Integer; var DrawInfo: TGridDrawInfo);
begin
    if (DX = 0) and (DY < 0) then
        ScrollUp(DY)
    else if (DX = 0) and (DY > 0) then
        ScrollDown(DY)
    else if (DX < 0) and (DY = 0) then
        ScrollLeft(DX)
    else if (DX > 0) and (DY = 0) then
        ScrollRight(DX)
    else
        inherited ScrollDataInfo(DX, DY, DrawInfo);
end;

procedure TtsBaseGrid.ScrollRowSelect(Delta: Integer);
var
    Top, Bottom: Integer;
    InvalidRect: TRect;
    MaxScrollHeight: Integer;
begin
    if Delta < 0 then
    begin
        Top := FRowSelectRect.Top;
        ScrollRect(0, FVertFixedHeight, ClientWidth, Top, Delta, False);

        InvalidRect := Rect(0, Top + Delta, ClientWidth, ClientHeight);
        ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
        Update;
    end
    else if Delta > 0 then
    begin
        Bottom := FRowSelectRect.Bottom + FHorzLineWidth;
        Bottom := CalcMax(Bottom, FVertFixedHeight);

        MaxScrollHeight := GetMaxScrollHeight;
        ScrollRect(0, Bottom, ClientWidth, MaxScrollHeight, Delta, False);

        InvalidRect := Rect(0, FVertFixedHeight, ClientWidth, Bottom + Delta);
        ValidateRect(Self.Handle, @InvalidRect);
        Update;

        Windows.InvalidateRect(Self.Handle, @InvalidRect, False);
        Update;
    end;
end;

procedure TtsBaseGrid.ScrollControl(DX, DY: Integer; var DrawInfo: TGridDrawInfo);
begin
    if DY = 0 then
        ScrollControlHorizontal(DX)
    else if DX = 0 then
    begin
        if EqualRect(FGridControlRect, FNullRect)
            then ScrollRowSelect(DY)
            else ScrollControlVertical(DY);
    end
    else
        inherited ScrollDataInfo(DX, DY, DrawInfo);
end;

procedure TtsBaseGrid.ScrollDataInfo(DX, DY: Integer; var DrawInfo: TGridDrawInfo);
begin
    if not CanPaint then
    begin
        Invalidate;
        Exit;
    end;

    case FScrollMode of
        smWindow:      ScrollWindow(DX, DY, DrawInfo);
        smGridControl: ScrollControl(DX, DY, DrawInfo);
        smRowSelect:   ScrollRowSelect(DY);
    end;
end;

procedure TtsBaseGrid.TopLeftMoved(const OldTopLeft: TGridCoord);
begin
    if FastAssign then
    begin
        Include(FFastAssignActions, gacTopLeftChanged);
        Exit;
    end;
    if HandleAllocated then inherited;
end;

procedure TtsBaseGrid.SetControlRect(DisplayCol, DisplayRow: Longint);
begin
    FGridControlRect := BoxRect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);
    if not EqualRect(FGridControlRect, FNullRect) then
    begin
        Inc(FGridControlRect.Left, tsRangeSelectWidth);
        if CheckCellFocusRect(DisplayCol, DisplayRow, True) and (FocusBorder in [fbDouble, fbSingle]) then
        begin
            Dec(FGridControlRect.Left);
            Dec(FGridControlRect.Top);
        end;
    end;
end;

procedure TtsBaseGrid.SetRowSelectRect(DisplayRow: Longint);
begin
    FRowSelectRect := CellRect(0, DisplayRow);
end;

procedure TtsBaseGrid.SetScrollMode(Mode: TtsScrollMode);
begin
    FScrollMode := Mode;
    SetControlRect(FPrevDisplayCol, FPrevDisplayRow);
    SetRowSelectRect(FPrevDisplayRow);
end;

procedure TtsBaseGrid.ResetScrollMode;
begin
    FScrollMode := smWindow;
end;

procedure TtsBaseGrid.ScrollGrid(NewLeft, NewTop: Longint; ScrollMode: TtsScrollMode);
begin
    SetScrollMode(ScrollMode);
    try
        if (LeftCol <> NewLeft) and (NewTop <> TopRow) then
            MoveTopLeft(NewLeft, NewTop)
        else if LeftCol <> NewLeft then
            LeftCol := NewLeft
        else if TopRow <> NewTop then
            TopRow := NewTop;

    finally
        ResetScrollMode;
    end;
end;

function TtsBaseGrid.WaitingTime(X, Y: Integer; Direction: Integer): Integer;
var
    Horz, Vert: Integer;
    Point, TopLeft: TPoint;
    UsedScrollWidth: Integer;
    TempResult: Integer;
    MaxScrollHeight: Integer;
begin
    Horz := 0;
    Vert := 0;
    UsedScrollWidth := DefaultScrollRange;

    Point.X := X;
    Point.Y := Y;

    X := ScreenToClient(Point).X;
    Y := ScreenToClient(Point).Y;

    TopLeft.X := FHorzFixedWidth;
    TopLeft.Y := FVertFixedHeight;

    if Direction in [0, 2] then
    begin
        if X >= ClientWidth then
        begin
            Horz := X - ClientWidth;
            UsedScrollWidth := CalcMin(UsedScrollWidth, Screen.Width - Point.X);
        end
        else if X <= TopLeft.X then
        begin
            Horz := TopLeft.X - X;
            UsedScrollWidth := CalcMin(UsedScrollWidth, ClientToScreen(TopLeft).X);
        end;
    end;

    if Direction in [1, 2] then
    begin
        MaxScrollHeight := GetMaxScrollHeight;
        if Y >= MaxScrollHeight then
        begin
            Vert := Y - MaxScrollHeight;
            UsedScrollWidth := CalcMin(UsedScrollWidth, Screen.Height - Point.Y);
        end
        else if Y <= TopLeft.Y then
        begin
            Vert := TopLeft.Y - Y;
            UsedScrollWidth := CalcMin(UsedScrollWidth, ClientToScreen(TopLeft).Y);
        end;
    end;

    if Direction = 2 then
        Horz := CalcMax(Horz, Vert)
    else if Direction = 1 then
        Horz := Vert;

    TempResult := (Abs(FMaxWaitingTime - FMinWaitingTime) * CalcMin(Horz, UsedScrollWidth)) div
                    UsedScrollWidth;

    if TempResult < FMaxWaitingTime div 2 then
        Result := FMaxWaitingTime
    else
        Result := FMinWaitingTime;
end;

function TtsBaseGrid.ScrollDelay(X, Y: Integer; Direction: Integer): Boolean;
var
    Msg: TMsg;
    Wait: Cardinal;
begin
    if (FScrollSpeed = spHigh) and (FMinWaitingTime = 0) then
        Result := True
    else
    begin
        Result := False;

        if FScrollSpeed = spHigh then
            Wait := FMinWaitingTime
        else if FScrollSpeed = spLow then
            Wait := FMaxWaitingTime
        else
            Wait := WaitingTime(X, Y, Direction);

        if FScrollDelayStart = 0 then FScrollDelayStart := GetTickCount;

        while ((GetTickCount - FScrollDelayStart) < Wait) do
        begin
            if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Exit;
            if CheckEscape then Exit;
        end;

        FScrollDelayStart := 0;
        Result := True;
    end;
end;

function TtsBaseGrid.CheckEscape: Boolean;
var
    Msg: TMsg;
begin
    Result := False;
    if PeekMessage(Msg, Handle, WM_KEYDOWN, WM_KEYDOWN, PM_NoRemove) then
    begin
        if Msg.wParam = VK_ESCAPE then Result := True;
    end;
end;

function TtsBaseGrid.NextSizingCol(DisplayCol: Longint): Longint;
var
    NewCol: Longint;
begin
    if DisplayCol < FixedCols - 1 then
    begin
        GetNextCol(DisplayCol, False, False, NewCol);
        if NewCol <= FixedCols - 1 then
        begin
            Result := NewCol;
            Exit;
        end;
    end;

    if DisplayCol <= FixedCols - 1 then DisplayCol := LeftCol - 1;
    GetNextCol(DisplayCol, False, False, NewCol);
    Result := NewCol;
end;

procedure TtsBaseGrid.CalcColSizingState(X, Y: Integer; var State: TtsMouseStatus);
var
    I, Range, Back, Line: Integer;
begin
    if FResizeCols = rcNone then Exit;

    Range := ResizeRange;
    Back := ResizeRange div 2;

    if RowBarOn then I := 0
                else I := NextSizingCol(0);

    Line := ColWidths[I] - 1;
    while (X < Line - Range + Back) or (X > Line - Back + Range - 1) do
    begin
        I := NextSizingCol(I);
        if I >= ColCount then Break;

        Inc(Line, ColWidths[I]);
        if (Line - Range + Back) >= ClientWidth then Break;
    end;

    if (I < ColCount) and ((Line - Range + Back) < ClientWidth) then
    begin
        FSizingIndex := I;
        FSizingPos := Line;
        FSizingOfs := Line - X;

        State := msColResize;
        if FSizingIndex = 0 then State := msRowBarResize;
    end;
end;

function TtsBaseGrid.NextSizingRow(DisplayRow: Longint): Longint;
var
    NewRow: Longint;
begin
    if DisplayRow < FixedRows - 1 then
    begin
        GetNextRow(DisplayRow, False, False, NewRow);
        if NewRow <= FixedRows - 1 then
        begin
            Result := NewRow;
            Exit;
        end;
    end;

    if DisplayRow <= FixedRows - 1 then DisplayRow := TopRow - 1;
    GetNextRow(DisplayRow, False, False, NewRow);
    Result := NewRow;
end;

procedure TtsBaseGrid.CalcRowSizingState(X, Y: Integer; var State: TtsMouseStatus);
var
    I: Longint;
    Range, Back, Line: Integer;
begin
    if FResizeRows = rrNone then Exit;

    Range := ResizeRange;
    Back := ResizeRange div 2;

    if HeadingOn then I := 0
                 else I := NextSizingRow(0);

    Line := RowHeights[I] - 1;
    while (Y < Line - Range + Back) or (Y > Line - Back + Range) do
    begin
        I := NextSizingRow(I);
        if I >= RowCount then Break;

        Inc(Line, RowHeights[I]);
        if (Line - Range + Back) >= ClientHeight then Break;
    end;

    if (I < RowCount) and ((Line - Range + Back) < ClientHeight) then
    begin
        FSizingIndex := I;
        FSizingPos := Line;
        FSizingOfs := Line - Y;
        State := msRowResize;
        if I = 0 then State := msHeadingResize;
    end;
end;

function TtsBaseGrid.GetSizingState(X, Y: Integer; DisplayCol, DisplayRow: Longint): TtsMouseStatus;
begin
    Result := msNormal;
    if ((DisplayCol = 0) or ResizeRowsInGrid) and
       ((DisplayRow > 0) or ((DisplayRow = 0) and (Y >= HeadingSizingArea.Top))) then
        CalcRowSizingState(X, Y, Result);

    if (Result = msNormal) and ((DisplayRow = 0) or ResizeColsInGrid) and
       ((DisplayCol > 0) or ((DisplayCol = 0) and (X >= RowBarSizingArea.Left))) then
        CalcColSizingState(X, Y, Result);
end;

procedure TtsBaseGrid.MouseDownResize;
begin
    if FMouseStatus in [msColResize, msRowBarResize, msRowResize, msHeadingResize] then
    begin
        Update;
        DrawSizingLine;
    end;
end;

procedure TtsBaseGrid.DrawSizingLine;
var
    OldPen: TPen;
    Rect: TRect;
begin
    OldPen := TPen.Create;
    try
        with Canvas do
        begin
            OldPen.Assign(Pen);
            Pen.Style := psDot;
            Pen.Mode := pmXor;
            Pen.Width := 1;
            Pen.Color := clBlack;
            Brush.Color := Color;
            try
                if FMouseStatus in [msRowResize, msHeadingResize] then
                begin
                    MoveTo(0, FSizingPos);
                    if LeftCol + VisibleColCount >= ColCount then
                    begin
                        Rect := CellRect(ColCount - 1, TopRow);
                        if EqualRect(Rect, FNullRect) then
                            Rect := CellRect(ColCount - 1, MaxVisibleRow);
                        LineTo(Rect.Right + FVertLineWidth, FSizingPos);
                    end
                    else LineTo(ClientWidth, FSizingPos);
                end
                else if FMouseStatus in [msColResize, msRowBarResize] then
                begin
                    MoveTo(FSizingPos, 0);
                    if TopRow + VisibleRowCount >= RowCount then
                    begin
                        Rect := CellRect(LeftCol, RowCount - 1);
                        if EqualRect(Rect, FNullRect) then
                            Rect := CellRect(MaxVisibleCol, RowCount - 1);
                        LineTo(FSizingPos, Rect.Bottom + FHorzLineWidth);
                    end
                    else LineTo(FSizingPos, ClientHeight);
                end;
            finally
                Pen.Assign(OldPen);
            end;
        end;
    finally
        OldPen.Free;
    end;
end;

procedure TtsBaseGrid.CalcHorzFixedWidth;
var
    I, Sum: Integer;
begin
    Sum := 0;
    for I := 0 to (FixedCols - 1) do Inc(Sum, ColWidths[I]);
    FHorzFixedWidth := Sum;
end;

procedure TtsBaseGrid.SetFixedColCount(Value: Integer);
begin
    if (Value < 0) then Exit;
    FFixedColCount := Value;
    InternalFixedCols := Value;
end;

procedure TtsBaseGrid.SetInternalFixedCols(Value: Integer);
var
    Show: Boolean;
    NewFixedCols: Integer;
begin
    if (Value < 0) then Exit;

    NewFixedCols := 0;
    if ColCount > 0 then NewFixedCols := CalcMin(ColCount - 1, Value + 1);

    if FInternalFixedCols <> CalcMax(0, NewFixedCols - 1) then
    begin
        Show := CheckHideControl(False);

        try
            FixedCols := NewFixedCols;
        finally
            FInternalFixedCols := CalcMax(0, FixedCols - 1);
        end;

        MoveTopLeft(LeftCol, TopRow);
        CalcHorzFixedWidth;

        if Show then ShowGridControl;
        UpdateScrollRange;
        CheckTopLeftChanged(False);
    end;
end;

procedure TtsBaseGrid.CalcVertFixedHeight;
var
    I, Sum: Integer;
begin
    Sum := 0;
    for I := 0 to (FixedRows - 1) do Inc(Sum, RowHeights[I]);
    FVertFixedHeight := Sum;
end;

procedure TtsBaseGrid.SetFixedRowCount(Value: Integer);
begin
    if (Value < 0) then Exit;
    FFixedRowCount := Value;
    InternalFixedRows := Value;
end;

procedure TtsBaseGrid.SetInternalFixedRows(Value: Integer);
var
    NewFixedRows: Integer;
begin
    if (Value < 0) then Exit;

    NewFixedRows := 0;
    if RowCount > 0 then NewFixedRows := CalcMin(RowCount - 1, Value + 1);

    if FInternalFixedRows <> CalcMax(0, NewFixedRows - 1) then
    begin
        HideGridControl(False);

        try
            FixedRows := NewFixedRows;
        finally
            FInternalFixedRows := CalcMax(0, FixedRows - 1);
        end;

        MoveTopLeft(LeftCol, TopRow);
        CalcVertFixedHeight;

        ShowGridControl;
        UpdateScrollRange;
        CheckTopLeftChanged(False);
    end;
end;

procedure TtsBaseGrid.SetFixedLineColor(Value: TColor);
begin
    if FFixedLineColor <> Value then
    begin
        FFixedLineColor := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetHeadingColor(Value: TColor);
begin
    if FHeadingColor <> Value then
    begin
        FHeadingColor := Value;
        Invalidate;
    end;
end;

function TtsBaseGrid.GetRowBarOn: Boolean;
begin
    Result := GridCols[0].Visible;
end;

procedure TtsBaseGrid.SetRowBarOn(Value: Boolean);
begin
    if GridCols[0].Visible <> Value then
    begin
        GridCols[0].Visible := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

function TtsBaseGrid.GetHeadingOn: Boolean;
begin
    Result := GridRows[0].Visible;
end;

procedure TtsBaseGrid.SetHeadingOn(Value: Boolean);
begin
    if GridRows[0].Visible <> Value then
    begin
        GridRows[0].Visible := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

function TtsBaseGrid.GetRowBarWidth: Integer;
begin
    Result := GridCols[0].Width;
end;

procedure TtsBaseGrid.SetRowBarWidth(Value: Integer);
begin
    if GridCols[0].Width <> Value then
    begin
        GridCols[0].Width := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

function TtsBaseGrid.GetHeadingHeight: Integer;
begin
    Result := GridRows[0].Height;
end;

procedure TtsBaseGrid.SetHeadingHeight(Value: Integer);
begin
    if GridRows[0].Height <> Value then
    begin
        GridRows[0].Height := Value;
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    end;
end;

procedure TtsBaseGrid.CheckFixedCols;
begin
    if (FixedCols = 0) and (ColCount > 1) then
    begin
        FixedCols := 1;
        if RowBarOn then ResizeCol(0, RowBarWidth);
        CalcHorzFixedWidth;
    end;

    if FixedColCount <> FixedCols - 1 then
        InternalFixedCols := FixedColCount;
end;

procedure TtsBaseGrid.SetNewColCount(Value: Longint);
var
    OldColCount: Longint;
    OldColWidth: Integer;
    OldMaxVisibleCol: Longint;
    ARect: TRect;
begin
    EnablePaint := False;
    try
        OldColCount := ColCount;
        OldColWidth := ColWidths[OldColCount - 1];
        OldMaxVisibleCol := MaxVisibleCol;

        FCurDeletedCols := 0;
        FCols := Value;
        ColCount := Value + 1;
        ResizeVisibleCols(OldColCount - 1);

        //Delphi bug workaround
        if OldColCount < ColCount then
        begin
            if OldColCount <= 1 then
                ResizeCol(OldColCount - 1, OldColWidth)
            else if Col[GetDataCol(OldColCount - 1)].Visible then
                ResizeCol(OldColCount - 1, Col[GetDataCol(OldColCount - 1)].Width)
            else
                ResizeCol(OldColCount - 1, 0)
        end;
        //End of Delphi bug workaround

        //Delphi 3 bug workaround
        if HandleAllocated then
        begin
            if (OldMaxVisibleCol <> MaxVisibleCol) then
            begin
                if MaxVisibleCol > OldMaxVisibleCol then
                    InvalidateCol(MaxVisibleCol)
                else
                begin
                    ARect := CellRect(MaxVisibleCol, 0);
                    ARect.Left := ARect.Right + 1;
                    ARect.Right := ClientWidth;
                    ARect.Bottom := ClientHeight;
                    Windows.InvalidateRect(Handle, @ARect, False);
                end;
            end
            else if not (CurrentPosInView and InGridMode) or (csDesigning in ComponentState) then
                InvalidateCol(MaxVisibleCol);
        end;
        //End of Delphi 3 bug workaround

        CheckFixedCols;
        CheckTopLeftChanged(False);
        UpdateScrollRange;
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.GetGridColCount: Longint;
begin
    Result := FCols - FCurDeletedCols;
end;

procedure TtsBaseGrid.SetGridColCount(Value: Longint);
var
    I: Integer;
    OldCount: Longint;
    OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    SetNewCell: Boolean;
begin
    if FCurDeletedCols > 0 then Exit;
    if Value < 0 then Value := 0;
    if (csLoading in ComponentState) and (FColMatch = cmaFieldName) then Exit;

    if FCols <> Value then
    begin
        SetNewCell := False;
        OldCount := Cols;
        OldDataRow := GetDataRow(FCurDisplayRow);
        OldDataCol := GetDataCol(FCurDisplayCol);
        CellDeleted := (OldDataCol > Value);
        if CellDeleted then if not CheckEndEdit(0, OldDataRow, False) then Exit;

        HideGridControl(False);
        if (Value < FCols) and (not FInStartingMode) then
        begin
            for I := (ColCount - 1) downto (Value + 1) do DeleteAllAtCol(I, I);
            SetNewCell := True;
        end;

        EnablePaint := False;
        try
            SetNewColCount(Value);
            DeleteColData(Value + 1, OldCount);
            CheckTopLeft(True);
            if SetNewCell then
            begin
                if CellDeleted then
                    MoveToNewCol(FCurDisplayCol, False, CanSkipReadOnly, False)
                else
                    SetNewCurrentCell(OldDataCol, OldDataRow);
            end
            else if FCurDisplayCol < 1 then
                MoveToNewCol(0, False, CanSkipReadOnly, False);

            AdjustComboGridExtents(DropDownCols, DropDownRows);
        finally
            EnablePaint := True;
        end;

        ShowGridControl;
        CheckRowSelection(True);
        SelectionsChanged(False);
        GridStatusChanged;
    end;
end;

procedure TtsBaseGrid.CheckFixedRows;
begin
    if (FixedRows = 0) and (RowCount > 1) then
    begin
        FixedRows := 1;
        if HeadingOn then ResizeRow(0, HeadingHeight);
        CalcVertFixedHeight;
    end;

    if FixedRowCount <> FixedRows - 1 then
        InternalFixedRows := FixedRowCount;
end;

procedure TtsBaseGrid.SetNewRowCount(Value: Longint);
var
    OldRowCount: Longint;
    OldRowHeight: Integer;
    OldMaxVisibleRow: Longint;
    NewMaxVisibleRow: Longint;
    ARect: TRect;
begin
    EnablePaint := False;
    try
        OldRowCount := RowCount;
        OldRowHeight := RowHeights[OldRowCount - 1];
        OldMaxVisibleRow := MaxVisibleRow;
        if (OldMaxVisibleRow = RowCount - 1) and (InsertionRow > 0) then
            Dec(OldMaxVisibleRow, InsertionRow);

        FCurDeletedRows := 0;
        FRows := Value;
        RowCount := Value + FInsertionRow + 1;
        ResizeVisibleRows(OldRowCount - 1);

        //Delphi bug workaround
        if OldRowCount < RowCount then
        begin
            if OldRowCount <= 1 then
                ResizeRow(OldRowCount - 1, OldRowHeight)
            else if RowVisible[GetDataRow(OldRowCount - 1)] then
                ResizeRow(OldRowCount - 1, RowHeight[GetDataRow(OldRowCount - 1)])
            else
                ResizeRow(OldRowCount - 1, 0)
        end;
        //End of Delphi bug workaround

        //Delphi 3 bug workaround
        NewMaxVisibleRow := MaxVisibleRow;
        if (NewMaxVisibleRow = RowCount - 1) and (InsertionRow > 0) then
            Dec(NewMaxVisibleRow, InsertionRow);

        if HandleAllocated then
        begin
            if (OldMaxVisibleRow <> NewMaxVisibleRow) then
            begin
                if NewMaxVisibleRow > OldMaxVisibleRow then
                begin
                    ARect := CellRect(0, OldMaxVisibleRow);
                    ARect.Top := ARect.Bottom + 1;
                    ARect.Bottom := ClientHeight;
                    ARect.Right := ClientWidth;
                    Windows.InvalidateRect(Handle, @ARect, False);
                end
                else
                begin
                    ARect := CellRect(0, NewMaxVisibleRow);
                    ARect.Top := ARect.Bottom + 1;
                    ARect.Bottom := ClientHeight;
                    ARect.Right := ClientWidth;
                    Windows.InvalidateRect(Handle, @ARect, False);
                end;
            end
            else if not (CurrentPosInView and InGridMode) or (csDesigning in ComponentState) then
                InvalidateRow(MaxVisibleRow);
        end;
        //End of Delphi 3 bug workaround

        CheckFixedRows;
        CheckTopLeftChanged(False);
        UpdateScrollRange;
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.GetGridRowCount: Longint;
begin
    Result := FRows - FCurDeletedRows;
end;

procedure TtsBaseGrid.SetGridRowCount(Value: Longint);
var
    I: Integer;
    OldCount: Longint;
    OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    SetNewCell: Boolean;
    InInsertRow: Boolean;
    OldRowCount: Longint;
begin
    if FCurDeletedRows > 0 then Exit;
    if Value < 0 then Value := 0;

    if Rows <> Value then
    begin
        OldRowCount := Rows;
        SetNewCell := False;
        OldCount := Rows;
        OldDataRow := GetDataRow(FCurDisplayRow);
        OldDataCol := GetDataCol(FCurDisplayCol);
        InInsertRow := IsInsertRow(FCurDisplayRow);
        CellDeleted := (OldDataRow > Value);
        if CellDeleted and not InUndoEdit then if not CheckEndEdit(OldDataCol, -1, False) then Exit;

        HideGridControl(False);
        if (Value < Rows) then
        begin
            for I := (RowCount - 1 - InsertionRow) downto (Value + 1) do
                DeleteAllAtRow(I, I + InsertionRow);
            SetNewCell := True;
        end;

        if (GridMode = gmEditInsert) then SetInsertionRow(1);
        FInsertRowEdit := False;

        EnablePaint := False;
        try
            SetNewRowCount(Value);
            DeleteRowData(Value + 1, OldCOunt);
            CheckTopLeft(True);
            if SetNewCell then
            begin
                if InInsertRow then
                begin
                    if OldDataRow = RowCount - 1 then InvalidateRow(OldDataRow);
                    OldDataRow := RowCount - 1;
                end;

                if CellDeleted then
                    MoveToNewRow(FCurDisplayRow, False, CanSkipReadOnly, InRowSelectMode)
                else
                    SetNewCurrentCell(OldDataCol, OldDataRow);
            end
            else
            begin
                if OldRowCount = 0 then MoveToNewRow(0, False, CanSkipReadOnly, InRowSelectMode);
                if InInsertRow then
                begin
                    SetControlSelectMode(tsAll);
                    ClearControlBuffer;
                end;
            end;

            AdjustComboGridExtents(DropDownCols, DropDownRows);
        finally
            EnablePaint := True;
        end;

        ShowGridControl;
        CheckRowSelection(True);
        SelectionsChanged(False);
        GridStatusChanged;
    end;
end;

procedure TtsBaseGrid.InsertRow(DisplayRow: Longint);
var
    OldRowCount: Longint;
begin
    if not CheckIndex(itRow, DisplayRow, 1, Rows + 1) then Exit;

    EnablePaint := False;
    try
        OldRowCount := Rows;
        Rows := Rows + 1;
        if OldRowCount <> Rows then
        begin
            DisplayRownr[Rows] := DisplayRow;
            UpdateScrollRange;
            RowInserted(Rows, False);
        end;
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.AddColumn(DisplayCol: Longint): Boolean;
var
    OldColCount: Longint;
begin
    Result := False;
    if (DisplayCol < 1) or (DisplayCol > Cols + 1) then Exit;

    OldColCount := Cols;
    Cols := Cols + 1;
    if OldColCount <> Cols then
    begin
        Result := True;
        GridCols[Cols].DisplayCol := DisplayCol;
        UpdateScrollRange;
    end;
end;

function  TtsBaseGrid.GetCellPropSet: TtsCellPropSet;
begin
    Result := FCellPropSet;
end;

procedure TtsBaseGrid.InsertCol(DisplayCol: Longint);
begin
    if not CheckIndex(itCol, DisplayCol, 1, Cols + 1) then Exit;

    EnablePaint := False;
    try
        if AddColumn(DisplayCol) then DoInsertCol(Cols, False);
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.AddToPropList(Cell: TtsCellElement);
begin
    if FColCells[Cell.FDataCol] = nil then
        FColCells[Cell.FDataCol] := TtsIntegerSet.Create;
    FColCells[Cell.FDataCol].Add(Cell.FDataRow);

    if FRowCells[Cell.FDataRow] = nil then
        FRowCells[Cell.FDataRow] := TtsIntegerSet.Create;
    FRowCells[Cell.FDataRow].Add(Cell.FDataCol);
end;

procedure TtsBaseGrid.DeleteFromPropList(Cell: TtsCellElement);
begin
    if FColCells[Cell.FDataCol] <> nil then
    begin
        FColCells[Cell.FDataCol].Remove(Cell.FDataRow);
        if FColCells[Cell.FDataCol].Count = 0 then
        begin
            FColCells[Cell.FDataCol].Free;
            FColCells[Cell.FDataCol] := nil;
        end;
    end;

    if FRowCells[Cell.FDataRow] <> nil then
    begin
        FRowCells[Cell.FDataRow].Remove(Cell.FDataCol);
        if FRowCells[Cell.FDataRow].Count = 0 then
        begin
            FRowCells[Cell.FDataRow].Free;
            FRowCells[Cell.FDataRow] := nil;
        end;
    end;
end;

procedure TtsBaseGrid.SetLineColor(Value: TColor);
begin
    if FLineColor <> Value then
    begin
        FLineColor := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetInsertRowOn;
begin
    if (GridMode = gmEditInsert) and (InsertionRow = 0) then
    begin
        SetInsertionRow(1);
        SetNewRowCount(Rows);
    end;
end;

procedure TtsBaseGrid.SetInsertRowOff;
begin
    if (GridMode = gmEditInsert) and (InsertionRow = 1) then
    begin
        SetInsertionRow(0);
        FRows := FRows + 1;
        CheckRowCountChanged(Rows - 1, Rows);
        RowInserted(Rows, True);
    end;
end;

function TtsBaseGrid.GridModeToEditMode(Value: TtsGridMode): TtsEditMode;
begin
    Result := emNone;
    case Value of
        gmEdit: Result := emEdit;
        gmEditInsert: Result := emEditInsert;
        gmBrowse: Result := emBrowse;
        gmListBox: Result := emNone;
    end;
end;

function TtsBaseGrid.EditModeToGridMode(Value: TtsEditMode): TtsGridMode;
begin
    Result := gmEdit;
    case Value of
        emEdit: Result := gmEdit;
        emEditInsert: Result := gmEditInsert;
        emBrowse: Result := gmBrowse;
        emNone: Result := gmListBox;
    end;
end;

function TtsBaseGrid.EditModeStrValue(Value: string): TtsEditMode;
begin
    Value := LowerCase(Value);
    if Value = 'emnone' then
        Result := emNone
    else if Value = 'emeditinsert' then
        Result := emEditInsert
    else if Value = 'embrowse' then
        Result := emBrowse
    else
        Result := emEdit;
end;

procedure TtsBaseGrid.SetEditMode(Value: TtsEditMode);
begin
    GridMode := EditModeToGridMode(Value);
end;

procedure TtsBaseGrid.SetGridMode(Value: TtsGridMode);
begin
    if FAsCombo and not InDesignMode then Exit;

    if FGridMode <> Value then
    begin
        if Value = gmListBox then if not CheckEndEdit(-1, -1, False) then Exit;

        if Value = gmEditInsert then
        begin
            SetInsertionRow(1);
            SetNewRowCount(Rows);
        end
        else
        begin
            SetInsertionRow(0);
            SetNewRowCount(Rows);
        end;

        ClearCurrentFocusRect(False);
        FGridMode := Value;
        FEditMode := GridModeToEditMode(Value);

        if GridMode <> gmEditInsert then CheckTopLeft(False);

        if Value in [gmBrowse, gmListBox] then
        begin
            ClearCellBuffer;
            if CheckHideControl(True) then Update;
        end;

        if not FInStartingMode then
        begin
            MoveToNewRow(FCurDisplayRow, True, CanSkipReadOnly, InRowSelectMode);
        end;

        if (Value in [gmEdit, gmEditInsert]) then
        begin
            SetControlSelectMode(tsAll);
            ShowGridControl;
        end;

        if (csDesigning in ComponentState) and (Value <> gmListBox) then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteAllRowSelection;
        end;

        DrawCurrentFocusRect(False);
        CheckRowSelection(True);
        SelectionsChanged(False);
        GridStatusChanged;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetAlwaysShowEditor(Value: Boolean);
begin
    if FAlwaysShowEditor <> Value then
    begin
        FAlwaysShowEditor := Value;
        if not CellEditing then
        begin
            if AlwaysShowEditor then ClearCurrentFocusRect(False);
            CheckEnableControl(AlwaysShowEditor, True, tsAll);
            if not AlwaysShowEditor then
            begin
                CurrentCell.SelectAll;
                DrawCurrentFocusRect(False);
            end;
        end;
    end;
end;

procedure TtsBaseGrid.SetAlwaysShowFocus(Value: Boolean);
begin
    if FAlwaysShowFocus <> Value then
    begin
        if (not IsFocused) and AlwaysShowFocus then
            ClearCurrentFocusRect(False);
        FAlwaysShowFocus := Value;
        if Assigned(FGridControl) then FGridControl.AlwaysShowFocus := Value;
        if not IsFocused then
        begin
            RedisplayControl(True);
            if AlwaysShowFocus then DrawCurrentFocusRect(False);
        end;
    end;
end;

procedure TtsBaseGrid.SetSkipReadOnly(Value: Boolean);
begin
    if FSkipReadOnly <> Value then
    begin
        FSkipReadOnly := Value;
        MoveToNewCol(FCurDisplayCol, True, CanSkipReadOnly, False);
    end;
end;

procedure TtsBaseGrid.SetRowChangedIndicator(Value: TtsRowChangedIndicator);
begin
    if FRowChangedIndicator <> Value then
    begin
        FRowChangedIndicator := Value;
        if FRowChangedIndicator in [riOff, riAutoReset] then
            ResetRowProperties([prChanged]);
    end;
end;

procedure TtsBaseGrid.SetColSelectMode(Value: TtsColSelectMode);
begin
    if FColSelectMode <> Value then
    begin
        FColSelectMode := Value;
    end;
end;

function TtsBaseGrid.GetCurrentSelected: Boolean;
begin
    Result := IsRowSelected(GetDataRow(CurDisplayRow));
end;

function TtsBaseGrid.GetStartRowSelected: Boolean;
begin
    Result := GetCurrentSelected;
end;

procedure TtsBaseGrid.SetCurrentSelected;
begin
    AddRowSelection(CurDisplayRow, CurDisplayRow);
end;

function TtsBaseGrid.GetRowSelectMode: TtsRowSelectMode;
begin
    Result := FRowSelectMode;
end;

procedure TtsBaseGrid.SetRowSelectMode(Value: TtsRowSelectMode);
begin
    if FAsCombo and not InDesignMode then Exit;

    if RowSelectMode <> Value then
    begin
        if CheckHideControl(True) then Update;

        FRowSelectMode := Value;
        if (FGridStatus = grRowSelect) and (RowSelectMode = rsNone) then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteAllRowSelection;
        end
        else if (FGridStatus = grRowSelect) and (RowSelectMode = rsSingle) then
        begin
            if not GetCurrentSelected then
            begin
                InvertSelectedRows(1, RowCount - 1, False);
                DeleteAllRowSelection;
            end
            else
            begin
                if CurDisplayRow > 1 then
                    InvertSelectedRows(1, CurDisplayRow - 1, False);
                if CurDisplayRow < RowCount - 1 then
                    InvertSelectedRows(CurDisplayRow + 1, RowCount - 1, False);

                DeleteAllRowSelection;
                SetCurrentSelected;
            end;
        end;

        if (csDesigning in ComponentState) and (Value <> rsSingle) then
        begin
            InvertSelectedRows(1, RowCount - 1, False);
            DeleteAllRowSelection;
        end;

        ShowGridControl;
        CheckRowSelection(False);
        SelectionsChanged(False);
        GridStatusChanged;
    end;
end;

function TtsBaseGrid.GetCellSelectMode: TtsCellSelectMode;
begin
    Result := FCellSelectMode;
end;

procedure TtsBaseGrid.SetCellSelectMode(Value: TtsCellSelectMode);
begin
    if FCellSelectMode <> Value then
    begin
        FCellSelectMode := Value;
    end;
end;

procedure TtsBaseGrid.SetGridLines(Value: TtsGridLines);
begin
    if FGridLines <> Value then
    begin
        if Value in [glHorzLines, glBoth] then FHorzLineWidth := 1
                                          else FHorzLineWidth := 0;
        if Value in [glVertLines, glBoth] then FVertLineWidth := 1
                                          else FVertLineWidth := 0;
        FGridLines := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetThumbTracking(Value: Boolean);
begin
    if Value <> FThumbTracking then
    begin
        FThumbTracking := Value;
        if FThumbTracking then Options := Options + [goThumbTracking]
                          else Options := Options - [goThumbTracking];
    end;
end;

procedure TtsBaseGrid.SetIs3D(Value: Boolean);
begin
    if Value <> FIs3D then
    begin
        FIs3D := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetEditColor(Value: TColor);
begin
    if FEditColor <> Value then
    begin
        FEditColor := Value;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetEditFontColor(Value: TColor);
begin
    if FEditFontColor <> Value then
    begin
        FEditFontColor := Value;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetHeading3D(Value: Boolean);
begin
    if Value <> FHeading3D then
    begin
        FHeading3D := Value;
        InvalidateRow(0);
        Update;
        InvalidateCol(0);
        Update;
    end;
end;

procedure TtsBaseGrid.SetSelectFixed(Value: Boolean);
begin
    if FSelectFixed <> Value then
    begin
        FSelectFixed := Value;
        if not FSelectFixed then
        begin
            if FInternalFixedRows > 0 then
            begin
                InvertSelectedRows(1, FInternalFixedRows, False);
                DeleteRowSelection(1, FInternalFixedRows);
            end;

            if (FCurDisplayRow <= FInternalFixedRows) and InRowSelectMode then
            begin
                MoveToNewRow(FCurDisplayRow, True, False, True);
            end;
        end;

        CheckRowSelection(False);
        SelectionsChanged(False);
        GridStatusChanged;
    end;
end;

procedure TtsBaseGrid.SetCurrentDataRow(Value: Longint);
begin
    if (Value < 0) or (Value > RowCount - 1) then Exit;
    SetCurrentCell(FCurDisplayCol, GetDisplayRow(Value));
end;

function TtsBaseGrid.GetCurrentDataRow: Longint;
begin
    Result := 0;
    if (FCurDisplayRow >= 1) and (FCurDisplayRow <= RowCount - 1) then
        Result := GetDataRow(FCurDisplayRow);
end;

procedure TtsBaseGrid.SetCurrentDataCol(Value: Longint);
begin
    if (Value < 0) or (Value > ColCount - 1) then Exit;
    SetCurrentCell(GetDisplayCol(Value), FCurDisplayRow);
end;

function TtsBaseGrid.GetCurrentDataCol: Longint;
begin
    Result := 0;
    if (FCurDisplayCol >= 1) and (FCurDisplayCol <= ColCount - 1) then
        Result := GetDataCol(FCurDisplayCol);
end;

procedure TtsBaseGrid.GetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo);
begin
end;

procedure TtsBaseGrid.UpdateScrollRange;
begin
    if not HandleAllocated then Exit;
    if not CanPaint then begin FDoUpdateScrollRange := True; Exit; end;
    if FInUpdateScrollRange then begin FForceUpdateScrollRange := True; Exit; end;

    FInUpdateScrollRange := True;
    try
        SetHorzVisible(CanShowHorzScrollBar);
        SetVertVisible(CanShowVertScrollBar);
        FDoUpdateScrollRange := False;
    finally
        FInUpdateScrollRange := False;
    end;
end;

procedure TtsBaseGrid.GetHorzScrollRange(var ScrollCols, ScrollRange, StartCol,
                                         EndCol: Longint; var OutsideMaxRange: Boolean);
var
    Found: Boolean;
begin
    StartCol := FVisibleCols.Locate(FixedCols, Found);
    EndCol := FVisibleCols.Count;

    OutsideMaxRange := False;
    ScrollCols := EndCol - StartCol + 1;
    ScrollRange := CalcMin(tsMaxScrollRange, ScrollCols);
    if ScrollCols > ScrollRange then
    begin
        OutsideMaxRange := True;
        ScrollCols := MaxScrollCol - StartCol;
        ScrollRange := CalcMin(ScrollRange, ScrollCols);
    end;
end;

procedure TtsBaseGrid.GetVertScrollRange(var ScrollRows, ScrollRange, StartRow,
                                         EndRow: Longint; var OutsideMaxRange: Boolean);
var
    Found: Boolean;
begin
    StartRow := FVisibleRows.Locate(FixedRows, Found);
    EndRow := FVisibleRows.Count;

    OutsideMaxRange := False;
    ScrollRows := EndRow - StartRow + 1;
    ScrollRange := CalcMin(tsMaxScrollRange, ScrollRows);
    if ScrollRows > ScrollRange then
    begin
        OutsideMaxRange := True;
        ScrollRows := MaxScrollRow - StartRow;
        ScrollRange := CalcMin(ScrollRange, ScrollRows);
    end;
end;

function TtsBaseGrid.GetVertScrollPos: Integer;
var
    ScrollRange: Longint;
    ScrollRows: Longint;
    StartRow, EndRow: Longint;
    OutsideMaxRange: Boolean;
    TopPos: Longint;
    Found: Boolean;
begin
    GetVertScrollRange(ScrollRows, ScrollRange, StartRow, EndRow, OutsideMaxRange);

    Result := 1;
    if ScrollRows > 0 then
    begin
        TopPos := FVisibleRows.Locate(TopRow, Found);
        if OutsideMaxRange then
        begin
            Result := Round((TopPos - StartRow) * (ScrollRange / ScrollRows));
            if Result > FVisibleRows.Count then Result := EndRow;
        end
        else
        begin
            Result := TopPos - StartRow + 1;
            if Result > FVisibleRows.Count then Result := MaxScrollRow;
        end;
    end;
end;

function TtsBaseGrid.GetHorzScrollPos: Integer;
var
    ScrollRange: Longint;
    ScrollCols: Longint;
    StartCol, EndCol: Longint;
    OutsideMaxRange: Boolean;
    LeftPos: Longint;
    Found: Boolean;
begin
    GetHorzScrollRange(ScrollCols, ScrollRange, StartCol, EndCol, OutsideMaxRange);

    Result := 1;
    if ScrollCols > 0 then
    begin
        LeftPos := FVisibleCols.Locate(LeftCol, Found);
        if OutsideMaxRange then
        begin
            Result := Round((LeftPos - StartCol) * (ScrollRange / ScrollCols));
            if Result > FVisibleCols.Count then Result := EndCol;
        end
        else
        begin
            Result := LeftPos - StartCol + 1;
            if Result > FVisibleCols.Count then Result := MaxScrollCol;
        end;
    end;
end;

procedure TtsBaseGrid.UpdateScrollPos;
var
    Position: Integer;
begin
    if (not HandleAllocated) or (ScrollBars = ssNone) then Exit;
    if not CanPaint then begin FDoUpdateScrollPos := True; Exit end;

    try
        if (FScrollBars in [ssBoth, ssHorizontal]) then
        begin
            Position := GetHorzScrollPos;
            if GetScrollPos(Handle, SB_HORZ) <> Position then
                SetScrollPos(Handle, SB_HORZ, Position, True);
        end;

        if (FScrollBars in [ssBoth, ssVertical]) then
        begin
            Position := GetVertScrollPos;
            if GetScrollPos(Handle, SB_VERT) <> Position then
                SetScrollPos(Handle, SB_VERT, Position, True);
        end;
    finally
        FDoUpdateScrollPos := False;
    end;
end;

function TtsBaseGrid.VertScrollPageSize(ScrollRange, ScrollCount, EndRow: Longint): Integer;
begin
    Result := CalcMax(1, Round(ScrollRange * ((EndRow + 1 - MaxScrollRow) / ScrollCount)));
end;

function TtsBaseGrid.CurrentScrollInfo(ScrollBar: Integer): TScrollInfo;
begin
    ZeroMemory(@Result, SizeOf(Result));
    Result.cbSize := SizeOf(Result);
    Result.fMask := SIF_ALL;
    GetScrollInfo(Handle, ScrollBar, Result);
end;

procedure TtsBaseGrid.GetScrollBarInfo(ScrollBar: Integer; var OldInfo, NewInfo: TScrollInfo);
var
    ScrollRange: Longint;
    ScrollCount: Longint;
    StartScrollRow, StartScrollCol: Longint;
    EndScrollRow, EndScrollCol: Longint;
    OutsideMaxRange: Boolean;
begin
    OldInfo := CurrentScrollInfo(ScrollBar);
    NewInfo := OldInfo;

    if ScrollBar = SB_HORZ then
    begin
        GetHorzScrollRange(ScrollCount, ScrollRange, StartScrollCol, EndScrollCol, OutsideMaxRange);
        NewInfo.nMin := 1;
        NewInfo.nMax := ScrollRange;
        if OutsideMaxRange then NewInfo.nMin := 0;

        if ScrollCount = 0 then
            NewInfo.nPage := 0
        else
        begin
            if OutsideMaxRange then
                NewInfo.nPage := 1
            else
                NewInfo.nPage := CalcMax(1, Round(ScrollRange * ((EndScrollCol + 1 - MaxScrollCol)  / ScrollCount)))
        end;
    end
    else
    begin
        GetVertScrollRange(ScrollCount, ScrollRange, StartScrollRow, EndScrollRow, OutsideMaxRange);
        NewInfo.nMin := 1;
        NewInfo.nMax := ScrollRange;
        if OutsideMaxRange then NewInfo.nMin := 0;

        if ScrollCount = 0 then
            NewInfo.nPage := 0
        else
        begin
            if OutsideMaxRange then
                NewInfo.nPage := 1
            else
                NewInfo.nPage := VertScrollPageSize(ScrollRange, ScrollCount, EndScrollRow);
        end;
    end;
end;

function TtsBaseGrid.AlwaysShowHorzScrollBar: Boolean;
begin
    Result := (AlwaysShowScrollBar in [ssHorizontal, ssBoth]) and
              (ScrollBars in [ssHorizontal, ssBoth]);
end;

function TtsBaseGrid.AlwaysShowVertScrollBar: Boolean;
begin
    Result := (AlwaysShowScrollBar in [ssVertical, ssBoth]) and
              (ScrollBars in [ssVertical, ssBoth]);
end;

procedure TtsBaseGrid.SetHorzVisible(Value: Boolean);
var
    OldInfo: TScrollInfo;
    NewInfo: TScrollInfo;
begin
    if Value then
    begin
        GetScrollBarInfo(SB_HORZ, OldInfo, NewInfo);
        NewInfo.nPos := GetHorzScrollPos;
        FIsHorzVisible := Value;
        if (NewInfo.nMin <> OldInfo.nMin) or (NewInfo.nMax <> OldInfo.nMax) or
           (NewInfo.nPage <> OldInfo.nPage) or (NewInfo.nPos <> OldInfo.nPos) then
        begin
            SetScrollInfo(Handle, SB_HORZ, NewInfo, True);
        end;
        EnableScrollBar(Handle, SB_HORZ, ESB_ENABLE_BOTH);
        ShowScrollBar(Handle, SB_HORZ, True);
    end
    else if FIsHorzVisible or AlwaysShowHorzScrollBar then
    begin
        FIsHorzVisible := Value or AlwaysShowHorzScrollBar;
        if AlwaysShowHorzScrollBar then
        begin
            ShowScrollBar(Handle, SB_HORZ, True);
            EnableScrollBar(Handle, SB_HORZ, ESB_DISABLE_BOTH)
        end
        else
            ShowScrollBar(Handle, SB_HORZ, False);
    end;
end;

procedure TtsBaseGrid.SetVertVisible(Value: Boolean);
var
    OldInfo: TScrollInfo;
    NewInfo: TScrollInfo;
begin
    if Value then
    begin
        GetScrollBarInfo(SB_VERT, OldInfo, NewInfo);
        NewInfo.nPos := GetVertScrollPos;
        FIsVertVisible := Value;
        if (NewInfo.nMin <> OldInfo.nMin) or (NewInfo.nMax <> OldInfo.nMax) or
           (NewInfo.nPage <> OldInfo.nPage) or (NewInfo.nPos <> OldInfo.nPos) then
        begin
            SetScrollInfo(Handle, SB_VERT, NewInfo, True);
        end;
        EnableScrollBar(Handle, SB_VERT, ESB_ENABLE_BOTH);
        ShowScrollBar(Handle, SB_VERT, True);
    end
    else if FIsVertVisible or AlwaysShowVertScrollBar then
    begin
        FIsVertVisible := Value or AlwaysShowVertScrollBar;
        if AlwaysShowVertScrollBar then
        begin
            ShowScrollBar(Handle, SB_VERT, True);
            EnableScrollBar(Handle, SB_VERT, ESB_DISABLE_BOTH)
        end
        else
            ShowScrollBar(Handle, SB_VERT, False);
    end;
end;

procedure TtsBaseGrid.SetScrollBars(Value: TScrollStyle);
begin
    if FScrollBars <> Value then
    begin
        FScrollBars := Value;
        UpdateScrollRange;
        UpdateScrollPos;
    end;
end;

procedure TtsBaseGrid.SetWordWrap(Value: TtsWordWrap);
begin
    if FWordWrap <> Value then
    begin
        FWordWrap := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetReadOnlyButton(Value: Boolean);
begin
    if FReadOnlyButton <> Value then
    begin
        FReadOnlyButton := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetHeadingFont(Value: TFont);
begin
    if FHeadingFont <> Value then
    begin
        FHeadingFont.Assign(Value);
        FHeadingParentFont := False;
    end;
end;

procedure TtsBaseGrid.SetHeadingParentFont(Value: Boolean);
begin
    if HeadingParentFont <> Value then
    begin
        FHeadingParentFont := Value;
        if FHeadingParentFont and Assigned(Parent) then
            FHeadingFont.Assign(TWinControl_(Parent).Font);
    end;
end;

function TtsBaseGrid.GetMaskDefs: TtsMaskDefsComponent;
begin
    Result := nil;
    if Assigned(FMaskLink) then Result := FMaskLink.MaskDefs;
end;

procedure TtsBaseGrid.SetMaskDefs(Value: TtsMaskDefsComponent);
begin
    if MaskDefs <> Value then
    begin
        FMaskLink.MaskDefs := Value;
        SetControlMask;
    end;
end;

function TtsBaseGrid.GetImageList: TtsImageListComponent;
begin
    Result := nil;
    if FAsCombo then
        Result := ParentGrid.ImageList
    else if Assigned(FImageLink) then
        Result := FImageLink.ImageList;
end;

procedure TtsBaseGrid.SetImageList(Value: TtsImageListComponent);
begin
    if FasCombo then Exit;
    if ImageList <> Value then
    begin
        FImageLink.ImageList := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetStretchPicture(Value: Boolean);
begin
    if FStretchPicture <> Value then
    begin
        FStretchPicture := Value;
        if not FInPaintWindow then
        begin
            CurrentCell.FStretchPicture := FStretchPicture;
            Invalidate;
        end;
    end;
end;

procedure TtsBaseGrid.SetShrinkPicture(Value: Boolean);
begin
    if FShrinkPicture <> Value then
    begin
        FShrinkPicture := Value;
        if not FInPaintWindow then
        begin
            CurrentCell.FShrinkPicture := FShrinkPicture;
            Invalidate;
        end;
    end;
end;

procedure TtsBaseGrid.SetCenterPicture(Value: Boolean);
begin
    if FCenterPicture <> Value then
    begin
        FCenterPicture := Value;
        if not FInPaintWindow then
        begin
            CurrentCell.FCenterPicture := FCenterPicture;
            Invalidate;
        end;
    end;
end;

procedure TtsBaseGrid.SetTransparentColor(Value: TColor);
begin
    if FTransparentColor <> Value then
    begin
        FTransparentColor := Value;
        if not FInPaintWindow then
        begin
            CurrentCell.FCenterPicture := FCenterPicture;
            Invalidate;
        end;
    end;
end;

procedure TtsBaseGrid.SetKeepAspectRatio(Value: Boolean);
begin
    if FKeepAspectRatio <> Value then
    begin
        FKeepAspectRatio := Value;
        if not FInPaintWindow then
        begin
            CurrentCell.FKeepAspectRatio := FKeepAspectRatio;
            Invalidate;
        end;
    end;
end;

function TtsBaseGrid.CanSetFocus: Boolean;
begin
    Result := True;
    if FAsCombo then
    begin
        Result := False;
        with ParentGrid do
        begin
            if ComboVisible and InDesignMode then
                Result := True;
        end;
    end;
end;

procedure TtsBaseGrid.SetFocus;
begin
    Inc(FInSetFocus);
    try
        if CanSetFocus then inherited;
    finally
        Dec(FInSetFocus);
    end;
end;

procedure TtsBaseGrid.SetGridFocus;
begin
    if CanFocus then
    begin
        if (GetParentForm(Self) = nil) or (GetParentForm(Self).ActiveControl <> Self)
            then SetFocus
            else Windows.SetFocus(Handle);
    end;
end;

function TtsBaseGrid.GetDateTimeForm: TtsDropDownForm;
begin
    if FDateTimeForm = nil then
    begin
        FDateTimeForm := TtsDropDownForm.Create(Self);
        InitializeDropDownForm(FDateTimeForm);
    end;
    Result := FDateTimeForm;
end;

procedure TtsBaseGrid.UpdateDateTime;
begin
    if DateTimeControlAssigned then FDateTimeComponent.Control.Update;
end;

function TtsBaseGrid.GiveCellDateTime(DataCol, DataRow: Longint): TtsDateTimeDefComponent;
begin
    Result := nil;
    if (DataCol <= 0) or (DataCol > Cols) then Exit;
    if (DataRow <= 0) or (DataRow > Rows) then Exit;

    if CellButtonType[DataCol, DataRow] in [btDateTimeDropDown, btDateTimePopup] then
        Result := CellDateTimeDef[DataCol, DataRow]
    else if FDrawOverlap = doDrawColOnTop then
    begin
        if GridCols[DataCOl].ButtonType in [btDateTimeDropDown, btDateTimePopup]
            then Result := GridCols[DataCol].DateTimeDef
            else Result := RowDateTimeDef[DataRow];
    end
    else
    begin
        if RowButtonType[DataRow] in [btDateTimeDropDown, btDateTimePopup]
            then Result := RowDateTimeDef[DataRow]
            else Result := GridCols[DataCol].DateTimeDef;
    end;

    if not Assigned(Result) then Result := DateTimeDef;
end;

procedure TtsBaseGrid.CheckCreateDateTime(DataCol, DataRow: Longint);
var
    CurDateTime: TtsDateTimeDefComponent;
begin
    CurDateTime := GiveCellDateTime(DataCol, DataRow);
    if not Assigned(CurDateTime) then
    begin
        FDateTimeComponent.Free;
        FDateTimeComponent := nil;
    end
    else if Assigned(FDateTimeComponent) and
            (FDateTimeComponent.ClassType <> CurDateTime.ClassType) then
    begin
        FDateTimeComponent.Free;
        FDateTimeComponent := nil;
    end;

    if Assigned(CurDateTime) then
    begin
        if not Assigned(FDateTimeComponent) then
            FDateTimeComponent := TtsDateTimeDefComponentClass(CurDateTime.ClassType).Create(DateTimeForm);
        if DateTimeControlAssigned then
            FDateTimeComponent.Control.Parent := DateTimeForm;

        FDateTimeComponent.OnSelect := DateTimeSelect;
        FDateTimeComponent.OnCancel := DateTimeCancel;
    end;
end;

procedure TtsBaseGrid.DateTimeInit(DataCol, DataRow: Longint; ButtonType: TtsButtonType);
var
    CurDateTime: TtsDateTimeDefComponent;
begin
    if not FDateTimeInitialized then
    begin
        CurDateTime := GiveCellDateTime(DataCol, DataRow);
        if Assigned(CurDateTime) and (CurDateTime <> FLastUsedDateTime) then
        begin
            FLastUsedDateTime := CurDateTime;
            FDateTimeComponent.Assign(FLastUsedDateTime);
        end;

        FDateTimeComponent.DateTimeProps.PopupForm := (ButtonType = btDateTimePopup);
        FDateTimeComponent.InitializeDisplay;
        ActivateDateTimeInit(FDateTimeComponent, DataCol, DataRow);
        FDateTimeInitialized := True;
    end;
end;

function TtsBaseGrid.DateTimeControlAssigned: Boolean;
begin
    Result := Assigned(FDateTimeComponent);
    if Result then Result := Assigned(FDateTimeComponent.Control);
end;

procedure TtsBaseGrid.SetdateTimeFormExtents(DataCol, DataRow: Longint);
var
    ARect: TRect;
    TopLeft, WidthHeight: TPoint;
    DisplayCol, DisplayRow: Longint;
    DateTimeControl: TWinControl;
begin
    if DateTimeControlAssigned then
    begin
        WidthHeight.X := FDateTimeComponent.Control.Width;
        WidthHeight.Y := FDateTimeComponent.Control.Height;
    end
    else
    begin
        WidthHeight.X := Col[FDropDownCol].Width;
        WidthHeight.Y := 15;
    end;

    WidthHeight.X := WidthHeight.X + (DateTimeForm.Width - DateTimeForm.ClientWidth);
    WidthHeight.Y := WidthHeight.Y + (DateTimeForm.Height - DateTimeForm.ClientHeight);

    DisplayCol := GetDisplayCol(DataCol);
    DisplayRow := GetDisplayRow(DataRow);

    ARect := CellRect(DisplayCol, DisplayRow);
    TopLeft.X := ARect.Left;
    TopLeft.Y := ARect.Bottom;
    TopLeft := ClientToScreen(TopLeft);

    if WidthHeight.X < ColWidths[DisplayCol] then
    begin
        TopLeft.X := TopLeft.X + ColWidths[DisplayCol] - WidthHeight.X;
    end;

    if DateTimeControlAssigned then
    begin
        DateTimeControl := FDateTimeComponent.Control;
        if DateTimeControl.Left <> 0 then DateTimeControl.Left := 0;
        if DateTimeControl.Top <> 0 then DateTimeControl.Top := 0;
    end;

    if DateTimeForm.DropDownForm then
    begin
        PositionDropDownForm(DataCol, DataRow, WidthHeight, TopLeft);
        SetWindowPos(DateTimeForm.Handle, HWND_TOP, TopLeft.X, TopLeft.Y, WidthHeight.X, WidthHeight.Y, 0);
    end
    else
    begin
        PositionPopupForm(DataCol, DataRow, WidthHeight, TopLeft);
        FDateTimeForm.SetBounds(TopLeft.X, TopLeft.Y, WidthHeight.X, WidthHeight.Y);
    end;
end;

procedure TtsBaseGrid.DateTimeActivate(Sender: TObject);
begin
    FDateTimeComponent.InitializeFocus;
end;

procedure TtsBaseGrid.DateTimeClose(Sender: TObject; var Action: TCloseAction);
begin
    DateTimeCancel(Sender);
end;

procedure TtsBaseGrid.SetDateTimeVisible;
begin
    DateTimeForm.Enabled := True;
    if FDateTimeForm.DropDownForm then
    begin
        DateTimeForm.Visible := True;
        FDateTimeComponent.InitializeFocus;
    end
    else
    begin
        FDateTimeDateSelected := False;
        FDateTimeDateCanceled := False;
        FDateTimeDisplayed := True;
        DateTimeForm.OnActivate := DateTimeActivate;
        DateTimeForm.OnClose := DateTimeClose;
        try
            DateTimeForm.ShowModal;
        finally
            DateTimeForm.OnActivate := nil;
            DateTimeForm.OnClose := nil;
            if FDateTimeDateSelected then
                SetDateTimeSelection
            else if FDateTimeDateCanceled then
                CancelDateTimeSelection;
            FDateTimeDisplayed := False;
        end;
    end;
end;

function TtsBaseGrid.GetCurrentDateTime: Variant;
begin
    Result := VariantToDateTime(CurrentCell.Value);
end;

procedure TtsBaseGrid.InitDateTimeForm(DataCol, DataRow: Longint; ButtonType: TtsButtonType);
begin
    if (ButtonType = btDateTimeDropDown) and not DateTimeForm.DropDownForm then
    begin
        DateTimeForm.BorderStyle := bsNone;
        DateTimeForm.BorderIcons := [];
        DateTimeForm.Caption := '';
        DateTimeForm.DropDownForm := True;
        DateTimeForm.RecreateWnd;
    end
    else if (ButtonType = btDateTimePopup) and DateTimeForm.DropDownForm then
    begin
        DateTimeForm.BorderStyle := bsToolWindow;
        DateTimeForm.BorderIcons := [biSystemMenu];
        DateTimeForm.DropDownForm := False;
        DateTimeForm.RecreateWnd;
    end
    else
        DateTimeForm.RecreateWnd;

    if (ButtonType = btDateTimePopup) then
        DateTimeForm.Caption := FDateTimeComponent.DateTimeProps.Caption;
    DateTimeForm.HandleNeeded;
end;

procedure TtsBaseGrid.InternalShowDateTime(DataCol, DataRow: Longint);
var
    ButtonType: TtsButtonType;
begin
    DateTimeForm.HandleNeeded;
    CheckCreateDateTime(DataCol, DataRow);

    FDateTimeComponent.DateTimeProps.DateTime := Unassigned;
    ButtonType := GiveCellButtonType(DataCol, DataRow);
    DateTimeInit(DataCol, DataRow, ButtonType);
    DateTimeDropDown(DataCol, DataRow);
    InitDateTimeForm(DataCol, DataRow, ButtonType);

    if VarIsEmpty(FDateTimeComponent.DateTimeProps.DateTime) then
        FDateTimeComponent.DateTimeProps.DateTime := GetCurrentDateTime;

    SetDateTimeFormExtents(DataCol, DataRow);
    SetDateTimeVisible;
    Update;
    UpdateDateTime;
end;

procedure TtsBaseGrid.DisplayDateTime(DataCol, DataRow: Longint);
begin
    CheckDropDownOff(False);
    InternalShowDateTime(DataCol, DataRow);

    if Assigned(FDateTimeForm) and FDateTimeForm.DropDownForm then
    begin
        HookDropDownHook(Self);
    end;
end;

procedure TtsBaseGrid.ShowDateTime;
begin
    if not CurrentCellInView then Exit;
    if not CanDropDown(FCurDataCol, FCurDataRow, [btDateTimeDropDown, btDateTimePopup]) then Exit;

    if (not DateTimeVisible) or
       (FDropDownCol <> FCurDataCol) or (FDropDownRow <> FCurDataRow) then
    begin
        CheckDropDownOff(False);
        CurrentCell.PutInView;
        DisplayDateTime(FCurDataCol, FCurDataRow);
    end;
end;

procedure TtsBaseGrid.HideDateTime;
begin
    CheckDropDownOff(False);
end;

function TtsBaseGrid.DateTimeButtonDown(DataCol, DataRow: Longint): Boolean;
begin
    Result := True;
    if (DataCol = FDropDownCol) and (DataRow = FDropDownRow) then
        CheckDropDownOff(False)
    else
    begin
        Result := CanDropDown(FCurDataCol, FCurDataRow, [btDateTimeDropDown, btDateTimePopup]);
        if Result then DisplayDateTime(DataCol, DataRow);
    end;
end;

procedure TtsBaseGrid.ActivateDateTimeInit(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint);
begin
    DoDateTimeInit(DateTimeDef, DataCol, DataRow);
end;

procedure TtsBaseGrid.ActivateDateTimeDropDown(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint);
begin
    DoDateTimeDropDown(DateTimeDef, DataCol, DataRow);
end;

procedure TtsBaseGrid.ActivateDateTimeRollUp(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint);
begin
    DoDateTimeRollUp(DateTimeDef, DataCol, DataRow);
end;

procedure TtsBaseGrid.ActivateDateTimeGetValue(DateTimeDef: TtsDateTimeDefComponent; DataCol, DataRow: Longint; var Value: Variant);
begin
    DoDateTimeGetValue(DateTimeDef, DataCol, DataRow, Value);
end;

procedure TtsBaseGrid.DateTimeDropDown(DataCol, DataRow: Longint);
begin
    if (FDropDownCol = -1) and (FDropDownRow = -1) then
    begin
        ActivateDateTimeDropDown(FDateTimeComponent, DataCol, DataRow);
        FDropDownCol := DataCol;
        FDropDownRow := DataRow;
    end;
end;

procedure TtsBaseGrid.DateTimeRollUp;
begin
    if (FDropDownCol <> -1) and (FDropDownRow <> -1) then
    begin
        ActivateDateTimeRollUp(FDateTimeComponent, FDropDownCol, FDropDownRow);
        FDropDownCol := -1;
        FDropDownRow := -1;
    end;
end;

procedure TtsBaseGrid.RemoveDateTime(DateTime: TtsDateTimeDefComponent);
begin
    FDateTimeLink.Remove(DateTime);
end;

procedure TtsBaseGrid.AddDateTime(DateTime: TtsDateTimeDefComponent);
begin
    FDateTimeLink.Add(DateTime);
end;

procedure TtsBaseGrid.RemoveRowDateTimeDef(DateTimeDef: TtsDateTimeDefComponent);
var
    I: Longint;
begin
    for I := 1 to Rows do
    begin
        if Assigned(GridRows[I]) then
        begin
            if GridRows[I].DateTimeDef = DateTimeDef then
                RowDateTimeDef[I] := nil;
        end;
    end;
end;

procedure TtsBaseGrid.RemoveCellDateTimeDef(DateTimeDef: TtsDateTimeDefComponent);
var
    I: Longint;
    AList: TtsSetList;
    Element: TtsCustomElement;
begin
    AList := FCellPropSet.List;
    try
        for I := 1 to AList.Count do
        begin
            Element := TtsCustomElement(AList.Items[I]);
            if TtsCellElement(Element).FDateTimeDef = DateTimeDef then
                FCellPropSet.SetProperty([0,0], Element, ObjectToVariant(nil), prDateTime, 0, False);
        end;
    finally
        AList.Free;
    end;
end;

procedure TtsBaseGrid.DateTimeDefDeleted(DateTimeDef: TtsDateTimeDefComponent);
var
    I: Longint;
begin
    if Self.DateTimeDef = DateTimeDef then
        Self.DateTimeDef := nil;

    for I := 1 to Cols do
    begin
        if GridCols[I].DateTimeDef = DateTimeDef then
            GridCols[I].DateTimeDef := nil;
    end;

    RemoveRowDateTimeDef(DateTimeDef);
    RemoveCellDateTimeDef(DateTimeDef);
end;

function TtsBaseGrid.GetMaxTopRow: Longint;
var
    Sum: Integer;
    ARow: Longint;
    TopMost, BottomMost: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    ARow := RowCount - 1;
    Sum := FVertFixedHeight + RowHeights[ARow];
    while (ARow > FixedRows) do
    begin
        if Sum + RowHeights[ARow - 1] > ClientHeight then Break;

        Dec(ARow);
        Sum := Sum + RowHeights[ARow];
    end;

    if (ARow > 0) and not IsRowVisible(GetDataRow(ARow)) then
        GetNextRow(ARow, False, False, ARow);

    TopMost := TopMostRow(False, False);
    if (GridMode = gmEditInsert) and (InsertionRow > 0)
        then BottomMost := RowCount - 1
        else BottomMost := BottomMostRow(False, False);

    if BottomMost < TopMost then
        ARow := FixedRows
    else
    begin
        if ARow > BottomMost then ARow := BottomMost;
        if ARow < TopMost then ARow := TopMost;
        if ARow < FixedRows then ARow := FixedRows;
    end;

    Result := ARow;
end;

function TtsBaseGrid.GetMaxScrollRow: Longint;
var
    Sum: Integer;
    Index, DisplayRow: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    if FVisibleRows.Count > 0 then
    begin
        Index := FVisibleRows.Count;
        DisplayRow := FVisibleRows.Item[Index];
        Sum := FVertFixedHeight;
        if DisplayRow > 0 then Sum := Sum + RowHeights[DisplayRow];

        while (Index > 1) and (DisplayRow > FixedRows) do
        begin
            DisplayRow := FVisibleRows.Item[Index - 1];
            if DisplayRow < FixedRows then Break;
            if Sum + RowHeights[DisplayRow] > ClientHeight then Break;

            Dec(Index);
            Sum := Sum + RowHeights[DisplayRow];
        end;

        Result := Index;
    end;

    Result := CalcMax(Result, FVisibleRows.Locate(FixedRows, Found));
    if Result > FVisibleRows.Count then Result := FVisibleRows.Count;
end;

function TtsBaseGrid.GetMaxLeftCol: Longint;
var
    Sum: Integer;
    ACol: Longint;
    LeftMost, RightMost: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    ACol := ColCount - 1;
    Sum := FHorzFixedWidth + ColWidths[ACol];
    while (ACol > FixedCols) do
    begin
        if Sum + ColWidths[ACol - 1] > ClientWidth then Break;

        Dec(ACol);
        Sum := Sum + ColWidths[ACol];
    end;

    if (ACol > 0) and not GridCols[GetDataCol(ACol)].Visible then
        GetNextCol(ACol, False, False, ACol);

    LeftMost := LeftMostCol(False, False);
    RightMost := RightMostCol(False, False);

    if RightMost < LeftMost then
        ACol := FixedCols
    else
    begin
        if ACol > RightMost then ACol := RightMost;
        if ACol < LeftMost then ACol := LeftMost;
        if ACol < FixedCols then ACol := FixedCols;
    end;

    Result := ACol;
end;

function TtsBaseGrid.GetMaxScrollCol: Longint;
var
    Sum: Integer;
    Index, DisplayCol: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    if FVisibleCols.Count > 0 then
    begin
        Index := FVisibleCols.Count;
        DisplayCol := FVisibleCols.Item[Index];
        Sum := FHorzFixedWidth;
        if DisplayCol > 0 then Sum := Sum + ColWidths[DisplayCol];

        while (Index > 1) and (DisplayCol > FixedCols) do
        begin
            DisplayCol := FVisibleCols.Item[Index - 1];
            if DisplayCol < FixedCols then Break;
            if Sum + ColWidths[DisplayCol] > ClientWidth then Break;

            Dec(Index);
            Sum := Sum + ColWidths[DisplayCol];
        end;

        Result := Index;
    end;

    Result := CalcMax(Result, FVisibleCols.Locate(FixedCols, Found));
    if Result > FVisibleCols.Count then Result := FVisibleCols.Count;
end;

function TtsBaseGrid.GetMaxTopLeft: TGridCoord;
begin
    Result.X := MaxLeftCol;
    Result.Y := MaxTopRow;
end;

procedure TtsBaseGrid.CheckTopLeft(DoPaint: Boolean);
begin
    if FastAssign then
    begin
        Include(FFastAssignActions, gacCheckTopLeft);
        Exit;
    end;

    if not DoPaint then EnablePaint := False;
    try
        MoveTopLeft(LeftCol, TopRow);
    finally
        if not DoPaint then EnablePaint := True;
    end;
end;

function TtsBaseGrid.CalcVertScrollBar(ScrollCode, Pos: Integer): Longint;
var
    ScrollRows, ScrollRange: Longint;
    StartRow, EndRow: Longint;
    OutsideMaxRange: Boolean;
    ScrollIndex: Longint;
    Found: Boolean;
begin
    EndRow := 0;
    ScrollIndex := FVisibleRows.Locate(TopRow, Found);
    case ScrollCode of
        SB_LINEUP:
            ScrollIndex := ScrollIndex - 1;
        SB_LINEDOWN:
            ScrollIndex := ScrollIndex + 1;
        SB_PAGEUP:
            ScrollIndex := ScrollIndex - CalcMax(1, PrevScrollRows);
        SB_PAGEDOWN:
            ScrollIndex := ScrollIndex + CalcMax(1, VisibleScrollRows);
        SB_THUMBPOSITION, SB_THUMBTRACK:
            if (goThumbTracking in Options) or (ScrollCode = SB_THUMBPOSITION) then
            begin
                GetVertScrollRange(ScrollRows, ScrollRange, StartRow, EndRow, OutsideMaxRange);
                if not OutsideMaxRange then
                begin
                    ScrollIndex := StartRow - 1 + Pos;
                    if ScrollIndex > FVisibleRows.Count then ScrollIndex := EndRow;
                end
                else
                begin
                    ScrollIndex := StartRow + Round(Pos * (ScrollRows / ScrollRange));
                    if ScrollIndex > FVisibleRows.Count then ScrollIndex := MaxScrollRow;
                end;
            end;
        SB_BOTTOM:
            ScrollIndex := FVisibleRows.Count;
        SB_TOP:
            ScrollIndex := FVisibleRows.Locate(FixedRows, Found);
    end;

    if (ScrollIndex > 0) and (ScrollIndex <= FVisibleRows.Count) then
        Result := FVisibleRows.Item[ScrollIndex]
    else if ScrollIndex > FVisibleRows.Count then
    begin
        if EndRow = 0 then
            GetVertScrollRange(ScrollRows, ScrollRange, StartRow, EndRow, OutsideMaxRange);
        Result := FVisibleRows[EndRow];
    end
    else
        Result := FVisibleRows.Locate(FixedRows, Found);
end;

procedure TtsBaseGrid.ModifyVertScrollBar(var Msg: TWMVScroll);
var
    NewRow: Longint;
begin
    if Visible then
    begin
        if CanFocus and (not (csDesigning in ComponentState)) and (not IsFocused) then
            SetGridFocus;
    end;

    NewRow := CalcVertScrollBar(Msg.ScrollCode, Msg.Pos);
    NewRow := CalcMax(NewRow, FixedRows);
    NewRow := CalcMin(NewRow, MaxTopRow);
    if NewRow <> TopRow then MoveTopLeft(LeftCol, NewRow);
    DrawCurrentFocusRect(True);
end;

function TtsBaseGrid.CalcHorzScrollBar(ScrollCode, Pos: Integer): Longint;
var
    ScrollCols, ScrollRange: Longint;
    StartCol, EndCol: Longint;
    OutsideMaxRange: Boolean;
    ScrollCol: Longint;
    Found: Boolean;
begin
    EndCol := 0;
    ScrollCol := FVisibleCols.Locate(LeftCol, Found);

    case ScrollCode of
        SB_LINEUP:
            ScrollCol := ScrollCol - 1;
        SB_LINEDOWN:
            ScrollCol := ScrollCol + 1;
        SB_PAGEUP:
            ScrollCol := ScrollCol - CalcMax(1, PrevScrollCols);
        SB_PAGEDOWN:
            ScrollCol := ScrollCol + CalcMax(1, VisibleScrollCols);
        SB_THUMBPOSITION, SB_THUMBTRACK:
            if (goThumbTracking in Options) or (ScrollCode = SB_THUMBPOSITION) then
            begin
                GetHorzScrollRange(ScrollCols, ScrollRange, StartCol, EndCol, OutsideMaxRange);
                if not OutsideMaxRange then
                begin
                    ScrollCol := StartCol - 1 + Pos;
                    if ScrollCol > FVisibleCols.Count then ScrollCol := EndCol;
                end
                else
                begin
                    ScrollCol := StartCol + Round(Pos * (ScrollCols / ScrollRange));
                    if ScrollCol > FVisibleCols.Count then ScrollCol := MaxScrollCol;
                end;
            end;
        SB_BOTTOM:
            ScrollCol := FVisibleCols.Count;
        SB_TOP:
            ScrollCol := FVisibleCols.Locate(FixedCols, Found);
    end;

    if (ScrollCol > 0) and (ScrollCol <= FVisibleCols.Count) then
        Result := FVisibleCols[ScrollCol]
    else if ScrollCol > FVisibleCols.Count then
    begin
        if EndCol = 0 then
            GetHorzScrollRange(ScrollCols, ScrollRange, StartCol, EndCol, OutsideMaxRange);
        Result := FVisibleCols[EndCol];
    end
    else
        Result := FVisibleCols.Locate(FixedCols, Found);
end;

procedure TtsBaseGrid.ModifyHorzScrollBar(var Msg: TWMVScroll);
var
    NewCol: Longint;
begin
    if Visible then
    begin
        if CanFocus and (not (csDesigning in ComponentState)) and (not IsFocused) then
            SetGridFocus;
    end;

    NewCol := CalcHorzScrollBar(Msg.ScrollCode, Msg.Pos);
    NewCol := CalcMax(NewCol, FixedCols);
    NewCol := CalcMin(NewCol, MaxLeftCol);
    if NewCol <> LeftCol then MoveTopLeft(NewCol, TopRow);
    DrawCurrentFocusRect(True);
end;

procedure TtsBaseGrid.HideControlBeforeScroll(DoInvalidate: Boolean);
begin
    if not FControlHidden then HideGridControl(False);
    if DoInvalidate and InEditMode then InvalidateCell(CurDisplayCol, CurDisplayRow);
end;

procedure TtsBaseGrid.ShowControlAfterScroll;
begin
    ShowGridControl;
end;

procedure TtsBaseGrid.SetRedraw;
begin
    if not EnableRedraw then
        SendMessage(Handle, WM_SETREDRAW, 0, 0)
    else
        SendMessage(Handle, WM_SETREDRAW, 1, 0);
end;

procedure TtsBaseGrid.SetEnablePaint(Value: Boolean);
begin
    if not Value then
        Inc(FEnablePaintCount)
    else if FEnablePaintCount > 0 then
        Dec(FEnablePaintCount);

    if EnablePaint and FSetBounds then
    begin
        FSetBounds := False;
        UpdateComboExtents(DropDownCols, DropDownRows, True);
    end;
end;

function TtsBaseGrid.GetEnablePaint: Boolean;
begin
    Result := (FEnablePaintCount = 0);
end;

procedure TtsBaseGrid.SetEnableRedraw(Value: Boolean);
begin
    if not Value then
        Inc(FEnableRedrawCount)
    else if FEnableRedrawCount > 0 then
        Dec(FEnableRedrawCount);

    SetRedraw;
    if EnableRedraw then
    begin
        Invalidate;
        Update;
    end;
end;

function TtsBaseGrid.GetEnableRedraw: Boolean;
begin
    Result := (FEnableRedrawCount = 0);
end;

procedure TtsBaseGrid.PerformFastAssignActions;
var
    I: TtsGridAction;
begin
    for I := Low(TtsGridAction) to High(TtsGridAction) do
    begin
        if I in FFastAssignActions then
        begin
            case I of
                gacCheckTopLeft: CheckTopLeft(True);
                gacTopLeftChanged: TopLeftChanged;
            end;
        end;
    end;

    FFastAssignActions := [];
end;

procedure TtsBaseGrid.InitFastAssign;
begin
    EnablePaint := False;
    HideGridControl(True);
    FFastAssignActions := [];
end;

procedure TtsBaseGrid.EndFastAssign;
begin
    try
        PerformFastAssignActions;
        ShowGridControl;
        Invalidate;
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.SetFastAssign(Value: Boolean);
begin
    if Value then
    begin
        if not FastAssign then InitFastAssign;
        Inc(FFastAssignCount);
    end
    else if FFastAssignCount > 0 then
    begin
        Dec(FFastAssignCount);
        if not FastAssign then EndFastAssign;
    end;
end;

function TtsBaseGrid.GetFastAssign: Boolean;
begin
    Result := (FFastAssignCount > 0) or Reading;
end;

procedure TtsBaseGrid.SetFocusRectDisabled(Value: Boolean);
begin
    if Value then
        Inc(FFocusRectDisabled)
    else if FFocusRectDisabled > 0 then
        Dec(FFocusRectDisabled);
end;

function TtsBaseGrid.GetFocusRectDisabled: Boolean;
begin
    Result := (FFocusRectDisabled > 0);
end;

procedure TtsBaseGrid.SetSetComboExtents(Value: Boolean);
begin
    if not Value then
        Inc(FSetComboExtents)
    else if FSetComboExtents > 0 then
        Dec(FSetComboExtents);
end;

function TtsBaseGrid.GetSetComboExtents: Boolean;
begin
    Result := (FSetComboExtents = 0);
end;

function TtsBaseGrid.CanPaint: Boolean;
begin
    Result := EnablePaint and EnableRedraw and not FGridMemoryCanvas.Locked(Self);
end;

function TtsBaseGrid.ColInView(DisplayCol: Longint): Boolean;
begin
    Result := True;
    if (DisplayCol < 1) or
       ((DisplayCol < LeftCol) and (DisplayCol >= FixedCols)) or
       (DisplayCol > MaxVisibleCol) then
    begin
        Result := False;
    end;
end;

function TtsBaseGrid.RowInView(DisplayRow: Longint): Boolean;
begin
    Result := True;
    if (DisplayRow < 1) or
       ((DisplayRow < TopRow) and (DisplayRow >= FixedRows)) or
       (DisplayRow > MaxVisibleRow) then
    begin
        Result := False;
    end;
end;

procedure TtsBaseGrid.CopyToDrawBitmap(Bmp:TBitmap);
begin
    if DrawBitmap.Width < Bmp.Width then DrawBitmap.Width := Bmp.Width;
    if DrawBitmap.Height < Bmp.Height then DrawBitmap.Height := Bmp.Height;
    DrawBitmap.Canvas.Draw(0, 0, Bmp);
end;

procedure TtsBaseGrid.DrawBmpRowBar(DisplayRow: Longint; Bmp: TBitmap;
                                    ClearInsert: Boolean; CopyMode: TCopyMode);
var
    AGridRect, BmpRect: TRect;
    TopOffset: Integer;
    TextHeight: Integer;
    OldTop: Integer;
    Alignment: TtsVertAlignment;
begin
    if not RowBarOn then Exit;
    if not RowInView(DisplayRow) then Exit;
    if not CanDrawCell(0, DisplayRow) then Exit;
    if ClearInsert and IsInsertRow(DisplayRow) then ClearRowBarCell(DisplayRow);

    AGridRect := CellRect(0, DisplayRow);
    if (FHorzLineWidth = 0) then AGridRect.Right := AgridRect.Right - 1;
    if (FVertLineWidth = 0) then AGridRect.Bottom := AgridRect.Bottom - 1;

    if (AGridRect.Left >= AGridRect.Right) or
       (AGridRect.Top >= AGridRect.Bottom) then Exit;

    if Canvas.Brush.Color <> FHeadingColor then Canvas.Brush.Color := FHeadingColor;

    AGridRect.Left := ((AGridRect.Right - AGridRect.Left - 1) div 2) - (Bmp.Width div 2) + 1;
    AGridRect.Left := CalcMax(AGridRect.Left, 1);

    Alignment := RowBarAlignment;
    if Alignment = vtaDefault then Alignment := VertAlignment;
    if Alignment = vtaCenter then
    begin
        TopOffset := (RowHeights[DisplayRow] div 2) - (Bmp.Height div 2);
        TopOffset := CalcMax(TopOffset, 1);
    end
    else if Alignment = vtaBottom then
    begin
        Canvas.Font := Font;
        TextHeight := Canvas.TextHeight('X');
        TopOffset := (TextHeight div 2) - (Bmp.Height div 2);
        TopOffset := TopOffset + RowHeights[DisplayRow] - TextHeight - 1;
    end
    else
    begin
        Canvas.Font := Font;
        TextHeight := Canvas.TextHeight('X');
        TopOffset := (TextHeight div 2) - (Bmp.Height div 2);
        TopOffset := CalcMax(TopOffset, 1);
    end;

    OldTop := AGridRect.Top;
    AGridRect.Top := AGridRect.Top + TopOffset;
    AGridRect.Right := CalcMin(AGridRect.Left + Bmp.Width, AGridRect.Right);
    AGridRect.Bottom := CalcMin(AGridRect.Top + Bmp.Height, AGridRect.Bottom);
    AGridRect.Top := CalcMax(AGridRect.Top, OldTop + 1);

    BmpRect.Left := 0;
    BmpRect.Top := 0;
    BmpRect.Right := CalcMin(Bmp.Width, AGridRect.Right - AGridRect.Left);
    BmpRect.Bottom := (AGridRect.Bottom - AGridRect.Top);
    if (Bmp.Height > BmpRect.Bottom - BmpRect.Top) and (VertAlignment = vtaBottom) then
    begin
        BmpRect.Top := BmpRect.Top + (Bmp.Height - (BmpRect.Bottom - BmpRect.Top));
        BmpRect.Bottom := BmpRect.Bottom + BmpRect.Top;
    end;

    CopyToDrawBitmap(Bmp);
    Canvas.CopyMode := CopyMode;
    Canvas.CopyRect(AGridRect, DrawBitmap.Canvas, BmpRect);
    Canvas.CopyMode := cmSrcCopy;
end;

function TtsBaseGrid.DrawRowChangedIndicator(DataRow: Longint): Boolean;
begin
    Result := False;
    if ((RowChangedIndicator = riOn) and IsRowChanged(DataRow)) or
       ((RowChangedIndicator in [riOn, riAutoReset]) and FCurRowChanged) then
        Result := True;
end;

procedure TtsBaseGrid.DrawCurrent(DisplayRow: Longint);
begin
    if not RowBarIndicator then Exit;
    if DrawRowChangedIndicator(GetDataRow(DisplayRow)) then
        DrawBmpRowBar(DisplayRow, BitMapChangedRow, True, cmMergeCopy)
    else if CanDrawInsert then
        DrawInsert
    else
        DrawBmpRowBar(DisplayRow, BitMapArrowRight, True, cmMergeCopy);
end;

procedure TtsBaseGrid.DrawCurrentSelected(DisplayRow: Longint);
begin
    if not RowBarIndicator then Exit;
    if DrawRowChangedIndicator(GetDataRow(DisplayRow)) then
        DrawBmpRowBar(DisplayRow, BitMapChangedRow, True, cmMergePaint)
    else if CanDrawInsert then
        DrawInsert
    else
        DrawBmpRowBar(DisplayRow, BitMapArrowRight, True, cmMergePaint);
end;

procedure TtsBaseGrid.RectInvert(Dc: HDC; ARect: TRect; Selected: Boolean);
begin
    if CanPaint then
    begin
        PatBlt(Dc, ARect.Left, ARect.Top, ARect.Right - ARect.Left,
               ARect.Bottom - ARect.Top, cmDstInvert);
    end
    else
        Windows.InvalidateRect(Handle, @ARect, False);
end;

procedure TtsBaseGrid.GridRectInvert(Dc: HDC; ARect: TGridRect; InvertRect: TRect; Selected: Boolean);
var
    LineRect, ClipRect: TRect;
    DisplayCol, DisplayRow: Longint;
    DrawRect: TRect;
begin
    if not CanPaint then
    begin
        if EqualRect(InvertRect, FNullRect) then
            InvertRect := BoxRect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom);
        if not EqualRect(InvertRect, FNullRect) then Windows.InvalidateRect(Handle, @InvertRect, False);
        Exit;
    end;

    if (not SelectionColorEnabled) then
    begin
        if EqualRect(InvertRect, FNullRect) then
            InvertRect := BoxRect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom);
        if not EqualRect(InvertRect, FNullRect) then RectInvert(Dc, InvertRect, Selected);
    end
    else
    begin
        ClipRect := InvertRect;
        if EqualRect(ClipRect, FNullRect) then
            ClipRect := BoxRect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom);
        if not EqualRect(ClipRect, FNullRect) then
        begin
            FocusRectDisabled := True;
            try
                for DisplayRow := ARect.Top to ARect.Bottom do
                begin
                    for DisplayCol := ARect.Left to ARect.Right do
                    begin
                        FDrawSelectCell.X := DisplayCol;
                        FDrawSelectCell.Y := DisplayRow;
                        if (DisplayCol = 0) or (DisplayRow = 0)
                            then FDrawCellSelected := False
                            else FDrawCellSelected := Selected;

                        DrawRect := CalcCellRect(DisplayCol, DisplayRow);
                        if (DrawRect.Left < DrawRect.Right) and (DrawRect.Top < DrawRect.Bottom) then
                        begin
                            LineRect := DrawRect;
                            if ColWidths[DisplayCol] <= (ClientWidth - LineRect.Left) then
                                Dec(LineRect.Right, FVertLineWidth);
                            if RowHeights[DisplayRow] <= (ClientHeight - LineRect.Top) then
                                Dec(LineRect.Bottom, FHorzLineWidth);

                            if (DisplayRow = 0) or (DisplayCol = 0) then
                                RectInvert(Canvas.Handle, DrawRect, Selected)
                            else
                                DoDrawCell(DisplayCol, DisplayRow, DrawRect, FDrawCellSelected);
                        end;
                    end;
                end;
            finally
                FDrawSelectCell.X := -1;
                FDrawSelectCell.Y := -1;
                FocusRectDisabled := False;
            end;
        end;
    end;
end;

function TtsBaseGrid.CanDrawCell(DisplayCol, DisplayRow: Longint): Boolean;
begin
    if CanPaint then
    begin
        Result := True;
        Exit;
    end;

    Result := False;
    InvalidateCell(DisplayCol, DisplayRow);
end;

procedure TtsBaseGrid.ClearRowBarCell(DisplayRow: Longint);
var
    ARect: TRect;
begin
    ARect := CellRect(0, DisplayRow);
    Inc(ARect.Right, FVertLineWidth);
    Inc(ARect.Bottom, FHorzLineWidth);

    if IsRowSelected(GetDataRow(DisplayRow)) and not FInPaintWindow then
        DrawFixedCellSelected(ARect)
    else
        DrawFixedCellUnselected(ARect, -1);
end;

procedure TtsBaseGrid.ClearCurrent(DisplayRow: Longint);
begin
    if not RowBarOn then Exit;
    if not RowInView(DisplayRow) then Exit;
    if not CanDrawCell(0, DisplayRow) then Exit;

    ClearRowBarCell(DisplayRow);
    if IsInsertRow(DisplayRow) then DrawInsert;
end;

procedure TtsBaseGrid.CheckDisableControl;
begin
    FControlEnabled := AlwaysShowEditor;
end;

procedure TtsBaseGrid.PositionCell(DisplayCol, DisplayRow: Longint);
begin
    FPrevDisplayCol := FCurDisplayCol;
    FPrevDisplayRow := FCurDisplayRow;

    if (FCurDisplayCol <> DisplayCol) or
       (GetDataCol(FCurDisplayCol) <> FCurDataCol) then
    begin
        FCurDisplayCol := DisplayCol;
        FCurDataCol := GetDataCol(FCurDisplayCol);
    end;

    if (FCurDisplayRow <> DisplayRow) or
       (GetDataRow(FCurDisplayRow) <> FCurDataRow) then
    begin
        FCurDisplayRow := DisplayRow;
        FCurDataRow := GetDataRow(FCurDisplayRow);
    end;

    FLastAddedCol := DisplayCol;
end;

procedure TtsBaseGrid.SetCurrentPosition(DisplayCol, DisplayRow: Longint;
                                         InvalidateInsertRow, InvalidateOldCell: Boolean);
var
    OldDataCol, OldDataRow: Longint;
begin
    OldDataCol := FCurDataCol;
    OldDataRow := FCurDataRow;

    PositionCell(DisplayCol, DisplayRow);

    if (OldDataCol <> FCurDataCol) or
       (OldDataRow <> FCurDataRow) then
    begin
        ClearCellBuffer;
        CheckDisableControl;
    end;

    CheckInsertionRow(InvalidateInsertRow);
end;

procedure TtsBaseGrid.SetCurrentPositionAndDraw(DisplayCol, DisplayRow: Longint;
                                                InvalidateInsertRow, InvalidateOldCell: Boolean);
begin
    try
        SetCurrentPosition(DisplayCol, DisplayRow, InvalidateInsertRow, InvalidateOldCell);
    finally
        DrawCurrent(FCurDisplayRow);
    end;
end;

function TtsBaseGrid.ButtonsActive: Boolean;
begin
    Result := True;
end;

function TtsBaseGrid.CanDrawInsert: Boolean;
begin
    Result := False;
end;

procedure TtsBaseGrid.DrawInsert;
begin
    if IsRowSelected(RowCount - 1) and not FInPaintWindow then
        DrawBmpRowBar(RowCount - 1, BitMapInsertRow, False, cmMergePaint)
    else
        DrawBmpRowBar(RowCount - 1, BitMapInsertRow, False, cmMergeCopy);
end;

procedure TtsBaseGrid.SetSelectChanged(SelectType: TtsSelectType);
begin
    if (not FSelectChanged[SelectType]) then FSelectChanged[SelectType] := True;
end;

procedure TtsBaseGrid.SelectChanged(SelectType: TtsSelectType; ByUser: Boolean);
begin
    if FSelectChanged[SelectType] then
    begin
        FSelectChanged[SelectType] := False;
        DoSelectChanged(SelectType, ByUser);
    end;
end;

procedure TtsBaseGrid.SelectionsChanged(ByUser: Boolean);
var
    SelectType: TtsSelectType;
begin
    for SelectType := Low(TtsSelectType) to High(TtsSelectType) do
        SelectChanged(SelectType, ByUser);
end;

procedure TtsBaseGrid.AddColSelection(First, Last: Longint);
var
    ACol: Longint;
begin
    if First > Last then SwapLongint(First, Last);
    if Last > ColCount - 1 then Last := ColCount - 1;

    if First < 1 then
    begin
        First := 1;
        if Last < 1 then Exit;
    end;

    for ACol := First to Last do
    begin
        if (not FSelectedCols[ACol]) and GridCols[GetDataCol(ACol)].Visible then
        begin
            SetSelectChanged(stColSelect);

            if (ACol < FSelectedCols.FFirst) or (FSelectedCols.FFirst < 0) then
                FSelectedCols.FFirst := ACol;

            if ACol > FSelectedCols.FLast then FSelectedCols.FLast := ACol;

            FSelectedCols.FBits[ACol] := True;
            Inc(FSelectedCols.FCount);
        end;
    end;

    if (FSelectedCols.Count > 0) and (FGridStatus = grNormal) then
        FGridStatus := grColSelect;
end;

procedure TtsBaseGrid.DeleteColSelection(First, Last: Longint);
var
    ACol: Longint;
begin
    if FSelectedCols.Count = 0 then Exit;

    if First > Last then SwapLongint(First, Last);
    if Last > ColCount - 1 then Last := ColCount - 1;

    if First < 1 then
    begin
        First := 1;
        if Last < 1 then Exit;
    end;

    if (First <= FSelectedCols.First) and (Last >= FSelectedCols.Last) then
    begin
        SetSelectChanged(stColSelect);
        FSelectedCols.Reset;
    end
    else
    begin
        if FSelectedCols[First] then ACol := First
                                else ACol := FSelectedCols.Next(First);

        while (ACol >= 0) and (ACol <= Last) do
        begin
            SetSelectChanged(stColSelect);

            FSelectedCols.FBits[ACol] := False;
            Dec(FSelectedCols.FCount);

            if (ACol = FSelectedCols.FFirst) then
                FSelectedCols.FFirst := FSelectedCols.Next(ACol);

            if (ACol = FSelectedCols.FLast) then
                FSelectedCols.FLast := FSelectedCols.Previous(First);

            ACol := FSelectedCols.Next(ACol);
        end;
    end;

    if (FSelectedCols.Count = 0) and (FGridStatus = grColSelect) then
        FGridStatus := grNormal;
end;

procedure TtsBaseGrid.ChangeColSelection(First, Last: Longint);
var
    ACol: Longint;
    ColPos, StartColPos: Longint;
    Found: Boolean;
begin
    if First > Last then SwapLongint(First, Last);
    if First < 1 then
    begin
        First := 1;
        if Last < 1 then Exit;
    end;
    if Last > ColCount - 1 then Last := ColCount - 1;

    if FSelectedCols.Count = 0 then
        AddColSelection(First, Last)
    else
    begin
        StartColPos := FVisibleCols.Locate(First, Found);
        for ColPos := StartColPos to FVisibleCols.Count do
        begin
            ACol := FVisibleCols[ColPos];
            if ACol > Last then Break;

            if (ACol >= First) and GridCols[GetDataCol(ACol)].Visible then
            begin
                SetSelectChanged(stColSelect);
                if FSelectedCols[ACol] then Dec(FSelectedCols.FCount)
                                       else Inc(FSelectedCols.FCount);
                FSelectedCols.FBits[ACol] := not FSelectedCols[ACol];

                if (ACol = FSelectedCols.FFirst) and (not FSelectedCols[ACol]) then
                    FSelectedCols.FFirst := FSelectedCols.Next(ACol)
                else if ((ACol < FSelectedCols.FFirst) or (FSelectedCols.FFirst < 0)) and
                        (FSelectedCols[ACol]) then
                    FSelectedCols.FFirst := ACol;

                if (ACol = FSelectedCols.FLast) and (not FSelectedCols[ACol]) then
                    FSelectedCols.FLast := FSelectedCols.Previous(ACol)
                else if (ACol > FSelectedCols.FLast) and (FSelectedCols[ACol]) then
                    FSelectedCols.FLast := ACol;
            end;
        end;

        if (FSelectedCols.Count = 0) and (FGridStatus = grColSelect) then
            FGridStatus := grNormal
        else if (FSelectedCols.Count > 0) and (FGridStatus = grNormal) then
            FGridStatus := grColSelect;
    end;
end;

procedure TtsBaseGrid.DeleteAllColSelection;
begin
    DeleteColSelection(1, ColCount - 1);
end;

procedure TtsBaseGrid.NewColSelection(First, Last: Longint);
begin
    DeleteAllColSelection;
    AddColSelection(First, Last);
end;

procedure TtsBaseGrid.AddRowSelection(First, Last: Longint);
var
    ARow: Longint;
begin
    if First > Last then SwapLongint(First, Last);
    if Last > RowCount - 1 then Last := RowCount - 1;

    if First < 1 then
    begin
        First := 1;
        if Last < 1 then Exit;
    end;

    for ARow := First to Last do
    begin
        if (not FSelectedRows[ARow]) and IsRowVisible(GetDataRow(ARow)) then
        begin
            SetSelectChanged(stRowSelect);

            if (ARow < FSelectedRows.FFirst) or (FSelectedRows.FFirst < 0) then
                FSelectedRows.FFirst := ARow;

            if ARow > FSelectedRows.FLast then FSelectedRows.FLast := ARow;

            FSelectedRows.FBits[ARow] := True;
            Inc(FSelectedRows.FCount);
        end;
    end;

    if (FSelectedRows.Count > 0) and (FGridStatus = grNormal) then
        FGridStatus := grRowSelect;
end;

procedure TtsBaseGrid.DeleteRowSelection(First, Last: Longint);
var
    ARow: Longint;
begin
    if FSelectedRows.Count = 0 then Exit;

    if First > Last then SwapLongint(First, Last);
    if Last > RowCount - 1 then Last := RowCount - 1;

    if First < 1 then
    begin
        First := 1;
        if Last < 1 then Exit;
    end;

    if (First <= FSelectedRows.First) and (Last >= FSelectedRows.Last) then
    begin
        SetSelectChanged(stRowSelect);
        FSelectedRows.Reset
    end
    else
    begin
        if FSelectedRows[First] then ARow := First
                                else ARow := FSelectedRows.Next(First);

        while (ARow >= 0) and (ARow <= Last) do
        begin
            SetSelectChanged(stRowSelect);

            FSelectedRows.FBits[ARow] := False;
            Dec(FSelectedRows.FCount);

            if (ARow = FSelectedRows.FFirst) then
                FSelectedRows.FFirst := FSelectedRows.Next(ARow);

            if (ARow = FSelectedRows.FLast) then
                FSelectedRows.FLast := FSelectedRows.Previous(First);

            ARow := FSelectedRows.Next(ARow);
        end;
    end;

    if (FSelectedRows.Count = 0) and (FGridStatus = grRowSelect) then
        FGridStatus := grNormal;
end;

procedure TtsBaseGrid.DeleteAllRowSelection;
begin
    DeleteRowSelection(1, RowCount - 1);
end;

procedure TtsBaseGrid.NewRowSelection(First, Last: Longint);
begin
    DeleteAllRowSelection;
    AddRowSelection(First, Last);
end;

procedure TtsBaseGrid.ChangeRowSelection(First, Last: Longint);
var
    ARow: Longint;
    RowPos, StartRowPos: Integer;
    Found: Boolean;
begin
    if First > Last then SwapLongint(First, Last);
    if Last < 1 then Exit;
    if First < 1 then First := 1;
    if Last > Rows then Last := Rows;

    if FSelectedRows.Count = 0 then
        AddRowSelection(First, Last)
    else
    begin
        StartRowPos := FVisibleRows.Locate(First, Found);
        for RowPos := StartRowPos to FVisibleRows.Count do
        begin
            ARow := FVisibleRows[RowPos];
            if ARow > Last then Break;

            if (ARow >= First) and IsRowVisible(GetDataRow(ARow)) then
            begin
                SetSelectChanged(stRowSelect);
                if FSelectedRows[ARow] then Dec(FSelectedRows.FCount)
                                       else Inc(FSelectedRows.FCount);
                FSelectedRows.FBits[ARow] := not FSelectedRows[ARow];

                if (ARow = FSelectedRows.FFirst) and (not FSelectedRows[ARow]) then
                    FSelectedRows.FFirst := FSelectedRows.Next(ARow)
                else if ((ARow < FSelectedRows.FFirst) or (FSelectedRows.FFirst < 0)) and
                        (FSelectedRows[ARow]) then
                    FSelectedRows.FFirst := ARow;

                if (ARow = FSelectedRows.FLast) and (not FSelectedRows[ARow]) then
                    FSelectedRows.FLast := FSelectedRows.Previous(ARow)
                else if (ARow > FSelectedRows.FLast) and (FSelectedRows[ARow]) then
                    FSelectedRows.FLast := ARow;
            end;
        end;

        if (FSelectedRows.Count = 0) and (FGridStatus = grRowSelect) then
            FGridStatus := grNormal
        else if (FSelectedRows.Count > 0) and (FGridStatus = grNormal) then
            FGridStatus := grRowSelect;
    end;
end;

function TtsBaseGrid.CanEditCol(DataCol: Longint): Boolean;
begin
    Result := GridCols[DataCol].Visible and not GridCols[DataCol].ReadOnly;
end;

function TtsBaseGrid.CanEditRow(DataRow: Longint): Boolean;
begin
    Result := IsRowVisible(DataRow) and not IsRowReadOnly(DataRow);
end;

function TtsBaseGrid.CanEditCell(DataCol, DataRow: Longint): Boolean;
var
    ReadOnly: TtsReadOnly;
    IsVisible: Boolean;
begin
    IsVisible := GridCols[DataCol].Visible and IsRowVisible(DataRow);
    Result := IsVisible and InDesignMode and StoreData;
    if not Result then
    begin
        ReadOnly := IsCellReadOnly(DataCol, DataRow);
        if ReadOnly = roDefault then
            Result := IsVisible and not GridCols[DataCol].ReadOnly and not IsRowReadOnly(DataRow)
        else
            Result := IsVisible and (ReadOnly = roOff);
    end;
end;

function TtsBaseGrid.CellIsReadOnly(DataCol: Longint; DataRow: Longint): Boolean;
begin
    Result := False;
    if (DataCol <= 0) or (DataCol > Cols) then Exit;
    if (DataRow <= 0) or (DataRow > RowCount - 1) then Exit;
    Result := not CanEditCell(DataCol, DataRow);
end;

function TtsBaseGrid.GetNextCol(DisplayCol: Longint; CheckEdit, CheckSelect: Boolean;
                                var NewCol: Longint): Boolean;
begin
    NewCol := DisplayCol + 1;
    if NewCol < 1 then NewCol := 1;

    while NewCol <= Cols do
    begin
        if (not GridCols[GetDataCol(NewCol)].ReadOnly) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           GridCols[GetDataCol(NewCol)].Visible then Break;

        if ((not CheckEdit) or (GridMode = gmListBox)) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           GridCols[GetDataCol(NewCol)].Visible then Break;

        if (GridCols[GetDataCol(NewCol)].ReadOnly and not SkipReadOnly) then break;

        Inc(NewCol);
    end;

    Result := (NewCol <= Cols);
end;

function TtsBaseGrid.GetPrevCol(DisplayCol: Longint; CheckEdit, CheckSelect: Boolean;
                                var NewCol: Longint): Boolean;
var theCol : TtsCol;
begin                   
    NewCol := DisplayCol - 1;
    if NewCol > Cols then NewCol := Cols;

    while NewCol > 0 do
    begin
        theCol := Self.Col[GetDataCol(NewCol)];
        if (not theCol.ReadOnly) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           theCol.Visible then
           Break;

        if ((not CheckEdit) or (GridMode = gmListBox)) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           theCol.Visible then
           Break;
       { if (not GridCols[GetDataCol(NewCol)].ReadOnly) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           GridCols[GetDataCol(NewCol)].Visible then Break;

        if ((not CheckEdit) or (GridMode = gmListBox)) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(NewCol, -1)) and
           GridCols[GetDataCol(NewCol)].Visible then Break; }

        Dec(NewCol);
    end;

    Result := (NewCol > 0);
end;

function TtsBaseGrid.LeftMostCol(CheckEdit, CheckSelect: Boolean): Longint;
var
    NewCol: Longint;
begin
    GetNextCol(0, CheckEdit, CheckSelect, NewCol);
    if NewCol <= Cols
        then Result := NewCol
        else Result := 0;
end;

function TtsBaseGrid.LeftMostScrollCol: Longint;
var
    NewCol: Longint;
begin
    GetNextCol(FixedCols - 1, False, False, NewCol);
    if NewCol <= Cols
        then Result := NewCol
        else Result := 0;
end;

function TtsBaseGrid.RightMostCol(CheckEdit, CheckSelect: Boolean): Longint;
var
    NewCol: Longint;
begin
    GetPrevCol(Cols + 1, CheckEdit, CheckSelect, NewCol);
    Result := NewCol;
end;

function TtsBaseGrid.GetNextRow(DisplayRow: Longint; CheckEdit, CheckSelect: Boolean;
                                var NewRow: Longint): Boolean;
begin
    NewRow := DisplayRow + 1;
    if NewRow < 1 then NewRow := 1;

    while NewRow <= RowCount - 1 do
    begin
        if (not IsRowReadOnly(GetDataRow(NewRow))) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(-1, NewRow)) and
           IsRowVisible(GetDataRow(NewRow)) then Break;

        if ((not CheckEdit) or (GridMode = gmListBox)) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(-1, NewRow)) and
           IsRowVisible(GetDataRow(NewRow)) then Break;

        Inc(NewRow);
    end;

    Result := (NewRow <= RowCount - 1);
end;

function TtsBaseGrid.GetPrevRow(DisplayRow: Longint; CheckEdit, CheckSelect: Boolean;
                                var NewRow: Longint): Boolean;
begin
    NewRow := DisplayRow - 1;
    if NewRow > RowCount - 1 then NewRow := RowCount - 1;

    while NewRow > 0 do
    begin
        if (not IsRowReadOnly(GetDataRow(NewRow))) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(-1, NewRow)) and
           IsRowVisible(GetDataRow(NewRow)) then Break;

        if ((not CheckEdit) or (GridMode = gmListBox)) and
           (((not CheckSelect) and (GridMode <> gmListBox)) or CanSelect(-1, NewRow)) and
           IsRowVisible(GetDataRow(NewRow)) then Break;

        Dec(NewRow);
    end;

    Result := (NewRow > 0);
end;

function TtsBaseGrid.TopMostRow(CheckEdit, CheckSelect: Boolean): Longint;
var
    NewRow: Longint;
begin
    GetNextRow(0, CheckEdit, CheckSelect, NewRow);
    if NewRow <= Rows
        then Result := NewRow
        else Result := 0;
end;

function TtsBaseGrid.TopMostScrollRow: Longint;
var
    NewRow: Longint;
begin
    GetNextRow(FixedRows - 1, False, False, NewRow);
    if NewRow <= Rows
        then Result := NewRow
        else Result := FixedRows;
end;

function TtsBaseGrid.BottomMostRow(CheckEdit, CheckSelect: Boolean): Longint;
var
    NewRow: Longint;
begin
    if not GetPrevRow(Rows + 1, CheckEdit, CheckSelect, NewRow) then
    begin
        if (GridMode = gmEditInsert) then NewRow := RowCount - 1;
    end;
    Result := NewRow;
end;

function TtsBaseGrid.GetNextCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                 var NewCol, NewRow: Longint): Boolean;
var
    CellFound: Boolean;
    ACol, ARow: Longint;
begin
    Result := False;
    NewCol := 0;
    NewRow := 0;

    ARow := DisplayRow;
    if (ARow < 0) or (ARow > RowCount - 1) then Exit;

    if ARow = 0 then
    begin
        GetNextRow(ARow, False, False, ARow);
        ACol := 0;
    end
    else
        ACol := DisplayCol;

    CellFound := False;
    while (ARow <= RowCount - 1) do
    begin
        CellFound := GetNextCol(ACol, False, False, ACol);
        if CellFound and
           ((not CheckEdit) or CanEditCell(GetDataCol(ACol), GetDataRow(ARow))) then
        begin
            Break;
        end;

        if not CellFound then
        begin
            if not GetNextRow(ARow, False, False, ARow) then Break;
            ACol := 0;
        end
    end;

    Result := CellFound;
    if Result then
    begin
        NewCol := ACol;
        NewRow := ARow;
    end;
end;

function TtsBaseGrid.GetNextDownCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                     var NewCol, NewRow: Longint): Boolean;
var
    CellFound: Boolean;
    ACol, ARow: Longint;
begin
    CellFound := False;
    ARow := DisplayRow;
    ACol := Cols;
    while GetNextCell(ACol, ARow, CheckEdit, ACol, ARow) do
    begin
        if ACol = DisplayCol then
        begin
            CellFound := True;
            Break;
        end;
    end;

    Result := CellFound;
    if Result then
    begin
        NewCol := ACol;
        NewRow := ARow;
    end;
end;

function TtsBaseGrid.GetPrevCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                 var NewCol, NewRow: Longint): Boolean;
var
    CellFound: Boolean;
    ACol, ARow: Longint;
begin
    Result := False;
    NewCol := 0;
    NewRow := 0;

    ARow := DisplayRow;
    ACol := DisplayCol;
    if (ARow < 0) or (ARow > RowCount - 1) or (ACol > Cols + 1) then Exit;

    CellFound := False;
    while (ARow > 0) do
    begin
        CellFound := GetPrevCol(ACol, False, False, ACol);
        if CellFound and
           ((not CheckEdit) or CanEditCell(GetDataCol(ACol), GetDataRow(ARow))) then
        begin
            Break;
        end;

        if not CellFound then
        begin
            if not GetPrevRow(ARow, False, False, ARow) then Break;
            ACol := ColCount;
        end
    end;

    Result := CellFound;
    if Result then
    begin
        NewCol := ACol;
        NewRow := ARow;
    end;
end;

function TtsBaseGrid.GetNextUpCell(DisplayCol, DisplayRow: Longint; CheckEdit: Boolean;
                                   var NewCol, NewRow: Longint): Boolean;
var
    CellFound: Boolean;
    ACol, ARow: Longint;
begin
    CellFound := False;
    ARow := DisplayRow;
    ACol := 1;
    while GetPrevCell(ACol, ARow, CheckEdit, ACol, ARow) do
    begin
        if ACol = DisplayCol then
        begin
            CellFound := True;
            Break;
        end;
    end;

    Result := CellFound;
    if Result then
    begin
        NewCol := ACol;
        NewRow := ARow;
    end;
end;

procedure TtsBaseGrid.MoveToNewCol(DisplayCol: Longint; ClearFocus, CheckEdit, CheckSelect: Boolean);
var
    ACol: Longint;
    NewCol: Longint;
begin
    NewCol := 0;
    if GetNextCol(DisplayCol - 1, CheckEdit, CheckSelect, ACol) then
        NewCol := ACol
    else if GetPrevCol(DisplayCol, CheckEdit, CheckSelect, ACol) then
        NewCol := ACol;

    if NewCol = 0 then NewCol := LeftMostCol(False, False);
    if NewCol > Cols then NewCol := 0;

    if (NewCol <> FCurDisplayCol) or (FCurDataCol <> GetDataCol(NewCol)) then
    begin
        CheckHideControl(True);
        if ClearFocus then ClearCurrentFocusRect(False);
        SetCurrentPosition(NewCol, FCurDisplayRow, True, True);
    end;

    ClearControlBuffer;
    SetControlSelectMode(tsAll);
    ShowGridControl;
    DrawCurrentFocusRect(False);
    CheckRowColChanged;
end;

procedure TtsBaseGrid.MoveToNewRow(DisplayRow: Longint; ClearFocus, CheckEdit, CheckSelect: Boolean);
var
    ARow: Longint;
    NewRow: Longint;
begin
    NewRow := 0;
    if GetNextRow(DisplayRow - 1, CheckEdit, CheckSelect, ARow) then
    begin
        NewRow := ARow;
        if IsInsertRow(NewRow) then
        begin
            GetPrevRow(Rows + 1, CheckEdit, CheckSelect, NewRow);
        end
    end
    else if GetPrevRow(DisplayRow, CheckEdit, CheckSelect, ARow) then
        NewRow := ARow;

    if NewRow > Rows then NewRow := Rows;
    if (NewRow <> FCurDisplayRow) or (FCurDataRow <> GetDataRow(NewRow)) then
    begin
        CheckHideControl(True);
        if ClearFocus then ClearCurrentFocusRect(False);
        ClearCurrent(FCurDisplayRow);
        SetCurrentPosition(FCurDisplayCol, NewRow, True, True);
        if IsRowSelected(GetDataRow(NewRow)) then DrawCurrentSelected(NewRow)
                                             else DrawCurrent(NewRow);
    end;

    ClearControlBuffer;
    SetControlSelectMode(tsAll);
    ShowGridControl;
    DrawCurrentFocusRect(False);
    CheckRowColChanged;
end;

procedure TtsBaseGrid.CheckRowColPos;
begin
    MoveToNewCol(FCurDisplayCol, False, CanSkipReadOnly, InRowSelectMode);
    MoveToNewRow(FCurDisplayRow, False, CanSkipReadOnly, InRowSelectMode);
end;

procedure TtsBaseGrid.SetNewCurrentCell(DataCol, DataRow: Longint);
var
    OldRow: Longint;
    NewCurrentRow, NewCurrentCol: Longint;
begin
    NewCurrentCol := FCurDisplayCol;
    NewCurrentRow := FCurDisplayRow;

    if FCurDisplayRow <> GetDisplayRow(DataRow) then
        NewCurrentRow := GetDisplayRow(DataRow);

    if FCurDisplayCol <> GetDisplayCol(DataCol) then
        NewCurrentCol := GetDisplayCol(DataCol);

    if (NewCurrentRow <> FCurDisplayRow) or (NewCurrentCol <> FCurDisplayCol) then
    begin
        OldRow := FCurDisplayRow;
        ClearCurrentFocusRect(False);
        SetCurrentPosition(NewCurrentCol, NewCurrentRow, True, True);
        DrawCurrentFocusRect(False);
        CheckRowColChanged;
        if OldRow <> FCurDisplayRow then DrawCurrent(FCurDisplayRow);
    end
    else if (FCurDataCol <> DataCol) or (FCurDataRow <> DataRow) then
    begin
        PositionCell(FCurDisplayCol, FCurDisplayRow);
        CheckRowColChanged;
    end;
end;

function TtsBaseGrid.StartCellEdit: Boolean;
var
    Cancel: Boolean;
begin
    Cancel := False;
    if (not CellEditing) then DoStartCellEdit(FCurDataCol, FCurDataRow, Cancel);
    Result := not Cancel;
end;

function TtsBaseGrid.StartRowEdit: Boolean;
var
    Cancel: Boolean;
begin
    Cancel := False;
    if (not RowEditing) then
    begin
        DoStartRowEdit(FCurDataRow, Cancel);
        if not Cancel and StoreData then
            FGridData.BackupRow(FCurDataRow);
    end;

    Result := not Cancel;
end;

procedure TtsBaseGrid.CellEdit(DataCol, DataRow: Longint; ByUser: Boolean);
var
    ControlType: TtsControlType;
begin
    if StoreData then
    begin
        ControlType := GiveCellControlType(DataCol, DataRow);
        SetDataValue(DataCol, DataRow, ControlType, CurrentCell.Value);
    end;
    DoCellEdit(DataCol, DataRow, ByUser);
end;

function TtsBaseGrid.EndCellEdit: Boolean;
var
    Cancel: Boolean;
begin
    try
        DoEndCellEdit(FCurDataCol, FCurDataRow, Cancel);
        Result := not Cancel;
    except
        Result := False;
    end;
end;

function TtsBaseGrid.CheckMaskValue: Boolean;
var
    Text: string;
    Mask: TtsMaskItem;
    InsertChars: string;
begin
    Result := True;
    if CurCellControlType <> ctText then Exit;

    Mask := FMaskLink.Mask[CurCellMaskName];
    if Mask = nil then Exit;
    if not (mcOnExit in Mask.Evaluate) then Exit;

    InsertChars := '';
    Text := CurrentCell.Value;
    Result := Mask.ValidInput(Text, InsertChars, Length(Text) + 1,
                              True, mcOnExit in Mask.AutoFill);
    if Result then
    begin
        if InsertChars <> '' then
        begin
            Text := Text + InsertChars;
            SetCurrentValue(Text, False, True);
            CurrentCell.SelStart := Length(Text);
        end;
    end
    else
        ActivateInvalidMaskValue(Result);
end;

function TtsBaseGrid.EndRowEdit: Boolean;
var
    Cancel: Boolean;
begin
    DoEndRowEdit(FCurDataRow, Cancel);
    Result := not Cancel;
    if Result and StoreData then FGridData.ClearBackupRow;
end;

function TtsBaseGrid.StartEdit: Boolean;
begin
    Result := False;
    if not InEditState then Exit;

    Result := StartCellEdit;
    if Result then Result := StartRowEdit;

    if Result then
    begin
        FCellEditing := True;
        FRowEditing := True;
        FCurRowChanged := True;
        InvalidateRow(CurDisplayRow);
    end;
end;

function TtsBaseGrid.Edit: Boolean;
begin
    Result := StartEdit;
end;

function TtsBaseGrid.EditRow: Boolean;
begin
    Result := RowEditing;
    if Result then Exit;

    Result := StartRowEdit;
    if Result then
    begin
        FRowEditing := True;
        FCurRowChanged := True;
    end;
end;

procedure TtsBaseGrid.DoPaint;
begin
    if Assigned(FOnPaint) then FOnPaint(Self);
end;

procedure TtsBaseGrid.DoResize;
begin
    if Assigned(FOnResize) and CanActivateEvent then FOnResize(Self);
end;

procedure TtsBaseGrid.DoHeadingDown(DataCol: Longint; Button: TMouseButton);
begin
    if Assigned(FOnHeadingDown) then FOnHeadingDown(Self, DataCol);
end;

procedure TtsBaseGrid.DoHeadingUp(DataCol: Longint; Button: TMouseButton);
begin
    if Assigned(FOnHeadingUp) then FOnHeadingUp(Self, DataCol);
end;

procedure TtsBaseGrid.DoHeadingClick(DataCol: Longint);
begin
    if Assigned(FOnHeadingClick) then FOnHeadingClick(Self, DataCol);
end;

procedure TtsBaseGrid.DoColMoved(ToDisplayCol, Count: Longint; ByUser: Boolean);
begin
    if Assigned(FOnColMoved) and CanActivateEvent then FOnColMoved(Self, ToDisplayCol, Count, ByUser);
end;

procedure TtsBaseGrid.DoRowMoved(ToDisplayRow, Count: Longint; ByUser: Boolean);
begin
    if Assigned(FOnRowMoved) and CanActivateEvent then FOnRowMoved(Self, ToDisplayRow, Count, ByUser);
end;

procedure TtsBaseGrid.DoColChanged(OldCol, NewCol: Longint);
begin
    if Assigned(FOnColChanged) and CanActivateEvent then FOnColChanged(Self, OldCol, FCurDataCol);
end;

procedure TtsBaseGrid.DoSelectChanged(SelectType: TtsSelectType; ByUser: Boolean);
begin
    if Assigned(FOnSelectChanged) and CanActivateEvent then FOnSelectChanged(Self, SelectType, ByUser);
end;

procedure TtsBaseGrid.DoColCountChanged(OldCount, NewCount: Longint);
begin
    if Assigned(FOnColCountChanged) and CanActivateEvent then FOnColCountChanged(Self, OldCount, NewCount);
end;

procedure TtsBaseGrid.DoRowCountChanged(OldCount, NewCount: Longint);
begin
    if Assigned(FOnRowCountChanged) and CanActivateEvent then FOnRowCountChanged(Self, OldCount, NewCount);
end;

procedure TtsBaseGrid.DoColResized(DataCol: Longint);
begin
    if Assigned(FOnColResized) and CanActivateEvent then FOnColResized(Self, DataCol);
end;

procedure TtsBaseGrid.DoRowResized(DataRow: Longint);
begin
    if Assigned(FOnRowResized) and CanActivateEvent then FOnRowResized(Self, DataRow);
end;

procedure TtsBaseGrid.DoCanStartDrag;
begin
    if Assigned(FOnCanStartDrag) then FOnCanStartDrag(Self);
end;

procedure TtsBaseGrid.DoMouseStatusChanged(OldStatus, NewStatus: TtsMouseStatus);
begin
    if Assigned(FOnMouseStatusChanged) then
        FOnMouseStatusChanged(Self, OldStatus, NewStatus);
end;

procedure TtsBaseGrid.DoGridStatusChanged(OldStatus, NewStatus: TtsGridStatus);
begin
    if Assigned(FOnGridStatusChanged) then
        FOnGridStatusChanged(Self, OldStatus, NewStatus);
end;

procedure TtsBaseGrid.DoEditTextResized(ByUser: Boolean);
begin
    if Assigned(FOnEditTextResized) then FOnEditTextResized(Self, ByUser);
end;

procedure TtsBaseGrid.DoDeleteCol(DataCol: Longint; ByUser: Boolean);
begin
    if Assigned(FOnDeleteCol) and CanActivateEvent then FOnDeleteCol(Self, DataCol, ByUser);
end;

procedure TtsBaseGrid.DoInsertCol(DataCol: Longint; ByUser: Boolean);
begin
    if Assigned(FOnInsertCol) and CanActivateEvent then FOnInsertCol(Self, DataCol, ByUser);
end;

procedure TtsBaseGrid.DoComboCompareValue(ComboString, CurrentCellString: string; var CompareRes: Integer);
begin
    if Assigned(FOnComboCompareValue) then
        FOnComboCompareValue(Self, ComboString, CurrentCellString, CompareRes);
end;

procedure TtsBaseGrid.DoComboLCompareValue(ComboString, CurrentCellString: string; Len: Integer; var CompareRes: Integer);
begin
    if Assigned(FOnComboLCompareValue) then
        FOnComboLCompareValue(Self, ComboString, CurrentCellString, Len, CompareRes);
end;

procedure TtsBaseGrid.DoKeyDown(var Key: Word; Shift: TShiftState);
begin
    if Assigned(OnKeyDown) then OnKeyDown(Self, Key, Shift);
end;

procedure TtsBaseGrid.DoKeyUp(var Key: Word; Shift: TShiftState);
begin
    if Assigned(OnKeyUp) then OnKeyUp(Self, Key, Shift);
end;

procedure TtsBaseGrid.DoKeyPress(var Key: Char);
begin
    if Assigned(OnKeyPress) then OnKeyPress(Self, Key);
end;

procedure TtsBaseGrid.ActivateInvalidMaskValue(var Accept: Boolean);
begin
    DoInvalidMaskValue(CurDataCol, CurDataRow, Accept)
end;

procedure TtsBaseGrid.ActivateInvalidMaskEdit(Keys: string; var Accept: Boolean);
begin
    DoInvalidMaskEdit(Keys, CurDataCol, CurDataRow, Accept);
end;

{$IFDEF TSVER_V4}
function TtsBaseGrid.DoMouseWheelDown(Shift: TShiftState; MousePos: TPoint): Boolean;
var
    Msg: TWMVScroll;
    I, Count, ScrollLines: Integer;
begin
    Result := inherited DoMouseWheelDown(Shift, MousePos);
    if not Result then
    begin
        if (Shift = []) then
        begin
            ScrollLines := 0;
            SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @ScrollLines, 0);
            Count := CalcMax(1, ScrollLines);
            Count := CalcMin(Count, VisibleRowCount);

            Msg.Msg := WM_VSCROLL;
            Msg.Pos := 0;
            Msg.ScrollCode := SB_LINEDOWN;
            for I := 1 to Count do Dispatch(Msg);

            if (Abs(WheelAccumulator) < WHEEL_DELTA) then
            begin
                Msg.ScrollCode := SB_ENDSCROLL;
                Dispatch(Msg);
            end;
            Result := True;
        end;
    end;
end;

function TtsBaseGrid.DoMouseWheelUp(Shift: TShiftState; MousePos: TPoint): Boolean;
var
    Msg: TWMVScroll;
    I, Count, ScrollLines: Integer;
begin
    Result := inherited DoMouseWheelUp(Shift, MousePos);
    if not Result then
    begin
        if (Shift = []) then
        begin
            ScrollLines := 0;
            SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @ScrollLines, 0);
            Count := CalcMax(1, ScrollLines);
            Count := CalcMin(Count, VisibleRowCount);

            Msg.Msg := WM_VSCROLL;
            Msg.Pos := 0;
            Msg.ScrollCode := SB_LINEUP;
            for I := 1 to Count do Dispatch(Msg);

            if (Abs(WheelAccumulator) < WHEEL_DELTA) then
            begin
                Msg.ScrollCode := SB_ENDSCROLL;
                Dispatch(Msg);
            end;
            Result := True;
        end;
    end;
end;
{$ENDIF}

procedure TtsBaseGrid.CtrlOnEdit(Sender : TObject; var Cancel : Boolean);
begin
    Cancel := not StartCellEdit;
    if not Cancel then Cancel := not StartRowEdit;
end;

procedure TtsBaseGrid.CtrlOnCanChange(Sender : TObject; Edit: Boolean; var Cancel : Boolean);
begin
    Cancel := False;
    if (not FInCellLoaded) and EnableStartEdit and Edit then
        Cancel := not StartCellChange(FCurDataCol, True);
end;

procedure TtsBaseGrid.CtrlOnNotifyChanged(Sender: TObject; DataChanged: Boolean);
var
    ControlType: TtsControlType;
begin
    FCurrentCell.FSelStart := FGridControl.SelStart;
    FCurrentCell.FSelLength := FGridControl.SelLength;
    if DataChanged then
    begin
        FCurrentCell.SetBuffer(FGridControl.Value, False);
        if StoreData then
        begin
            ControlType := GiveCellControlType(CurrentDataCol, CurrentDataRow);
            SetDataValue(CurrentDataCol, CurrentDataRow, ControlType, CurrentCell.Value);
        end;
    end;
end;

procedure TtsBaseGrid.CtrlOnChanged(Sender : TObject; Edit, ByUser, TextAdded: Boolean);
begin
    ControlValueChanged(Edit, ByUser, TextAdded);
end;

function TtsBaseGrid.CheckUndoRowEdit(UndoAll: Boolean; var RowEditing: Boolean): Boolean;
begin
    RowEditing := FRowEditing and (UndoAll or (not FCellEditing) or (not FRowEdited));
    Result := RowEditing;
end;

function TtsBaseGrid.UndoEdit(UndoAll: Boolean; ByUser: Boolean; var Restore, UndoDone: Boolean): Boolean;
var
    UndoRow: Boolean;
    UndoCell: Boolean;
    RowEditing: Boolean;
begin
    FInUndoEdit := True;
    try
        UndoRow := CheckUndoRowEdit(UndoAll, RowEditing);
        UndoCell := FCellEditing;
        UndoDone := UndoRow or UndoCell;

        Result := True;
        if UndoCell then Result := UndoCellEdit(ByUser);
        if Result and UndoRow then Result := UndoRowEdit(ByUser, RowEditing);
        if not Result then Exit;

        Restore := True;
        if (UndoCell and not ByUser) or (not UndoCell and UndoRow) then
        begin
            ClearControlBuffer;
            Restore := False;
        end;

        if UndoRow then
        begin
            FCellEditing := False;
            FRowEditing := False;
            FRowEdited := False;
            FCurRowChanged := False;

            if IsInsertRow(FCurDisplayRow + 1) and
               not (IsRowChanged(FCurDisplayRow)) and (FInsertRowEdit) then
            begin
                FInsertRowEdit := False;
                SetInsertionRow(0);
                SetNewRowCount(Rows);
                InvalidateRow(FCurDisplayRow);
            end
            else
                InvalidateRow(FCurDisplayRow);
        end
        else if FCellEditing then
        begin
            FCellEditing := False;
            InvalidateCell(FCurDisplayCol, FCurDisplayRow);
        end;
    finally
        FInUndoEdit := False;
    end;
end;

function TtsBaseGrid.UndoCellEdit(ByUser: Boolean): Boolean;
var
    Cancel: Boolean;
begin
    DoUndoCellEdit(FCurDataCol, FCurDataRow, ByUser, Cancel);
    Result := not Cancel;
end;

function TtsBaseGrid.UndoRowEdit(ByUser: Boolean; RowEditing: Boolean): Boolean;
var
    Cancel: Boolean;
begin
    Result := True;
    if RowEditing then
    begin
        DoUndoRowEdit(FCurDataRow, ByUser, Cancel);
        Result := not Cancel;
        if Result and StoreData then
            FGridData.RestoreBackupRow(FCurDataRow);
    end;
end;

procedure TtsBaseGrid.CtrlOnUndoChanged(Sender : TObject; ByUser: Boolean; var Cancel: Boolean);
var
    Restore, UndoDone: Boolean;
    IsCombo: Boolean;
begin
    if DropDownVisible then
    begin
        IsCombo := ComboVisible;
        Cancel := True;
        CheckDropDownOff(False);
        if IsCombo then
        begin
            Combo.FGrid.MouseCapture := False;
            Combo.FGrid.SetMouseStatus(msNormal);
        end;
    end
    else
    begin
        Cancel := not UndoEdit(False, ByUser, Restore, UndoDone);
        Cancel := Cancel or (not Restore);
    end;
end;

procedure TtsBaseGrid.CtrlOnWantKey(Sender : TObject; Key: Word; var WantKey: Boolean);
begin
    WantKey := True;
    if Key <> VK_ESCAPE then Exit;

    WantKey := (CellEditing or RowEditing) or
               (not (FMouseStatus in [msNormal, msButtonDown])) or
               (FComboSearchValue <> '') or
               DropDownVisible or
               IsInsertRow(FCurDisplayRow);
end;

procedure TtsBaseGrid.CtrlOnInvalidMaskEdit(Sender : TObject; Keys: string; var Accept: Boolean);
begin
    ActivateInvalidMaskEdit(Keys, Accept);
end;

procedure TtsBaseGrid.CtrlOnEditTextResized(Sender : TObject; ByUser: Boolean);
begin
    DoEditTextResized(ByUser);
end;

procedure TtsBaseGrid.CtrlOnKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
    CanProcessKey := False;
    try
        KeyDown(Key, Shift);
    finally
        CanProcessKey := True;
    end;
end;

procedure TtsBaseGrid.CtrlOnKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
    KeyUp(Key, Shift);
end;

procedure TtsBaseGrid.CtrlOnKeyPress(Sender: TObject; var Key: Char);
begin
    CanProcessKey := False;
    try
        KeyPress(Key);
    finally
        CanProcessKey := True;
    end;
end;

procedure TtsBaseGrid.CtrlOnClick(Sender: TObject);
begin
    if Assigned(OnClick) then OnClick(Self);
    SetMouseUpColRow(FCurDisplayCol, FCurDisplayRow);
    ClickCell(FCurDataCol, FCurDataRow, FCurDataCol, FCurDataRow);
end;

procedure TtsBaseGrid.CtrlOnDblClick(Sender: TObject);
begin
    if Assigned(OnDblClick) then OnDblClick(Self);
    DblClickCell(FCurDataCol, FCurDataRow);
end;

{$IFDEF TSVER_V5}
procedure TtsBaseGrid.DoContextPopup(MousePos: TPoint; var Handled: Boolean);
begin
  inherited DoContextPopup(MousePos, Handled);
  if Handled then exit;

  if ((Self.FGridReport <> Nil) and (FGridReport.ProvideGridMenu)) or
     ProvideGridMenu then
  begin
     ShowGridMenu(MousePos.X, MousePos.Y);
     Handled := True;
  end;
end;
{$ENDIF}

procedure TtsBaseGrid.CtrlOnMouseDown(Sender: TObject; Button: TMouseButton;
                                      Shift: TShiftState; X, Y: Integer);
var
    Pnt: TPoint;
    DisplayCol, DisplayRow: Longint;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    if IsFocused or (not CheckMouseFocus) then
    begin
        Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
        if (Button = mbLeft) then
        begin
            SetMouseDownColRow(FCurDisplayCol, FCurDisplayRow);
            if (not FGridControl.KeyEdit) then
            begin
                CellFromXY(Pnt.X, Pnt.Y, DisplayCol, DisplayRow);
                ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
                if (ButtonType in [btCombo, btDateTimeDropDown]) and (DropDownStyle = ddDropDownList) then
                begin
                    MDButtonDown(Shift, Pnt.X, Pnt.Y, DisplayCol, DisplayRow);
                    MouseCapture := True;
                end;
            end;
        end;
    end;

    if Assigned(OnMouseDown) then OnMouseDown(Self, Button, Shift, Pnt.X, Pnt.Y);
end;

procedure TtsBaseGrid.CtrlOnMouseUp(Sender: TObject; Button: TMouseButton;
                                  Shift: TShiftState; X, Y: Integer);
var
    Pnt: TPoint;
begin
    Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
    if Assigned(OnMouseUp) then OnMouseUp(Self, Button, Shift, Pnt.X, Pnt.Y);
end;

procedure TtsBaseGrid.CtrlOnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
    Pnt: TPoint;
begin
    Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
    if Assigned(OnMouseMove) then OnMouseMove(Self, Shift, Pnt.X, Pnt.Y);
end;

procedure TtsBaseGrid.CtrlOnDragDrop(Sender, Source: TObject; X, Y: Integer);
var
    Pnt: TPoint;
begin
    Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
    if Assigned(OnDragDrop) then OnDragDrop(Self, Source, Pnt.X, Pnt.Y);
end;

procedure TtsBaseGrid.CtrlOnDragOver(Sender, Source: TObject; X, Y: Integer;
                                       State: TDragState; var Accept: Boolean);
var
    Pnt: TPoint;
begin
    Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
    if Assigned(OnDragOver) 
        then OnDragOver(Self, Source, Pnt.X, Pnt.Y, State, Accept)
        else Accept := False;
end;

procedure TtsBaseGrid.CtrlOnEndDrag(Sender, Target: TObject; X, Y: Integer);
var
    Pnt: TPoint;
begin
    Pnt := ScreenToClient(TControl(Sender).ClientToScreen(Point(X, Y)));
    if Assigned(OnEndDrag) then OnEndDrag(Self, Target, Pnt.X, Pnt.Y);
end;

procedure TtsBaseGrid.CtrlOnStartDrag(Sender: TObject; var DragObject: TDragObject);
begin
    if Assigned(OnStartDrag) then OnStartDrag(Self, DragObject);
end;

procedure TtsBaseGrid.CtrlOnKillFocus(Sender: TObject);
begin
end;

procedure TtsBaseGrid.CtrlOnEndKeyDown(Sender : TObject; var Key : Word; Shift : TShiftState);
begin
    ProcessKeyDown(Key, Shift);
end;

procedure TtsBaseGrid.CtrlOnEndKeyPress(Sender : TObject; var Key : Char);
begin
    if Key in [#32..#255] then
        ProcessKeyDropDownList(Key);
end;

function TtsBaseGrid.CanEndCellEdit(ByUser: Boolean): Boolean;
begin
    Result := True;
    if FCellEditing then
    begin
        CheckSetAutoFillValue;
        if not CheckMaskValue then
        begin
            Result := False;
            Exit;
        end;

        if not EndCellEdit then
        begin
            Result := False;
            Exit;
        end;

        ResetCellEdit;
    end;
end;

function TtsBaseGrid.CanEndRowEdit(ByUser: Boolean): Boolean;
begin
    Result := True;
    if FRowEditing then
    begin
        if not EndRowEdit then
        begin
            Result := False;
            Exit;
        end;

        ResetEdit(FCurDataRow);
    end;
end;

function TtsBaseGrid.CanEndEdit(ByUser: Boolean): Boolean;
begin
    Result := CanEndCellEdit(ByUser);
    if Result then Result := CanEndRowEdit(ByUser);
end;

function TtsBaseGrid.EndEdit(Undo: Boolean): Boolean;
var
    Restore, UndoDone: Boolean;
begin
    if not Undo then
        Result := CheckEndEdit(-1, -1, False)
    else
        Result := UndoEdit(True, False, Restore, UndoDone);
end;

function TtsBaseGrid.CheckEndEdit(NewDataCol, NewDataRow: Longint; ByUser: Boolean): Boolean;
begin
    Result := True;
    if FInCheckEndEdit then Exit;

    FInCheckEndEdit := True;
    try
        if CellEditing or RowEditing then
        begin
            if NewDataRow <> FCurDataRow then
                Result := CanEndEdit(ByUser)
            else if NewDataCol <> FCurDataCol then
                Result := CanEndCellEdit(ByUser);
        end;
    finally
        FInCheckEndEdit := False;
    end;
end;

procedure TtsBaseGrid.ResetCellEdit;
begin
    if FCellEditing then
    begin
        FRowEdited := True;
        FCellEditing := False;
    end;
end;

procedure TtsBaseGrid.ResetEdit(DataRow: Longint);
begin
    if FRowEditing then
    begin
        if (DataRow >= 1) and (DataRow <= Rows) and (RowChangedIndicator = riOn) then
            FChangedRows.Bits[DataRow] := FChangedRows.Bits[DataRow] or FCurRowChanged;

        FRowEditing := False;
        FRowEdited := False;
        FCellEditing := False;
        FInsertRowEdit := False;
        FCurRowChanged := False;
    end;
end;

procedure TtsBaseGrid.UndoInsertRow;
begin
    if (GridMode <> gmEditInsert) or (InsertionRow <> 0) then Exit;

    SetInsertionRow(1);
    FRows := FRows - 1;
    CheckRowCountChanged(Rows + 1, Rows);
    DeleteRowData(Rows + 1, Rows + 1);
    RowDeleted(Rows + 1, True);
    InvalidateRow(RowCount - 1);
end;

procedure TtsBaseGrid.CheckInsertionRow(CanInvalidate: Boolean);
begin
    if GridMode <> gmEditInsert then Exit;

    if (FCurDataRow = RowCount - 1) then
    begin
        if (InsertionRow = 1) then
        begin
            SetInsertionRow(0);
            FRows := FRows + 1;
            CheckRowCountChanged(Rows - 1, Rows);
            RowInserted(Rows, True);
            if CanInvalidate then InvalidateRow(RowCount - 1);
        end;
    end
    else if (FOldDataRow = RowCount - 1) then
    begin
        if (InsertionRow = 0) then UndoInsertRow;
    end;
end;

function TtsBaseGrid.CheckColChanged(var OldCol: Longint): Boolean;
begin
    Result := False;
    OldCol := FOldDataCol;
    if FOldDataCol <> FCurDataCol then
    begin
        FOldDataCol := FCurDataCol;
        if (GridMode <> gmListBox) then DoColChanged(OldCol, FCurDataCol);
        Result := True;
    end;
end;

function TtsBaseGrid.CheckRowChanged(var OldRow: Variant): Boolean;
begin
    Result := False;
    OldRow := FOldDataRow;
    if FOldDataRow <> FCurDataRow then
    begin
        FOldDataRow := FCurDataRow;
        DoRowChanged(OldRow, FCurDataRow);
        Result := True;
    end;
end;

procedure TtsBaseGrid.ActivateCellChanged(OldCol: Integer; OldRow: Variant);
begin
    DoCellChanged(OldCol, FCurDataCol, OldRow, FCurDataRow);
end;

procedure TtsBaseGrid.CheckRowColChanged;
var
    OldCol: Longint;
    OldRow: Variant;
    CellChanged: Boolean;
begin
    CellChanged := CheckColChanged(OldCol);
    if CheckRowChanged(OldRow) then CellChanged := True;
    if CellChanged then
    begin
        FComboInitialized := False;
        FDateTimeInitialized := False;
        ResetComboSearchValue;
        ActivateCellChanged(OldCol, OldRow);
    end;
end;

procedure TtsBaseGrid.GridStatusChanged;
var
    OldStatus: TtsGridStatus;
begin
    if (FOldGridStatus = FGridStatus) then Exit;

    if FGridStatus <> grNormal then
    begin
        ClearControlBuffer;
        CheckDisableControl;
        SetControlSelectMode(tsAll);
    end;

    OldStatus := FOldGridStatus;
    FOldGridStatus := FGridStatus;
    DoGridStatusChanged(OldStatus, FGridStatus);
end;

procedure TtsBaseGrid.MouseStatusChanged;
var
    OldStatus: TtsMouseStatus;
begin
    if (FOldMouseStatus = FMouseStatus) then Exit;

    if InEditMode and
       (FMouseStatus in [msRowSelect, msColSelect, msCellSelect, msAllRowSelect]) then
    begin
        InvalidateCell(CurDisplayCol, CurDisplayRow);
    end;

    OldStatus := FOldMouseStatus;
    FOldMouseStatus := FMouseStatus;
    DoMouseStatusChanged(OldStatus, FMouseStatus);
end;

procedure TtsBaseGrid.SetMouseStatus(Status: TtsMouseStatus);
begin
    FMouseStatus := Status;
    MouseStatusChanged;
end;

procedure TtsBaseGrid.ResetChangedRowStatus;
begin
    if (FCurDisplayRow >= 1) and (FCurDisplayRow <= RowCount - 1) and
       IsRowChanged(GetDataRow(FCurDisplayRow)) then
        InvalidateCell(0, FCurDisplayRow);

    FChangedRows.Size := 0;
    FChangedRows.Size := RowCount;
end;

function TtsBaseGrid.ShowHorzScrollBar(MaxWidth: Integer): Boolean;
var
    Sum: Integer;
    ACol: Longint;
    NumCols: Integer;
    FixedPos: Integer;
    Found: Boolean;
begin
    Result := False;
    if not HandleAllocated then Exit;
    if not (FScrollBars in [ssBoth, ssHorizontal]) then Exit;

    ACol := FixedCols - 1;
    Sum := FHorzFixedWidth;
    NumCols := 0;
    while (Sum <= MaxWidth) and (ACol < ColCount - 1) do
    begin
        Inc(ACol);
        Sum := Sum + ColWidths[ACol];
        if ColWidths[ACol] > 0 then Inc(NumCols);
    end;

    Result := (Sum > MaxWidth) and (NumCols > 1);
    if (not Result) and (Sum > MaxWidth) then
    begin
        FixedPos := FVisibleCols.Locate(FixedCols, Found);
        Result := FVisibleCols.Count - FixedPos > 0;
    end;
end;

function TtsBaseGrid.ShowVertScrollBar(MaxHeight: Integer): Boolean;
var
    Sum: Integer;
    ARow: Longint;
    NumRows: Integer;
    FixedPos: Integer;
    Found: Boolean;
begin
    Result := False;
    if not HandleAllocated then Exit;
    if not (FScrollBars in [ssBoth, ssVertical]) then Exit;

    ARow := FixedRows - 1;
    Sum := FVertFixedHeight;
    NumRows := 0;
    while (Sum <= MaxHeight) and (ARow < RowCount - 1) do
    begin
        Inc(ARow);
        Sum := Sum + RowHeights[ARow];
        if RowHeights[ARow] > 0 then Inc(NumRows);
    end;

    Result := (Sum > MaxHeight) and (NumRows > 1);
    if (not Result) and (Sum > MaxHeight) then
    begin
        FixedPos := FVisibleRows.Locate(FixedRows, Found);
        Result := FVisibleRows.Count - FixedPos > 0;
    end;
end;

function TtsBaseGrid.CanShowHorzScrollBar: Boolean;
var
    Offset: Integer;
begin
    Result := False;
    if not HandleAllocated then Exit;

    Offset := 0;
    if (not FIsVertVisible) and AlwaysShowVertScrollBar then
        Offset := VertScrollBarWidth;
    Result := ShowHorzScrollBar(ClientWidth - Offset);
end;

function TtsBaseGrid.CanShowVertScrollBar: Boolean;
var
    Offset: Integer;
begin
    Result := False;
    if not HandleAllocated then Exit;

    Offset := 0;
    if (not FIsHorzVisible) and AlwaysShowHorzScrollBar then
        Offset := HorzScrollBarHeight;
    Result := ShowVertScrollBar(ClientHeight - Offset);
end;

function TtsBaseGrid.GetHorzScrollBarVisible: Boolean;
begin
    Result := CanShowHorzScrollBar or AlwaysShowHorzScrollBar;
end;

function TtsBaseGrid.GetVertScrollBarVisible: Boolean;
begin
    Result := CanShowVertScrollBar or AlwaysShowVertScrollBar;
end;

procedure TtsBaseGrid.ClearControlBuffer;
begin
    FCurrentCell.ClearBuffer;
end;

procedure TtsBaseGrid.ClearCellBuffer;
begin
    ClearControlBuffer;
    SetControlSelectMode(tsAll);
end;

procedure TtsBaseGrid.MoveCellBuffer(NewDataCol, NewDataRow: Longint);
begin
    FCurrentCell.FValueCol := NewDataCol;
    FCurrentCell.FValueRow := NewDataRow;
end;

function TtsBaseGrid.StartCellChange(DataCol: Longint; SetModified: Boolean): Boolean;
begin
    Result := True;
end;

procedure TtsBaseGrid.RefreshData(ResetOrder: TtsResetOrder; ResetPosition: TtsResetPosition);
begin
    ClearControlBuffer;
    SetControlSelectMode(tsAll);

    case ResetOrder of
        roCols: ResetColProperties([prDisplayNumber]);
        roRows: ResetRowProperties([prDisplayNumber]);
        roBoth:
            begin
                ResetColProperties([prDisplayNumber]);
                ResetRowProperties([prDisplayNumber]);
            end;
    end;

    EnablePaint := False;
    try
        case ResetPosition of
            rpLeft: LeftCol := FixedCols;
            rpTop: TopRow := FixedRows;
            rpTopLeft: MoveTopLeft(FixedCols, FixedRows);
        end;
    finally
        EnablePaint := True;
    end;

    Refresh;
end;

procedure TtsBaseGrid.ResizeRowChanged;
begin
    FChangedRows.Size := RowCount;
end;

procedure TtsBaseGrid.DeleteColoredColCells(DataCol: Longint);
var
    I: Integer;
    DataRow: Longint;
    RowList: TtsSetList;
    Element: TtsCustomElement;
begin
    if FColCells[DataCol] <> nil then
    begin
        RowList := FColCells[DataCol].List;
        try
            for I := 1 to RowList.Count do
            begin
                DataRow := Longint(RowList.Items[I]^);
                Element := TtsCustomElement(FCellPropSet.Get([DataCol, DataRow]));
                FCellPropSet.DeleteElement(Element);
                FAutoFontCells.RemoveCoord(DataCol, DataRow);
            end;
            FColCells[DataCol].Free;
            FColCells[DataCol] := nil;
        finally
            RowList.Free;
        end;
    end;
end;

procedure TtsBaseGrid.MoveColoredColCells(DataCol: Longint; MaxCol: Longint);
var
    I, J: Integer;
    DataRow: Longint;
    RowList: TtsSetList;
    Element: TtsCellElement;
begin
    for J := (DataCol + 1) to MaxCol do
    begin
        if FColCells[J] <> nil then
        begin
            RowList := FColCells[J].List;
            try
                for I := 1 to RowList.Count do
                begin
                    DataRow := Longint(RowList.Items[I]^);
                    Element := TtsCellElement(FCellPropSet.Get([J, DataRow]));
                    DeleteFromPropList(Element);
                    Element.SetKey(J-1, DataRow);
                    AddToPropList(Element);
                end;
                FColCells[J].Free;
                FColCells[J] := nil;
            finally
                RowList.Free;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.DeleteAutoFontCol(DataCol: Longint);
var
    I, Index: Integer;
    Colnr, Rownr: Integer;
begin
    FAutoFontCols.Remove(DataCol);
    for I := 0 to FAutoFontCols.Count - 1 do
    begin
        Colnr := FAutoFontCols.Item[I];
        if Colnr > DataCol then FAutoFontCols.Item[I] := Colnr - 1;
    end;

    I := 0;
    Index := I;
    while FAutoFontCells.NextCoord(I, Colnr, Rownr) do
    begin
        if Colnr > DataCol then FAutoFontCells.UpdateCoord(Index, Colnr - 1, Rownr);
        Index := I;
    end;
end;

procedure TtsBaseGrid.DeleteAllAtCol(DataCol: Longint; MaxCol: Longint);
var
    I: Integer;
    DisplayCol: Longint;
    OldCol: TtsCol;
begin
    OldCol := GridCols[DataCol];
    DisplayCol := GetDisplayCol(DataCol);

    if FSelectedCols[DisplayCol] then DeleteColSelection(DisplayCol, DisplayCol);

    DeleteSelectedCellsCol(DisplayCol);
    DeleteColoredColCells(DataCol);
    DeleteAutoFontCol(DataCol);
    MoveColoredColCells(DataCol, MaxCol);

    if FVisibleCols.Count <> Cols + FCurDeletedCols then
        FVisibleCols.MoveItem(DisplayCol, MaxCol);

    if DataCol = FCurrentCell.FValueCol then
        ClearControlBuffer
    else if DataCol < FCurrentCell.FValueCol then
        FCurrentCell.FValueCol := FCurrentCell.FValueCol - 1;

    for I := (DisplayCol + 1) to MaxCol do
    begin
        ResizeCol(I-1, ColWidths[I]);

        Dec(GridCols[GetDataCol(I)].FDisplayCol);
        FDataColNumber[I - 1] := FDataColNumber[I];

        if FSelectedCols[I] then
        begin
            AddColSelection(I-1, I-1);
            DeleteColSelection(I, I);
        end;
    end;
    SetDataCol(MaxCol, DataCol);

    GridCols.CntMoveProperties(DataCol + 1, DataCol, MaxCol - DataCol);
    for I := (DataCol + 1) to MaxCol do
    begin
        Dec(FDataColNumber[GetDisplayCol(I - 1)]);

        if GridCols[I-1].Visible and (ColWidths[GetDisplayCol(I-1)] = 0) then
            ResizeCol(GetDisplayCol(I-1), GridCols[I-1].Width)
        else if (not GridCols[I-1].Visible) and (ColWidths[GetDisplayCol(I-1)] <> 0) then
            ResizeCol(GetDisplayCol(I-1), 0)
    end;
    SetDataCol(MaxCol, MaxCol);

    FGridCols.FCols[MaxCol] := OldCol;
    GridCols[MaxCol].FDisplayCol := MaxCol;

    Inc(FCurDeletedCols);
end;

procedure TtsBaseGrid.InvalidateNextCols(DataCol: Longint);
var
    DisplayCol: Longint;
    ARect: TRect;
begin
    if not HandleAllocated then Exit;
    if FastAssign then Exit;
    if (DataCol < 1) or (DataCol > Cols) then Exit;

    DisplayCol := GetDisplayCol(DataCol);
    if DisplayCol <= LeftCol then
        Invalidate
    else
    begin
        ARect := CellRect(DisplayCol, 0);
        if (ARect.Left >= 0) and (ARect.Left <= ARect.Right) then
        begin
            ARect.Right := ClientWidth;
            ARect.Top := 0;
            ARect.Bottom := ClientHeight;
            InvalidateRect(Handle, @ARect, False);
        end;
    end;
end;

procedure TtsBaseGrid.DoDeleteCols(FromDataCol, ToDataCol: Longint);
var
    I, MaxCol: Longint;
    OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    DelBeforeDataCol: Longint;
    DelBeforeDisplayCol: Longint;
begin
    if FromDataCol > Cols then Exit;
    if ToDataCol < 1 then Exit;

    if FromDataCol < 1 then FromDataCol := 1;
    if ToDataCol > Cols then ToDataCol := Cols;
    if FromDataCol > ToDataCol then Exit;

    OldDataRow := GetDataRow(FCurDisplayRow);
    OldDataCol := GetDataCol(FCurDisplayCol);
    CellDeleted := (OldDataCol >= FromDataCol) and (OldDataCol <= ToDataCol);
    if CellDeleted then if not CheckEndEdit(0, OldDataRow, False) then Exit;

    DelBeforeDisplayCol := 0;
    DelBeforeDataCol := 0;
    CheckHideControl(True);

    EnablePaint := False;
    try
        MaxCol := ColCount - 1;
        for I := ToDataCol downto FromDataCol do
        begin
            InvalidateNextCols(I);

            if GetDisplayCol(I) < FCurDisplayCol then Inc(DelBeforeDisplayCol);
            if I < OldDataCol then Inc(DelBeforeDataCol);

            DeleteAllAtCol(I, MaxCol);
            DeleteColData(I, I);
            DoDeleteCol(I, False);
            Dec(MaxCol);
        end;

        SetNewColCount(FCols - (ToDataCol - FromDataCol + 1));
        CheckTopLeft(False);
        if CellDeleted then
            MoveToNewCol(FCurDisplayCol - DelBeforeDisplayCol, False, CanSkipReadOnly, False)
        else
        begin
            OldDataCol := OldDataCol - DelBeforeDataCol;
            SetNewCurrentCell(OldDataCol, OldDataRow);
        end;

        AdjustComboGridExtents(DropDownCols, DropDownRows);
    finally
        EnablePaint := True;
    end;

    UpdateScrollRange;
    ShowGridControl;
end;

procedure TtsBaseGrid.DeleteCols(FromDataCol, ToDataCol: Longint);
begin
    DoDeleteCols(FromDataCol, ToDataCol);
    CheckRowSelection(True);
    SelectionsChanged(False);
    GridStatusChanged;
end;

procedure TtsBaseGrid.DeleteColoredRowCells(DataRow: Longint);
var
    I: Integer;
    ColList: TtsSetList;
    DataCol: Longint;
    Element: TtsCustomElement;
begin
    if FRowCells[DataRow] <> nil then
    begin
        ColList := FRowCells[DataRow].List;
        try
            for I := 1 to ColList.Count do
            begin
                DataCol := Longint(ColList.Items[I]^);
                Element := TtsCustomElement(FCellPropSet.Get([DataCol, DataRow]));
                FCellPropSet.DeleteElement(Element);
                FAutoFontCells.RemoveCoord(DataCol, DataRow);
            end;
            FRowCells[DataRow].Free;
            FRowCells[DataRow] := nil;
        finally
            ColList.Free;
        end;
    end;
end;

procedure TtsBaseGrid.MoveColoredRowCells(DataRow: Longint; MaxRow: Longint);
var
    I, J: Integer;
    DataCol: Longint;
    ColList: TtsSetList;
    Element: TtsCellElement;
begin
    for J := (DataRow + 1) to MaxRow do
    begin
        if FRowCells[J] <> nil then
        begin
            ColList := FRowCells[J].List;
            try
                for I := 1 to ColList.Count do
                begin
                    DataCol := Longint(ColList.Items[I]^);
                    Element := TtsCellElement(FCellPropSet.Get([DataCol, J]));
                    DeleteFromPropList(Element);
                    Element.SetKey(DataCol, J-1);
                    AddToPropList(Element);
                end;
                FRowCells[J].Free;
                FRowCells[J] := nil;
            finally
                ColList.Free;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.DeleteAutoFontRow(DataRow: Longint);
var
    I, Index: Integer;
    Rownr, Colnr: Integer;
begin
    FAutoFontRows.Remove(DataRow);
    for I := 0 to FAutoFontRows.Count - 1 do
    begin
        Rownr := FAutoFontRows.Item[I];
        if Rownr > DataRow then FAutoFontRows.Item[I] := Rownr - 1;
    end;

    I := 0;
    Index := I;
    while FAutoFontCells.NextCoord(I, Colnr, Rownr) do
    begin
        if Rownr > DataRow then FAutoFontCells.UpdateCoord(Index, Colnr, Rownr - 1);
        Index := I;
    end;
end;

procedure TtsBaseGrid.DeleteAllAtRow(DataRow: Longint; MaxRow: Longint);
var
    I: Integer;
    DisplayRow: Longint;
    OldRow: TtsRow;
begin
    OldRow := GridRows.FRows[DataRow];
    DisplayRow := GridRows.DisplayRowNumber[DataRow];

    if FSelectedRows[DisplayRow] then DeleteRowSelection(DisplayRow, DisplayRow);

    DeleteSelectedCellsRow(DisplayRow);
    DeleteColoredRowCells(DataRow);
    DeleteAutoFontRow(DataRow);
    MoveColoredRowCells(DataRow, MaxRow);

    if FVisibleRows.Count <> Rows + InsertionRow + FCurDeletedRows then
        FVisibleRows.MoveItem(DisplayRow, MaxRow);

    if FCurrentCell.FValueRow = DataRow then
        ClearControlBuffer
    else if DataRow < FCurrentCell.FValueRow then
        FCurrentCell.FValueRow := FCurrentCell.FValueRow - 1;

    for I := (DisplayRow + 1) to MaxRow do
    begin
        ResizeRow(I-1, RowHeights[I], True);   // CHANGE to supply ResizeRow with True (DeleteInProgress)

        GridRows.DisplayRowNumber[GetDataRow(I)] := GridRows.DisplayRowNumber[GetDataRow(I)] - 1;
        FDataRowNumber[I - 1] := FDataRowNumber[I];

        if FSelectedRows[I] then
        begin
            AddRowSelection(I-1, I-1);
            DeleteRowSelection(I, I);
        end;
    end;
    SetDataRow(MaxRow, DataRow);

    GridRows.CntMoveProperties(DataRow + 1, DataRow, MaxRow - DataRow);
    for I := (DataRow + 1) to MaxRow do
    begin
        if Assigned(GridRows[I - 1]) then GridRows[I - 1].FDataRow := I - 1;
        Dec(FDataRowNumber[GetDisplayRow(I - 1)]);
        FChangedRows[I - 1] := FChangedRows[I];

        if IsRowVisible(I-1) and (RowHeights[GetDisplayRow(I-1)] = 0) then
            ResizeRow(GetDisplayRow(I-1), GridRows.RowHeight[I-1])
        else if (not IsRowVisible(I-1)) and (RowHeights[GetDisplayRow(I-1)] <> 0) then
            ResizeRow(GetDisplayRow(I-1), 0)
    end;
    FDataRowNumber[MaxRow] := MaxRow;
    GridRows.DisplayRowNumber[MaxRow] := MaxRow;

    GridRows.FRows[MaxRow] := OldRow;
    if Assigned(GridRows[MaxRow]) then GridRows[MaxRow].FDataRow := MaxRow;

    Inc(FCurDeletedRows);
end;

procedure TtsBaseGrid.InvalidateNextRows(DataRow: Longint);
var
    DisplayRow: Longint;
    ARect: TRect;
begin
    if not HandleAllocated then Exit;
    if FastAssign then Exit;
    if (DataRow < 1) or (DataRow > Rows) then Exit;

    DisplayRow := GetDisplayRow(DataRow);
    if DisplayRow <= TopRow then
        Invalidate
    else
    begin
        ARect := CellRect(0, DisplayRow);
        if (ARect.Top >= 0) and (ARect.Top <= ARect.Bottom) then
        begin
            ARect.Left := 0;
            ARect.Right := ClientWidth;
            ARect.Bottom := ClientHeight;
            InvalidateRect(Handle, @ARect, False);
        end;
    end;
end;

procedure TtsBaseGrid.DeleteRows(FromDataRow, ToDataRow: Longint);
var
    I, MaxRow: Longint;
    OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    InInsertRow: Boolean;
    LastRowDeleted: Boolean;
    DelBeforeDataRow: Longint;
    DelBeforeDisplayRow: Longint;
begin
    if FromDataRow > Rows then Exit;
    if ToDataRow < 1 then Exit;

    if FromDataRow < 1 then FromDataRow := 1;
    if ToDataRow > Rows then ToDataRow := Rows;
    if FromDataRow > ToDataRow then Exit;

    OldDataRow := GetDataRow(FCurDisplayRow);
    OldDataCol := GetDataCol(FCurDisplayCol);
    InInsertRow := IsInsertRow(FCurDisplayRow);
    CellDeleted := (OldDataRow >= FromDataRow) and (OldDataRow <= ToDataRow);
    LastRowDeleted := (ToDataRow = Rows);

    if CellDeleted then if not CheckEndEdit(OldDataCol, 0, False) then Exit;

    DelBeforeDisplayRow := 0;
    DelBeforeDataRow := 0;
    CheckHideControl(True);

    EnablePaint := False;
    try
        MaxRow := RowCount - 1;
        for I := ToDataRow downto FromDataRow do
        begin
            InvalidateNextRows(I);

            if GetDisplayRow(I) < FCurDisplayRow then Inc(DelBeforeDisplayRow);
            if I < OldDataRow then Inc(DelBeforeDataRow);

            DeleteAllAtRow(I, MaxRow);
            DeleteRowData(I, I);
            RowDeleted(I, False);
            Dec(MaxRow);
        end;

        if LastRowDeleted and (GridMode = gmEditInsert) then
        begin
            SetInsertionRow(1);
            FInsertRowEdit := False;
        end;

        SetNewRowCount(FRows - (ToDataRow - FromDataRow + 1));
        CheckTopLeft(False);
        if CellDeleted then
            MoveToNewRow(FCurDisplayRow - DelBeforeDisplayRow, False, CanSkipReadOnly, InRowSelectMode)
        else
        begin
            if InInsertRow then OldDataRow := RowCount - 1
                           else OldDataRow := OldDataRow - DelBeforeDataRow;
            SetNewCurrentCell(OldDataCol, OldDataRow);
        end;

        AdjustComboGridExtents(DropDownCols, DropDownRows);
    finally
        EnablePaint := True;
    end;

    UpdateScrollRange;
    ShowGridControl;
    CheckRowSelection(True);
    SelectionsChanged(False);
    GridStatusChanged;
end;

procedure TtsBaseGrid.DeleteSelectedCols;
var
    ACol, MaxCol: Longint;
    DataCol, OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    SelectedColCount: Longint;
    DelBeforeCurCol: Longint;
begin
    if FSelectedCols.Count = 0 then Exit;

    OldDataRow := GetDataRow(FCurDisplayRow);
    OldDataCol := GetDataCol(FCurDisplayCol);
    CellDeleted := FSelectedCols[FCurDisplayCol];

    ACol := FSelectedCols.Last;
    SelectedColCount := FSelectedCols.Count;
    DelBeforeCurCol := 0;
    MaxCol := ColCount - 1;

    EnablePaint := False;
    try
        while ACol > 0 do
        begin
            if ACol < FCurDisplayCol then Inc(DelBeforeCurCol);

            DataCol := GetDataCol(ACol);
            if DataCol < OldDataCol then Dec(OldDataCol);

            InvalidateNextCols(DataCol);
            DeleteAllAtCol(DataCol, MaxCol);
            DeleteColData(DataCol, DataCol);
            DoDeleteCol(DataCol, False);
            Dec(MaxCol);

            ACol := FSelectedCols.Previous(ACol);
        end;

        SetNewColCount(FCols - SelectedColCount);
        CheckTopLeft(False);
        if CellDeleted then
            MoveToNewCol(FCurDisplayCol - DelBeforeCurCol, False, CanSkipReadOnly, False)
        else
            SetNewCurrentCell(OldDataCol, OldDataRow);
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    finally
        EnablePaint := True;
    end;

    ShowGridControl;
    CheckRowSelection(True);
    SelectionsChanged(False);
    GridStatusChanged;
end;

procedure TtsBaseGrid.DeleteSelectedRows;
var
    DataRow, ARow, MaxRow: Longint;
    OldDataRow, OldDataCol: Longint;
    CellDeleted: Boolean;
    InInsertRow: Boolean;
    SelectedRowCount: Longint;
    DelBeforeCurRow: Longint;
    DelBeforeDataRow: Longint;
    LastRowDeleted: Boolean;
begin
    if FSelectedRows.Count = 0 then Exit;

    OldDataRow := GetDataRow(FCurDisplayRow);
    OldDataCol := GetDataCol(FCurDisplayCol);
    InInsertRow := IsInsertRow(FCurDisplayRow);
    CellDeleted := FSelectedRows[FCurDisplayRow];

    ARow := FSelectedRows.Last;
    SelectedRowCount := FSelectedRows.Count;
    if (FSelectedRows.Last > Rows) then
    begin
        SelectedRowCount := SelectedRowCount - 1;
        if SelectedRowCount = 0 then Exit;
        ARow := FSelectedRows.Previous(ARow);
    end;

    LastRowDeleted := (ARow = Rows);

    EnablePaint := False;
    try
        DelBeforeCurRow := 0;
        DelBeforeDataRow := 0;
        MaxRow := RowCount - 1;
        while ARow > 0 do
        begin
            if ARow < FCurDisplayRow then Inc(DelBeforeCurRow);

            DataRow := GetDataRow(ARow);
            if DataRow < OldDataRow then Inc(DelBeforeDataRow);

            InvalidateNextRows(DataRow);
            DeleteAllAtRow(DataRow, MaxRow);
            DeleteRowData(DataRow, DataRow);
            RowDeleted(DataRow, False);
            Dec(MaxRow);

            ARow := FSelectedRows.Previous(ARow);
        end;

        if LastRowDeleted and (GridMode = gmEditInsert) then
        begin
            SetInsertionRow(1);
            FInsertRowEdit := False;
        end;

        SetNewRowCount(FRows - SelectedRowCount);
        if CellDeleted then
        begin
            if IsInsertRow(FCurDisplayRow - DelBeforeCurRow) then Inc(DelBeforeCurRow);
            MoveToNewRow(FCurDisplayRow - DelBeforeCurRow, False, CanSkipReadOnly, InRowSelectMode);
        end
        else
        begin
            if InInsertRow then OldDataRow := RowCount - 1
                           else OldDataRow := OldDataRow - DelBeforeDataRow;
            SetNewCurrentCell(OldDataCol, OldDataRow);
        end;
        
        CheckTopLeft(True);
        AdjustComboGridExtents(DropDownCols, DropDownRows);
    finally
        EnablePaint := True;
    end;

    ShowGridControl;
    CheckRowSelection(True);
    SelectionsChanged(False);
    GridStatusChanged;
end;

function TtsBaseGrid.NumberOfColsSelected(FromDisplayCol, ToDisplayCol: Longint): Longint;
begin
    Result := FSelectedCols.RangeCount(FromDisplayCol, ToDisplayCol);
end;

function TtsBaseGrid.NumberOfRowsSelected(FromDisplayRow, ToDisplayRow: Longint): Longint;
begin
    Result := FSelectedRows.RangeCount(FromDisplayRow, ToDisplayRow);
end;

function TtsBaseGrid.InResizing: Boolean;
begin
    Result := FMouseStatus in [msColResize, msRowBarResize, msRowResize, msHeadingResize];
end;

function TtsBaseGrid.GetHorzScrollBarHeight: Integer;
begin
    Result := GetSystemMetrics(SM_CYHSCROLL);
end;

function TtsBaseGrid.GetVertScrollBarWidth: Integer;
begin
    Result := GetSystemMetrics(SM_CXVSCROLL);
end;

procedure TtsBaseGrid.CheckRowCountChanged(OldCount, NewCount: Longint);
begin
    if OldCount <> NewCount then DoRowCountChanged(OldCount, NewCount);
end;

function TtsBaseGrid.InClipRect(ARect: TRect): Boolean;
var
    ClipRect: TRect;
begin
    ClipRect := Canvas.ClipRect;
    Result := (ARect.Left <= ClipRect.Right) and (ARect.Right > ClipRect.Left + FVertLineWidth - 1) and
              (ARect.Top <= ClipRect.Bottom) and (ARect.Bottom > ClipRect.Top + FHorzLineWidth - 1);
end;

function TtsBaseGrid.BoxRect(ALeft, ATop, ARight, ABottom: Longint): TRect;
var
    BottomRight: TRect;
begin
    if ( (ALeft > MaxVisibleCol) or (ARight < 0) ) or
       ( (ATop > MaxVisibleRow) or (ABottom < 0) ) then
    begin
        Result.Left := 0;
        Result.Top := 0;
        Result.Right := 0;
        Result.Bottom := 0;
    end
    else
    begin
        if (RowBarOn and HeadingOn) or ((ALeft >= FixedCols) and (ATop >= FixedRows)) then
            Result := inherited BoxRect(ALeft, ATop, ARight, ABottom)
        else
        begin
            Result := inherited BoxRect(ALeft, ATop, ALeft, ATop);
            if (Aleft <> ARight) or (ATop <> ABottom) then
            begin
                BottomRight := inherited BoxRect(ARight, ABottom, ARight, ABottom);
                Result.Right := BottomRight.Right;
                Result.Bottom := BottomRight.Bottom;
            end;
        end;
    end;
end;

function TtsBaseGrid.CalcColOffset(DisplayCol: Longint): Integer;
var
    Sum: Integer;
    I: Longint;
    ColPos: longint;
    Found: Boolean;
begin
    Result := 0;
    if DisplayCol = 0 then Exit;

    Result := -1;
    Sum := 0;
    if RowBarOn then Sum := Sum + RowBarWidth;

    ColPos := 1;
    I := FVisibleCols[ColPos];
    while (I <= FInternalFixedCols) and (I < DisplayCol) do
    begin
        Sum := Sum + ColWidths[I];
        if Sum > ClientWidth then Exit;

        ColPos := ColPos + 1;
        if ColPos > FVisibleCols.Count then Break;
        I := FVisibleCols[ColPos];
    end;

    if (DisplayCol > FInternalFixedCols) and (Sum <= ClientWidth) and
       (ColPos <= FVisibleCols.Count) then
    begin
        I := LeftCol;
        ColPos := FVisibleCols.Locate(I, Found);
        if ColPos <= FVisibleCols.Count then
        begin
            I := FVisibleCols[ColPos];
            while (I <= ColCount - 1) and (I < DisplayCol) do
            begin
                Sum := Sum + ColWidths[I];
                if Sum > ClientWidth then Break;

                ColPos := ColPos + 1;
                if ColPos > FVisibleCols.Count then Break;
                I := FVisibleCols[ColPos];
            end;
        end;
    end;

    if (I <= DisplayCol) and (Sum <= ClientWidth) then Result := Sum;
end;

function TtsBaseGrid.CalcRowOffset(DisplayRow: Longint): Integer;
var
    Sum: Integer;
    I: Longint;
    RowPos: longint;
    Found: Boolean;
begin
    Result := 0;
    if DisplayRow = 0 then Exit;

    Result := -1;
    Sum := 0;
    if HeadingOn then Sum := Sum + HeadingHeight;

    RowPos := 1;
    I := FVisibleRows[RowPos];
    while (I <= FInternalFixedRows) and (I < DisplayRow) do
    begin
        Sum := Sum + RowHeights[I];
        if Sum > ClientHeight then Exit;

        RowPos := RowPos + 1;
        if RowPos > FVisibleRows.Count then Break;
        I := FVisibleRows[RowPos];
    end;

    if (DisplayRow > FInternalFixedRows) and (Sum <= ClientHeight) and
       (RowPos <= FVisibleRows.Count) then
    begin
        I := TopRow;
        RowPos := FVisibleRows.Locate(I, Found);
        if RowPos <= FVisibleRows.Count then
        begin
            I := FVisibleRows[RowPos];
            while (I <= RowCount - 1) and (I < DisplayRow) do
            begin
                Sum := Sum + RowHeights[I];
                if Sum > ClientHeight then Break;

                RowPos := RowPos + 1;
                if RowPos > FVisibleRows.Count then Break;
                I := FVisibleRows[RowPos];
            end;
        end;
    end;

    //if (I <= DisplayRow) and (Sum <= ClientHeight) then
       Result := Sum;
end;

function TtsBaseGrid.CalcCellRect(DisplayCol, DisplayRow: Longint): TRect;
var
    ColOffset, RowOffset: Integer;
    ColWidth, RowHeight: Integer;
begin
    Result := FNullRect;
    if not HandleAllocated then Exit;

    ColOffset := CalcColOffset(displayCol);
    if ColOffset < 0 then Exit;

    RowOffset := CalcRowOffset(DisplayRow);
    if RowOffset < 0 then Exit;

    ColWidth := 0;
    RowHeight := 0;
    if DisplayCol <= ColCount - 1 then ColWidth := ColWidths[DisplayCol];
    if DisplayRow <= RowCount - 1 then RowHeight := RowHeights[DisplayRow];

    Result := Rect(ColOffset, RowOffset, ColOffset + ColWidth, RowOffset + RowHeight);
    if Result.Right > ClientWidth then Result.Right := ClientWidth;
    if Result.Bottom > ClientHeight then Result.Bottom := ClientHeight;
end;

function TtsBaseGrid.CellRect(DisplayCol, DisplayRow: Longint): TRect;
var
    ARect: TRect;
begin
    Result := Rect(0, 0, 0, 0);
    if not HandleAllocated then Exit;

    ARect := CalcCellRect(DisplayCol, DisplayRow);
    if EqualRect(ARect, Result) then Exit;
    if (ARect.Left >= ClientWidth) then Exit;
    if (ARect.Top >= ClientHeight) then Exit;

    if (ARect.Right < ClientWidth) or
       ((ARect.Right - ARect.Left) = ColWidths[DisplayCol]) then
        Dec(ARect.Right, FVertLineWidth);

    if (ARect.Bottom < ClientHeight) or
       ((ARect.Bottom - ARect.Top) = RowHeights[DisplayRow]) then
        Dec(ARect.Bottom, FHorzLineWidth);

    Result := ARect;
end;

procedure TtsBaseGrid.ColFromX(X: Integer; var DisplayCol: Longint);
var
    Coord: TGridCoord;
begin
    DisplayCol := -1;
    if not HandleAllocated then Exit;

    if (X < 0) or (X > ClientWidth) then
        DisplayCol := -1
    else
    begin
        Coord := MouseCoord(X, 0);
        DisplayCol := Coord.X
    end;
end;

procedure TtsBaseGrid.RowFromY(Y: Integer; var DisplayRow: Longint);
var
    Coord: TGridCoord;
begin
    DisplayRow := -1;
    if not HandleAllocated then Exit;

    if (Y < 0) or (Y > ClientHeight) then
        DisplayRow := -1
    else
    begin
        Coord := MouseCoord(0, Y);
        DisplayRow := Coord.Y
    end;
end;

procedure TtsBaseGrid.ColRowFromXY(X, Y: Integer; var DisplayCol, DisplayRow: Longint);
begin
    ColFromX(X, DisplayCol);
    if DisplayCol < 0 then
    begin
        if X <= 0 then DisplayCol := 0
                  else DisplayCol := ColCount - 1;
    end;

    RowFromY(Y, DisplayRow);
    if DisplayRow < 0 then
    begin
        if Y <= 0 then DisplayRow := 0
                  else DisplayRow := RowCount - 1;
    end;
end;

procedure TtsBaseGrid.CellFromXY(X, Y: Integer; var DisplayCol, DisplayRow: Longint);
begin
    ColFromX(X, DisplayCol);
    RowFromY(Y, DisplayRow);
end;

procedure TtsBaseGrid.ColInvalidate(DisplayCol: Longint);
begin
    InvalidateCol(DisplayCol);
end;

procedure TtsBaseGrid.RowInvalidate(DisplayRow: Longint);
begin
    InvalidateRow(DisplayRow);
end;

procedure TtsBaseGrid.CellInvalidate(DisplayCol, DisplayRow: Longint);
begin
    InvalidateCell(DisplayCol, DisplayRow);
end;

function TtsBaseGrid.CheckInvalidateCell(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := not FInPaintWindow;
    if Result then
        InvalidateCell(DisplayCol, DisplayRow);
end;

function TtsBaseGrid.CheckInvalidateRow(DisplayRow: Longint): Boolean;
begin
    Result := not FInPaintWindow;
    if Result then
        InvalidateRow(DisplayRow);
end;

function TtsBaseGrid.CheckInvalidateCol(DisplayCol: Longint): Boolean;
begin
    Result := not FInPaintWindow;
    if Result then
        InvalidateCol(DisplayCol);
end;

function TtsBaseGrid.MinLeftCol: Longint;
var
    NewLeft: Longint;
begin
    Result := FixedCols;
    if (Result > 0) and not GridCols[GetDataCol(Result)].Visible then
    begin
        if GetNextCol(Result, False, False, NewLeft) then
            Result := NewLeft;
    end;
end;

function  TtsBaseGrid.MinTopRow: Longint;
var
    NewTop: Longint;
begin
    Result := FixedRows;
    if (Result > 0) and not IsRowVisible(GetDataRow(Result)) then
    begin
        if GetNextRow(Result, False, False, NewTop) then
            Result := NewTop;
    end;
end;

function TtsBaseGrid.GetVisibleLeftCol(ALeft: Longint; var NewLeft: Longint): Boolean;
begin
    NewLeft := CalcMax(ALeft, FixedCols);
    Result := True;

    if not GridCols[GetDataCol(NewLeft)].Visible then
    begin
        if ALeft < LeftCol then
        begin
            Result := GetPrevCol(NewLeft, False, False, NewLeft) and (NewLeft >= FixedCols);
            if not Result then Result := GetNextCol(NewLeft, False, False, NewLeft);
        end
        else
        begin
            Result := GetNextCol(NewLeft, False, False, NewLeft);
            if not Result then
                Result := GetPrevCol(NewLeft, False, False, NewLeft) and (NewLeft >= FixedCols);
        end;
    end;
end;

function TtsBaseGrid.GetVisibleTopRow(ATop: Longint; var NewTop: Longint): Boolean;
begin
    NewTop := CalcMax(ATop, FixedRows);
    Result := True;

    if not IsRowVisible(GetDataRow(NewTop)) then
    begin
        if ATop < TopRow then
        begin
            Result := GetPrevRow(NewTop, False, False, NewTop) and (NewTop >= FixedRows);
            if not Result then Result := GetNextRow(NewTop, False, False, NewTop);
        end
        else
        begin
            Result := GetNextRow(NewTop, False, False, NewTop);
            if not Result then
                Result := GetPrevRow(NewTop, False, False, NewTop) and (NewTop >= FixedRows);
        end;
    end;
end;

function TtsBaseGrid.ValidButton(X, Y: Integer; DisplayCol, DisplayRow: Longint;
                                 ButtonType: TtsButtonType): Boolean;
begin
    Result := not (MouseOverCombo(X, Y) or
                   (DisplayCol <= 0) or
                   (DisplayRow <= 0) or
                   ((X > ClientWidth) or (Y > ClientHeight)) or
                   (ButtonType = btNone));
    // New property AlwaysDetectButton is used to allow detection even if grid/row/cell is readonly...
    if (Result) and (not Self.AlwaysDetectButton) and
       ((GridMode in [gmListBox, gmBrowse]) or
         CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow))) then
       Result := False;
end;

function TtsBaseGrid.DrawButtonDown(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
var
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    Result := False;
    if (DisplayCol <= 0) or (DisplayRow <= 0) then Exit;

    ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
    Result := MouseOverButton(X, Y, DisplayCol, DisplayRow);

    if (not Result) and (ButtonType in [btCombo, btDateTimeDropDown]) then
    begin
        if not ValidButton(X, Y, DisplayCol, DisplayRow, ButtonType) then Exit;
        Result := (DropDownStyle = ddDropDownList);
    end;
end;

function TtsBaseGrid.MouseOverButton(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
var
    ARect: TRect;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    Result := False;
    if (DisplayCol <= 0) or (DisplayRow <= 0) then Exit;

    ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
    if not ValidButton(X, Y, DisplayCol, DisplayRow, ButtonType) then Exit;
    FGridButton := GridCellButton(DisplayCol, ButtonType);

    ARect := CellRect(DisplayCol, DisplayRow);
    ARect.Right := ARect.Left + ColWidths[DisplayCol] - FVertLineWidth;
    ARect.Bottom := ARect.Top + RowHeights[DisplayRow] - FHorzLineWidth;

    if (X > CalcMax(ARect.Left + tsRangeSelectWidth, ARect.Right - FGridButton.FullWidth)) and
       (X <= ARect.Right) and (Y >= ARect.Top) and
       (Y <= CalcMin(ARect.Bottom, ARect.Top + FGridButton.FullHeight)) then
    begin
        Result := true;
    end;
end;

procedure TtsBaseGrid.CheckMousePosition;
var
    MousePos: TPoint;
    DisplayCol, DisplayRow: Longint;
begin
    GetCursorPos(MousePos);
    MousePos := ScreenToClient(MousePos);
    with MousePos do
    begin
        CellFromXY(X, Y, DisplayCol, DisplayRow);
        if (DisplayCol <= 0) or (DisplayRow <= 0) or
           (not MouseOverButton(X, Y, DisplayCol, DisplayRow)) then
        begin
            ResetButton;
        end;
    end;
end;

function TtsBaseGrid.SpinTimerActive: Boolean;
begin
    Result := (IsFocused) and (MouseStatus = msButtonDown) and
              (MouseCapture) and (FDownSpinButton <> spbNone) and
              (FSpinTimer <> 0);
end;

function TtsBaseGrid.ResetSpinTimer: Boolean;
begin
    Result := not SpinTimerActive;
    if Result then
    begin
        StopTimer(FSpinTimer);
        ResetButton;
    end;
end;

procedure TtsBaseGrid.SpinTimerEvent;
begin
    if ResetSpinTimer then Exit;
    CheckRestartSpinTimer;
    try
        Inc(FSpinRepeatCount);
        SpinRepeat(CurDataCol, CurDataRow, FSpinRepeatCount, FDownSpinButton);
    except
        ResetButtonDown;
        CellInvalidate(CurDisplayCol, CurDisplayRow);
        raise;
    end;
end;

function TtsBaseGrid.MouseOverCombo(X, Y: Integer): Boolean;
var
    APoint: TPoint;
    TopLeft, BottomRight: TPoint;
    ComboRect: TRect;
begin
    Result := false;

    if ComboVisible then
    begin
        APoint := ClientToScreen(Point(X, Y));
        if not InDesignMode then
        begin
            ComboRect := Rect(ComboForm.Left, ComboForm.Top,
                              ComboForm.Left + ComboForm.Width, ComboForm.Top + ComboForm.Height);
        end
        else
        begin
            TopLeft := Combo.FGrid.ClientToScreen(Point(0,0));
            BottomRight := Combo.FGrid.ClientToScreen(Point(Combo.FGrid.Width, Combo.FGrid.Height));
            ComboRect := Rect(TopLeft.X, TopLeft.Y, BottomRight.X, BottomRight.Y);
        end;

        if (APoint.X >= ComboRect.Left) and (APoint.X <= ComboRect.Right) and
           (APoint.Y > ComboRect.Top) and (APoint.Y <= ComboRect.Bottom) then
        begin
            Result := true;
        end;
    end;
end;

procedure TtsBaseGrid.ResetButtonUp;
begin
    FButtonUp.X := -1;
    FButtonUp.Y := -1;
end;

procedure TtsBaseGrid.ResetButtonDown;
begin
    FButtonDown.X := -1;
    FButtonDown.Y := -1;
    FDownSpinButton := spbNone;
    FSpinRepeatCount := 0;
    StopTimer(FSpinTimer);
end;

procedure TtsBaseGrid.ResetButton;
begin
    StopTimer(FButtonTimer);

    if (FButtonUp.X <> -1) or (FButtonUp.Y <> -1) then
    begin
        DoDrawButton(FButtonUp.X, FButtonUp.Y, [FUpSpinButton], spbNone,
                     ButtonColor(FButtonUp.X, FButtonUp.Y), bmFlat);
        ResetButtonUp;
    end;

    if (FButtonDown.X <> -1) or (FButtonDown.Y <> -1) then
    begin
        DoDrawButton(FButtonDown.X, FButtonDown.Y, [FDownSpinButton], spbNone,
                     ButtonColor(FButtonDown.X, FButtonDown.Y), bmFlat);
        ResetButtonDown;
    end;
end;

procedure TtsBaseGrid.CheckResetButtons;
begin
    if (FButtonUp.X > ColCount - 1) or (FButtonUp.Y > RowCount - 1) then
        ResetButtonUp;
    if (FButtonDown.X > ColCount - 1) or (FButtonDown.Y > RowCount - 1) then
        ResetButtonDown;
end;

function TtsBaseGrid.ButtonColor(DisplayCol, DisplayRow: Longint): TColor;
begin
    if FInactiveButtonState = ibsBackGround then
        Result := clBtnFace
    else if DrawCurrentButton(DisplayCol, DisplayRow) and
            not CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then
        Result := clBtnFace
    else
        Result := clNone;
end;

procedure TtsBaseGrid.SetInactiveButtonState(Value: TtsInactiveButtonState);
begin
    if Value <> FInactiveButtonState then
    begin
        FInactiveButtonState := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetButtonEdgeWidth(Value: Integer);
begin
    if Value <> FButtonEdgeWidth then
    begin
        FButtonEdgeWidth := Value;
        Invalidate;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetDefaultButtonWidth(Value: Integer);
begin
    if Value <> FDefaultButtonWidth then
    begin
        FDefaultButtonWidth := Value;
        CheckResizeButtons;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetDefaultButtonHeight(Value: Integer);
begin
    if Value <> FDefaultButtonHeight then
    begin
        FDefaultButtonHeight := Value;
        CheckResizeButtons;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetSpinButtonWidth(Value: Integer);
begin
    if Value <> FSpinButtonWidth then
    begin
        FSpinButtonWidth := Value;
        CheckResizeSpinButtons;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetSpinButtonHeight(Value: Integer);
begin
    if Value <> FSpinButtonHeight then
    begin
        FSpinButtonHeight := Value;
        CheckResizeSpinButtons;
        RedisplayControl(True);
    end;
end;

procedure TtsBaseGrid.SetHeadingButton(Value: TtsHeadingButton);
begin
    if FHeadingButton <> Value then
    begin
        FHeadingButton := Value;
        InvalidateRow(0);
    end;
end;

procedure TtsBaseGrid.SetHeadingAlignment(Value: TAlignment);
begin
    if FHeadingAlignment <> Value then
    begin
        FHeadingAlignment := Value;
        FHeadingHorzAlignment := AlignmentToHorzAlignment(FHeadingAlignment, True);
        if FHeadingHorzAlignment = htaLeft then FHeadingHorzAlignment := htaDefault;
        if HeadingOn then CheckInvalidateRow(0);
    end;
end;

procedure TtsBaseGrid.SetHeadingHorzAlignment(Value: TtsHorzAlignment);
begin
    if FHeadingHorzAlignment <> Value then
    begin
        FHeadingHorzAlignment := Value;
        FHeadingAlignment := HorzAlignmentToAlignment(FHeadingHorzAlignment);
        if HeadingOn then CheckInvalidateRow(0);
    end;
end;

procedure TtsBaseGrid.SetHeadingVertAlignment(Value: TtsVertAlignment);
begin
    if FHeadingVertAlignment <> Value then
    begin
        FHeadingVertAlignment := Value;
        if HeadingOn then CheckInvalidateRow(0);
    end;
end;

procedure TtsBaseGrid.SetHorzAlignment(Value: TtsHorzAlignment);
begin
    if FHorzAlignment <> Value then
    begin
        FHorzAlignment := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetVertAlignment(Value: TtsVertAlignment);
begin
    if FVertAlignment <> Value then
    begin
        FVertAlignment := Value;
        Invalidate;
    end;
end;

procedure TtsBaseGrid.SetRowBarAlignment(Value: TtsVertAlignment);
begin
    if FRowBarAlignment <> Value then
    begin
        FRowBarAlignment := Value;
        InvalidateCol(0);
    end;
end;

procedure TtsBaseGrid.SetHeadingWordWrap(Value: TtsWordWrap);
begin
    if FHeadingWordWrap <> Value then
    begin
        FHeadingWordWrap := Value;
        if HeadingOn then CheckInvalidateRow(0);
    end;
end;

procedure TtsBaseGrid.HeadingFontChange(Sender: TObject);
var
    I: Integer;
begin
    for I := 0 to FAutoFontCols.Count - 1 do
    begin
        Col[FAutoFontCols.Item[I]].CheckHeadingFont;
    end;

    FHeadingParentFont := False;
    if HeadingOn then CheckInvalidateRow(0);
end;

procedure TtsBaseGrid.CheckComboCreated;
begin
    if FCombo = nil then
    begin
        FCombo := CreateCombo;
        InitializeComboSettings(Combo.FGrid);
        Combo.FGrid.Visible := True;
    end;
end;

function TtsBaseGrid.GetCombo: TtsCombo;
begin
    if FCombo = nil then CheckComboCreated;
    Result := FCombo;
end;

function TtsBaseGrid.GetComboForm: TtsDropDownForm;
begin
    if FComboForm = nil then
    begin
        FComboForm := TtsDropDownForm.Create(Self);
        InitializeDropDownForm(FComboForm);
    end;
    Result := FComboForm;
end;

function TtsBaseGrid.GetDropDownRows: Longint;
begin
    Result := 0;
end;

procedure TtsBaseGrid.SetDropDownRows(Value: Longint);
begin
end;

function TtsBaseGrid.GetAutoLookup: Boolean;
begin
    Result := False;
end;

procedure TtsBaseGrid.SetAutoLookup(Value: Boolean);
begin
end;

function TtsBaseGrid.GetDropDownCols: Longint;
begin
    Result := 0;
end;

procedure TtsBaseGrid.SetDropDownCols(Value: Longint);
begin
end;

function TtsBaseGrid.GetParentGrid: TtsBaseGrid;
begin
    Result := nil;
end;

procedure TtsBaseGrid.SetParentGrid(Value: TtsBaseGrid);
begin
end;

function TtsBaseGrid.GetValueCol: Longint;
begin
    Result := 0;
end;

function TtsBaseGrid.GetValueColSorted: Boolean;
begin
    Result := False;
end;

function TtsBaseGrid.GetCompareType: TtsComboCompareType;
begin
    Result := ctCaseInsensitive;
end;

function TtsBaseGrid.GetAutoSearch: TtsComboAutoSearchType;
begin
    Result := asNone;
end;

function TtsBaseGrid.GetAutoFill: Boolean;
begin
    Result := False;
end;

function TtsBaseGrid.GetDropDownStyle: TtsDropDownStyle;
begin
    Result := ddDropDown;
end;

procedure TtsBaseGrid.SetDisplayCol(Value: Longint);
begin
end;

procedure TtsBaseGrid.SetValueCol(Value: Longint);
begin
end;

procedure TtsBaseGrid.SetValueColSorted(Value: Boolean);
begin
end;

procedure TtsBaseGrid.SetCompareType(Value: TtsComboCompareType);
begin
end;

procedure TtsBaseGrid.SetAutoSearch(value: TtsComboAutoSearchType);
begin
end;

procedure TtsBaseGrid.SetAutoFill(Value: Boolean);
begin
end;

procedure TtsBaseGrid.SetDropDownStyle(Value: TtsDropDownStyle);
begin
end;

function TtsBaseGrid.CreateCombo: TtsCombo;
begin
    Result := nil;
    InvalidOp(StsCreateCombo);
end;

function TtsBaseGrid.CreateComboGrid: TtsBaseGrid;
begin
    Result := nil;
    InvalidOp(StsCreateComboGrid);
end;

procedure TtsBaseGrid.ResetLastUsedCombo;
begin
    FLastUsedCombo := nil;
end;

procedure TtsBaseGrid.CheckLastUsedCombo(Combo: TtsCombo);
begin
    if FLastUsedCombo = Combo then ResetLastUsedCombo;
end;

procedure TtsBaseGrid.ResetCombo;
begin
    if FAsCombo then Exit;
    Combo.Reset;
    FComboInitialized := False;
    ResetLastUsedCombo;
end;

procedure TtsBaseGrid.ResetComboInit(ResetCombo: Boolean);
begin
    if FAsCombo then Exit;

    if FComboInitialized then
    begin
        FComboInitialized := False;
        if ResetCombo and Assigned(FLastUsedCombo) then Combo.Reset;
    end;
    ResetLastUsedCombo;
end;

procedure TtsBaseGrid.CheckResetComboInit(Combo: TtsCombo; ResetCombo: Boolean);
begin
    if FAsCombo then Exit;
    if Assigned(Combo) and (FLastUsedCombo = Combo) then
        ResetComboInit(ResetCombo);
end;

function TtsBaseGrid.GetParentGridCombo: TtsCombo;
begin
    Result := nil;
end;

procedure TtsBaseGrid.SetParentGridCombo(Value: TtsCombo);
begin
end;

procedure TtsBaseGrid.Reset;
begin
    ResetPropKinds(tsAllPropKinds);
end;

function TtsBaseGrid.GiveCellCombo(DataCol, DataRow: Longint): TtsCombo;
begin
    Result := nil;
    if (DataCol <= 0) or (DataCol > Cols) then Exit;
    if (DataRow <= 0) or (DataRow > RowCount - 1) then Exit;

    if (CellButtonType[DataCol,DataRow] = btCombo) and
       (not CellParentCombo[DataCol,DataRow] or InDesignMode) then
    begin
        Result := CellCombo[DataCol, DataRow]
    end
    else
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            if (GridCols[DataCol].ButtonType = btCombo) and
               (not GridCols[DataCol].ParentCombo or InDesignMode) then
                Result := GridCols[DataCol].Combo
            else if RowButtonType[DataRow] = btCombo then
                Result := RowCombo[DataRow];
        end
        else
        begin
            if (RowButtonType[DataRow] = btCombo) and
               (not RowParentCombo[DataRow] or InDesignMode) then
                Result := RowCombo[DataRow]
            else if GridCols[DataCol].ButtonType = btCombo then
                Result := GridCols[DataCol].Combo;
        end;
    end;
end;

procedure TtsBaseGrid.InitializeDropDownForm(Form: TtsDropDownForm);
begin
    Form.Visible := False;
    Form.Enabled := False;
    Form.Left := Self.Left;
    Form.Ctl3D := False;
    Form.Font := Font;
end;

procedure TtsBaseGrid.InitializeComboSettings(ComboGrid: TtsBaseGrid);
begin
    ComboGrid.EnablePaint := False;
    try
        ComboGrid.Color := Self.Color;
        if ComboGrid.InDesignMode
            then ComboGrid.Cols := 2
            else ComboGrid.Cols := 1;

        ComboGrid.Ctl3D := False;
        ComboGrid.Cursor := Self.Cursor;
        ComboGrid.DefaultButtonHeight := Self.DefaultButtonHeight;
        ComboGrid.DefaultButtonWidth := Self.DefaultButtonWidth;
        ComboGrid.DefaultRowHeight := FScaledRowHeight;
        ComboGrid.EditColor := Self.EditColor;
        ComboGrid.EditFontColor := Self.EditFontColor;
        ComboGrid.FSelectionColor := Self.SelectionColor;
        ComboGrid.FSelectionFontColor := Self.SelectionFontColor;
        ComboGrid.FSelectionType := Self.SelectionType;
        ComboGrid.Font.Assign(Font);
        ComboGrid.RowChangedIndicator := riAutoReset;

        if ComboGrid.InDesignMode then
        begin
            ComboGrid.FRowSelectMode := rsMulti;
            ComboGrid.ColSelectMode := csMulti;
            ComboGrid.FGridMode := gmEdit;
            ComboGrid.RowMoving := True;
            ComboGrid.ColMoving := True;
            ComboGrid.AlwaysShowEditor := False;
            ComboGrid.AlwaysShowFocus := True;
            ComboGrid.FocusBorder := fbDouble;
        end
        else
        begin
            ComboGrid.FRowSelectMode := rsSingle;
            ComboGrid.ColSelectMode := csNone;
            ComboGrid.FGridMode := gmListBox;
            ComboGrid.RowMoving := False;
            ComboGrid.ColMoving := False;
            ComboGrid.AlwaysShowEditor := True;
            ComboGrid.AlwaysShowFocus := False;
            ComboGrid.FocusBorder := fbDot;
        end;

        ComboGrid.HeadingOn := False;
        ComboGrid.RowBarOn := False;
        ComboGrid.FEditMode := GridModeToEditMode(ComboGrid.FGridMode);
        ComboGrid.HeadingHeight := 15;
        ComboGrid.RowBarWidth := 14;
        ComboGrid.ParentCtl3D := False;
        ComboGrid.ParentShowHint := False;

        if ComboGrid.InDesignMode then
        begin
            ComboGrid.ResizeCols := rcSingle;
            ComboGrid.ResizeRows := rrAll;
        end
        else
        begin
            ComboGrid.ResizeCols := rcNone;
            ComboGrid.ResizeRows := rrNone;
        end;

        ComboGrid.Scrollbars := ssVertical;
        ComboGrid.TabStop := False;
        ComboGrid.ThumbTracking := True;
    finally
        ComboGrid.EnablePaint := True;
    end;
end;

function TtsBaseGrid.DropDownVisible: Boolean;
begin
    Result := ComboVisible or DateTimeVisible;
end;

function TtsBaseGrid.ComboVisible: Boolean;
begin
    Result := false;
    if FCombo <> nil then
    begin
        Result := ComboForm.Visible or (FCombo.FGrid.Parent <> ComboForm);
    end;
end;

function TtsBaseGrid.TotalColWidth : Integer;
var i : Integer;
begin
  Result := 0;
  for i := 1 to Self.Cols do    // Iterate
    Result := Result + Col[i].Width;
end;

function TtsBaseGrid.TurnComboOff(ResetForm, DoUpdate: Boolean): Boolean;
begin
    Result := ComboVisible;
    if Result then
    begin
        ComboForm.Visible := False;
        Combo.FGrid.Parent := ComboForm;
        if DoUpdate then Update;
        UnHookDropDownHook(Self);
        if ResetForm then
        begin
            if Assigned(GetParentForm(Self)) and GetParentForm(Self).Active then
                GetParentForm(Self).Show;
        end;
    end;
end;

function TtsBaseGrid.DateTimeVisible: Boolean;
begin
    Result := False;
    if Assigned(FDateTimeForm) then Result := FDateTimeForm.Visible;
    if (not Result) and DateTimeControlAssigned then Result := FDateTimeComponent.Control.Parent <> FDateTimeForm;
end;

function TtsBaseGrid.IsDateTimeHandle(Handle: Hwnd): Boolean;
begin
    Result := False;
    if not DateTimeControlAssigned then Exit;
    Result := IsControlHandle(Handle, FDateTimeComponent.Control);
end;

function TtsBaseGrid.TurnDateTimeOff(ResetForm, DoUpdate: Boolean): Boolean;
begin
    Result := DateTimeVisible or FDateTimeDisplayed;
    if Result then
    begin
        DateTimeForm.Visible := False;
        if not DateTimeForm.DropDownForm
            then DateTimeForm.Close
            else UnhookDropDownHook(Self);
        FDateTimeDisplayed := False;
        if DoUpdate then Update;

        if ResetForm then
        begin
            if Assigned(GetParentForm(Self)) and GetParentForm(Self).Active then
                GetParentForm(Self).Show;
        end;
    end;
end;

procedure TtsBaseGrid.ResetDateTimeInit;
begin
    if FDateTimeInitialized then FDateTimeInitialized := False;
    ResetLastUsedDateTime;
end;

procedure TtsBaseGrid.CheckResetDateTimeInit(DateTime: TtsDateTimeDefComponent);
begin
    if Assigned(DateTime) and (DateTime = FLastUsedDateTime) then
        ResetDateTimeInit;
end;

procedure TtsBaseGrid.ResetLastUsedDateTime;
begin
    FLastUsedDateTime := nil;
end;

procedure TtsBaseGrid.CheckLastUsedDateTime(DateTime: TtsDateTimeDefComponent);
begin
    if FLastUsedDateTime = DateTime then ResetLastUsedDateTime;
end;

procedure TtsBaseGrid.GetDateTimeValue(DataCol, DataRow: Longint; var Value: Variant);
var
    Fmt: string;
    DateStr: string;
    Hour, Min, Sec, MSec: Word;
begin
    Value := FDateTimeComponent.DateTimeProps.DateTime;
    ActivateDateTimeGetValue(FDateTimeComponent, DataCol, DataRow, Value);

    if VarType(Value) in [varDate, varDouble] then
    begin
        Fmt := '';
        case FDateTimeComponent.DateTimeProps.DateTimeDisplay of
            dtDate:
                Fmt := GetEditDateFormat(True);
            dtTime:
                Fmt := LongTimeFormat;
            dtDateTime:
                begin
                    Fmt := GetEditDateFormat(True);
                    DecodeTime(Value, Hour, Min, Sec, MSec);
                    if (Hour <> 0) or (Min <> 0) or (Sec <> 0) then
                        Fmt := Trim(Fmt) + ' ' + LongTimeFormat;
                end;
        end;

        Fmt := LongYearFormat(Fmt);
        if not AMPMFormat then Fmt := LongHourFormat(Fmt);
        DateTimeToString(DateStr, Fmt, Value);
        Value := DateStr;
    end
end;

procedure TtsBaseGrid.SetDateTimeSelection;
var
    Value: Variant;
    RollUp: Boolean;
begin
    try
        if VarIsEmpty(FDateTimeComponent.DateTimeProps.DateTime) or (InDesignMode and not StoreData) then
        begin
            ShowGridControl;
            CheckDropDownOff(False);
            SetFocus;
            Exit;
        end;

        RollUp := TurnDateTimeOff(False, True);
        try
            GetDateTimeValue(FCurDataCol, FCurDataRow, Value);
            try
                if not VarIsEmpty(Value) then CheckVarType(CurCellControlType, Value);
                SetCurrentValue(Value, True, True);
                if not VariantEqual(CurrentCell.Value, Value) then
                    AssignControlValue(GiveCellControlType(CurDataCol, CurDataRow), Value, False, False);
            finally
                ShowGridControl;
            end;
        finally
            if RollUp then DateTimeRollUp;
            SetFocus;
        end;
    finally
        FDateTimeDateSelected := False;
    end;
end;

procedure TtsBaseGrid.CancelDateTimeSelection;
begin
    ShowGridControl;
    CheckDropDownOff(False);
    if not IsFocused then SetFocus;
    FDateTimeDateCanceled := False;
end;

procedure TtsBaseGrid.DateTimeSelect(Sender: TObject);
begin
    FDateTimeDateSelected := True;
    if FDateTimeForm.DropDownForm then
        SetDateTimeSelection;
end;

procedure TtsBaseGrid.DateTimeCancel(Sender: TObject);
begin
    FDateTimeDateCanceled := True;
    if FDateTimeForm.DropDownForm then
        CancelDateTimeSelection;
end;

procedure TtsBaseGrid.CheckDropDownOff(ResetForm: Boolean);
begin
    if TurnComboOff(ResetForm, True) then
        ComboRollUp
    else if TurnDateTimeOff(ResetForm, True) then
        DateTimeRollUp;
end;

procedure TtsBaseGrid.PositionDropDownForm(DataCol, DataRow: Longint; AWidthHeight: TPoint; var ATopLeft: TPoint);
var WorkArea: TRect;
    iTaskBarHeight, iTaskBarWidth : Integer;
begin
    SystemParametersInfo(SPI_GETWORKAREA, 0, @WorkArea, 0);
    if (Screen.MonitorCount > 1) then
    begin
      // Determine if task bar is using up width or height on primary screen...
      iTaskBarHeight := 0;
      iTaskBarWidth  := 0;
      if (Screen.Height > (WorkArea.Bottom - WorkArea.Top)) then
         iTaskBarHeight := Screen.Height - (WorkArea.Bottom - WorkArea.Top);
      if (Screen.Width > (WorkArea.Right - WorkArea.Left)) then
         iTaskBarWidth := Screen.Width - (WorkArea.Right - WorkArea.Left);
      WorkArea.Right := Screen.DesktopWidth - iTaskBarWidth;
      WorkArea.Bottom := Screen.DesktopHeight - iTaskBarHeight;
    end;

    if (ATopLeft.X + AWidthHeight.X) > WorkArea.Right - WorkArea.Left then
        ATopLeft.X := CalcMax(WorkArea.Left, WorkArea.Right - WorkArea.Left - AWidthHeight.X);

    if (ATopLeft.Y + AWidthHeight.Y) > WorkArea.Bottom - WorkArea.Top then
        ATopLeft.Y := CalcMax(WorkArea.Top, ATopLeft.Y - RowHeights[DataRow] + FVertLineWidth - AWidthHeight.Y);
end;

procedure TtsBaseGrid.PositionPopupForm(DataCol, DataRow: Longint; AWidthHeight: TPoint; var ATopLeft: TPoint);
var WorkArea: TRect;
    parentForm : TCustomForm;
begin
    SystemParametersInfo(SPI_GETWORKAREA, 0, @WorkArea, 0);

    parentForm := GetParentForm(Self);
    if (parentForm <> Nil) then // middle of window
    begin
      ATopLeft.X := parentForm.Left + (parentForm.Width  - AWidthHeight.X) div 2;
      ATopLeft.Y := parentForm.Top + (parentForm.Height  - AWidthHeight.Y) div 2;
    end
    else // middle of screen
    begin
      ATopLeft.X := (WorkArea.Right - WorkArea.Left - AWidthHeight.X) div 2;
      ATopLeft.Y := (WorkArea.Bottom - WorkArea.Top - AWidthHeight.Y) div 2;
    end;
end;

procedure TtsBaseGrid.ShowInsertionRow;
begin
    if (GridMode <> gmEditInsert) or (InsertionRow <> 0) then Exit;

    FInsertRowEdit := False;
    SetInsertionRow(1);
    SetNewRowCount(Rows);
end;

function TtsBaseGrid.ButtonInColHeading(DisplayCol: Longint): Boolean;
begin
    Result := ((FHeadingButton = hbButton) and (GridCols[GetDataCol(DisplayCol)].FHeadingButton = cbGrid)) or
              (GridCols[GetDataCol(DisplayCol)].FHeadingButton = cbButton);
end;

function TtsBaseGrid.IsColHeadingButton(DisplayCol: Longint): Boolean;
begin
    Result := ((FHeadingButton = hbCell) and (GridCols[GetDataCol(DisplayCol)].FHeadingButton = cbGrid)) or
              (GridCols[GetDataCol(DisplayCol)].FHeadingButton = cbCell);
end;

function TtsBaseGrid.MouseOverHeadingButton(X, Y: Integer; DisplayCol: Longint): Boolean;
var
    DrawData: TtsDrawData;
    ARect: TRect;
begin
    Result := False;
    if not ButtonInColHeading(DisplayCol) then Exit;

    GetDrawData(DisplayCol, 0, True, DrawData);
    ARect := DrawData.ButtonRect;
    ARect.Bottom := CalcMin(ARect.Bottom, ARect.Top + HeadButHeight);
    Result := (X >= ARect.Left) and (X < ARect.Right) and (Y < ARect.Bottom);
end;

function TtsBaseGrid.CanClickHeading(X, Y: Integer; DisplayCol: Longint): Boolean;
begin
    Result := False;
    if FHeadingClicked <> -1 then Exit;
    if (DisplayCol < 1) or (DisplayCol > Cols) then Exit;
    if IsCellSelected(DisplayCol, 0) then Exit;

    Result := (ButtonInColHeading(DisplayCol) and
               MouseOverHeadingButton(X, Y, DisplayCol));
    Result := Result or (IsColHeadingButton(DisplayCol) and HeadingOn and
                         (Y <= HeadingHeight));
end;

procedure TtsBaseGrid.SetInsertionRow(Value: Integer);
begin
    FOldInsertionRow := FInsertionRow;
    FInsertionRow := Value;
end;

function TtsBaseGrid.IsInsertRow(DisplayRow: Longint): Boolean;
begin
    Result := (DisplayRow = RowCount - 1) and (GridMode = gmEditInsert);
end;

function TtsBaseGrid.IsAppendRow(DisplayRow: Longint): Boolean;
begin
    Result := (DisplayRow = RowCount - 1) and (GridMode = gmEditInsert) and
              (InsertionRow = 1);
end;

procedure TtsBaseGrid.MoveTopLeft(ALeft, ATop: Longint);
var
    MaxTopLeft: TGridCoord;
    Show: Boolean;
    OldRow, OldCol: Longint;
begin
    if FastAssign then
    begin
        inherited MoveTopLeft(ALeft, ATop);
        Exit;
    end;

    MaxTopLeft := GetMaxTopLeft;
    if ALeft > MaxTopLeft.X then ALeft := MaxTopLeft.X;
    if not GetVisibleLeftCol(ALeft, ALeft) then ALeft := LeftCol;

    if ATop > MaxTopLeft.Y then ATop := MaxTopLeft.Y;
    if not GetVisibleTopRow(ATop, ATop) then ATop := TopRow;

    if (ALeft <> LeftCol) or (ATop <> TopRow) then
    begin
        ResetButton;
        Show := not FControlHidden;
        CheckHideControl(False);
        OldCol := FCurDisplayCol;
        OldRow := FCurDisplayRow;
        inherited MoveTopLeft(ALeft, ATop);
        if Show then ShowGridControl;
        if (OldCol <> FCurDisplayCol) or (OldRow <> FCurDisplayRow) then
            InvalidateCell(OldCol, OldRow);
    end;
end;

procedure TtsBaseGrid.SetTopLeft(DisplayCol, DisplayRow: Longint);
begin
    MoveTopLeft(DisplayCol, DisplayRow);
end;

function TtsBaseGrid.IsFocused: Boolean;
begin
    Result := Focused or (FGridControl.Focused);
end;

procedure TtsBaseGrid.ChangeDisplayCol(FromDisplayCol, ToDisplayCol: Longint);
var
    I: Integer;
    FromDataCol: Longint;
begin
    FromDataCol := GetDataCol(FromDisplayCol);
    if FromDisplayCol > ToDisplayCol then
    begin
        for I := (FromDisplayCol - 1) downto ToDisplayCol do
        begin
            GridCols[GetDataCol(I)].FDisplayCol := GridCols[GetDataCol(I)].FDisplayCol + 1;
            SetDataCol(I + 1, GetDataCol(I));
        end;
    end
    else if FromDisplayCol < ToDisplayCol then
    begin
        for I := (FromDisplayCol + 1) to ToDisplayCol do
        begin
            GridCols[GetDataCol(I)].FDisplayCol := GridCols[GetDataCol(I)].FDisplayCol - 1;
            SetDataCol(I - 1, GetDataCol(I));
        end;
    end;

    GridCols[FromDataCol].FDisplayCol := ToDisplayCol;
    SetDataCol(ToDisplayCol, FromDataCol);
end;

procedure TtsBaseGrid.MoveVisibleCol(FromDisplayCol, ToDisplayCol: Longint);
begin
    if FVisibleCols.Count = Cols then Exit;
    FVisibleCols.MoveItem(FromDisplayCol, ToDisplayCol);
end;

procedure TtsBaseGrid.UpdateVisibleCols;
var
    I, Index: Integer;
begin
    if FVisibleCols.Count = Cols then Exit;

    Index := 0;
    for I := 1 to Cols do
    begin
        if GridCols[GetDataCol(I)].Visible and (Index < FVisibleCols.Count) then
        begin
            Inc(Index);
            FVisibleCols[Index] := I;
        end;
    end;
end;

procedure TtsBaseGrid.ChangeColWidths(FromDisplayCol, ToDisplayCol: Longint);
var
    I: Longint;
    ColWidth: Integer;
begin
    ColWidth := ColWidths[FromDisplayCol];

    EnablePaint := False;
    try
        if FromDisplayCol > ToDisplayCol then
        begin
            for I := FromDisplayCol downto (ToDisplayCol + 1) do
            begin
                ResizeCol(I, ColWidths[I-1]);
            end;
        end
        else if FromDisplayCol < ToDisplayCol then
        begin
            for I := FromDisplayCol to (ToDisplayCol - 1) do
            begin
                ResizeCol(I, ColWidths[I+1]);
            end;
        end;

        ResizeCol(ToDisplayCol, ColWidth);
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.DiffSelectedCols(DisplayCol, FromDisplayCol: Longint): Longint;
begin
    if DisplayCol > FromDisplayCol then
        Result := NumberOfColsSelected(FromDisplayCol + 1, DisplayCol)
    else if DisplayCol < FromDisplayCol then
        Result := - (NumberOfColsSelected(DisplayCol, FromDisplayCol - 1))
    else
        Result := 0;
end;

procedure TtsBaseGrid.MoveColRangeLeft(FromDisplayCol, ToDisplayCol: Longint);
var
    I:Integer;
    First, Last: Longint;
    DisplayCol, NewDisplayCol, ColsInRange: Longint;
    SmallerColsSelected: Longint;
    MoveVisible: Boolean;
begin
    if (FSelectedCols.Count = 0) then
    begin
        ChangeDisplayCol(FromDisplayCol, ToDisplayCol);
        MoveVisibleCol(FromDisplayCol, ToDisplayCol);
        ChangeColWidths(FromDisplayCol, ToDisplayCol);
        Exit;
    end;

    First := ToDisplayCol;
    Last := ToDisplayCol;
    MoveVisible := FSelectedCols.Count < 100;
    ColsInRange := NumberOfColsSelected(ToDisplayCol, FromDisplayCol - 1);

    SmallerColsSelected := 0;
    if ToDisplayCol > 1 then
        SmallerColsSelected := NumberOfColsSelected(1, ToDisplayCol - 1);

    try
        DisplayCol := FSelectedCols.Previous(ToDisplayCol);
        NewDisplayCol := -1;
        for I := 1 to SmallerColsSelected do
        begin
            if NewDisplayCol < 0 then
                NewDisplayCol := ToDisplayCol + ColsInRange +
                                 DiffSelectedCols(DisplayCol, FromDisplayCol)
            else
                Dec(NewDisplayCol);

            if I = SmallerColsSelected then First := NewDisplayCol;
            if DisplayCol <> NewDisplayCol then
            begin
                FSelectedCols.FBits[NewDisplayCol] := True;
                FSelectedCols.FBits[DisplayCol] := False;
                ChangeDisplayCol(DisplayCol, NewDisplayCol);
                if MoveVisible then MoveVisibleCol(DisplayCol, NewDisplayCol);
                ChangeColWidths(DisplayCol, NewDisplayCol);
            end;

            DisplayCol := FSelectedCols.Previous(DisplayCol);
        end;

        DisplayCol := FSelectedCols.Next(ToDisplayCol - 1);
        NewDisplayCol := -1;
        for I := SmallerColsSelected to (FSelectedCols.Count - 1) do
        begin
            if NewDisplayCol < 0 then
                NewDisplayCol := ToDisplayCol + ColsInRange +
                                 DiffSelectedCols(DisplayCol, FromDisplayCol)
            else
                Inc(NewDisplayCol);

            if I = FSelectedCols.Count - 1 then Last := NewDisplayCol;
            if DisplayCol <> NewDisplayCol then
            begin
                FSelectedCols.FBits[NewDisplayCol] := True;
                FSelectedCols.FBits[DisplayCol] := False;
                ChangeDisplayCol(DisplayCol, NewDisplayCol);
                if MoveVisible then MoveVisibleCol(DisplayCol, NewDisplayCol);
                ChangeColWidths(DisplayCol, NewDisplayCol);
            end;

            DisplayCol := FSelectedCols.Next(DisplayCol);
        end;
    finally
        if not MoveVisible then UpdateVisibleCols;
        FSelectedCols.FFirst := First;
        FSelectedCols.FLast := Last;
    end;
end;

procedure TtsBaseGrid.MoveColRangeRight(FromDisplayCol, ToDisplayCol: Longint);
var
    I:Integer;
    First, Last: Longint;
    DisplayCol, NewDisplayCol, ColsInRange: Longint;
    LargerColsSelected: Longint;
    MoveVisible: Boolean;
begin
    if (FSelectedCols.Count = 0) then
    begin
        ChangeDisplayCol(FromDisplayCol, ToDisplayCol);
        MoveVisibleCol(FromDisplayCol, ToDisplayCol);
        ChangeColWidths(FromDisplayCol, ToDisplayCol);
        Exit;
    end;

    First := ToDisplayCol;
    Last := ToDisplayCol;

    MoveVisible := FSelectedCols.Count < 100;
    ColsInRange := NumberOfColsSelected(FromDisplayCol + 1, ToDisplayCol);

    LargerColsSelected := 0;
    if ToDisplayCol < ColCount - 1 then
        LargerColsSelected := NumberOfColsSelected(ToDisplayCol + 1, ColCount - 1);

    try
        DisplayCol := FSelectedCols.Next(ToDisplayCol);
        NewDisplayCol := -1;
        for I := 1 to LargerColsSelected do
        begin
            if NewDisplayCol < 0 then
                NewDisplayCol := ToDisplayCol - ColsInRange +
                                 DiffSelectedCols(DisplayCol, FromDisplayCol)
            else
                Inc(NewDisplayCol);

            if I = LargerColsSelected then Last := NewDisplayCol;
            if DisplayCol <> NewDisplayCol then
            begin
                FSelectedCols.FBits[NewDisplayCol] := True;
                FSelectedCols.FBits[DisplayCol] := False;
                ChangeDisplayCol(DisplayCol, NewDisplayCol);
                if MoveVisible then MoveVisibleCol(DisplayCol, NewDisplayCol);
                ChangeColWidths(DisplayCol, NewDisplayCol);
            end;

            DisplayCol := FSelectedCols.Next(DisplayCol);
        end;

        DisplayCol := FSelectedCols.Previous(ToDisplayCol + 1);
        NewDisplayCol := -1;
        for I := LargerColsSelected to (FSelectedCols.Count - 1) do
        begin
            if NewDisplayCol < 0 then
                NewDisplayCol := ToDisplayCol - ColsInRange +
                                 DiffSelectedCols(DisplayCol, FromDisplayCol)
            else
                Dec(NewDisplayCol);

            if I = FSelectedCols.Count - 1 then First := NewDisplayCol;
            if DisplayCol <> NewDisplayCol then
            begin
                FSelectedCols.FBits[NewDisplayCol] := True;
                FSelectedCols.FBits[DisplayCol] := False;
                ChangeDisplayCol(DisplayCol, NewDisplayCol);
                if MoveVisible then MoveVisibleCol(DisplayCol, NewDisplayCol);
                ChangeColWidths(DisplayCol, NewDisplayCol);
            end;

            DisplayCol := FSelectedCols.Previous(DisplayCol);
        end;
    finally
        if not MoveVisible then UpdateVisibleCols;
        FSelectedCols.FFirst := First;
        FSelectedCols.FLast := Last;
    end;
end;

procedure TtsBaseGrid.MoveColRange(FromDisplayCol, ToDisplayCol: Longint);
begin
    if FromDisplayCol = ToDisplayCol then Exit;

    if ToDisplayCol < FromDisplayCol then
        MoveColRangeLeft(FromDisplayCol, ToDisplayCol)
    else if ToDisplayCol > FromDisplayCol then
        MoveColRangeRight(FromDisplayCol, ToDisplayCol);

    if FSelectedCols.Count > 0
        then DoColMoved(FSelectedCols.First, FSelectedCols.Count, True)
        else DoColMoved(ToDisplayCol, 1, True);
    UpdateScrollRange;
    Invalidate;
end;

procedure TtsBaseGrid.ChangeDisplayRow(FromDisplayRow, ToDisplayRow: Longint);
var
    I: Integer;
    DataRow: Longint;
begin
    GridRows.CreateDisplayRowNumber;
    DataRow := GetDataRow(FromDisplayRow);

    if FromDisplayRow > ToDisplayRow then
    begin
        for I := (FromDisplayRow - 1) downto ToDisplayRow do
        begin
            GridRows.DisplayRowNumber[GetDataRow(I)] := GetDisplayRow(GetDataRow(I)) + 1;
            SetDataRow(I + 1, GetDataRow(I));
        end;
    end
    else if FromDisplayRow < ToDisplayRow then
    begin
        for I := (FromDisplayRow + 1) to ToDisplayRow do
        begin
            GridRows.DisplayRowNumber[GetDataRow(I)] := GetDisplayRow(GetDataRow(I)) - 1;
            SetDataRow(I - 1, GetDataRow(I));
        end;
    end;

    GridRows.DisplayRowNumber[DataRow] := ToDisplayRow;
    SetDataRow(ToDisplayRow, DataRow);
end;

procedure TtsBaseGrid.MoveVisibleRow(FromDisplayRow, ToDisplayRow: Longint);
begin
    if FVisibleRows.Count = Rows then Exit;
    FVisibleRows.MoveItem(FromDisplayRow, ToDisplayRow);
end;

procedure TtsBaseGrid.UpdateVisibleRows;
var
    I, Index: Integer;
begin
    if FVisibleRows.Count = Rows then Exit;

    Index := 0;
    for I := 1 to Rows do
    begin
        if IsRowVisible(GetDataRow(I)) and (Index < FVisibleRows.Count) then
        begin
            Inc(Index);
            FVisibleRows[Index] := I;
        end;
    end;
end;

procedure TtsBaseGrid.ChangeRowHeights(FromDisplayRow, ToDisplayRow: Longint);
var
    I: Longint;
    FromRowHeight: Integer;
begin
    FromRowHeight := RowHeights[FromDisplayRow];

    if FromDisplayRow > ToDisplayRow then
    begin
        for I := FromDisplayRow downto (ToDisplayRow + 1) do
        begin
            ResizeRow(I, RowHeights[I-1]);
        end;
    end
    else if FromDisplayRow < ToDisplayRow then
    begin
        for I := FromDisplayRow to (ToDisplayRow - 1) do
        begin
            ResizeRow(I, RowHeights[I+1]);
        end;
    end;

    ResizeRow(ToDisplayRow, FromRowHeight);
end;

function TtsBaseGrid.DiffSelectedRows(DisplayRow, FromDisplayRow: Longint): Longint;
begin
    if DisplayRow > FromDisplayRow then
        Result := NumberOfRowsSelected(FromDisplayRow + 1, DisplayRow)
    else if DisplayRow < FromDisplayRow then
        Result := - (NumberOfRowsSelected(DisplayRow, FromDisplayRow - 1))
    else
        Result := 0;
end;

procedure TtsBaseGrid.MoveRowRangeUp(FromDisplayRow, ToDisplayRow: Longint);
var
    I:Integer;
    First, Last: Longint;
    DisplayRow, NewDisplayRow, RowsInRange: Longint;
    SmallerRowsSelected: Longint;
    MoveVisible: Boolean;
begin
    if FSelectedRows.Count = 0 then
    begin
        ChangeDisplayRow(FromDisplayRow, ToDisplayRow);
        MoveVisibleRow(FromDisplayRow, ToDisplayRow);
        ChangeRowHeights(FromDisplayRow, ToDisplayRow);
        Exit;
    end;

    First := ToDisplayRow;
    Last := ToDisplayRow;

    MoveVisible := FSelectedRows.Count < 100;
    RowsInRange := NumberOfRowsSelected(ToDisplayRow, FromDisplayRow - 1);

    SmallerRowsSelected := 0;
    if ToDisplayRow > 1 then
        SmallerRowsSelected := NumberOfRowsSelected(1, ToDisplayRow - 1);

    DisplayRow := FSelectedRows.Previous(ToDisplayRow);
    NewDisplayRow := -1;
    for I := 1 to SmallerRowsSelected do
    begin
        if NewDisplayRow < 0 then
            NewDisplayRow := ToDisplayRow + RowsInRange +
                             DiffSelectedRows(DisplayRow, FromDisplayRow)
        else
            Dec(NewDisplayRow);

        if I = SmallerRowsSelected then First := NewDisplayRow;
        if (DisplayRow <> NewDisplayRow) then
        begin
            FSelectedRows.FBits[NewDisplayRow] := True;
            FSelectedRows.FBits[DisplayRow] := False;
            ChangeDisplayRow(DisplayRow, NewDisplayRow);
            if MoveVisible then MoveVisibleRow(DisplayRow, NewDisplayRow);
            ChangeRowHeights(DisplayRow, NewDisplayRow);
        end;

        DisplayRow := FSelectedRows.Previous(DisplayRow);
    end;

    DisplayRow := FSelectedRows.Next(ToDisplayRow - 1);
    NewDisplayRow := -1;
    for I := SmallerRowsSelected to (FSelectedRows.Count - 1) do
    begin
        if NewDisplayRow < 0 then
            NewDisplayRow := ToDisplayRow + RowsInRange +
                             DiffSelectedRows(DisplayRow, FromDisplayRow)
        else
            Inc(NewDisplayRow);

        if I = FSelectedRows.Count - 1 then Last := NewDisplayRow;
        if (DisplayRow <> NewDisplayRow) then
        begin
            FSelectedRows.FBits[NewDisplayRow] := True;
            FSelectedRows.FBits[DisplayRow] := False;
            ChangeDisplayRow(DisplayRow, NewDisplayRow);
            if MoveVisible then MoveVisibleRow(DisplayRow, NewDisplayRow);
            ChangeRowHeights(DisplayRow, NewDisplayRow);
        end;

        DisplayRow := FSelectedRows.Next(DisplayRow);
    end;

    if not MoveVisible then UpdateVisibleRows;
    FSelectedRows.FFirst := First;
    FSelectedRows.FLast := Last;
end;

procedure TtsBaseGrid.MoveRowRangeDown(FromDisplayRow, ToDisplayRow: Longint);
var
    I:Integer;
    First, Last: Longint;
    DisplayRow, NewDisplayRow, RowsInRange: Longint;
    LargerRowsSelected: Longint;
    MoveVisible: Boolean;
begin
    if FSelectedRows.Count = 0 then
    begin
        ChangeDisplayRow(FromDisplayRow, ToDisplayRow);
        MoveVisibleRow(FromDisplayRow, ToDisplayRow);
        ChangeRowHeights(FromDisplayRow, ToDisplayRow);
        Exit;
    end;

    First := ToDisplayRow;
    Last := ToDisplayRow;

    MoveVisible := FSelectedRows.Count < 100;
    RowsInRange := NumberOfRowsSelected(FromDisplayRow + 1, ToDisplayRow);

    LargerRowsSelected := 0;
    if ToDisplayRow < RowCount - 1 then
        LargerRowsSelected := NumberOfRowsSelected(ToDisplayRow + 1, RowCount - 1);

    DisplayRow := FSelectedRows.Next(ToDisplayRow);
    NewDisplayRow := -1;
    for I := 1 to LargerRowsSelected do
    begin
        if NewDisplayRow < 0 then
            NewDisplayRow := ToDisplayRow - RowsInRange +
                             DiffSelectedRows(DisplayRow, FromDisplayRow)
        else
            Inc(NewDisplayRow);

        if I = LargerRowsSelected then Last := NewDisplayRow;
        if (DisplayRow <> NewDisplayRow) then
        begin
            FSelectedRows.FBits[NewDisplayRow] := True;
            FSelectedRows.FBits[DisplayRow] := False;
            ChangeDisplayRow(DisplayRow, NewDisplayRow);
            if MoveVisible then MoveVisibleRow(DisplayRow, NewDisplayRow);
            ChangeRowHeights(DisplayRow, NewDisplayRow);
        end;

        DisplayRow := FSelectedRows.Next(DisplayRow);
    end;

    DisplayRow := FSelectedRows.Previous(ToDisplayRow + 1);
    NewDisplayRow := -1;
    for I := LargerRowsSelected to (FSelectedRows.Count - 1) do
    begin
        if NewDisplayRow < 0 then
            NewDisplayRow := ToDisplayRow - RowsInRange +
                             DiffSelectedRows(DisplayRow, FromDisplayRow)
        else
            Dec(NewDisplayRow);

        if I = FSelectedRows.Count - 1 then First := NewDisplayRow;
        if DisplayRow <> NewDisplayRow then
        begin
            FSelectedRows.FBits[NewDisplayRow] := True;
            FSelectedRows.FBits[DisplayRow] := False;
            ChangeDisplayRow(DisplayRow, NewDisplayRow);
            if MoveVisible then MoveVisibleRow(DisplayRow, NewDisplayRow);
            ChangeRowHeights(DisplayRow, NewDisplayRow);
        end;

        DisplayRow := FSelectedRows.Previous(DisplayRow);
    end;

    if not MoveVisible then UpdateVisibleRows;
    FSelectedRows.FFirst := First;
    FSelectedRows.FLast := Last;
end;

procedure TtsBaseGrid.MoveRowRange(FromDisplayRow, ToDisplayRow: Longint);
begin
    if FromDisplayRow = ToDisplayRow then Exit;

    if GridMode = gmEditInsert then
    begin
        EnablePaint := False;
        try
            if IsRowSelected(RowCount-1) then RowSelected[RowCount-1] := False;
        finally
            EnablePaint := True;
        end;
    end;

    if ToDisplayRow < FromDisplayRow then
        MoveRowRangeUp(FromDisplayRow, ToDisplayRow)
    else if ToDisplayRow > FromDisplayRow then
        MoveRowRangeDown(FromDisplayRow, ToDisplayRow);

    if FSelectedRows.Count > 0
        then DoRowMoved(FSelectedRows.First, FSelectedRows.Count, True)
        else DoRowMoved(ToDisplayRow, 1, True);
    UpdateScrollRange;
    Invalidate;
end;

function TtsBaseGrid.GiveHeadingFont(DataCol: Longint): TFont;
begin
    Result := HeadingFont;
    if Assigned(GridCols[DataCol].HeadingFont) then Result := GridCols[DataCol].HeadingFont;
end;

function TtsBaseGrid.GiveCellFont(DataCol, DataRow: Longint): TFont;
begin
    if (DataCol = 0) or (DataRow = 0) then
        Result := GiveHeadingFont(DataCol)
    else
    begin
        if not CellParentFont[DataCol, DataRow] then
            Result := CellFont[DataCol, DataRow]
        else
        begin
            if FDrawOverlap = doDrawColOnTop then
            begin
                if not GridCols[DataCol].ParentFont then
                    Result := GridCols[DataCol].Font
                else if not RowParentFont[DataRow] then
                    Result := RowFont[DataRow]
                else
                    Result := Font;
            end
            else
            begin
                if not RowParentFont[DataRow] then
                    Result := RowFont[DataRow]
                else if not GridCols[DataCol].ParentFont then
                    Result := GridCols[DataCol].Font
                else
                    Result := Font;
            end;
        end;
    end;
end;

function TtsBaseGrid.GiveHeadingWordWrap(DataCol: Longint): TtsWordWrap;
begin
    Result := HeadingWordWrap;
    if GridCols[DataCol].HeadingWordWrap <> wwDefault then Result := GridCols[DataCol].HeadingWordWrap;
end;

function TtsBaseGrid.GiveCellWordWrap(DataCol, DataRow: Longint): TtsWordWrap;
begin
    if (DataCol = 0) or (DataRow = 0) then
        Result := GiveHeadingWordWrap(DataCol)
    else
    begin
        Result := CellWordWrap[DataCol, DataRow];
        if Result = wwDefault then
        begin
            if FDrawOverlap = doDrawColOnTop then
            begin
                Result := GridCols[DataCol].WordWrap;
                if Result = wwDefault then Result := RowWordWrap[DataRow];
                if Result = wwDefault then Result := WordWrap;
            end
            else
            begin
                Result := RowWordWrap[DataRow];
                if Result = wwDefault then Result := GridCols[DataCol].WordWrap;
                if Result = wwDefault then Result := WordWrap;
            end;
        end;
    end;
end;

function TtsBaseGrid.GiveCellButton(DataCol, DataRow: Longint; var Style: TtsDropDownStyle): TtsButtonType;
begin
    Result := btNone;
    Style := ddDropDown;
    if (DataCol < 1) or (DataCol > Cols) then Exit;
    if (DataRow < 1) or (DataRow > RowCount - 1) then Exit;

    if FReadOnlyButton or not CellIsReadOnly(DataCol, DataRow) then
    begin
        Result := CellButtonType[DataCol, DataRow];
        if Result <> btDefault then
            Style := CellDropDownStyle[DataCol, DataRow]
        else if DrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].ButtonType;
            if Result <> btDefault then
                Style := GridCols[DataCol].DropDownStyle
            else
            begin
                Result := RowButtonType[DataRow];
                if Result <> btDefault then Style := RowDropDownStyle[DataRow]
            end;
        end
        else
        begin
            Result := RowButtonType[DataRow];
            if Result <> btDefault then
                Style := RowDropDownStyle[DataRow]
            else
            begin
                Result := GridCols[DataCol].ButtonType;
                if Result <> btDefault then
                    Style := GridCols[DataCol].DropDownStyle;
            end;
        end;

        if Result = btDefault then Result := btNone;
    end;
end;

function TtsBaseGrid.GiveCellButtonType(DataCol, DataRow: Longint): TtsButtonType;
var
    DropDownStyle: TtsDropDownStyle;
begin
    Result := GiveCellButton(DataCol, DataRow, DropDownStyle);
end;

function TtsBaseGrid.GiveCellDropDownStyle(DataCol, DataRow: Longint): TtsDropDownStyle;
begin
    GiveCellButton(DataCol, DataRow, Result);
end;

function TtsBaseGrid.GiveCellColor(DataCol, DataRow: Longint; Cell3D: Boolean): TColor;
begin
    if (DataCol = 0) or (DataRow = 0) then
    begin
        Result := clNone;
        if DataCol > 0 then Result := GridCols[DataCol].HeadingColor;
        if Result = clNone then Result := HeadingColor;
        Exit;
    end;

    Result := CellColor[DataCol, DataRow];
    if Result = clNone then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].Color;
            if Result = clNone then Result := RowColor[DataRow];
            if Result = clNone then
            begin
                if ((Color <> clNone) and (Color <> clWindow)) or (not Cell3D) then
                    Result := Color
                else
                    Result := clBtnFace;
            end;
        end
        else
        begin
            Result := RowColor[DataRow];
            if Result = clNone then Result := GridCols[DataCol].Color;
            if Result = clNone then
            begin
                if ((Color <> clNone) and (Color <> clWindow)) or (not Cell3D) then
                    Result := Color
                else
                    Result := clBtnFace;
            end;
        end;
    end;
end;

function TtsBaseGrid.GiveCellAlignment(DataCol, DataRow: Longint): TAlignment;
var
    HorzAlign: TtsHorzAlignment;
begin
    HorzAlign := GiveCellHorzAlignment(DataCol, DataRow);
    Result := HorzAlignmentToAlignment(HorzAlign);
end;

function TtsBaseGrid.GiveHeadingHorzAlignment(DataCol: Longint): TtsHorzAlignment;
begin
    Result := GridCols[DataCol].HeadingHorzAlignment;
    if Result = htaDefault then Result := HeadingHorzAlignment;
    if Result = htaDefault then result := HorzAlignment;
end;

function TtsBaseGrid.GiveCellHorzAlignment(DataCol, DataRow: Longint): TtsHorzAlignment;
begin
    if (DataCol = 0) or (DataRow = 0) then
        Result := GiveHeadingHorzAlignment(DataCol)
    else
    begin
        Result := CellHorzAlignment[DataCol, DataRow];
        if Result = htaDefault then
        begin
            if FDrawOverlap = doDrawColOnTop then
            begin
                Result := GridCols[DataCol].HorzAlignment;
                if Result = htaDefault then Result := RowHorzAlignment[DataRow];
            end
            else
            begin
                Result := RowHorzAlignment[DataRow];
                if Result = htaDefault then Result := GridCols[DataCol].HorzAlignment;
            end;
        end;

        if Result = htaDefault then
        begin
            if GridCols[DataCol].Alignment <> taLeftJustify then
                Result := AlignmentToHorzAlignment(GridCols[DataCol].Alignment, True)
            else
                Result := HorzAlignment;
        end;
    end;

    if Result = htaDefault then Result := htaLeft;
end;

function TtsBaseGrid.GiveHeadingVertAlignment(DataCol: Longint): TtsVertAlignment;
begin
    Result := GridCols[DataCol].HeadingVertAlignment;
    if Result = vtaDefault then Result := HeadingVertAlignment;
    if Result = vtaDefault then Result := VertAlignment;
end;

function TtsBaseGrid.GiveCellVertAlignment(DataCol, DataRow: Longint): TtsVertAlignment;
begin
    if (DataCol = 0) or (DataRow = 0) then
        Result := GiveHeadingVertAlignment(DataCol)
    else
    begin
        Result := CellVertAlignment[DataCol, DataRow];
        if Result = vtaDefault then
        begin
            if FDrawOverlap = doDrawColOnTop then
            begin
                Result := GridCols[DataCol].VertAlignment;
                if Result = vtaDefault then Result := RowVertAlignment[DataRow];
            end
            else
            begin
                Result := RowVertAlignment[DataRow];
                if Result = vtaDefault then Result := GridCols[DataCol].VertAlignment;
            end;
        end;
        
        if Result = vtaDefault then Result := VertAlignment;
    end;

    if Result = vtaDefault then Result := vtaTop;
end;

function TtsBaseGrid.GiveCell3D(DataCol, DataRow: Longint): Boolean;
begin
    if (DataCol = 0) or (DataRow = 0) then
        Result := Heading3D
    else
    begin
        Result := Is3D or
                  GridCols[DataCol].Is3D or
                  RowIs3D[DataRow] or
                  CellIs3D[DataCol, DataRow];
    end;
end;

function TtsBaseGrid.GiveCellMaskName(DataCol, DataRow: Longint): string;
begin
    Result := '';
    if (DataCol <= 0) or (DataCol > Cols) then Exit;
    if (DataRow <= 0) or (DataRow > Rows) then Exit;

    Result := CellMaskName[DataCol, DataRow];
    if Result = '' then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].FMaskName;
            if Result = '' then Result := RowMaskName[DataRow];
        end
        else
        begin
            Result := RowMaskName[DataRow];
            if Result = '' then Result := GridCols[DataCol].FMaskName;
        end;
    end;
end;

function TtsBaseGrid.CurCellMaskName: string;
begin
    Result := GiveCellMaskName(CurDataCol, CurDataRow);
end;

function TtsBaseGrid.CurCellControlType: TtsControlType;
begin
    Result := GiveCellControlType(CurDataCol, CurDataRow);
end;

function TtsBaseGrid.CurCellReadOnly: Boolean;
begin
    Result := CellIsReadOnly(CurDataCol, CurDataRow);
end;

function TtsBaseGrid.CurCellSelected: Boolean;
begin
    Result := IsCellSelected(CurDisplayCol, CurDisplayRow);
end;

function TtsBaseGrid.CurCellCheckBoxValues: string;
begin
    Result := GiveCellCheckBoxValues(CurDataCol, CurDataRow);
end;

function TtsBaseGrid.GiveCellControlType(DataCol, DataRow: Longint): TtsControlType;
begin
    Result := ctNone;
    if (DataCol <= 0) or (DataCol > Cols) then Exit;
    if (DataRow <= 0) or (DataRow > RowCount - 1) then Exit;

    Result := CellControlType[DataCol, DataRow];
    if Result = ctDefault then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].ControlType;
            if Result = ctDefault then
                Result := RowControlType[DataRow]
        end
        else
        begin
            Result := RowControlType[DataRow];
            if Result = ctDefault then
                Result := GridCols[DataCol].ControlType;
        end;
    end;

    if Result = ctDefault then Result := ctText;
end;

function TtsBaseGrid.GiveCellSpinOptions(DataCol, DataRow: Longint): TtsSpinOptions;
begin
    Result := [];
    if (DataCol < 1) or (DataCol > Cols) then Exit;
    if (DataRow < 1) or (DataRow > RowCount - 1) then Exit;

    if IsSpinButton(CellButtonType[DataCol, DataRow]) then
        Result := CellSpinOptions[DataCol, DataRow]
    else if DrawOverlap = doDrawColOnTop then
    begin
        if IsSpinButton(GridCols[DataCol].ButtonType) then
            Result := GridCols[DataCol].SpinOptions
        else if IsSpinButton(RowButtonType[DataRow]) then
            Result := RowSpinOptions[DataRow];
    end
    else
    begin
        if IsSpinButton(RowButtonType[DataRow]) then
            Result := RowSpinOptions[DataRow]
        else if IsSpinButton(GridCols[DataCol].ButtonType) then
            Result := GridCols[DataCol].SpinOptions;
    end;
end;

function TtsBaseGrid.GiveCellSpinIncrement(DataCol, DataRow: Longint): Double;
begin
    Result := 0;
    if (DataCol < 1) or (DataCol > Cols) then Exit;
    if (DataRow < 1) or (DataRow > RowCount - 1) then Exit;

    if IsSpinButton(CellButtonType[DataCol, DataRow]) then
        Result := CellSpinIncrement[DataCol, DataRow]
    else if DrawOverlap = doDrawColOnTop then
    begin
        if IsSpinButton(GridCols[DataCol].ButtonType) then
            Result := GridCols[DataCol].SpinIncrement
        else if IsSpinButton(RowButtonType[DataRow]) then
            Result := RowSpinIncrement[DataRow];
    end
    else
    begin
        if IsSpinButton(RowButtonType[DataRow]) then
            Result := RowSpinIncrement[DataRow]
        else if IsSpinButton(GridCols[DataCol].ButtonType) then
            Result := GridCols[DataCol].SpinIncrement;
    end;
end;

function TtsBaseGrid.ActiveControlType(DataCol: Longint; DataRow: Variant): TtsControlType;
begin
    Result := ctNone;
    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, RowCount - 1) then
        Result := GiveCellControlType(DataCol, DataRow);
end;

function TtsBaseGrid.ActiveCombo(DataCol: Longint; DataRow: Variant): TtsCombo;
begin
    Result := nil;
    if CheckIndex(itCol, DataCol, 1, Cols) and
       CheckIndex(itRow, DataRow, 1, RowCount - 1) then
        Result := GiveCellCombo(DataCol, DataRow);
end;

function TtsBaseGrid.GiveCellStretchPicture(DataCol, DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if (DataCol = 0) or (DataRow = 0) then Exit;

    Result := CellStretchPicture[DataCol, DataRow];
    if Result = dopDefault then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].StretchPicture;
            if Result = dopDefault then
                Result := RowStretchPicture[DataRow]
        end
        else
        begin
            Result := RowStretchPicture[DataRow];
            if Result = dopDefault then
                Result := GridCols[DataCol].StretchPicture;
        end;
    end;
end;

function TtsBaseGrid.GiveCellShrinkPicture(DataCol, DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if (DataCol = 0) or (DataRow = 0) then Exit;

    Result := CellShrinkPicture[DataCol, DataRow];
    if Result = dopDefault then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].ShrinkPicture;
            if Result = dopDefault then
                Result := RowShrinkPicture[DataRow];
        end
        else
        begin
            Result := RowShrinkPicture[DataRow];
            if Result = dopDefault then
                Result := GridCols[DataCol].ShrinkPicture;
        end;
    end;
end;

function TtsBaseGrid.GiveCellCenterPicture(DataCol, DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if (DataCol = 0) or (DataRow = 0) then Exit;

    Result := CellCenterPicture[DataCol, DataRow];
    if Result = dopDefault then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].CenterPicture;
            if Result = dopDefault then
                Result := RowCenterPicture[DataRow];
        end
        else
        begin
            Result := RowCenterPicture[DataRow];
            if Result = dopDefault then
                Result := GridCols[DataCol].CenterPicture;
        end;
    end;
end;

function TtsBaseGrid.GiveCellKeepAspectRatio(DataCol, DataRow: Longint): TtsDrawOption;
begin
    Result := dopDefault;
    if (DataCol = 0) or (DataRow = 0) then Exit;

    Result := CellKeepAspectRatio[DataCol, DataRow];
    if Result = dopDefault then
    begin
        if FDrawOverlap = doDrawColOnTop then
        begin
            Result := GridCols[DataCol].KeepAspectRatio;
            if Result = dopDefault then
                Result := RowKeepAspectRatio[DataRow];
        end
        else
        begin
            Result := RowKeepAspectRatio[DataRow];
            if Result = dopDefault then
                Result := GridCols[DataCol].KeepAspectRatio;
        end;
    end;
end;

function TtsBaseGrid.GiveCellCheckBoxValues(DataCol, DataRow: Longint): string;
begin
    Result := '';
    if not GridCols[DataCol].UseCheckBoxValues then Exit;

    Result := GridCols[DataCol].CheckBoxValues;
    if Result = '' then Result := CheckBoxValues;
end;

procedure TtsBaseGrid.DrawFixedCellSelected(ARect: TRect);
var
    Bitmap: TBitmap;
    BmpRect: TRect;
begin
    if ARect.Left >= ARect.Right then Exit;
    if ARect.Top >= ARect.Bottom then Exit;

    Bitmap := nil;

    Dec(ARect.Right, 1);
    Dec(ARect.Bottom, 1);

    try
        Bitmap := TBitmap.Create;
        Bitmap.Width := ARect.Right - ARect.Left;
        Bitmap.Height := ARect.Bottom - ARect.Top;

        Bitmap.Canvas.Brush.Color := FHeadingColor;
        BmpRect := Rect(0, 0, Bitmap.Width, Bitmap.Height);
        Bitmap.Canvas.FillRect(BmpRect);

        PatBlt(Bitmap.Canvas.Handle, BmpRect.Left, BmpRect.Top,
               BmpRect.Right - BmpRect.Left,  BmpRect.Bottom - BmpRect.Top,
               cmDstInvert);

        Canvas.CopyRect(ARect, Bitmap.Canvas, BmpRect);
        if Heading3D then DrawEdge(Canvas.Handle, ARect, BDR_SUNKENINNER, BF_TOPLEFT);

    finally
        Bitmap.Free;
    end;
end;

procedure TtsBaseGrid.DrawFixedCellUnselected(ARect: TRect; ACol: Longint);
var
    AColor: TColor;
begin
    if ARect.Left >= ARect.Right then Exit;
    if ARect.Top >= ARect.Bottom then Exit;

    Dec(ARect.Right, 1);
    Dec(ARect.Bottom, 1);
    if ACol > 0
        then AColor := GiveCellColor(GetDataCol(ACol), 0, False)
        else AColor := FHeadingColor;
    if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;

    Canvas.FillRect(ARect);

    if (ACol <> -1) then
    begin
        if (FHeadingClicked = GetDataCol(ACol)) and (not FHeadingButtonClicked)
            and FDrawHeadingButtonDown then
                DrawEdge(Canvas.Handle, ARect, BDR_SUNKENINNER, BF_TOPLEFT)
        else if Heading3D then
            DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_TOPLEFT);
    end
    else if Heading3D then
        DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_TOPLEFT);
end;

procedure TtsBaseGrid.DrawGridCellUnselected(ARect: TRect);
begin
    if ARect.Left >= ARect.Right then Exit;
    if ARect.Top >= ARect.Bottom then Exit;

    Dec(ARect.Right, 1);
    Dec(ARect.Bottom, 1);
    if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
    Canvas.FillRect(Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom));
end;

procedure TtsBaseGrid.DrawFixedLines(ARect: TRect; AColor: TColor);
var
    OldPen: TPen;
begin
    OldPen := TPen.Create;
    try
        with Canvas do
        begin
            OldPen.Assign(Pen);
            Pen.Color := AColor;
            Pen.Style := psSolid;
            Pen.Mode := pmCopy;
            Pen.Width := 1;
            try
                MoveTo(ARect.Left, ARect.Bottom - 1);
                LineTo(ARect.Right - 1, ARect.Bottom - 1);
                LineTo(ARect.Right - 1, ARect.Top - 1);
            finally
                Pen.Assign(OldPen);
            end;
        end;
    finally
        OldPen.Free;
    end;
end;

procedure TtsBaseGrid.DrawHeadingButtonUp(Canvas: TCanvas; const DrawData: TtsDrawData;
                                          DisplayCol: Longint);
begin
    with Canvas, DrawData, DrawData.ButtonRect do
    begin
        Pen.Color := clBtnFace;
        if Alignment <> taRightJustify then
        begin
            MoveTo(Left - 1, Top - 1);
            LineTo(Left - 1, CalcMin(Bottom - Top, HeadButHeight));
        end
        else if Left + HeadButWidth <= Right then
        begin
            MoveTo(Right - 1, Top - 1);
            LineTo(Right - 1, CalcMin(Bottom - Top, HeadButHeight));
        end;

        Pen.Color := clWhite;
        MoveTo(Left, Top);
        LineTo(Left, CalcMin(Bottom - Top, HeadButHeight - 1));

        MoveTo(Left, Top - 1);
        LineTo(Left + CalcMin(Right - Left, HeadButWidth - 1), Top - 1);

        if (Bottom - Top > 2) and (Right - Left > 1) then
        begin
            Pen.Color := clBtnShadow;
            if Bottom - Top > HeadButHeight - 1 then
            begin
                MoveTo(Left, Top + HeadButHeight - 2);
                LineTo(Left + CalcMin(Right - Left, HeadButWidth - 1), Top + HeadButHeight - 2);
            end;

            Pen.Color := clBtnShadow;
            if (Right - Left > HeadButWidth - 1) and
               ((FHeadingClicked <> GetDataCol(DisplayCol)) or
                (FHeadingClicked = GetDataCol(DisplayCol)) and FHeadingButtonClicked) then
            begin
                MoveTo(Left + HeadButWidth - 1, Top + HeadButHeight - 2);
                LineTo(Left + HeadButWidth - 1, Top - 1);
            end;
        end;
    end;
end;

procedure TtsBaseGrid.DrawHeadingButtonDown(Canvas: TCanvas; const DrawData: TtsDrawData;
                                            DisplayCol: Longint);
begin
    with Canvas, DrawData, DrawData.ButtonRect do
    begin
        Pen.Color := clBlack;
        if Alignment <> taRightJustify
            then MoveTo(Left + CalcMin(Right - Left, HeadButWidth), Top - 1)
            else MoveTo(Left + CalcMin(Right - Left, HeadButWidth - 1), Top - 1);
        LineTo(Left, Top - 1);

        Pen.Color := clBlack;
        MoveTo(Left, Top - 1);
        LineTo(Left, CalcMin(Bottom - Top, HeadButHeight));

        Pen.Color := clBtnShadow;
        if (Alignment = taRightJustify) and (Left + HeadButWidth - 1 <= FullRect.Right) and
           ((FHeadingClicked <> GetDataCol(DisplayCol)) or
            (FHeadingClicked = GetDataCol(DisplayCol)) and FHeadingButtonClicked) then
        begin
            MoveTo(Left + HeadButWidth - 1, Top + HeadButHeight - 2);
            LineTo(Left + HeadButWidth - 1, Top - 1);
        end;

        if Top + HeadButHeight < Bottom then
        begin
            MoveTo(Left + 1, Top + HeadButHeight - 2);
            LineTo(Left + 1 + CalcMin(Right - Left, HeadButWidth - 1), Top + HeadButHeight - 2);
        end;
    end;
end;

procedure TtsBaseGrid.DoGetSortPicture(SortPicture: TtsSortPicture; var Bitmap: TBitmap);
begin
    Bitmap := nil;
    case SortPicture of
        spUp: Bitmap := BitMapSortUp;
        spDown: Bitmap := BitMapSortDown;
        spBullet: Bitmap := BitMapSortBullet;
    end;
end;

procedure TtsBaseGrid.DrawHeadingButton(Canvas: TCanvas; DisplayCol: Longint;
                                        const DrawData: TtsDrawData);
var
    OldPen: TPen;
    LeftOffset: Integer;
    NewRect, BmpRect: TRect;
    BmpOffSet: Integer;
    Bmp: TBitmap;
begin
    with DrawData do
    begin
        if not DrawButton then Exit;
        if FullRect.Right <= DrawRect.Right then Exit;

        OldPen := TPen.Create;
        try
            NewRect := ButtonRect;
            with Canvas do
            begin
                Brush.Color := GiveCellColor(DataCol, 0, False);
                if ButtonInColHeading(DisplayCol) then
                begin
                    LeftOffset := -1;
                    if Alignment <> taRightJustify then LeftOffset := 1;
                    Canvas.FillRect(Rect(NewRect.Left - LeftOffset, NewRect.Top,
                                         CalcMin(NewRect.Right + 1, FullRect.Right),
                                         NewRect.Bottom - 1));
                end;

                BmpOffset := 0;
                if FDrawHeadingButtonDown then Inc(BmpOffset);

                DoGetSortPicture(GridCols[GetDataCol(DisplayCol)].SortPicture, Bmp);
                if Bmp <> nil then
                with NewRect do
                begin
                    LeftOffset := 0;
                    if (Alignment = taRightJustify) and
                       (Bmp <> BitMapSortBullet) then LeftOffset := 1;

                    CopyToDrawBitmap(Bmp);
                    BmpRect := Rect(0, 0,
                                    CalcMin(Right - Left - 2 - BmpOffset, HeadButWidth - 3),
                                    CalcMin(HeadButHeight - 1 - BmpOffSet, Bottom - Top - 1 - BmpOffset));
                    BrushCopy(Rect(Left + BmpOffset + 2 - LeftOffset, Top + BmpOffset,
                                   Left + BmpOffset + 2 - LeftOffset + BmpRect.Right,
                                   Top + BmpOffset + BmpRect.Bottom),
                              DrawBitmap, BmpRect, clBlack);
                end;

                if ButtonInColHeading(DisplayCol) then
                begin
                    OldPen.Assign(Pen);
                    Pen.Style := psSolid;
                    Pen.Mode := pmCopy;
                    Pen.Width := 1;
                    try
                        if FHeadingButtonClicked and FDrawHeadingButtonDown then
                            DrawHeadingButtonDown(Canvas, DrawData, DisplayCol)
                        else
                            DrawHeadingButtonUp(Canvas, DrawData, DisplayCol);
                    finally
                        Pen.Assign(OldPen);
                    end;
                end;
            end;
        finally
            OldPen.Free;
        end;
    end;
end;

procedure TtsBaseGrid.DrawHeadingText(DisplayCol: Longint; ARect: TRect);
var
    Heading: string;
    TextRect: TRect;
    DrawData: TtsDrawData;
    AccelKeyPos: Integer;
begin
    if not GridCols[GetDataCol(DisplayCol)].Visible then Exit;

    Heading := TextAccelKey(GridCols[GetDataCol(DisplayCol)].Heading, AccelKeyPos);
    if (Heading = '') and
       not (IsColHeadingButton(DisplayCol) or ButtonInColHeading(DisplayCol) or
            (GridCols[GetDataCol(DisplayCol)].SortPicture <> spNone)) then Exit;

    GetDrawData(DisplayCol, 0, True, DrawData);
    with DrawData do
    begin
        if Canvas.Brush.Color <> BrushColor then Canvas.Brush.Color := BrushColor;
        Canvas.Font := Font;

        if (DrawRect.Right >= DrawRect.Left + tsRangeSelectWidth) and (Heading <> '') then
        begin
            TextRect := DrawRect;
            if (Alignment <> taLeftJustify) then
            begin
                if FDrawHeadingButtonDown and not ButtonInColHeading(DisplayCol) then
                    Inc(TextRect.Right);
            end;

            DisplayText(Canvas, PChar(Heading), HeadingHeight, TextRect,
                        TextRect.Left + tsRangeSelectWidth, TextRect.Top,
                        Alignment, VertAlignment, (WordWrap <> wwOff), AccelKeyPos);
        end;

        if Cell3D and ((not FDrawHeadingButtonDown) or (FHeadingButtonClicked)) and
           ((FHeadingClicked = GetDataCol(DisplayCol)) or (FHeadingClicked = -1)) then
        begin
            if FullRect.Right > FullRect.Left then
                DrawEdge(Canvas.Handle, FullRect, BDR_RAISEDINNER, BF_TOPLEFT);
        end;

        DrawHeadingButton(Canvas, DisplayCol, DrawData);
    end;
end;

procedure TtsBaseGrid.FillSelectionPart(ControlType: TtsControlType; const DrawData: TtsDrawData; DrawSelected: Boolean);
var
    Rect: TRect;
begin
    if not CanPaint then Exit;
    if csDesigning in ComponentState then Exit;

    if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;

    with DrawData do
    begin
        Rect := FullRect;
        Rect.Right := CalcMin(Rect.Left + tsRangeSelectWidth, Rect.Right);
        if Cell3D then Rect.Bottom := Rect.Bottom - (1 - FHorzLineWidth);

        FillCellRect(DrawData, Rect, ControlType, DrawSelected);

        if Cell3D and
           ((not DrawControl) or (ControlType <> ctText)) then
        begin
            DrawEdge(Canvas.Handle, Rect, BDR_RAISEDINNER, BF_TOPLEFT);
        end;
    end;
end;

function TtsBaseGrid.DrawFlatButtonUp(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := (not FlatButtons) and
              ((InactiveButtonState = ibsBackGround) or
               CanDrawButton(DisplayCol, DisplayRow, True));
end;

function TtsBaseGrid.ButtonBrushColor(AColor: TColor; var DrawData: TtsDrawData; DrawSelected: Boolean): TColor;
begin
    if AColor <> clNone then
        Result := AColor
    else
    begin
        with DrawData do
        begin
            Result := BrushColor;
            if DrawSelected and (SelectionColorEnabled) then
                Result := SelectionColor
            else if DisplayFocusRect(DisplayCol, DisplayRow, True) and (FocusColor <> clNone) then
                Result := FocusColor;
        end;
    end;
end;

procedure TtsBaseGrid.DrawUpButton(ARect: TRect; LineColor: TColor;
                                   ButtonWidth, ButtonHeight: Integer; DrawTopLine, DrawLeftLine: Boolean);
begin
    Canvas.FillRect(ARect);
    Canvas.Pen.Color := LineColor;
    if DrawLeftLine then
    begin
        Canvas.MoveTo(ARect.Left - 1, ARect.Top);
        Canvas.LineTo(ARect.Left - 1, ARect.Bottom);
    end;
    if DrawTopLine then
    begin
        Canvas.MoveTo(ARect.Left - 1, ARect.Top - 1);
        Canvas.LineTo(ARect.Right, ARect.Top - 1);
    end;

    DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_TOPLEFT);
    if ARect.Right >= (ARect.Left + ButtonWidth - 1) then
    begin
        if ARect.Bottom >= (ARect.Top + ButtonHeight)
            then DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_BOTTOMRIGHT)
            else DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_RIGHT);
    end
    else
    begin
        if ARect.Bottom >= (ARect.Top + ButtonHeight) then
             DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_BOTTOM)
    end;
end;

procedure TtsBaseGrid.DrawDownButton(ARect: TRect; LineColor: TColor;
                                     ButtonWidth, ButtonHeight: Integer; DrawTopLine, DrawLeftLine: Boolean);
var
    BorderMode: Integer;
begin
    Canvas.FillRect(ARect);
    Canvas.Pen.Color := LineColor;
    if DrawLeftLine then
    begin
        Canvas.MoveTo(ARect.Left - 1, ARect.Top);
        Canvas.LineTo(ARect.Left - 1, ARect.Bottom);
    end;
    if DrawTopLine then
    begin
        Canvas.MoveTo(ARect.Left - 1, ARect.Top - 1);
        Canvas.LineTo(ARect.Right, ARect.Top - 1);
    end;

    BorderMode := BDR_SUNKENINNER;
    if ARect.Right >= (ARect.Left + ButtonWidth - 1) then
    begin
        if (ARect.Bottom + 1) >= (ARect.Top + ButtonHeight)
            then DrawEdge(Canvas.Handle, ARect, BorderMode, BF_BOTTOMRIGHT)
            else DrawEdge(Canvas.Handle, ARect, BorderMode, BF_RIGHT);
    end
    else
    begin
        if (ARect.Bottom + 1) >= (ARect.Top + ButtonHeight) then
             DrawEdge(Canvas.Handle, ARect, BorderMode, BF_BOTTOM)
    end;
    DrawEdge(Canvas.Handle, ARect, BDR_SUNKENOUTER, BF_TOPLEFT);
end;

procedure TtsBaseGrid.DrawButtonBox(AColor: TColor; ButtonMode: TtsButtonMode;
                                    var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    ARect: TRect;
    ButtonColor: TColor;
begin
    with DrawData do
    begin
        if (ButtonRect.Left >= ButtonRect.Right) or
           (ButtonRect.Top >= ButtonRect.Bottom) then Exit;

        FGridButton := GridCellButton(DisplayCol, ButtonType);
        if not Assigned(FGridButton) then Exit;

        ARect := ButtonRect;
        if (ButtonMode = bmFlat) and FlatButtons then
        begin
            ARect.Left := CalcMax(ARect.Left + FButtonEdgeWidth,
                                  ARect.Right - FGridButton.Width - FButtonEdgeWidth);
            ARect.Right := CalcMax(ARect.Left, ARect.Right - FButtonEdgeWidth);
            Inc(ARect.Top, FButtonEdgeWidth);
            ARect.Bottom := CalcMin(ARect.Bottom, ARect.Top + FGridButton.Height);
        end
        else
        begin
            ARect.Left := CalcMin(ARect.Left + 1, ARect.Right);
            ARect.Top := ARect.Top + (1 - FHorzLineWidth);
            ARect.Bottom := CalcMin(ARect.Bottom, ARect.Top + FGridButton.FullHeight);
        end;

        ButtonColor := ButtonBrushColor(AColor, DrawData, DrawSelected);
        if Canvas.Brush.Color <> ButtonColor then Canvas.Brush.Color := ButtonColor;

        if (ButtonMode = bmUp) or
           ((ButtonMode = bmFlat) and DrawFlatButtonUp(DisplayCol, DisplayRow)) then
        begin
            DrawUpButton(ARect, clSilver, FGridButton.FullWidth, FGridButton.FullHeight, (FHorzLineWidth = 0), True);
        end
        else if ButtonMode = bmDown then
        begin
            DrawDownButton(ARect, clSilver, FGridButton.FullWidth, FGridButton.FullHeight, (FHorzLineWidth = 0), True);
        end
        else //ButtonMode = bmFlat
        begin
            Canvas.FillRect(ARect);

            if Cell3D then
            begin
                if (FCurDisplayCol <> DisplayCol) or (FCurDisplayRow <> DisplayRow) then
                    DrawEdge(Canvas.Handle, ButtonRect, BDR_RAISEDINNER, BF_TOP)
                else if (not DrawControl) or (ControlType <> ctText) then
                begin
                    if (FocusBorder in [fbNone, fbSingle]) or not DisplayFocusRect(DisplayCol, DisplayRow, True) then
                        DrawEdge(Canvas.Handle, ButtonRect, BDR_RAISEDINNER, BF_TOP)
                end
                else if FGridStatus <> grNormal then
                    DrawEdge(Canvas.Handle, ButtonRect, BDR_RAISEDINNER, BF_TOP);
            end;
        end;
    end;
end;

procedure TtsBaseGrid.GetVertSpinRects(ButtonRect: TRect; var TopRect, BottomRect: TRect; var TopHeight, BottomHeight: Integer);
var
    ARect: TRect;
begin
    ARect := ButtonRect;
    ARect.Top := ARect.Top + (1 - FHorzLineWidth);
    ARect.Bottom := ARect.Bottom;

    TopHeight := CalcMax(MinSpinButtonExtent, (ARect.Bottom - ARect.Top) div 2);
    TopHeight := CalcMin(TopHeight, FGridButton.FullHeight div 2);
    TopRect := ARect;
    TopRect.Left := CalcMin(TopRect.Left + 1, TopRect.Right);
    TopRect.Bottom := CalcMin(ARect.Bottom, TopRect.Top + TopHeight);

    BottomHeight := TopHeight;
    BottomRect := TopRect;
    BottomRect.Top := BottomRect.Top + TopHeight;
    BottomRect.Bottom := CalcMin(ARect.Bottom, BottomRect.Top + BottomHeight);
end;

procedure TtsBaseGrid.GetHorzSpinRects(ButtonRect: TRect; var RightRect, LeftRect: TRect; var RightWidth, LeftWidth: Integer);
var
    ARect: TRect;
    Diff: Integer;
begin
    ARect := ButtonRect;
    ARect.Top := ARect.Top + (1 - FHorzLineWidth);
    ARect.Left := ARect.Left + 1;

    LeftWidth := CalcMax(MinSpinButtonExtent, (ARect.Right - ARect.Left) div 2);
    LeftWidth := CalcMin(LeftWidth, FGridButton.FullWidth div 2);
    LeftRect := ARect;
    LeftRect.Left := CalcMin(LeftRect.Left, LeftRect.Right);
    LeftRect.Right := CalcMin(LeftRect.Left + LeftWidth, LeftRect.Right);
    LeftRect.Bottom := CalcMin(ARect.Bottom, LeftRect.Top + FGridButton.FullHeight);

    RightWidth := LeftWidth;
    RightRect := LeftRect;
    RightRect.Left := RightRect.Left + LeftWidth;
    RightRect.Right := CalcMin(ARect.Right, RightRect.Left + RightWidth);

    if RightRect.Right < ARect.Right then
    begin
        Diff := ARect.Right - RightRect.Right;
        Inc(RightRect.Left, Diff);
        Inc(RightRect.Right, Diff);
        Inc(LeftRect.Left, Diff);
        Inc(LeftRect.Right, Diff);
    end;
end;

procedure TtsBaseGrid.GetSpinRects(ButtonType: TtsButtonType; ButtonRect: TRect; var TopRightRect, BottomLeftRect: TRect; var TopRightExtent, BottomLeftExtent: Integer);
begin
    if ButtonType = btVertSpin
        then GetVertSpinRects(ButtonRect, TopRightRect, BottomLeftRect, TopRightExtent, BottomLeftExtent)
        else GetHorzSpinRects(ButtonRect, TopRightRect, BottomLeftRect, TopRightExtent, BottomLeftExtent);
end;

function TtsBaseGrid.GetSpinButtonXY(X, Y: Integer; DisplayCol, DisplayRow: Longint): TtsSpinButton;
var
    DrawData: TtsDrawData;
    IncRect, DecRect: TRect;
    IncExtent, DecExtent: Integer;
begin
    Result := spbNone;
    GetDrawData(DisplayCol, DisplayRow, True, DrawData);
    if (DrawData.ButtonType in [btVertSpin, btHorzSpin]) then
    begin
        GetSpinRects(DrawData.ButtonType, DrawData.ButtonRect, IncRect, DecRect, IncExtent, DecExtent);
        if PointInRect(Point(X,Y), IncRect) then
            Result := spbIncrement
        else if PointInRect(Point(X,Y), DecRect) then
            Result := spbDecrement;
    end;
end;

function TtsBaseGrid.OverSpinButton(X, Y: Integer; DisplayCol, DisplayRow: Longint; SpinButton: TtsSpinButton): Boolean;
begin
    Result := False;
    if SpinButton = spbNone then Exit;
    Result := SpinButton = GetSpinButtonXY(X, Y, DisplayCol, DisplayRow);
end;

procedure TtsBaseGrid.DrawSpinPicture(ButtonType: TtsButtonType; SpinButton: TtsSpinButton; DrawRect: TRect; ButtonWidth, ButtonHeight: Integer; Bitmap: TBitmap; ButtonDown: Boolean);
var
    ARect: TRect;
    BmpRect: TRect;
    OldMode: TCopyMode;
    BitmapWidth, BitmapHeight: Integer;
begin
    if (DrawRect.Left >= DrawRect.Right) or
       (DrawRect.Top >= DrawRect.Bottom) then Exit;

    if ButtonType = btVertSpin then
    begin
        Dec(ButtonWidth);
        BitmapWidth := CalcMin(Bitmap.Width, ButtonWidth - 2);
        BitmapHeight := CalcMin(Bitmap.Height, ButtonHeight - 4);
    end
    else
    begin
        BitmapWidth := CalcMin(Bitmap.Width, ButtonWidth - 4);
        BitmapHeight := CalcMin(Bitmap.Height, ButtonHeight - 2);
    end;

    BitmapWidth := CalcMin(CalcMax(2, BitmapWidth), ButtonWidth - 2);
    BitmapHeight := CalcMin(CalcMax(2, BitmapHeight), ButtonHeight - 2);
    if (BitmapHeight <= 0) or (BitmapWidth <= 0) then Exit;

    ARect := DrawRect;
    ARect.Left := ARect.Left + ((ButtonWidth - BitMapWidth) div 2);
    ARect.Top := ARect.Top + ((ButtonHeight - BitMapHeight) div 2);

    if (ButtonType = btVertSpin) and (SpinButton = spbDecrement) and
       ((ButtonHeight - BitMapHeight) mod 2 <> 0) then
    begin
        Inc(ARect.Top);
    end;

    if (ButtonType = btHorzSpin) then
    begin
        if ((ButtonHeight - BitMapHeight) mod 2 <> 0) then
            Inc(ARect.Top);
        if (SpinButton = spbIncrement) and ((ButtonWidth - BitMapWidth) mod 2 <> 0) then
            Inc(ARect.Left);
    end;

    if ButtonDown then Inc(ARect.Left, 1);
    ARect.Left := CalcMin(ARect.Left, ARect.Right);
    ARect.Right := CalcMin(ARect.Left + BitMapWidth, ARect.Right);
    if ARect.Left >= ARect.Right then Exit;

    if ButtonDown then Inc(ARect.Top, 1);
    ARect.Top := CalcMin(ARect.Top, ARect.Bottom);
    ARect.Bottom := CalcMin(ARect.Top + BitMapHeight, ARect.Bottom);
    if ARect.Top >= ARect.Bottom then Exit;

    BmpRect := Rect(0, 0, 0, 0);
    if ButtonType = btVertSpin then
    begin
        BmpRect.Left := (Bitmap.Width - BitmapWidth) div 2;
        if SpinButton = spbDecrement then
            BmpRect.Top := Bitmap.Height - BitmapHeight;
    end
    else
    begin
        if SpinButton = spbIncrement then
            BmpRect.Left := Bitmap.Width - BitmapWidth;
    end;
    BmpRect.Right := BmpRect.Left + BitmapWidth;
    BmpRect.Bottom := BmpRect.Top + BitmapHeight;

    BmpHandleNeeded(Bitmap);
    OldMode := Canvas.CopyMode;
    Canvas.CopyMode := cmMergeCopy;
    Canvas.CopyRect(ARect, Bitmap.Canvas, BmpRect);
    Canvas.CopyMode := OldMode;
end;

procedure TtsBaseGrid.DrawSpinButtons(ButtonType: TtsButtonType; DrawButtons: TtsSpinButtons; DownButton: TtsSpinButton;
                                      AColor: TColor; var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    UpRect, DownRect: TRect;
    UpHeight, DownHeight: Integer;
    LeftRect, RightRect: TRect;
    LeftWidth, RightWidth: Integer;
    ButtonColor: TColor;
begin
    with DrawData do
    begin
        ButtonColor := ButtonBrushColor(AColor, DrawData, DrawSelected);
        if Canvas.Brush.Color <> ButtonColor then Canvas.Brush.Color := ButtonColor;
        if ButtonType = btVertSpin then
        begin
            GetSpinRects(ButtonType, DrawData.ButtonRect, UpRect, DownRect, UpHeight, DownHeight);
            if (spbIncrement in DrawButtons) and (UpRect.Top < UpRect.Bottom) then
            begin
                if (DownButton = spbIncrement)
                    then DrawDownButton(UpRect, clSilver, FGridButton.FullWidth, UpHeight, (FHorzLineWidth = 0), True)
                    else DrawUpButton(UpRect, clSilver, FGridButton.FullWidth, UpHeight, (FHorzLineWidth = 0), True);
                DrawSpinPicture(ButtonType, spbIncrement, UpRect, FGridButton.FullWidth, UpHeight, BitmapSpinUp, (DownButton = spbIncrement));
            end;
            if (spbDecrement in DrawButtons) and (DownRect.Top < DownRect.Bottom) then
            begin
                if (DownButton = spbDecrement)
                    then DrawDownButton(DownRect, clSilver, FGridButton.FullWidth, DownHeight, False, True)
                    else DrawUpButton(DownRect, clSilver, FGridButton.FullWidth, DownHeight, False, True);
                DrawSpinPicture(ButtonType, spbDecrement, DownRect, FGridButton.FullWidth, DownHeight, BitmapSpinDown, (DownButton = spbDecrement));
            end;
        end
        else
        begin
            GetSpinRects(ButtonType, DrawData.ButtonRect, RightRect, LeftRect, RightWidth, LeftWidth);
            if (spbDecrement in DrawButtons) and (LeftRect.Left < LeftRect.Right) then
            begin
                if (DownButton = spbDecrement)
                    then DrawDownButton(LeftRect, clSilver, LeftWidth + 1, LeftRect.Bottom - LeftRect.Top, (FHorzLineWidth = 0), True)
                    else DrawUpButton(LeftRect, clSilver, LeftWidth + 1, LeftRect.Bottom - LeftRect.Top, (FHorzLineWidth = 0), True);
                DrawSpinPicture(ButtonType, spbDecrement, LeftRect, LeftWidth, LeftRect.Bottom - LeftRect.Top, BitmapSpinLeft, (DownButton = spbDecrement));
            end;
            if (spbIncrement in DrawButtons) and (RightRect.Left < RightRect.Right) then
            begin
                if (DownButton = spbIncrement)
                    then DrawDownButton(RightRect, clSilver, RightWidth + 1, RightRect.Bottom - RightRect.Top, (FHorzLineWidth = 0), False)
                    else DrawUpButton(RightRect, clSilver, RightWidth + 1, RightRect.Bottom - RightRect.Top, (FHorzLineWidth = 0), False);
                DrawSpinPicture(ButtonType, spbIncrement, RightRect, RightWidth, RightRect.Bottom - RightRect.Top, BitmapSpinRight, (DownButton = spbIncrement));
            end;
        end;
    end;
end;

function TtsBaseGrid.IsSpinButton(ButtonType: TtsButtonType): Boolean;
begin
     Result := ButtonType in [btVertSpin, btHorzSpin];
end;

procedure TtsBaseGrid.FillButtonPart(var DrawData: TtsDrawData; DrawSelected: Boolean);
begin
    with DrawData do
    begin
        if not DrawButton then Exit;

        if (ButtonRect.Left >= ButtonRect.Right) or
           (ButtonRect.Top >= ButtonRect.Bottom) then Exit;

        FillCellRect(DrawData, ButtonRect, ControlType, DrawSelected);

        if Cell3D and
           ((not DrawControl) or (ControlType <> ctText)) then
        begin
            DrawEdge(Canvas.Handle, ButtonRect, BDR_RAISEDINNER, BF_TOP);
        end;
    end;
end;

function TtsBaseGrid.DrawCurrentButton(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := (DisplayCol = CurDisplayCol) and (DisplayRow = CurDisplayRow) and
              InEditMode and (not FocusRectDisabled);
end;

function TtsBaseGrid.CanDrawButton(DisplayCol, DisplayRow: Longint; InActive: Boolean): Boolean;
begin
    Result := True;
    if InActive and
       ((not DrawCurrentButton(DisplayCol, DisplayRow)) or
        CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow))) then
    begin
        Result := False;
    end;
end;

procedure TtsBaseGrid.DrawButtonPicture(const DrawData: TtsDrawData; AColor: TColor; ButtonMode: TtsButtonMode);
var
    ARect: TRect;
    BmpRect: TRect;
    RealHeight: Integer;
    OldMode: TCopyMode;
begin
    with DrawData do
    begin
        if ButtonType = btNone then Exit;
        if (ButtonRect.Left >= ButtonRect.Right) or
           (ButtonRect.Top >= ButtonRect.Bottom) then Exit;
        if (FInactiveButtonState = ibsNone) and
           not CanDrawButton(DisplayCol, DisplayRow, (ButtonMode = bmFlat)) then Exit;

        FGridButton := GridCellButton(DisplayCol, ButtonType);
        if FGridButton = nil then Exit;
        if FGridButton.Bitmap = nil then Exit;

        if AColor = clNone then
        begin
            if Canvas.Brush.Color <> BrushColor then Canvas.Brush.Color := BrushColor;
        end
        else
        begin
            if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;
        end;

        ARect := FullRect;
        ARect.Left := CalcMax(ARect.Left + tsRangeSelectWidth + FButtonEdgeWidth,
                              ARect.Right - FGridButton.FullWidth + FButtonEdgeWidth) +
                      CalcMax(0, ((FGridButton.Width - FGridButton.BitMap.Width) div 2));
        if ButtonMode = bmDown then Inc(ARect.Left, 1);

        ARect.Right := CalcMin(ARect.Left + FGridButton.BitMap.Width, ARect.Right - FButtonEdgeWidth);
        ARect.Top := ARect.Top + (1 - FHorzLineWidth);
        Inc(ARect.Top, FButtonEdgeWidth + CalcMax(0, ((FGridButton.Height - FGridButton.BitMap.Height) div 2)));

        if ButtonMode = bmDown then
        begin
            Inc(ARect.Top, 1);
            RealHeight := CalcMin(FGridButton.Height - 1, FGridButton.BitMap.Height);
        end
        else
            RealHeight := CalcMin(FGridButton.Height, FGridButton.BitMap.Height);

        ARect.Bottom := CalcMin(ARect.Top + RealHeight, ARect.Bottom);
        BmpRect := Rect(0, 0, ARect.Right - ARect.Left, ARect.Bottom - ARect.Top);
    end;

    BmpHandleNeeded(FGridButton.Bitmap);
    if FGridButton.TransparentColor = clNone then
    begin
        OldMode := Canvas.CopyMode;
        Canvas.CopyMode := cmMergeCopy;
        Canvas.CopyRect(ARect, FGridButton.Bitmap.Canvas, BmpRect);
        Canvas.CopyMode := OldMode;
    end
    else
        Canvas.BrushCopy(ARect, FGridButton.Bitmap, BmpRect, FGridButton.TransparentColor);
end;

function TtsBaseGrid.NextToCurrentCell(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := False;
    if ((FVertLineWidth = 0) and (FCurDisplayRow = DisplayRow) and (FCurDisplayCol = DisplayCol + 1)) or
       ((FHorzLineWidth = 0) and (FCurDisplayRow = DisplayRow + 1) and (FCurDisplayCol = DisplayCol)) or
       ((FVertLineWidth = 0) and (FHorzLineWidth = 0) and (FCurDisplayRow = DisplayRow + 1) and (FCurDisplayCol = DisplayCol + 1)) then
    begin
        Result := True;
    end;
end;

procedure TtsBaseGrid.DoDrawButton(DisplayCol, DisplayRow: Longint; SpinButtons: TtsSpinButtons;
                                   DownButton: TtsSpinButton; AColor: TColor; ButtonMode: TtsButtonMode);
var
    ARect: TRect;
    DrawData: TtsDrawData;
    DrawSelected: Boolean;
    DrawMode: TtsButtonMode;
begin
    if (DisplayCol < 1) or (DisplayCol > ColCount - 1) then Exit;
    if (DisplayRow < 1) or (DisplayRow > RowCount - 1) then Exit;

    GetDrawData(DisplayCol, DisplayRow, True, DrawData);
    if (DrawData.ButtonRect.Left >= DrawData.ButtonRect.Right) or
       (DrawData.ButtonRect.Top >= DrawData.ButtonRect.Bottom) then Exit;

    DrawSelected := IsCellSelected(DisplayCol, DisplayRow);
    GetEditColor(DrawData, EditorActive);

    DrawMode := ButtonMode;
    if (DrawMode = bmFlat) and DrawFlatButtonUp(DisplayCol, DisplayRow) then
        DrawMode := bmUp;

    if DisplayFocusRect(DisplayCol, DisplayRow, True) and (DrawMode = bmFlat) then
    begin
        ResetButtonUp;
        ResetButtonDown;
        Windows.InvalidateRect(Handle, @DrawData.ButtonRect, False);
        Update;
    end
    else
    begin
        if IsSpinButton(DrawData.ButtonType) then
        begin
            if AColor <> clNone then
                DrawSpinButtons(DrawData.ButtonType, SpinButtons, DownButton, AColor, DrawData, DrawSelected)
            else
                FillButtonPart(DrawData, DrawSelected);
        end
        else
        begin
            if DrawMode = bmFlat then FillButtonPart(DrawData, DrawSelected);
            DrawButtonBox(AColor, ButtonMode, DrawData, DrawSelected);
            DrawButtonPicture(DrawData, AColor, ButtonMode);
        end;

        if (ButtonMode <> bmUp) and (not SelectionColorEnabled) and DrawSelected then
        begin
            ARect := DrawData.ButtonRect;
            PatBlt(Canvas.Handle, ARect.Left, ARect.Top, ARect.Right - ARect.Left,
                   ARect.Bottom - ARect.Top, cmDstInvert);
        end
        else if (DrawMode = bmFlat) and
                (FocusBorder in [fbSingle, fbDouble]) and
                DisplayFocusRect(CurDisplayCol, CurDisplayRow, True) and
                NextToCurrentCell(DisplayCol, DisplayRow) then
        begin
            DrawCurrentFocusRect(True);
        end;
    end;
end;

procedure TtsBaseGrid.DrawButtonInCell(var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    AColor: TColor;
    ButtonMode: TtsButtonMode;
    DownButton: TtsSpinButton;
begin
    with DrawData do
    begin
        if not DrawButton then Exit;

        if (FMouseStatus = msButtonDown) and
           (FButtonDown.X = DisplayCol) and (FButtonDown.Y = DisplayRow) then
        begin
            AColor := clBtnFace;
            ButtonMode := bmDown;
            DownButton := FDownSpinButton;
        end
        else if (FButtonUp.X = DisplayCol) and (FButtonUp.Y = DisplayRow) then
        begin
            AColor := clBtnFace;
            ButtonMode := bmUp;
            DownButton := spbNone;
        end
        else
        begin
            AColor := ButtonColor(DisplayCol, DisplayRow);
            ButtonMode := bmFlat;
            DownButton := spbNone;
        end;

        if IsSpinButton(ButtonType) then
        begin
            if (AColor <> clNone) then
                DrawSpinButtons(ButtonType, [spbIncrement, spbDecrement], DownButton, AColor, DrawData, DrawSelected)
        end
        else
        begin
            if AColor <> clNone then
                DrawButtonBox(AColor, ButtonMode, DrawData, DrawSelected);
            DrawButtonPicture(DrawData, AColor, ButtonMode);
        end;
    end;
end;

procedure TtsBaseGrid.DrawTextInRect(Value: PChar; var DrawData: TtsDrawData; DrawControl: Boolean; DrawSelected: Boolean);
var
    AColor: TColor;
begin
    with DrawData do
    begin
        Canvas.Font := Font;
        AColor := BrushColor;

        if DrawSelected then
        begin
            if SelectionColorEnabled then
            begin
                AColor := SelectionColor;
                if SelectionFontColor <> clNone then
                    Canvas.Font.Color := SelectionFontColor;
            end;
        end
        else if DisplayFocusRect(DisplayCol, DisplayRow, True) then
        begin
            if FocusColor <> clNone
                then AColor := FocusColor;
            if FocusFontColor <> clNone
                then Canvas.Font.Color := FocusFontColor;
        end;

        if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;

        if not DrawControl then
        begin
            DisplayText(Canvas, Value, RowHeights[DisplayRow] - FHorzLineWidth,
                        DrawRect, DrawRect.Left + tsRangeSelectWidth, DrawRect.Top,
                        Alignment, VertAlignment, (WordWrap <> wwOff), 0);

            if Cell3D then DrawEdge(Canvas.Handle, DrawRect, BDR_RAISEDINNER, BF_TOPLEFT);
        end
        else
        begin
            FGridControl.DrawControl(Canvas, RowHeights[DisplayRow] - FHorzLineWidth,
                                     DrawRect, DrawRect.Left + tsRangeSelectWidth,
                                     DrawRect.Top, IsFocused);
        end;
    end;
end;

procedure TtsBaseGrid.DrawText(Value: PChar; var DrawData: TtsDrawData; DrawSelected: Boolean);
begin
    with DrawData do
    begin
        if not CanPaint then begin InvalidateCell(DisplayCol, DisplayRow); Exit; end;

        if (FullRect.Left >= FullRect.Right) or
           (FullRect.Top >= FullRect.Bottom) then Exit;

        if DrawRect.Right > DrawRect.Left + tsRangeSelectWidth then
            DrawTextInRect(Value, DrawData, DrawControl, DrawSelected)
        else
            FillSelectionPart(ctText, DrawData, DrawSelected);

        FillButtonPart(DrawData, DrawSelected);
        DrawCellFocusRect(DisplayCol, DisplayRow);
        if (GridMode <> gmListBox) and
           ((CanEditCell(DataCol, DataRow)) or
            (AlwaysDetectButton)) then
           DrawButtonInCell(DrawData, DrawSelected);

        FCellDrawn.X := DisplayCol;
        FCellDrawn.Y := DisplayRow;
    end;
end;

procedure TtsBaseGrid.DrawCheckOnCanvas(ARect : TRect; Bitmap : TBitmap; BmpRect: TRect; CopyMode : TCopyMode);
begin
    BmpRect.Right := BmpRect.Left + (ARect.Right - ARect.Left);
    BmpRect.Bottom := BmpRect.Top + (ARect.Bottom - ARect.Top);

    Canvas.CopyMode := CopyMode;
    Canvas.CopyRect(ARect, Bitmap.Canvas, BmpRect);
end;

function TtsBaseGrid.CalcCheckRect(Cell3D: Boolean; Bitmap: TBitmap; CellRect, BmpRect: TRect; LeftOffset: Integer): TRect;
var
    Offset3D: Integer;
    CheckRect: TRect;
    CellHeight : Integer;
    CellWidth : Integer;
begin
    Offset3D := 0;
    if Cell3D then Offset3D := 1;
    CellHeight := CellRect.Bottom - CellRect.Top;
    CellWidth := CellRect.Right - CellRect.Left;

    CheckRect.Left := CellRect.Left + LeftOffset + ((CellWidth - LeftOffset - (BmpRect.Right - BmpRect.Left)) div 2) - 1;
    if CheckRect.Left < CellRect.Left + LeftOffset then CheckRect.Left := CellRect.Left + LeftOffset;

    CheckRect.Top := CellRect.Top + ((CellHeight - (BmpRect.Bottom - BmpRect.Top)) div 2) + Offset3D;
    if CheckRect.Top < CellRect.Top then CheckRect.Top := CellRect.Top;

    CheckRect.Right := CheckRect.Left + (BmpRect.Right - BmpRect.Left);
    if CheckRect.Right > CellRect.Right then CheckRect.Right := CellRect.Right;

    CheckRect.Bottom := CheckRect.Top + (BmpRect.Bottom - BmpRect.Top);
    if CheckRect.Bottom > CellRect.Bottom then CheckRect.Bottom := CellRect.Bottom;

    Result := CheckRect;
end;

procedure TtsBaseGrid.DrawCheck(Value: Variant; var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    CheckRect, BmpRect : TRect;
    Bitmap : TBitmap;
    CopyMode : TCopyMode;
    AColor: TColor;
    State: TCheckBoxState;
begin
    with DrawData do
    begin
        if not CanPaint then begin InvalidateCell(DisplayCol, DisplayRow); Exit; end;

        if (FullRect.Left >= FullRect.Right) or
           (FullRect.Top >= FullRect.Bottom) then Exit;

        AColor := BrushColor;
        if DrawSelected then
        begin
            if SelectionColorEnabled then AColor := SelectionColor;
        end
        else if DisplayFocusRect(DisplayCol, DisplayRow, True) then
        begin
            if FocusColor <> clNone then AColor := FocusColor;
        end;

        if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;

        if DrawRect.Right > DrawRect.Left + tsRangeSelectWidth then
        begin
            if DrawControl then
            begin
                FGridControl.Ctl3D := Cell3D;
                FGridControl.DrawControl(Canvas, RowHeights[DisplayRow] - FHorzLineWidth,
                                         DrawRect, DrawRect.Left + tsRangeSelectWidth,
                                         DrawRect.Top, IsFocused or AlwaysShowFocus);
            end
            else
            begin
                Canvas.FillRect(DrawRect);
                State := VariantToCheckBox(Value, GiveCellCheckBoxValues(DataCol, DataRow));
                Bitmap := FCheckControl.GetCheckBoxBitmap(State, CopyMode, BmpRect, False);
                CheckRect := CalcCheckRect(Cell3D, Bitmap, DrawRect, BmpRect, tsRangeSelectWidth);
                DrawCheckOnCanvas(CheckRect, Bitmap, BmpRect, CopyMode);
                if Cell3D then DrawEdge(Canvas.Handle, DrawRect, BDR_RAISEDINNER, BF_TOPLEFT);
            end;
        end;

        FillButtonPart(DrawData, DrawSelected);
        DrawCellFocusRect(DisplayCol, DisplayRow);
        DrawButtonInCell(DrawData, DrawSelected);

        FCellDrawn.X := DisplayCol;
        FCellDrawn.Y := DisplayRow;
    end;
end;

procedure TtsBaseGrid.GetEditColor(var DrawData: TtsDrawData; SetEditColor: Boolean);
begin
    with DrawData do
    begin
        DrawControl := SetEditColor;
        if (DisplayRow > 0) and SetEditColor and (DisplayCol = FCurDisplayCol) and
           (DisplayRow = FCurDisplayRow) and (ControlType = ctText) then
        begin
            if (FEditColor <> clNone) then DrawData.BrushColor := FEditColor;

            if (FEditFontColor <> clNone) then
            begin
                SetDrawFont(DrawData);
                DrawData.Font.Color := FEditFontColor;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.GetHeadDrawData(DisplayCol: Longint; var DrawData: TtsDrawData);
var
    LeftPos: Integer;
    MaxRight, MaxBottom: Integer;
begin
    with DrawData do
    begin
        if FVertLineWidth = 0 then
        begin
            Dec(FullRect.Right);
            if not Cell3D then Dec(DrawRect.Right);
        end;
        if FHorzLineWidth = 0 then
        begin
            Dec(FullRect.Bottom);
            if not Cell3D then Dec(DrawRect.Bottom);
        end;

        if (FHeadingClicked = GetDataCol(DisplayCol)) and not FHeadingButtonClicked and
           FDrawHeadingButtonDown then
        begin
            Inc(DrawRect.Left);
            Inc(DrawRect.Top);
        end;

        Dec(DrawRect.Right);
        DrawButton := ButtonInColHeading(DisplayCol) or
                      (IsColHeadingButton(DisplayCol) and
                       (GridCols[GetDataCol(DisplayCol)].SortPicture <> spNone));

        if DrawButton then
        begin
            if Alignment <> taRightJustify then
            begin
                DrawRect.Right := DrawRect.Right - (HeadButWidth - 1);
                LeftPos := CalcMax(FullRect.Left + tsRangeSelectWidth, DrawRect.Right);
                MaxRight := FullRect.Right - LeftPos;
            end
            else
            begin
                DrawRect.Left := DrawRect.Left + (HeadButWidth - 2);
                LeftPos := FullRect.Left;
                MaxRight := CalcMin(FullRect.Right - LeftPos, HeadButWidth);
            end;

            MaxBottom := CalcMin(FullRect.Bottom + 1, FullRect.Top + HeadingHeight - 1);
            if (FHeadingClicked = GetDataCol(DisplayCol)) and not FHeadingButtonClicked then
            begin
                Inc(MaxRight);
                Dec(MaxBottom);
            end;

            ButtonRect := Rect(LeftPos, FullRect.Top + 1, LeftPos + MaxRight, MaxBottom + 1);
        end;
    end;
end;

procedure TtsBaseGrid.SetDrawFont(var DrawData: TtsDrawData);
begin
    if DrawData.Font <> FDrawFont then
    begin
        if not Assigned(FDrawFont) then FDrawFont := TFont.Create;
        FDrawFont.Assign(DrawData.Font);
        DrawData.Font := FDrawFont;
    end;
end;

procedure TtsBaseGrid.FetchDrawInfo(var DrawData: TtsDrawData);
var
    DrawInfo: TtsDrawInfo;
begin
    if not ActivateDoGetDrawInfo then Exit;

    with DrawData do
    begin
        SetDrawFont(DrawData);
        DrawInfo.Font := Font;
        DrawInfo.Color := BrushColor;
        DrawInfo.Alignment := Alignment;
        DrawInfo.VertAlignment := VertAlignment;
        DrawInfo.WordWrap := WordWrap;
        DrawInfo.TransparentColor := Transparent;

        GetDrawInfo(DataCol, DataRow, DrawInfo);
        if DrawInfo.HorzAlignment = htaDefault then DrawInfo.HorzAlignment := htaLeft;

        Font := DrawInfo.Font;
        BrushColor := DrawInfo.Color;
        Alignment := DrawInfo.Alignment;
        VertAlignment := DrawInfo.VertAlignment;
        WordWrap := DrawInfo.WordWrap;
        Transparent := DrawInfo.TransparentColor;
    end;
end;

procedure TtsBaseGrid.UpdateDrawData(var DrawData: TtsDrawData; SetEditColor: Boolean);
var
    In3D: Boolean;
    Changed3D: Boolean;
begin
    with DrawData do
    begin
        Changed3D := False;
        In3D := GiveCell3D(DataCol, DataRow);
        if In3D <> Cell3D then
        begin
            Cell3D := In3D;
            Changed3D := True;
        end;

        Alignment := GiveCellAlignment(DataCol, DataRow);
        VertAlignment := GiveCellVertAlignment(DataCol, DataRow);
        WordWrap := GiveCellWordWrap(DataCol, DataRow);
        BrushColor := GiveCellColor(DataCol, DataRow, Cell3D);
        Font := GiveCellFont(DataCol, DataRow);
        Transparent := clDefault;

        if (DisplayCol > 0) and (DisplayRow > 0) and (DisplayRow <= Rows) then
            FetchDrawInfo(DrawData);

        GetEditColor(DrawData, SetEditColor);
        if Changed3D and (DisplayRow <> 0) then
        begin
            Cell3D := In3D;
            SetDrawRect(DrawData);
        end;
    end;
end;

procedure TtsBaseGrid.SetDrawRect(var DrawData: TtsDrawData);
begin
    with DrawData do
    begin
        if (FVertLineWidth = 0) and Cell3D then DrawRect.Right := DrawRect.Right - 1;
        if (FHorzLineWidth = 0) and Cell3D then DrawRect.Bottom := DrawRect.Bottom - 1;

        if (DisplayRow = 0) then
            GetHeadDrawData(DisplayCol, DrawData)
        else
        begin
            ButtonType := GiveCellButton(DataCol, DataRow, DropDownStyle);
            DrawButton := (ButtonType <> btNone);
            if DrawButton then
               FGridButton := GridCellButton(DisplayCol, ButtonType);
            if DrawButton and
               (FGridButton <> Nil) then
            begin
                //FGridButton := GridCellButton(DisplayCol, ButtonType);
                DrawRect.Right := DrawRect.Right - FGridButton.FullWidth;
                ButtonRect.Left := CalcMax(DrawRect.Left + tsRangeSelectWidth, DrawRect.Right);
                ButtonRect.Top := DrawRect.Top;
                ButtonRect.Right := DrawRect.Right + FGridButton.FullWidth;
                ButtonRect.Bottom := DrawRect.Bottom;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.GetDrawData(ADisplayCol, ADisplayRow: Longint; FullInfo: Boolean;
                                  var DrawData: TtsDrawData);
begin
    with DrawData do
    begin
        DisplayCol := ADisplayCol;
        DisplayRow := ADisplayRow;
        DataCol := FDataColNumber[DisplayCol];
        DataRow := FDataRowNumber[DisplayRow];

        DrawControl := False;
        Cell3D := GiveCell3D(DataCol, DataRow);
        ControlType := GiveCellControlType(DataCol, DataRow);

        if FullInfo then
        begin
            Alignment := GiveCellAlignment(DataCol, DataRow);
            VertAlignment := GiveCellVertAlignment(DataCol, DataRow);
            BrushColor := GiveCellColor(DataCol, DataRow, Cell3D);
            Font := GiveCellFont(DataCol, DataRow);
            WordWrap := GiveCellWordWrap(DataCol, DataRow);
            Transparent := clDefault;
        end;

        BoxRect := FNullRect;
        FullRect := CellRect(DisplayCol, DisplayRow);
        if (FullRect.Left < FullRect.Right) and (FullRect.Top < FullRect.Bottom) then
        begin
            if FullInfo and (DisplayCol > 0) and
               (DisplayRow > 0) and (DisplayRow <= Rows) then FetchDrawInfo(DrawData);

            BoxRect := FullRect;
            if not EqualRect(BoxRect, FNullRect) then
            begin
                BoxRect.Right := BoxRect.Right + FVertLineWidth;
                BoxRect.Bottom := BoxRect.Bottom + FHorzLineWidth;
            end;

            FullRect.Right := FullRect.Left + ColWidths[DisplayCol] - FVertLineWidth;
            FullRect.Bottom := FullRect.Top + RowHeights[DisplayRow] - FHorzLineWidth;
            DrawRect := FullRect;
            SetDrawRect(DrawData);
        end
        else
        begin
            DrawRect := FullRect;
            ButtonRect := FullRect;
            ButtonType := GiveCellButton(DataCol, DataRow, DropDownStyle);
            DrawButton := (ButtonType <> btNone);
        end;
    end;
end;

procedure TtsBaseGrid.FillCellRect(const DrawData: TtsDrawData; ARect: TRect; ControlType: TtsControlType; DrawSelected: Boolean);
var
    MaskRect: TRect;
    DrawMask: Boolean;
    AColor, MaskColor: TColor;
begin
    with DrawData do
    begin
        DrawMask := False;
        MaskColor := clNone;
        AColor := BrushColor;
        if DrawSelected then
        begin
            if SelectionColorEnabled then
            begin
                DrawMask := ControlType = ctPicture;
                if DrawMask then MaskColor := SelectionColor
                            else AColor := SelectionColor;
            end;
        end
        else if DisplayFocusRect(DisplayCol, DisplayRow, True) then
        begin
            if FocusColor <> clNone then
            begin
                DrawMask := ControlType = ctPicture;
                if DrawMask then MaskColor := FocusColor
                            else AColor := FocusColor;
            end;
        end;

        if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;
        Canvas.FillRect(ARect);
        if DrawMask then
        begin
            MaskRect := ARect;
            MaskRect.Left := MaskRect.Left - ((MaskRect.Left - DrawData.FullRect.Left) mod 8);
            DrawPictureMask(MaskRect, MaskColor);
        end;
    end;
end;

procedure TtsBaseGrid.DrawEmpty(var DrawData: TtsDrawData; ControlType: TtsControlType; DrawSelected: Boolean);
begin
    if not CanPaint then Exit;
    if Canvas.Brush.Color <> Color then Canvas.Brush.Color := Color;
    with DrawData do
    begin
        if (FullRect.Left >= FullRect.Right) or
           (FullRect.Top >= FullRect.Bottom) then Exit;

        if (DrawRect.Left <= DrawRect.Right) then
        begin
            FillCellRect(DrawData, DrawRect, ControlType, DrawSelected);
            if Cell3D then DrawEdge(Canvas.Handle, DrawRect, BDR_RAISEDINNER, BF_TOPLEFT);
        end;

        FillButtonPart(DrawData, DrawSelected);
        DrawCellFocusRect(DisplayCol, DisplayRow);
        DrawButtonInCell(DrawData, DrawSelected);

        FCellDrawn.X := DisplayCol;
        FCellDrawn.Y := DisplayRow;
    end;
end;

procedure TtsBaseGrid.GetDrawOptions(DataCol, DataRow: Longint; CurrentCellSet: Boolean;
                                     var Stretch, Shrink, Center, KeepAspect: Boolean);
var
    StretchOption: TtsDrawOption;
    ShrinkOption: TtsDrawOption;
    CenterOption: TtsDrawOption;
    KeepAspectOption: TtsDrawOption;
begin
    if CurrentCellSet then
    begin
        Stretch := CurrentCell.StretchPicture;
        Shrink := CurrentCell.ShrinkPicture;
        Center := CurrentCell.CenterPicture;
        KeepAspect := CurrentCell.KeepAspectRatio;
    end
    else
    begin
        Stretch := StretchPicture;
        Shrink := ShrinkPicture;
        Center := CenterPicture;
        KeepAspect := KeepAspectRatio;

        StretchOption := GiveCellStretchPicture(DataCol, DataRow);
        ShrinkOption := GiveCellShrinkPicture(DataCol, DataRow);
        CenterOption := GiveCellCenterPicture(DataCol, DataRow);
        KeepAspectOption := GiveCellKeepAspectRatio(DataCol, DataRow);

        if StretchOption <> dopDefault then Stretch := (StretchOption = dopOn);
        if ShrinkOption <> dopDefault then Shrink := (ShrinkOption = dopOn);
        if CenterOption <> dopDefault then Center := (CenterOption = dopOn);
        if KeepAspectOption <> dopDefault then KeepAspect := (KeepAspectOption = dopOn);
    end;
end;

function TtsBaseGrid.PictureTransparentColor(Bitmap: TBitmap; Image: TtsImageItem): TColor;
begin
    Result := clNone;
    if Assigned(Image) then
    begin
        if Image.Transparent then
            Result := Image.TransparentColor;
    end
    else
    begin
        {$IFDEF TSVER_V3}
        if Bitmap.Transparent then
            TransparentColor := Bitmap.TransparentColor;
        {$ENDIF}
    end;
end;

procedure TtsBaseGrid.DrawPictureMask(DrawRect: TRect; MaskColor: TColor);
begin
    CheckPictureMaskColor(MaskColor);
    Canvas.Brush.Bitmap := FPictureMonoMask;
    PatBlt(Canvas.Handle, DrawRect.Left, DrawRect.Top, DrawRect.Right - DrawRect.Left, DrawRect.Bottom - DrawRect.Top, PATAND);
    Canvas.Brush.Bitmap := PictureColorMask;
    PatBlt(Canvas.Handle, DrawRect.Left, DrawRect.Top, DrawRect.Right - DrawRect.Left, DrawRect.Bottom - DrawRect.Top, PATINVERT);
    Canvas.Brush.Bitmap := nil;
end;

procedure TtsBaseGrid.DrawPictureInRect(Bitmap: TBitmap; Image: TtsImageItem; var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    ValueSet: Boolean;
    Stretch, Center, KeepAspect, Shrink: Boolean;
    TransparentColor: TColor;
begin
    with DrawData do
    begin
        if Cell3D then
        begin
            if Canvas.Brush.Color <> clBtnFace then Canvas.Brush.Color := clBtnFace
        end
        else
        begin
            if Canvas.Brush.Color <> BrushColor then Canvas.Brush.Color := BrushColor;
        end;

        if (DrawRect.Left > DrawRect.Right) or (DrawRect.Top > DrawRect.Bottom) then Exit;

        ValueSet := CurrentCell.ValueSet(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
        GetDrawOptions(DataCol, DataRow, ValueSet, Stretch, Shrink, Center, KeepAspect);

        TransparentColor := Transparent;
        if TransparentColor = clDefault then
        begin
            TransparentColor := PictureTransparentColor(Bitmap, Image);
            if TransparentColor = clNone then
            begin
                if ValueSet
                    then TransparentColor := CurrentCell.FTransparentColor
                    else TransparentColor := Self.TransparentColor;
            end;
        end;

        tsStretchDraw(Canvas, DrawRect, Bitmap, TransparentColor, Center, Stretch, Shrink, KeepAspect);
        if SelectionColorEnabled and DrawSelected then
        begin
            DrawPictureMask(DrawRect, SelectionColor);
        end
        else if (not DrawSelected) and (FocusColor <> clNone) and
                 DisplayFocusRect(DisplayCol, DisplayRow, True) then
        begin
            DrawPictureMask(DrawRect, FocusColor);
        end;

        if Cell3D then DrawEdge(Canvas.Handle, DrawRect, BDR_RAISEDINNER, BF_TOPLEFT);
    end;
end;

procedure TtsBaseGrid.DrawPicture(Bitmap: TBitmap; Image: TtsImageItem; var DrawData: TtsDrawData; DrawSelected: Boolean);
begin
    with DrawData do
    begin
        if not CanPaint then begin InvalidateCell(DisplayCol, DisplayRow); Exit; end;

        if (FullRect.Left >= FullRect.Right) or
           (FullRect.Top >= FullRect.Bottom) then Exit;

        if Bitmap = nil then
            DrawEmpty(DrawData, ctPicture, DrawSelected)
        else
        begin
            if DrawRect.Right > DrawRect.Left + tsRangeSelectWidth then
                DrawPictureInRect(Bitmap, Image, DrawData, DrawSelected)
            else
                FillSelectionPart(ctPicture, DrawData, DrawSelected);

            FCellDrawn.X := DisplayCol;
            FCellDrawn.Y := DisplayRow;
        end;

        FillButtonPart(DrawData, DrawSelected);
        DrawCellFocusRect(DisplayCol, DisplayRow);
        DrawButtonInCell(DrawData, DrawSelected)
    end;
end;

function TtsBaseGrid.EmptyCellValue(ControlType: TtsControlType): Variant;
begin
    Result := Unassigned;
    case ControlType of
        ctText : Result := '';
        ctCheck : Result := cbGrayed;
        ctPicture: Result := Integer(nil);
    end;
end;

procedure TtsBaseGrid.DrawEmptyCell(var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    Value: Variant;
begin
    EnableStartEdit := False;
    try
        with DrawData do
        begin
            Value := EmptyCellValue(ControlType);
            if not VarIsEmpty(Value) then
                AssignCellValue(DataCol, DataRow, DrawData, DrawSelected, Value, nil, False, False)
            else
            begin
                UpdateDrawData(DrawData, False);
                DrawEmpty(DrawData, ctNone, DrawSelected);
            end;
        end;
    finally
        EnableStartEdit := True;
    end;
end;

procedure TtsBaseGrid.GetPaintCellPars(DisplayCol, DisplayRow: Longint;
                                       var State: TtsPaintCellState);
begin
    State := [];
    if IsCellSelected(DisplayCol, DisplayRow) then Include(State, psSelected);
    if (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then Include(State, psCurrent);
    if (DisplayCol < FixedCols) or (DisplayRow < FixedRows) then Include(State, psFixed);
end;

function TtsBaseGrid.FocusEnabled: Boolean;
begin
    Result := (FocusBorder <> fbNone) or
              (FocusColor <> clNone) or
              (FocusFontColor <> clNone);
end;

function TtsBaseGrid.FocusRectActive: Boolean;
begin
    Result := FocusEnabled and (GridMode <> gmListBox) and (GridStatus = grNormal);
end;

function TtsBaseGrid.FocusRectVisible(DisplayCol, DisplayRow: Longint): Boolean;
var
    Control: TtsCustomGridControl;
    ControlType: TtsControlType;
    ControlVisible: Boolean;
begin
    Result := False;
    if (DisplayCol = 0) or (DisplayRow = 0) then Exit;

    if (not FControlEnabled) or CurCellReadOnly then
        Result := True
    else
    begin
        ControlType := GiveCellControlType(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
        ControlVisible := (ControlType in [ctText, ctCheck]);
        if (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then
        begin
            ControlVisible := ControlVisible and GridControlActive;
            if not (csDesigning in ComponentState) then
            begin
                if not ControlVisible then ControlVisible := FSetGridControlVisible;
                if not ControlVisible then
                begin
                    Control := GridCellControl(ControlType);
                    if Assigned(Control) then ControlVisible := Control.Visible
                end;
            end;
        end;

        Result := not ControlVisible
    end;
end;

function TtsBaseGrid.CheckCellFocusRect(DisplayCol, DisplayRow: Longint; CheckFocus: Boolean): Boolean;
begin
    Result := False;
    if FocusRectDisabled then Exit;
    if (DisplayCol = 0) or (DisplayRow = 0) then Exit;

    Result := FocusRectActive and ((not CheckFocus) or AlwaysShowFocus or IsFocused);
    if Result then Result := FocusRectVisible(DisplayCol, DisplayRow);
end;

function TtsBaseGrid.DisplayFocusRect(DisplayCol, DisplayRow: Longint; CheckFocus: Boolean): Boolean;
begin
    Result := False;
    if (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow) then Exit;
    if (DisplayCol > Cols) or (DisplayRow > RowCount - 1) then Exit;
    Result := CheckCellFocusRect(DisplayCol, DisplayRow, CheckFocus);
end;

procedure TtsBaseGrid.DrawFocusRect(Canvas: TCanvas; DisplayCol, DisplayRow: Longint);
var
    FocusRect, InnerRect, OuterRect: TRect;
    OldFontColor: TColor;
    OldBrushStyle: TBrushStyle;
begin
    FFocusLineOnVertFixed := False;
    FFocusLineOnHorzFixed := False;

    if (FocusBorder in [fbDot, fbDash]) then
    begin
        OldFontColor := Canvas.Font.Color;
        try
            if (FocusColor <> clNone) and (FocusFontColor <> clNone) then
            begin
              if Canvas.Brush.Color <> FocusColor then
                 Canvas.Brush.Color := FocusColor;
              Canvas.Font.Color := FocusFontColor;
            end
            else
            begin
              if Canvas.Brush.Color <> Color then
                 Canvas.Brush.Color := Color;
              Canvas.Font.Color := Font.Color;
            end;

            FocusRect := BoxRect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);
            FocusRect.Right := FocusRect.Left + ColWidths[DisplayCol] - FVertLineWidth;
            FocusRect.Bottom := FocusRect.Top + RowHeights[DisplayRow] - FHorzLineWidth;
            if FocusBorder = fbDot then
              Canvas.DrawFocusRect(FocusRect)
            else
            begin
              Canvas.Pen.Color := FocusBorderColor;
              Canvas.Pen.Style := psDash;
              Canvas.Pen.Mode := pmCopy;
              Canvas.MoveTo(FocusRect.Left+1, FocusRect.Top);
              Canvas.LineTo(FocusRect.Right-1, FocusRect.Top);
              Canvas.LineTo(FocusRect.Right-1, FocusRect.Bottom-1);
              Canvas.LineTo(FocusRect.Left+1, FocusRect.Bottom-1);
              Canvas.LineTo(FocusRect.Left+1, FocusRect.Top);
            end;
        finally
            Canvas.Font.Color := OldFontColor;
        end;
    end
    else if FocusBorder <> fbNone then
    begin
        OldBrushStyle := Canvas.Brush.Style;
        try
            Canvas.Brush.Style := bsSolid;
            Canvas.Brush.Color := FocusBorderColor;
            OuterRect := BoxRect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);
            if not EqualRect(OuterRect, FNullRect) then
            begin
                OuterRect.Right := OuterRect.Left + ColWidths[DisplayCol] - 1;
                OuterRect.Bottom := OuterRect.Top + RowHeights[DisplayRow] -1;

                InnerRect := OuterRect;
                Inc(InnerRect.Left);
                Dec(InnerRect.Right);
                Inc(InnerRect.Top);
                Dec(InnerRect.Bottom);
                //Inc(OuterRect.Left); 
                Canvas.FrameRect(OuterRect);

                if FocusBorder = fbDouble then
                   Canvas.FrameRect(InnerRect);

                if OuterRect.Top <= FVertFixedHeight then
                    FFocusLineOnVertFixed := True;
                if OuterRect.Left <= FHorzFixedWidth then
                    FFocusLineOnHorzFixed := True;
            end;
        finally
            Canvas.Brush.Style := OldBrushStyle;
        end;
    end;
end;

procedure TtsBaseGrid.DrawCellFocusRect(DisplayCol, DisplayRow: Longint);
begin
    if not DisplayFocusRect(DisplayCol, DisplayRow, True) then Exit;
    DrawFocusRect(Canvas, DisplayCol, DisplayRow);
end;

procedure TtsBaseGrid.InvalidateFocusRect(DisplayCol, DisplayRow: Longint; OuterBorder: Boolean);
var
    FocusRect: TRect;
begin
    if FastAssign then Exit;
    if (FocusBorder in [fbSingle, fbDouble]) or OuterBorder then
    begin
        FocusRect := BoxRect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);
        if not EqualRect(FocusRect, FNullRect) then
        begin
            FocusRect.Right := FocusRect.Left + ColWidths[DisplayCol];
            FocusRect.Bottom := FocusRect.Top + RowHeights[DisplayRow];
            Dec(FocusRect.Left);
            Dec(FocusRect.Top);
            Windows.InvalidateRect(Handle, @FocusRect, False);
        end;
    end
    else
        InvalidateCell(DisplayCol, DisplayRow);
end;

procedure TtsBaseGrid.ClearCurrentFocusRect(DoUpdate: Boolean);
begin
    if DisplayFocusRect(FCurDisplayCol, FCurDisplayRow, True) then
    begin
        FocusRectDisabled := True;
        try
            InvalidateFocusRect(FCurDisplayCol, FCurDisplayRow, False);
            if DoUpdate and CanPaint then Update;
        finally
            FocusRectDisabled := False;
        end;
    end;
end;

procedure TtsBaseGrid.DrawCurrentFocusRect(DoUpdate: Boolean);
begin
    if DisplayFocusRect(FCurDisplayCol, FCurDisplayRow, True) then
    begin
        InvalidateFocusRect(FCurDisplayCol, FCurDisplayRow, False);
        if DoUpdate and CanPaint then Update;
    end;
end;

procedure TtsBaseGrid.FocusChanged(ResetOuterBorder: Boolean);
begin
    CheckPictureMask(False);
    InvalidateFocusRect(FCurDisplayCol, FCurDisplayRow, ResetOuterBorder);
end;

procedure TtsBaseGrid.UpdateGrid(IgnoreFocus: Boolean);
begin
    if IgnoreFocus then FocusRectDisabled := True;
    try
        Update;
    finally
        if IgnoreFocus then FocusRectDisabled := False;
    end;
end;

function TtsBaseGrid.SelectionColorEnabled: Boolean;
begin
    if FAsCombo and (SelectionType = sltDefault) then
        Result := ParentGrid.SelectionColorEnabled
    else
        Result := (SelectionType = sltColor) and (SelectionColor <> clNone);
end;

procedure TtsBaseGrid.DoDrawCell(ACol, ARow: Longint; ARect: TRect; DrawSelected: Boolean);
var
    Cancel: Boolean;
    DrawData: TtsDrawData;
begin
    if (not GridCols[GetDataCol(ACol)].Visible) or
       (not IsRowVisible(GetDataRow(ARow))) then Exit;

    if (FVertFixedHeight >= ARect.Top) and (FVertFixedHeight <= ARect.Bottom) and (ACol = FCurDisplayCol) then
        FFocusLineOnVertFixed := False;
    if (FHorzFixedWidth >= ARect.Left) and (FHorzFixedWidth <= ARect.Right) and (ARow = FCurDisplayRow) then
        FFocusLineOnHorzFixed := False;

    if (ACol < 1) or (ARow < 1) then
    begin
        DrawFixedCellUnselected(ARect, ACol);
        if Heading3D then DrawFixedLines(ARect, HeadingShadeColor)
                     else DrawFixedLines(ARect, HeadingLineColor);
    end
    else if (csDesigning in ComponentState) and
            ((ACol <= FInternalFixedCols) or (ARow <= FInternalFixedRows)) then
    begin
        DrawGridCellUnselected(ARect);
    end;

    if ColWidths[ACol] <= (ClientWidth - ARect.Left) then Dec(ARect.Right, FVertLineWidth);
    if RowHeights[ARow] <= (ClientHeight - ARect.Top) then Dec(ARect.Bottom, FHorzLineWidth);

    GetDrawData(ACol, ARow, False, DrawData);
    Cancel := PaintCell(DrawData, ARect, DrawSelected);

    if (ACol < 1) and (ARow = FCurDisplayRow) and
       not ((RowCount <= 2) and (GridMode = gmEditInsert)) then
    begin
        if not Cancel then DrawCurrent(ARow);
    end
    else if (ACol < 1) and (ARow = RowCount - 1) and (GridMode = gmEditInsert) then
    begin
        if not Cancel then
        begin
            if (FCurDisplayRow <> ARow) or CanDrawInsert
                then DrawInsert
                else DrawCurrent(ARow)
        end;
    end
    else if (ACol >= 1) and (ARow < 1) then
    begin
        if not Cancel then DrawHeadingText(ACol, ARect);
    end
    else if (not Cancel) and (ACol >= 1) and (ARow >= 1) then
    begin
        if DrawData.ControlType = ctNone then
            DrawEmptyCell(DrawData, DrawSelected)
        else if (ARow = RowCount - 1) and (InsertionRow = 1) then
            DrawEmptyCell(DrawData, DrawSelected)
        else
            CellLoaded(DrawData, DrawSelected);
    end;

    if (csDesigning in ComponentState) then
    begin
        if DisplayFocusRect(ACol, ARow, True) then
            DrawFocusRect(Canvas, ACol, ARow);
    end;

    if DrawSelected then
    begin
        if (ACol = 0) or (ARow = 0) then
            InvertCell(ACol, ARow, DrawData.BoxRect, True, Canvas.Handle)
        else if (not SelectionColorEnabled) then
            InvertCell(ACol, ARow, DrawData.BoxRect, True, Canvas.Handle);
    end;
end;

procedure TtsBaseGrid.DrawCell(ACol, ARow: Longint; ARect: TRect;
                               AState: TGridDrawState);
begin
    DoDrawCell(ACol, ARow, ARect, IsCellSelected(ACol, ARow));
end;

procedure TtsBaseGrid.TopLeftChanged;
var
    NewLeftCol, NewTopRow: Longint;
    MaxTopLeft: TGridCoord;
begin
    Inc(FInTopLeftChanged);
    try
        MaxTopLeft := GetMaxTopLeft;
        NewTopRow := TopRow;
        NewLeftCol := LeftCol;

        if NewLeftCol > MaxTopLeft.X then NewLeftCol := MaxTopLeft.X;
        if NewTopRow > MaxTopLeft.Y then NewTopRow := MaxTopLeft.Y;

        if (LeftCol <> NewLeftCol) or (TopRow <> NewTopRow) then
        begin
            EnablePaint := False;
            try
                MoveTopLeft(NewLeftCol, NewTopRow);
            finally
                EnablePaint := True;
            end;
        end;

        FTopLeftChanged := True;
        if FInTopLeftChanged = 1 then CheckTopLeftChanged(True);
    finally
        Dec(FInTopLeftChanged);
    end;
end;

procedure TtsBaseGrid.CheckTopLeftChanged(ByUser: Boolean);
begin
    if (FOldTopLeft.X <> LeftCol) or (FOldTopLeft.Y <> TopRow) then
    begin
        UpdateScrollPos;
        try
            TopLeftChangedEvent(FOldTopLeft.X, FOldTopLeft.Y, LeftCol, TopRow, ByUser);
        finally
            FOldTopLeft.X := LeftCol;
            FOldTopLeft.Y := TopRow;
        end;
    end;
end;

procedure TtsBaseGrid.CheckRowHeights(var NewHeight: Integer);
var
    I: Integer;
begin
    NewHeight := 0;
    if DefaultRowHeight < 1 then
    begin
        DefaultRowHeight := 1;
        for I := 1 to (RowCount - 1) do
        begin
            GridRows.RowHeight[I] := 1;
            if Reading then GridRows.OldRowHeight[I] := 1;
        end;
    end
    else
    begin
        for I := 0 to (RowCount - 1) do
        begin
            if RowHeights[I] < 0 then RowHeights[I] := 0;

            if IsRowVisible(GetDataRow(I)) or (RowHeights[I] <> 0) then
            begin
                if GridRows.RowHeight[GetDataRow(I)] <> RowHeights[I] then
                begin
                    if I <> 0 then NewHeight := RowHeights[I];
                    GridRows.RowHeight[GetDataRow(I)] := RowHeights[I];
                    if not FInChangingAllRowHeights then
                        GridRows.OldRowHeight[I] := RowHeights[I];
                end;
            end;
        end;
    end;

    if not FInChangingAllRowHeights then
        FOldDefaultRowHeight := DefaultRowHeight;
end;

procedure TtsBaseGrid.RowHeightsChanged;
var
    I: Longint;
    OldHeight: Integer;
    NewHeight: Integer;
begin
    if FSkipRowHeightsChanged then Exit;

    FSkipRowHeightsChanged := True;

    OldHeight := HeadingHeight;
    CheckRowHeights(NewHeight);
    GridRows[0].FHeight := OldHeight;
    if HeadingOn then ResizeRow(0, OldHeight)
                 else ResizeRow(0, 0);

    for I := 1 to RowCount - 1 do
    begin
        if (RowHeights[GetDisplayRow(I)] <> 0) and (not IsRowVisible(I)) then
            RowHeights[GetDisplayRow(I)] := 0;
    end;

    FSkipRowHeightsChanged := False;
    CalcVertFixedHeight;

    if not FControlHidden then ShowGridControl;
    RowResized(-1);

    if (csDesigning in ComponentState) and (NewHeight <> 0) and (ResizeRows = rrAll) and
       (not FInChangingAllRowHeights) and (FGridState = gsRowSizing) then
    begin
        ChangeAllRowHeights(NewHeight, False);
    end;

    AdjustComboGridExtents(DropDownCols, DropDownRows);
    UpdateDesigner;
end;

procedure TtsBaseGrid.SingleRowHeightChanged(DisplayRow: Longint);
var
    DataRow: Longint;
begin
    DataRow := GetDataRow(DisplayRow);
    if (RowHeights[DisplayRow] <> 0) and (not IsRowVisible(DataRow)) then
        RowHeights[DisplayRow] := 0;

    if DisplayRow < FixedRows then CalcVertFixedHeight;
    if FGridControl <> nil then
        if not FControlHidden then ShowGridControl;
    AdjustComboGridExtents(DropDownCols, DropDownRows);
    UpdateDesigner;
end;

procedure TtsBaseGrid.CheckColWidths(var NewWidth: Integer);
var
    I: Integer;
begin
    NewWidth := 0;
    if DefaultColWidth < 1 then
    begin
        DefaultColWidth := 1;
        for I := 1 to (ColCount - 1) do
        begin
            GridCols[I].FWidth := 1;
            if Reading then GridCols[I].FOldWidth := 1;
        end;
    end
    else
    begin
        for I := 0 to (ColCount - 1) do
        begin
            if ColWidths[I] < 0 then ColWidths[I] := 0;

            if GridCols[GetDataCol(I)].Visible or (ColWidths[I] <> 0) then
            begin
                if GridCols[GetDataCol(I)].FWidth <> ColWidths[I] then
                begin
                    if I <> 0 then NewWidth := ColWidths[I];
                    GridCols[GetDataCol(I)].FWidth := ColWidths[I];
                    if Reading or FAsCombo then
                        GridCols[I].FOldWidth := ColWidths[I];
                end;
            end;
        end;
    end;

    if not FInChangingAllColWidths then
        FOldDefaultColWidth := DefaultColWidth;
end;

procedure TtsBaseGrid.ColWidthsChanged;
var
    I: Longint;
    OldWidth: Integer;
    NewWidth: Integer;
begin
    if FSkipColWidthsChanged then Exit;

    FSkipColWidthsChanged := True;

    OldWidth := RowBarWidth;
    CheckColWidths(NewWidth);
    GridCols[0].FWidth := OldWidth;
    if RowBarOn then ResizeCol(0, OldWidth)
                else ResizeCol(0, 0);

    for I := 1 to ColCount - 1 do
    begin
        if (ColWidths[GetDisplayCol(I)] <> 0) and (not GridCols[I].Visible) then
            ColWidths[GetDisplayCol(I)] := 0;
    end;

    FSkipColWidthsChanged := False;
    CalcHorzFixedWidth;

    if not FControlHidden then ShowGridControl;
    ColResized(-1);

    if (csDesigning in ComponentState) and (NewWidth <> 0) and (ResizeCols = rcAll) and
       (not FInChangingAllColWidths) and (FGridState = gsColSizing) then
    begin
        ChangeAllColWidths(NewWidth, False);
    end;

    AdjustComboGridExtents(DropDownCols, DropDownRows);
    UpdateDesigner;
end;

procedure TtsBaseGrid.SingleColWidthChanged(DisplayCol: Longint);
var
    DataCol: Longint;
begin
    DataCol := GetDataCol(DisplayCol);

    if (ColWidths[DisplayCol] <> 0) and (not GridCols[DataCol].Visible) then
        ColWidths[DisplayCol] := 0;

    if DisplayCol < FixedCols then CalcHorzFixedWidth;
    if FGridControl <> nil then
        if not FControlHidden then ShowGridControl;

    AdjustComboGridExtents(DropDownCols, DropDownRows);
    UpdateDesigner;
end;

procedure TtsBaseGrid.CellLoaded(var DrawData: TtsDrawData; DrawSelected: Boolean);
var
    DataCol, DataRow: Longint;
    Value: Variant;
begin
    FInCellLoaded := True;
    try
        DataCol := DrawData.DataCol;
        DataRow := DrawData.DataRow;

        FCellDrawn.X := -1;
        FCellDrawn.Y := -1;

        if (not FInGetCell) and
           ((not GridCols[DataCol].Visible) or (not IsRowVisible(DataRow))) then Exit;

        if CellEditing and CurrentCell.ValueSet(DataCol, DataRow) then
            AssignCellValue(DataCol, DataRow, DrawData, DrawSelected, FCurrentCell.FValue, nil, False, False)
        else
        begin
            Value := GetDataValue(DataCol, DataRow, DrawData.ControlType);
            CellLoadedEvent(DataCol, DataRow, DrawData.ControlType, Value);

            RestoreHandle;
            if not VarIsEmpty(Value) then
                AssignCellValue(DataCol, DataRow, DrawData, DrawSelected, Value, nil, False, False);
        end;

        if (not FInGetCell) and
           ((FCellDrawn.X <> DrawData.DisplayCol) or
            (FCellDrawn.Y <> DrawData.DisplayRow)) then
        begin
            DrawEmptyCell(DrawData, DrawSelected);
        end;

        FCellDrawn.X := -1;
        FCellDrawn.Y := -1;

    finally
        FInCellLoaded := False;
    end;
end;

procedure TtsBaseGrid.ChangeSelectedCols(FromDisplayCol, ToDisplayCol: Longint);
var
    FromColSelected: Boolean;
    I: Integer;
    FirstSelected, LastSelected: Longint;
begin
    if NumberOfColsSelected(FromDisplayCol, ToDisplayCol) <> 0 then
    begin
        FromColSelected := FSelectedCols[FromDisplayCol];
        FirstSelected := FSelectedCols.First;
        LastSelected := FSelectedCols.Last;

        if FromDisplayCol > ToDisplayCol then
        begin
            if FromColSelected and (FromDisplayCol >= LastSelected) then
                LastSelected := ToDisplayCol;

            for I := (FromDisplayCol - 1) downto ToDisplayCol do
            begin
                if FSelectedCols[I] then
                begin
                    if I = FirstSelected then FirstSelected := I + 1;
                    if I + 1 > LastSelected then LastSelected := I + 1;
                end;

                FSelectedCols.FBits[I + 1] := FSelectedCols.FBits[I];
            end;

            if FromColSelected and (ToDisplayCol < FirstSelected) then
                FirstSelected := ToDisplayCol;
        end
        else if FromDisplayCol < ToDisplayCol then
        begin
            if FromColSelected and (FromDisplayCol <= FirstSelected) then
                FirstSelected := ToDisplayCol;

            for I := (FromDisplayCol + 1) to ToDisplayCol do
            begin
                if FSelectedCols[I] then
                begin
                    if I = LastSelected then LastSelected := I - 1;
                    if I - 1 < FirstSelected then FirstSelected := I - 1;
                end;

                FSelectedCols.FBits[I - 1] := FSelectedCols.FBits[I];
            end;

            if FromColSelected and (ToDisplayCol > LastSelected) then
                LastSelected := ToDisplayCol;
        end;

        FSelectedCols.FBits[ToDisplayCol] := FromColSelected;
        FSelectedCols.FFirst := FirstSelected;
        FSelectedCols.FLast := LastSelected;
    end;
end;

procedure TtsBaseGrid.ChangeCurrentColPosition(FromDisplayCol, ToDisplayCol: Longint);
var
    NewCurrentCol: Longint;
begin
    NewCurrentCol := FCurDisplayCol;
    if (FromDisplayCol > ToDisplayCol) then
    begin
        if (FCurDisplayCol < FromDisplayCol) and
           (FCurDisplayCol >= ToDisplayCol) then
            Inc(NewCurrentCol)
        else if (FCurDisplayCol = FromDisplayCol)
            then NewCurrentCol := ToDisplayCol;
    end
    else if (FromDisplayCol < ToDisplayCol) then
    begin
        if (FCurDisplayCol > FromDisplayCol) and
           (FCurDisplayCol <= ToDisplayCol) then
            Dec(NewCurrentCol)
        else if (FCurDisplayCol = FromDisplayCol) then
            NewCurrentCol := ToDisplayCol;
    end;

    if NewCurrentCol <> FCurDisplayCol then
    begin
        ClearCurrentFocusRect(False);
        SetCurrentPosition(NewCurrentCol, FCurDisplayRow, True, True);
        DrawCurrentFocusRect(False);
        CheckRowColChanged;
    end;
end;

procedure TtsBaseGrid.ChangeSelectedRows(FromDisplayRow, ToDisplayRow: Longint);
var
    FromRowSelected: Boolean;
    I: Integer;
    FirstSelected, LastSelected: Longint;
begin
    if NumberOfRowsSelected(FromDisplayRow, ToDisplayRow) <> 0 then
    begin
        FromRowSelected := FSelectedRows[FromDisplayRow];
        FirstSelected := FSelectedRows.First;
        LastSelected := FSelectedRows.Last;

        if FromDisplayRow > ToDisplayRow then
        begin
            if FromRowSelected and (FromDisplayRow >= LastSelected) then
                LastSelected := ToDisplayRow;

            for I := (FromDisplayRow - 1) downto ToDisplayRow do
            begin
                if FSelectedRows[I] then
                begin
                    if I = FirstSelected then FirstSelected := I + 1;
                    if I + 1 > LastSelected then LastSelected := I + 1;
                end;

                FSelectedRows.FBits[I + 1] := FSelectedRows.FBits[I];
            end;

            if FromRowSelected and (ToDisplayRow < FirstSelected) then
                FirstSelected := ToDisplayRow;
        end
        else if FromDisplayRow < ToDisplayRow then
        begin
            if FromRowSelected and (FromDisplayRow <= FirstSelected) then
                FirstSelected := ToDisplayRow;

            for I := (FromDisplayRow + 1) to ToDisplayRow do
            begin
                if FSelectedRows[I] then
                begin
                    if I = LastSelected then LastSelected := I - 1;
                    if I - 1 < FirstSelected then FirstSelected := I - 1;
                end;

                FSelectedRows.FBits[I - 1] := FSelectedRows.FBits[I];
            end;

            if FromRowSelected and (ToDisplayRow > LastSelected) then
                LastSelected := ToDisplayRow;
        end;

        FSelectedRows.FBits[ToDisplayRow] := FromRowSelected;
        FSelectedRows.FFirst := FirstSelected;
        FSelectedRows.FLast := LastSelected;
    end;
end;

procedure TtsBaseGrid.ChangeCurrentRowPosition(FromDisplayRow, ToDisplayRow: Longint);
var
    NewCurrentRow: Longint;
begin
    NewCurrentRow := FCurDisplayRow;
    if (FromDisplayRow > ToDisplayRow) then
    begin
        if (FCurDisplayRow < FromDisplayRow) and
           (FCurDisplayRow >= ToDisplayRow) then
            Inc(NewCurrentRow)
        else if (FCurDisplayRow = FromDisplayRow)
            then NewCurrentRow := ToDisplayRow;
    end
    else if (FromDisplayRow < ToDisplayRow) then
    begin
        if (FCurDisplayRow > FromDisplayRow) and
           (FCurDisplayRow <= ToDisplayRow) then
            Dec(NewCurrentRow)
        else if (FCurDisplayRow = FromDisplayRow) then
            NewCurrentRow := ToDisplayRow;
    end;

    if NewCurrentRow <> FCurDisplayRow then
    begin
        ClearCurrentFocusRect(False);
        SetCurrentPosition(FCurDisplayCol, NewCurrentRow, True, True);
        DrawCurrentFocusRect(False);
        CheckRowColChanged;
    end;
end;

procedure TtsBaseGrid.SelectCols(FromDisplayCol, ToDisplayCol: Longint; Select: Boolean);
var
    First, Last: Longint;
begin
    if FColSelectMode = csNone then Exit;
    if (FromDisplayCol > ColCount - 1) then Exit;
    if (ToDisplayCol < 1) then Exit;
    if (not Select) and (FGridStatus <> grColSelect) then Exit;

    if FromDisplayCol < 1 then FromDisplayCol := 1;
    if ToDisplayCol > Colcount - 1 then ToDisplayCol := ColCount - 1;
    if FromDisplayCol > ToDisplayCol then Exit;
    if not CheckEndEdit(-1, -1, False) then Exit;

    if CheckHideControl(True) then Update;

    DeleteSelections([grRowSelect, grCellSelect], True);
    SelectionsChanged(False);

    First := FromDisplayCol;
    Last := First;
    while First <= ToDisplayCol do
    begin
        while (FSelectedCols[First] = FSelectedCols[Last]) do
        begin
            Inc(Last);
            if Last > ToDisplayCol then Break;
        end;

        if Select and (not FSelectedCols[First]) then
        begin
            AddColSelection(First, Last - 1);
            AddColInversion(First, Last - 1);
        end
        else if (not Select) and FSelectedCols[First] then
        begin
            DeleteColInversion(First, Last - 1);
            DeleteColSelection(First, Last - 1);
        end;

        First := Last;
    end;

    ShowGridControl;
    CheckRowSelection(False);
    SelectionsChanged(False);
    GridStatusChanged;
end;

procedure TtsBaseGrid.InvertRowSelection(FromDisplayRow, ToDisplayRow: Longint; Select: Boolean);
var
    First, Last: Longint;
    MaxRow: Longint;
begin
    First := FromDisplayRow;
    MaxRow := MaxVisibleRow;

    if (First >= FixedRows) and (First < TopRow) then
    begin
        if Select then AddRowSelection(First, CalcMin(ToDisplayRow, TopRow - 1))
                  else DeleteRowSelection(First, CalcMin(ToDisplayRow, TopRow - 1));
        First := CalcMin(ToDisplayRow, TopRow - 1) + 1;
    end;

    Last := First;
    while (First <= MaxRow) and (First <= ToDisplayRow) do
    begin
        while (FSelectedRows[First] = FSelectedRows[Last]) do
        begin
            Inc(Last);
            if (Last > MaxRow) or (Last > ToDisplayRow) then Break;
        end;

        if Select and (not FSelectedRows[First]) then
        begin
            AddRowSelection(First, Last - 1);
            InvertSelectedRows(First, Last - 1, Select);
        end
        else if (not Select) and FSelectedRows[First] then
        begin
            InvertSelectedRows(First, Last - 1, Select);
            DeleteRowSelection(First, Last - 1);
        end;

        First := Last;
    end;

    if First <= ToDisplayRow then
    begin
        if Select then AddRowSelection(First, ToDisplayRow)
                  else DeleteRowSelection(First, ToDisplayRow);
    end;
end;

procedure TtsBaseGrid.DoRowSelection(FromDisplayRow, ToDisplayRow: Longint; Select: Boolean; ByUser: Boolean);
var
    InvertRows: Boolean;
    DisablePaint: Boolean;
begin
    if RowSelectMode in [rsNone] then Exit;
    if InRowSelectMode and not Select then Exit;
    if (FromDisplayRow > RowCount - 1) then Exit;
    if (ToDisplayRow < 1) then Exit;
    if (not Select) and (FGridStatus <> grRowSelect) then Exit;

    if FromDisplayRow < 1 then FromDisplayRow := 1;
    if ToDisplayRow > Rows then ToDisplayRow := Rows;
    if FromDisplayRow > ToDisplayRow then Exit;
    if (RowSelectMode in [rsSingle]) and (FromDisplayRow <> ToDisplayRow) and Select then Exit;
    if not CheckEndEdit(-1, -1, False) then Exit;

    DisablePaint := SelectionColorEnabled;
    if DisablePaint then EnablePaint := False;
    try
        if CheckHideControl(True) then Update;
        ClearCurrentFocusRect(True);

        if (RowSelectMode = rsSingle) and Select and (FromDisplayRow <> FCurDisplayRow) then
        begin
            if GridStatus = grRowSelect then
            begin
                InvertSelectedRows(FCurDisplayRow, FCurDisplayRow, False);
                DeleteRowSelection(FCurDisplayRow, FCurDisplayRow);
            end;
        end;

        InvertRows := True;
        if ((FromDisplayRow <= 1) or
           ((FromDisplayRow <= TopRow) and (FInternalFixedRows = 0))) and
           (ToDisplayRow >= MaxVisibleRow) and Select and (FGridStatus <> grNormal) then
        begin
            InvertRows := False;
            AdjustSelection(stRowSelect);
        end
        else
            DeleteSelections([grColSelect, grCellSelect], True);

        SelectionsChanged(ByUser);
        if InvertRows then InvertRowSelection(FromDisplayRow, ToDisplayRow, Select)
                      else AddRowSelection(FromDisplayRow, ToDisplayRow);

        if (RowSelectMode = rsSingle) and Select and (FromDisplayRow <> FCurDisplayRow) then
        begin
            ClearCurrent(FCurDisplayRow);
            SetCurrentPosition(FCurDisplayCol, FromDisplayRow, True, True);
            DrawCurrentSelected(FromDisplayRow);
        end;
    finally
        if DisablePaint then begin EnablePaint := True; Update; end;
    end;

    ShowGridControl;
    DrawCurrentFocusRect(False);
    CheckRowColChanged;
    CheckRowSelection(False);
    SelectionsChanged(ByUser);
    GridStatusChanged;
end;

procedure TtsBaseGrid.SelectRows(FromDisplayRow, ToDisplayRow: Longint; Select: Boolean);
begin
    DoRowSelection(FromDisplayRow, ToDisplayRow, Select, False);
end;

procedure TtsBaseGrid.SelectCells(DisplayLeft, DisplayTop,
                                  DisplayRight, DisplayBottom: Longint);
var
    ARect: TRect;
    InvertRange: Boolean;
begin
    if DisplayRight < DisplayLeft then SwapLongint(DisplayLeft, DisplayRight);
    if DisplayBottom < DisplayTop then SwapLongint(DisplayTop, DisplayBottom);

    if (DisplayRight < 1) or (DisplayLeft >= ColCount) or
       (DisplayBottom < 1) or (DisplayTop >= RowCount) then Exit;
    if not CheckEndEdit(-1, -1, False) then Exit;

    if CheckHideControl(True) then Update;
    DeleteSelections([grRowSelect, grColSelect], True);
    SelectionsChanged(False);

    InvertRange := True;
    if FGridStatus = grCellSelect then
    begin
        ModifyRangeInversion(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom);
        DeleteRangeSelection;
        InvertRange := False;
    end;

    ARect := Rect(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom);
    FGridStatus := grCellSelect;
    FSelectedCells := ARect;
    FBaseSelectedCells := Rect(DisplayLeft, DisplayTop, DisplayLeft, DisplayTop);
    if InvertRange then AddRangeInversion(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom);

    SelectionsChanged(False);
    GridStatusChanged;
end;

procedure TtsBaseGrid.ResetSelection;
begin
    if FGridStatus in [grColSelect, grRowSelect, grCellSelect] then
    begin
        if (GridMode = gmListBox) and (RowSelectMode in [rsSingle, rsMulti]) then
        begin
            if not InRowSelectMode then DeleteSelections([], True);
            CheckRowSelection(False);
        end
        else
        begin
            SelectNone(FCurDisplayCol, FCurDisplayRow, -1, tsDefault);
            FGridStatus := grNormal;
        end;

        ShowGridControl;
        DrawCurrentFocusRect(False);
        SelectionsChanged(False);
        GridStatusChanged;
    end;
end;

function TtsBaseGrid.InEditMode: Boolean;
begin
    Result := (GridMode in [gmEdit, gmEditInsert]) and (FGridStatus = grNormal);
end;

function TtsBaseGrid.InGridMode: Boolean;
begin
    Result := (GridMode in [gmEdit, gmEditInsert, gmBrowse]) and
              (FGridStatus = grNormal);
end;

function TtsBaseGrid.InEditState: Boolean;
begin
    Result := not (csDesigning in ComponentState);
    if Result then Result := InEditMode and (Rows > 0) and (Cols > 0);
end;

function TtsBaseGrid.InGridState: Boolean;
begin
    Result := not (csDesigning in ComponentState);
    if Result then Result := InGridMode and (Rows > 0) and (Cols > 0);
end;

function TtsBaseGrid.CanSkipReadOnly: Boolean;
begin
    Result := (not InDesignMode) and SkipReadOnly and (GridMode <> gmListBox);
end;

procedure TtsBaseGrid.SetEnableStartEdit(Value: Boolean);
begin
    if not Value then
        Inc(FEnableStartEditCount)
    else if FEnableStartEditCount > 0 then
        Dec(FEnableStartEditCount);
end;

function TtsBaseGrid.GetEnableStartEdit: Boolean;
begin
    Result := (FEnableStartEditCount = 0);
end;

function TtsBaseGrid.InRowSelectMode: Boolean;
begin
    Result := (GridMode = gmListBox) and (RowSelectMode = rsSingle);
end;

procedure TtsBaseGrid.PositionCurrentCell(DataCol, DataRow: Longint);
var
    DisplayCol, DisplayRow: Longint;
begin
    DisplayCol := GetDisplayCol(DataCol);
    DisplayRow := GetDisplayRow(DataRow);

    if (FCurDisplayCol <> DisplayCol) or (FCurDisplayRow <> DisplayRow) then
    begin
        if DisplayRow <> FCurDisplayRow then
        begin
            if IsRowSelected(FCurDataRow) and InRowSelectMode then
            begin
                InvertSelectedRows(FCurDisplayRow, FCurDisplayRow, False);
                DeleteRowSelection(FCurDisplayRow, FCurDisplayRow);
            end;

            ClearCurrent(FCurDisplayRow);
            SetCurrentPosition(DisplayCol, DisplayRow, True, True);
            if IsRowSelected(DataRow) then DrawCurrentSelected(DisplayRow)
                                      else DrawCurrent(DisplayRow);
        end
        else
            SetCurrentPosition(DisplayCol, DisplayRow, True, True);
    end;
end;

procedure TtsBaseGrid.SetCurrentCell(DisplayCol, DisplayRow: Longint);
begin
    if (FCurDisplayCol <> DisplayCol) or (FCurDisplayRow <> DisplayRow) then
    begin
        if not CheckEndEdit(GetDataCol(DisplayCol), GetDataRow(DisplayRow), False) then Exit;

        CheckHideControl(True);
        ClearCurrentFocusRect(False);
        PositionCurrentCell(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
        ShowGridControl;
        DrawCurrentFocusRect(False);

        CheckRowColChanged;
        CheckRowSelection(False);
        SelectionsChanged(False);
    end;
end;

function TtsBaseGrid.GetCellValue(DataCol: Longint; DataRow: Longint): Variant;
var
    ControlType: TtsControlType;
begin
    Result := Unassigned;
    if (DataCol < 1) or (DataCol > Cols) then Exit;
    if (DataRow < 1) or (DataRow > Rows) then Exit;

    ControlType := GiveCellControlType(DataCol, DataRow);
    if ControlType = ctNone then Exit;

    if CurrentCell.ValueSet(DataCol, DataRow) then
    begin
        Result := CurrentCell.Value;
        Exit;
    end;

    if not CheckGetCell then Exit;

    FInGetCell := True;
    try
        FGetCellCol := DataCol;
        FGetCellRow := DataRow;

        FGetCellValue := GetDataValue(DataCol, DataRow, ControlType);
        CellLoadedEvent(DataCol, DataRow, ControlType, FGetCellValue);
        Result := FGetCellValue;
    finally
        FInGetCell := False;
    end;
end;

procedure TtsBaseGrid.ControlValueChanged(Edit, ByUser, TextAdded: Boolean);
var
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    if FFirstTimePainted then
    begin
        if Edit then
        begin
            FCellEditing := True;
            FCurRowChanged := True;
            if RowBarIndicator and DrawRowChangedIndicator(GetDataRow(FCurDisplayRow)) then
                DrawBmpRowBar(FCurDisplayRow, BitMapChangedRow, True, cmMergeCopy);

            if IsInsertRow(FCurDisplayRow) then
            begin
                SetInsertionRow(1);
                FInsertRowEdit := True;
                SetNewRowCount(Rows);
            end;
        end;

        if (not FInCellLoaded) and Edit and
           (not ((not ByUser) and IsInsertRow(FCurDisplayRow))) then
        begin
            CellEdit(FCurDataCol, FCurDataRow, ByUser);
            if not FRowEditing then FRowEditing := FCellEditing;

            ButtonType := GiveCellButton(CurDataCol, CurDataRow, DropDownStyle);
            if TextAdded and (ButtonType = btCombo) and (DropDownStyle = ddDropDown) then
            begin
                if not PositionAutoFill(False) then PositionComboRow;
            end
            else if ComboVisible then
                PositionComboRow;
        end;
    end;
end;

function TtsBaseGrid.GetCheckBoxValue(Value: Variant): Variant;
begin
    if (VarType(Value) = varInteger) or
       (VarType(Value) = varByte) then
        Result := Value
    else if VarIsNull(Value) or (VarType(Value) = varString) then
        Result := Value
    else
        Result := cbGrayed;
end;

function TtsBaseGrid.AssignControlValue(ControlType: TtsControlType; Value: Variant; Edit, ByUser: Boolean): Variant;
var
    CellValue: Variant;
    Bitmap: TBitmap;
begin
    if VarIsEmpty(Value)
        then CellValue := EmptyCellValue(ControlType)
        else CellValue := Value;

    if (not VarIsEmpty(CellValue)) then
    begin
        case ControlType of
            ctText:
                if not VarIsNull(CellValue) then
                begin
                    if not Edit then FGridControl.Value := CellValue
                                else FGridControl.SetEditValue(CellValue, ByUser);
                end;

            ctCheck:
                begin
                    if not Edit then FGridControl.Value := GetCheckBoxValue(CellValue)
                                else FGridControl.SetEditValue(GetCheckBoxValue(CellValue), ByUser);
                end;

            ctPicture:
                if not VarIsNull(CellValue) then
                begin
                    if VarType(CellValue) = varString then
                        FCurrentCell.SetBuffer(CellValue, False)
                    else if VariantToBitmap(CellValue) <> nil then
                    begin
                        Bitmap := TBitmap.Create;
                        Bitmap.Assign(VariantToBitmap(CellValue));
                        FCurrentCell.SetBuffer(BitmapToVariant(Bitmap), True);
                    end;

                    FCurrentCell.FStretchPicture := StretchPicture;
                    FCurrentCell.FShrinkPicture := ShrinkPicture;
                    FCurrentCell.FCenterPicture := CenterPicture;
                    FCurrentCell.FKeepAspectRatio := KeepAspectRatio;
                    FCurrentCell.FTransparentColor := TransparentColor;
                    ControlValueChanged(Edit, ByUser, False);
                end;
        end;
    end;
    Result := CellValue;
end;

procedure TtsBaseGrid.SetControlValue(const Value: Variant; Edit, ByUser: Boolean);
var
    ControlType: TtsControlType;
    CellValue: Variant;
begin
    if not InGridState then Exit;

    ControlType := CurCellControlType;
    SetGridControl(ControlType);
    SetControlProperties(FGridControl);

    CellValue := AssignControlValue(ControlType, Value, Edit, ByUser);
    SetControlMask;

    if (not VarIsEmpty(CellValue)) and (not VarIsNull(CellValue)) then
    begin
        if (ControlType <> ctPicture) and FGridControl.IsEditControl then
        begin
            if FEditSelect = tsAll then
                FGridControl.SelectAll
            else if FEditSelect = tsNone then
                FGridControl.SelLength := 0;
        end;
    end;

    SetControlSelectMode(tsCurrent);
end;

procedure TtsBaseGrid.SetControlMask;
begin
    if not Assigned(FGridControl) then Exit;
    FGridControl.MaskDefs := MaskDefs;
    FGridControl.MaskName := CurCellMaskName;
end;

function TtsBaseGrid.SetControlCheckBoxValues: Boolean;
var
    Value: string;
begin
    Result := False;
    if not Assigned(FGridControl) then Exit;
    if FGridControl <> FCheckControl then Exit;

    Value := CurCellCheckBoxValues;
    if FCheckControl.CheckBoxValues <> Value then
    begin
        Result := True;
        FCheckControl.CheckBoxValues := CurCellCheckBoxValues;
    end;
end;

procedure TtsBaseGrid.RestoreHandle;
begin
    if (FGridMemoryCanvas.Dc <> 0) and FFirstTimePainted and FInPaintWindow and
       (Canvas.Handle <> FGridMemoryCanvas.Dc) then
    begin
        Canvas.Handle := FGridMemoryCanvas.Dc;
    end;
end;

function TtsBaseGrid.BmpHandleNeeded(Bitmap: TBitmap): Hdc;
begin
    try
        Result := Bitmap.Canvas.Handle;
    finally
        RestoreHandle;
    end;
end;

procedure TtsBaseGrid.AssignCellValue(DataCol, DataRow: Longint; var DrawData: TtsDrawData;
                                      DrawSelected: Boolean; const Value: Variant; PValue: PChar; Edit, ByUser: Boolean);
var
    DisplayCol, DisplayRow : Longint;
    DrawAsControl: Boolean;
    Text: string;
    Bmp: TBitmap;
    Image: TtsImageItem;
    ControlType: TtsControlType;
begin
    if FInGetCell and (FGetCellCol = DataCol) and (FGetCellRow = DataRow) then
    begin
        if Assigned(PValue) then FGetCellValue := StrPas(PValue)
                            else FGetCellValue := Value;
        Exit;
    end;

    if (not GridCols[DataCol].Visible) or (not IsRowVisible(DataRow)) then Exit;

    DisplayCol := DrawData.DisplayCol;
    DisplayRow := DrawData.DisplayRow;
    DrawAsControl := False;
    ControlType := DrawData.ControlType;

    if (not DrawSelected) and InEditMode and (DisplayCol = FCurDisplayCol) and
       (DisplayRow = FCurDisplayRow) then
    begin
        if Assigned(PValue) then
        begin
            if (not CurrentCell.ValueSet(DataCol, DataRow)) or
               (StrPas(PValue) <> CurrentCell.FValue) then
            begin
                SetControlValue(StrPas(PValue), Edit, ByUser);
            end;
        end
        else
        begin
            if (not CurrentCell.ValueSet(DataCol, DataRow)) or
               (VarType(Value) <> VarType(CurrentCell.FValue)) or
               (Value <> CurrentCell.FValue) then
            begin
                SetControlValue(Value, Edit, ByUser);
            end;
        end;

        if ControlType <> ctPicture then
        begin
            if not FGridControl.Visible and FControlSet then
                FSetGridControlVisible := True;
            if CanSetControl and (FControlSet or FDisplayAsControl) then
                DrawAsControl := FControlEnabled;
        end;
    end;

    RestoreHandle;
    if (DrawData.FullRect.Left <= DrawData.FullRect.Right) and
       (DrawData.FullRect.Top <= DrawData.FullRect.Bottom) then
    begin
        if InClipRect(DrawData.FullRect) then
        begin
            FGridButton := GridCellButton(DisplayCol, DrawData.ButtonType);
            UpdateDrawData(DrawData, DrawAsControl);

            if (FSetGridControlVisible or DrawAsControl) and
               (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then
            begin
                UpdateControlProperties(DrawData);
            end;

            if Assigned(PValue) then
                DrawText(PValue, DrawData, DrawSelected)
            else
            case ControlType of
                ctText:
                    begin
                        Text := Value;
                        DrawText(PChar(Text), DrawData, DrawSelected);
                    end;

                ctCheck:
                    DrawCheck(GetCheckBoxValue(Value), DrawData, DrawSelected);

                ctPicture:
                    begin
                        Image := nil;
                        if VarType(Value) = varString then
                        begin
                            Bmp := nil;
                            Image := ImageListPicture(Value);
                            if Assigned(Image) then Bmp := Image.Bitmap;
                        end
                        //else if (VarType(Value) = varInteger) then
                        //    Bmp := Nil
                        else
                            Bmp := VariantToBitmap(Value);
                        DrawPicture(Bmp, Image, DrawData, DrawSelected);
                    end;
            end;

            if DrawAsControl then
                FillSelectionPart(ControlType, DrawData, DrawSelected);
        end
        else if (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then
        begin
            DrawCellFocusRect(DisplayCol, DisplayRow);
        end
    end;

    FCellDrawn.X := DisplayCol;
    FCellDrawn.Y := DisplayRow;
end;

procedure TtsBaseGrid.UpdateCellFonts;
var
    I: Integer;
    DataCol, DataRow: Integer;
    Element: TtsCellElement;
begin
    I := 0;
    while FAutoFontCells.NextCoord(I, DataCol, DataRow) do
    begin
        Element := TtsCellElement(FCellPropSet.Get([DataCol,DataRow]));
        if Assigned(Element) then Element.CheckFont;
    end;
end;

function TtsBaseGrid.IsDrawProp(Prop: TtsProperty): Boolean;
begin
    Result := Prop in [prColor, prFont, prAlign, prAlignment,
                       prWordWrap, prParentFont, prPicture];
end;

procedure TtsBaseGrid.InitPictureMaskColor(MaskColor: TColor);
var
    I, J: Integer;
begin
    if FPictureColorMask.Width <> 8 then FPictureColorMask.Width := 8;
    if FPictureColorMask.Height <> FPictureColorMask.Width then
        FPictureColorMask.Height := FPictureColorMask.Width;

    for I := 0 to FPictureColorMask.Width - 1 do
    begin
        for J := 0 to FPictureColorMask.Height - 1 do
        begin
            if (I + J) mod 2 = 0
                then FPictureColorMask.Canvas.Pixels[I,J] := MaskColor
                else FPictureColorMask.Canvas.Pixels[I,J] := clBlack;
        end;
    end;
    FPictureMaskRGBColor := ColorToRGB(MaskColor);
end;

procedure TtsBaseGrid.CheckPictureMaskColor(MaskColor: TColor);
begin
    if not Assigned(PictureColorMask) then Exit;
    if FPictureMaskRGBColor <> ColorToRGB(MaskColor) then
    begin
        InitPictureMaskColor(MaskColor);
    end;
end;

procedure TtsBaseGrid.CheckPictureMask(Create: Boolean);
begin
    if (FSelectionColor = clNone) and (FocusColor = clNone) then
    begin
        FPictureColorMask.Free;
        FPictureColorMask := nil;
    end
    else if Create then
    begin
        if FPictureColorMask = nil then
            FPictureColorMask := TBitmap.Create;
    end;
end;

procedure TtsBaseGrid.ImageListDeleted;
begin
    Invalidate;
end;

procedure TtsBaseGrid.ImageChanged(Image: TtsImageItem);
begin
    Invalidate;
end;

function TtsBaseGrid.ImageListPicture(Value: Variant): TtsImageItem;
begin
    Result := nil;
    if not Assigned(ImageList) then Exit;
    if ImageList.IndexExists(Value) then
        Result := ImageList.Image[Value];
end;

function TtsBaseGrid.PrepareCanvas(ClipRect: TRect): Boolean;
var
    Dc: Hdc;
begin
    Result := False;
    if FInPaintWindow then Exit;

    Dc := GetDC(Handle);
    try
        FGridMemoryCanvas.Lock(Self);
        SetGridDc(Dc);
        FGridMemoryCanvas.SetObjects(ClipRect);
    finally
        ReleaseDC(Handle, Dc);
    end;

    Canvas.Handle := FGridMemoryCanvas.Dc;
    if FDoInitCanvas then
    begin
        InitCanvas(Canvas);
        FDoInitCanvas := False;
    end;

    FInPaintWindow := True;
    Result := True;
end;

procedure TtsBaseGrid.CanvasToScreen(ClipRect: TRect);
var
    Dc: Hdc;
    ARect: TRect;
begin
    try
        if (ClipRect.Left <= ClipRect.Right) and (ClipRect.Top <= ClipRect.Bottom) then
        begin
            if Canvas.Handle = FGridMemoryCanvas.Dc then
            begin
                Dc := GetDC(Handle);
                try
                    ARect := ClipRect;
                    if ARect.Right > ClientWidth then ARect.Right := ClientWidth;
                    if ARect.Bottom > ClientHeight then ARect.Bottom := ClientHeight;
                    BitBlt(Dc, ARect.Left, ARect.Top, ARect.Right - ARect.Left,
                           ARect.Bottom - ARect.Top, FGridMemoryCanvas.Dc,
                           ARect.Left, ARect.Top, cmSrcCopy);
                finally
                    ReleaseDC(Handle, Dc);
                end;
            end;
        end;
    finally
        FGridMemoryCanvas.Unlock;
        FInPaintWindow := False;
        if Canvas.Handle = FGridMemoryCanvas.Dc then Canvas.Handle := 0;
    end;
end;

procedure TtsBaseGrid.SetCellValue(DataCol: Longint; DataRow: Longint; const Value: Variant);
var
    DrawData: TtsDrawData;
    DisplayCol, DisplayRow: Longint;
    DrawSelected, CanvasPrepared: Boolean;
    CurValue: Variant;
    ControlType: TtsControlType;
begin
    if (DataCol < 1) or (DataCol > FCols) then Exit;
    if (DataRow < 1) or (DataRow > FRows) then Exit;

    DisplayCol := DisplayColnr[DataCol];
    DisplayRow := DisplayRownr[DataRow];
    if StoreData then
    begin
        ControlType := GiveCellControlType(DataCol, DataRow);
        SetDataValue(DataCol, DataRow, ControlType, CheckStrValue(ControlType, Value));
        if (not FastAssign) and HandleAllocated and (not FInPaintWindow) and
           ((not CellEditing) or (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow)) then
        begin
            if (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow) then
            begin
                if CellVisible(DisplayCol, DisplayRow) then
                    CheckInvalidateCell(DisplayCol, DisplayRow);
                Exit;
            end;
        end;
    end;

    if not HandleAllocated then Exit;

    DrawSelected := IsCellSelected(DisplayCol, DisplayRow);
    GetDrawData(DisplayCol, DisplayRow, True, DrawData);
    CanvasPrepared := False;
    if DrawSelected then CanvasPrepared := PrepareCanvas(DrawData.FullRect);
    try
        CurValue := CheckStrValue(DrawData.ControlType, Value);
        AssignCellValue(DataCol, DataRow, DrawData, DrawSelected, CurValue, nil, False, False);
        if DrawSelected and CanvasPrepared then
        begin
            if (DisplayCol = 0) or (DisplayRow = 0) then
                RectInvert(Canvas.Handle, DrawData.FullRect, True)
            else if (not SelectionColorEnabled) then
                RectInvert(Canvas.Handle, DrawData.FullRect, True);
        end;
    finally
        if CanvasPrepared then CanvasToScreen(DrawData.FullRect);
    end;
end;

procedure TtsBaseGrid.SetCellPText(DataCol: Longint; DataRow: Longint; Value: PChar);
var
    VarValue: Variant;
    DrawData: TtsDrawData;
    DisplayCol, DisplayRow: Longint;
    DrawSelected, CanvasPrepared: Boolean;
    ControlType: TtsControlType;
begin
    if (DataCol < 1) or (DataCol > Cols) then Exit;
    if (DataRow < 1) or (DataRow > Rows) then Exit;

    DisplayCol := DisplayColnr[DataCol];
    DisplayRow := DisplayRownr[DataRow];
    if StoreData then
    begin
        VarValue := StrPas(Value);
        ControlType := GiveCellControlType(DataCol, DataRow);
        SetDataValue(DataCol, DataRow, ControlType, VarValue);
        if (not FastAssign) and HandleAllocated and (not FInPaintWindow) and
           ((not CellEditing) or (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow)) then
        begin
            if (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow) then
            begin
                if CellVisible(DisplayCol, DisplayRow) then
                    CheckInvalidateCell(DisplayCol, DisplayRow);
                Exit;
            end;
        end;
    end;

    if not HandleAllocated then Exit;

    DrawSelected := IsCellSelected(DisplayCol, DisplayRow);
    GetDrawData(GetDisplayCol(DataCol), GetDisplayRow(DataRow), True, DrawData);
    CanvasPrepared := False;
    if DrawSelected then CanvasPrepared := PrepareCanvas(DrawData.FullRect);
    try
        AssignCellValue(DataCol, DataRow, DrawData, DrawSelected, Unassigned, Value, False, False);
        if DrawSelected and CanvasPrepared then
        begin
            if (DisplayCol = 0) or (DisplayRow = 0) then
                RectInvert(Canvas.Handle, DrawData.FullRect, True)
            else if (not SelectionColorEnabled) then
                RectInvert(Canvas.Handle, DrawData.FullRect, True);
        end;
    finally
        if CanvasPrepared then CanvasToScreen(DrawData.FullRect);
    end;
end;

procedure TtsBaseGrid.ColResized(DataCol: Longint);
begin
    FComboInitialized := false;
    DoColResized(DataCol);
    UpdateScrollRange;
end;

procedure TtsBaseGrid.RowResized(DataRow: Longint);
begin
    DoRowResized(DataRow);
    UpdateScrollRange;
end;

function TtsBaseGrid.LastVisibleCol(StartCol: Longint): Longint;
var
    Sum: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth;

    while (Sum < ClientWidth) and (StartCol + Count <= ColCount - 1) do
    begin
        Inc(Sum, ColWidths[StartCol + Count]);
        Inc(Count);
    end;

    if Count = 0 then Inc(Count);
    Result := StartCol + Count - 1;
end;

function TtsBaseGrid.CompVisibleCols(StartCol: Longint): Longint;
var
    Sum: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth - FVertLineWidth;

    while (StartCol + Count <= ColCount - 1) do
    begin
        if Sum + ColWidths[StartCol + Count] > ClientWidth then Break;

        Inc(Sum, ColWidths[StartCol + Count]);
        Inc(Count);
    end;

    Result := Count;
end;

function TtsBaseGrid.PrevVisibleCols: Longint;
var
    Sum: Integer;
    Count: Longint;
    StartCol: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth - FVertLineWidth;
    StartCol := LeftCol - 1;

    while (StartCol - Count >= FixedCols) do
    begin
        if Sum + ColWidths[StartCol - Count] > ClientWidth then Break;
        Inc(Sum, ColWidths[StartCol - Count]);
        Inc(Count);
    end;

    Result := Count;
end;

function TtsBaseGrid.LastVisibleRow(StartRow: Longint): Longint;
var
    Sum: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FVertFixedHeight;

    while (Sum < ClientHeight) and (StartRow + Count <= RowCount - 1) do
    begin
        Inc(Sum, RowHeights[StartRow + Count]);
        Inc(Count);
    end;

    if Count = 0 then Inc(Count);
    Result := StartRow + Count - 1;
end;

function TtsBaseGrid.CompVisibleRows(StartRow: Longint): Longint;
var
    Sum: Integer;
    Count: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FVertFixedHeight - FHorzLineWidth;

    while (StartRow + Count <= RowCount - 1) do
    begin
        if Sum + RowHeights[StartRow + Count] > ClientHeight then Break;

        Inc(Sum, RowHeights[StartRow + Count]);
        Inc(Count);
    end;

    Result := Count;
end;

function TtsBaseGrid.PrevScrollRows: Longint;
var
    Sum: Integer;
    Count: Longint;
    ScrollRow, DisplayRow: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FVertFixedHeight - FHorzLineWidth;

    ScrollRow := FVisibleRows.Locate(TopRow, Found) - 1;
    while (ScrollRow >= 1) do
    begin
        DisplayRow := FVisibleRows[ScrollRow];
        if DisplayRow < FixedRows then Break;
        if Sum + RowHeights[DisplayRow] > ClientHeight then Break;
        Inc(Sum, RowHeights[DisplayRow]);
        Inc(Count);
        Dec(ScrollRow);
    end;

    Result := Count;
end;

function TtsBaseGrid.VisibleScrollRows: Longint;
var
    Sum: Integer;
    Count: Longint;
    ScrollRow, DisplayRow: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FVertFixedHeight - FHorzLineWidth;

    ScrollRow := FVisibleRows.Locate(TopRow, Found);
    while (ScrollRow <= FVisibleRows.Count) do
    begin
        DisplayRow := FVisibleRows[ScrollRow];
        if Sum + RowHeights[DisplayRow] > ClientHeight then Break;
        Inc(Sum, RowHeights[DisplayRow]);
        Inc(Count);
        Inc(ScrollRow);
    end;

    Result := Count;
end;

function TtsBaseGrid.PrevScrollCols: Longint;
var
    Sum: Integer;
    Count: Longint;
    ScrollCol, DisplayCol: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth - FVertLineWidth;

    ScrollCol := FVisibleCols.Locate(LeftCol, Found) - 1;
    while (ScrollCol >= 1) do
    begin
        DisplayCol := FVisibleCols[ScrollCol];
        if DisplayCol < FixedCols then Break;
        if Sum + ColWidths[DisplayCol] > ClientWidth then Break;
        Inc(Sum, ColWidths[DisplayCol]);
        Inc(Count);
        Dec(ScrollCol);
    end;

    Result := Count;
end;

function TtsBaseGrid.VisibleScrollCols: Longint;
var
    Sum: Integer;
    Count: Longint;
    ScrollCol, DisplayCol: Longint;
    Found: Boolean;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    Count := 0;
    Sum := FHorzFixedWidth - FVertLineWidth;

    ScrollCol := FVisibleCols.Locate(LeftCol, Found);
    while (ScrollCol <= FVisibleCols.Count) do
    begin
        DisplayCol := FVisibleCols[ScrollCol];
        if Sum + ColWidths[DisplayCol] > ClientWidth then Break;
        Inc(Sum, ColWidths[DisplayCol]);
        Inc(Count);
        Inc(ScrollCol);
    end;

    Result := Count;
end;

function TtsBaseGrid.MaxVisibleCol: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    if LeftCol + VisibleColCount = ColCount then
        Result := RightMostCol(False, False)
    else
        Result := MouseCoord(ClientWidth - 1, 0).X;
end;

function TtsBaseGrid.MaxVisibleRow: Longint;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    if TopRow + VisibleRowCount >= RowCount then
    begin
        if GridMode = gmEditInsert then Result := RowCount - 1
                                   else Result := BottomMostRow(False, False);
    end
    else
        Result := MouseCoord(0, ClientHeight - 1).Y;
end;

function TtsBaseGrid.GridCellControl(ControlType: TtsControlType) : TtsCustomGridControl;
begin
    Result := FDefaultControl;
    case ControlType of
        ctText  : Result := FEditControl;
        ctCheck : Result := FCheckControl;
        ctPicture: Result := FPictureControl;
    end;
end;

function TtsBaseGrid.GridCellButton(DisplayCol: Longint; ButtonType: TtsButtonType): TtsCustomButton;
begin
    Result := FComboButton;
    case ButtonType of
        btCombo:
            begin
                if FComboButton = nil then
                begin
                    FComboButton := TtsComboButton.Create(Self, BitmapCombo, clNone,
                                                          FDefaultButtonWidth, FDefaultButtonHeight);
                end;
                Result := FComboButton;
            end;

        btDateTimeDropDown:
            begin
                if FDateTimeDropDownButton = nil then
                begin
                    FDateTimeDropDownButton := TtsDateTimeButton.Create(Self, BitmapCombo, clNone,
                                                                        FDefaultButtonWidth, FDefaultButtonHeight);
                end;
                Result := FDateTimeDropDownButton;
            end;

        btDateTimePopup:
            begin
                if FDateTimePopupButton = nil then
                begin
                    FDateTimePopupButton := TtsDateTimeButton.Create(Self, BitmapButtonDetail, clNone,
                                                                     FDefaultButtonWidth, FDefaultButtonHeight);
                end;
                Result := FDateTimePopupButton;
            end;

        btNormal:
            begin
                Result := GridCols[GetDataCol(DisplayCol)].FNormalButton;
                if Result = nil then
                begin
                    if FNormalButton = nil then
                    begin
                        FNormalButton := TtsNormalButton.Create(Self, BitmapButtonDetail, clNone,
                                                                FDefaultButtonWidth, FDefaultButtonHeight);
                    end;
                    Result := FNormalButton;
                end;
            end;

        btVertSpin:
            begin
                if FVertSpinButton = nil then
                    FVertSpinButton := TtsVertSpinButton.Create(Self, nil, clNone, SpinButtonWidth, SpinButtonHeight);
                Result := FVertSpinButton;
            end;

        btHorzSpin:
            begin
                if FHorzSpinButton = nil then
                    FHorzSpinButton := TtsHorzSpinButton.Create(Self, nil, clNone, SpinButtonHeight, SpinButtonWidth);
                Result := FHorzSpinButton;
            end;
    end;
end;

procedure TtsBaseGrid.SetCheckBoxOnBitmap(Bmp : TBitmap);
begin
    FCheckControl.SetCheckBoxBitmap(cbChecked, Bmp);
    Invalidate;
end;

procedure TtsBaseGrid.SetCheckBoxOffBitmap(Bmp : TBitmap);
begin
    FCheckControl.SetCheckBoxBitmap(cbUnchecked, Bmp);
    Invalidate;
end;

procedure TtsBaseGrid.SetCheckBoxGrayedBitmap(Bmp : TBitmap);
begin
    FCheckControl.SetCheckBoxBitmap(cbGrayed, Bmp);
    Invalidate;
end;

function TtsBaseGrid.ShapeCursor(X, Y: integer; DisplayCol, DisplayRow: Longint): HCursor;
var
    State: TtsMouseStatus;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
    ControlType: TtsControlType;
begin
    Result := 0;

    if FMouseStatus in [msColResize, msRowBarResize] then
    begin
        Result := Screen.Cursors[crVSplit];
        Exit;
    end
    else if FMouseStatus in [msRowResize, msHeadingResize] then
    begin
        Result := Screen.Cursors[crHSplit];
        Exit;
    end
    else if FMouseStatus = msButtonDown then
    begin
        Exit;
    end
    else if (X > ClientWidth) or (Y > ClientHeight) then
    begin
        Result := Screen.Cursors[crDefault];
        Exit;
    end
    else
    begin
        State := GetSizingState(X, Y, DisplayCol, DisplayRow);
        if State in [msColResize, msRowBarResize] then
        begin
            Result := Screen.Cursors[crHSplit];
            Exit;
        end
        else if State in [msRowResize, msHeadingResize] then
        begin
            Result := Screen.Cursors[crVSplit];
            Exit;
        end;
    end;

    if InDragArea(DisplayCol, DisplayRow) and (FSelectedAreaCursor <> crDefault) then
    begin
        Result := Screen.Cursors[FSelectedAreaCursor];
        Exit;
    end
    else if ((LeftCol + VisibleColCount >= ColCount) and (X > CellRect(ColCount-1,MaxVisibleRow).Right - (1 - FVertLineWidth))) or
             ((TopRow + VisibleRowCount >= RowCount) and (Y > CellRect(MaxVisibleCol,RowCount-1).Bottom - (1 - FHorzLineWidth))) then
    begin
        Result := Screen.Cursors[Cursor];
        Exit;
    end
    else if (DisplayCol < 1) and (DisplayRow >= 1) then
    begin
        if (RowSelectMode in [rsSingle, rsMulti]) then
        begin
            if IsRowSelected(GetDataRow(DisplayRow)) and (FGridStatus = grRowSelect) and
               RowMoving and not FixedRowsSelected then
                Result := Screen.Cursors[Cursor]
            else if not CanSelect(-1, DisplayRow) then
                Result := Screen.Cursors[Cursor]
            else if IsAppendRow(DisplayRow) then
                Result := Screen.Cursors[Cursor]
            else
                Result := CursorHorArrowRight;
            Exit;
        end;
    end
    else if (DisplayCol >= 1) and (DisplayRow < 1) then
    begin
        if FColSelectMode = csMulti then
        begin
            if (FSelectedCols.Count > 0) and (FSelectedCols[DisplayCol]) and
               FColMoving and not FixedColsSelected then
                Result := Screen.Cursors[Cursor]
            else if not CanSelect(DisplayCol, -1) then
                Result := Screen.Cursors[Cursor]
            else if (ButtonInColHeading(DisplayCol) and MouseOverHeadingButton(X, Y, DisplayCol)) or
                    IsColHeadingButton(DisplayCol) then
                        Result := Screen.Cursors[Cursor]
            else
                Result := CursorVertArrowDown;
            Exit;
        end;
    end
    else if (DisplayCol < 1) and (DisplayRow < 1) then
    begin
        Result := Screen.Cursors[Cursor];
        Exit;
    end
    else if (X >= CellRect(DisplayCol, DisplayRow).Left) and
            (X < CellRect(DisplayCol, DisplayRow).Left + tsRangeSelectWidth) and
            (GridMode in [gmEdit, gmEditInsert, gmBrowse]) and (CellSelectMode = cmRange) then
    begin
        if not CanSelect(DisplayCol, DisplayRow) then
            Result := Screen.Cursors[Cursor]
        else if IsAppendRow(DisplayRow) then
            Result := Screen.Cursors[Cursor]
        else
            Result := CursorArrowRev;
        Exit;
    end
    else if GridMode in [gmEdit, gmEditInsert] then
    begin
        ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
        if CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then
            Result := Screen.Cursors[Cursor]
        else if (ButtonType in [btCombo, btDateTimeDropDown, btDateTimePopup]) and (DropDownStyle = ddDropDownList) then
            Result := Screen.Cursors[Cursor]
        else
        begin
            ControlType := GiveCellControlType(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
            if ControlType = ctText then
            begin
                if AlwaysShowEditor and not MouseOverButton(X, Y, DisplayCol, DisplayRow) then
                    Result := Screen.Cursors[crIBeam]
                else
                    Result := Screen.Cursors[Cursor];
            end
            else if ControlType = ctCheck then
                Result := Screen.Cursors[Cursor];
        end;
        Exit;
    end;

    Result := Screen.Cursors[Cursor]
end;

procedure TtsBaseGrid.ChangeRowInversion(FromRow, ToRow: Longint; SelectionSet: Boolean);
var
    I: Integer;
    Dc: HDC;
    Step: Integer;
    DataRow: Integer;
    RowPos: Integer;
    Found: Boolean;
begin
    Step := 1;
    if FromRow > ToRow then
    begin
        SwapLongint(FromRow, ToRow);
        Step := -1;
    end;

    if ToRow < 1 then Exit;
    if FromRow < 1 then FromRow := 1;
    if ToRow >= RowCount then ToRow := RowCount - 1;
    ToRow := CalcMin(ToRow, MaxVisibleRow);
    if Step < 0 then SwapLongint(FromRow, ToRow);

    Dc := GetDC(Handle);
    try
        RowPos := FVisibleRows.Locate(FromRow, Found);
        I := FVisibleRows[RowPos];
        while ((Step > 0) and (I <= ToRow)) or ((Step < 0) and (I >= ToRow)) do
        begin
            if ((Step > 0) and (I >= FromRow)) or ((Step < 0) and (I <= FromRow)) then
            begin
                DataRow := GetDataRow(I);
                if ((I < FixedRows) or (I >= TopRow)) and IsRowVisible(DataRow) then
                    InvertRow(I, (not SelectionSet) xor IsRowSelected(DataRow), Dc);
            end;

            RowPos := RowPos + Step;
            if (RowPos <= 0) or (RowPos > FVisibleRows.Count) then Break;
            I := FVisibleRows[RowPos];
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertSelectedRows(FromRow, ToRow: Longint; Select: Boolean);
var
    I: integer;
    Dc: HDC;
    Step: Integer;
begin
    if not HandleAllocated then Exit;

    Step := 1;
    if FromRow > ToRow then
    begin
        SwapLongint(FromRow, ToRow);
        Step := -1;
    end;

    if ToRow < 1 then Exit;
    if FromRow < 1 then FromRow := 1;
    if ToRow >= RowCount then ToRow := RowCount - 1;
    ToRow := CalcMin(ToRow, MaxVisibleRow);
    if Step < 0 then SwapLongint(FromRow, ToRow);

    Dc := GetDC(Handle);
    try
        I := FromRow;
        while ((Step > 0) and (I <= ToRow)) or ((Step < 0) and (I >= ToRow)) do
        begin
            if ((I < FixedRows) or (I >= TopRow)) then
                if FSelectedRows[I] then InvertRow(I, Select, Dc);
            I := I + Step;
       end
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.AddColInversion(FromCol, ToCol: Longint);
var
    I: integer;
    Dc: HDC;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);
    if ToCol < 1 then Exit;

    if FromCol < 1 then FromCol := 1;
    if ToCol >= ColCount then ToCol := ColCount - 1;

    Dc := GetDC(Handle);
    try
        for I := CalcMax(FromCol, 1) to CalcMin(ToCol, MaxVisibleCol) do
        begin
            if ((I < FixedCols) or (I >= LeftCol)) then
                if FSelectedCols[I] then InvertCol(I, ivBoth, True, Dc);
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.ChangeColInversion(FromCol, ToCol: Longint; SelectionSet: Boolean);
var
    I: integer;
    Dc: HDC;
    Step: Integer;
    ColPos: Longint;
    Found: Boolean;
begin
    Step := 1;
    if FromCol > ToCol then
    begin
        SwapLongint(FromCol, ToCol);
        Step := -1;
    end;

    if ToCol < 1 then Exit;
    if FromCol < 1 then FromCol := 1;
    if ToCol >= ColCount then ToCol := ColCount - 1;
    ToCol := CalcMin(ToCol, MaxVisibleCol);
    if Step < 0 then SwapLongint(FromCol, ToCol);

    Dc := GetDC(Handle);
    try
        ColPos := FVisibleCols.Locate(FromCol, Found);
        I := FVisibleCols[ColPos];
        while ((Step > 0) and (I <= ToCol)) or ((Step < 0) and (I >= ToCol)) do
        begin
            if ((Step > 0) and (I >= FromCol)) or ((Step < 0) and (I <= FromCol)) then
            begin
                if ((I < FixedCols) or (I >= LeftCol)) and GridCols[GetDataCol(I)].Visible then
                    InvertCol(I, ivBoth, (not SelectionSet) xor FSelectedCols[I], Dc);
            end;

            ColPos := ColPos + Step;
            if (ColPos <= 0) or (ColPos > FVisibleCols.Count) then Break;
            I := FVisibleCols[ColPos];
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.DeleteColInversion(FromCol, ToCol: Longint);
var
    I: integer;
    Dc: HDC;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);
    if ToCol < 1 then Exit;

    if FromCol < 1 then FromCol := 1;
    if ToCol >= ColCount then ToCol := ColCount - 1;

    Dc := GetDC(Handle);
    try
        for I := CalcMax(FromCol, 1) to CalcMin(ToCol, MaxVisibleCol) do
        begin
            if ((I < FixedCols) or (I >= LeftCol)) then
                if FSelectedCols[I] then InvertCol(I, ivBoth, False, Dc);
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertUnselectedCols(FromCol, ToCol: Longint; Invert: TtsInvert);
var
    I: integer;
    Dc: HDC;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);
    if ToCol < 1 then Exit;

    if FromCol < 1 then FromCol := 1;
    if ToCol >= ColCount then ToCol := ColCount - 1;

    Dc := GetDC(Handle);

    try
        for I := CalcMax(FromCol, 1) to CalcMin(ToCol, MaxVisibleCol) do
        begin
            if ((I < FixedCols) or (I >= LeftCol)) then
                if not FSelectedCols[I] then InvertCol(I, Invert, True, Dc);
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertSelectedColHeadings(FromCol, ToCol: Longint);
var
    I: integer;
    Dc: HDC;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);
    if ToCol < 1 then Exit;

    if FromCol < 1 then FromCol := 1;
    if ToCol >= ColCount then ToCol := ColCount - 1;

    Dc := GetDC(Handle);

    try
        for I := CalcMax(FromCol, 1) to CalcMin(ToCol, MaxVisibleCol) do
        begin
            if ((I < FixedCols) or (I >= LeftCol)) then
                if FSelectedCols[I] then InvertCol(I, ivHead, False, Dc);
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.InvertUnselectedRows(FromRow, ToRow: Longint);
var
    I: integer;
    Dc: HDC;
    Step: Integer;
begin
    Step := 1;
    if FromRow > ToRow then
    begin
        SwapLongint(FromRow, ToRow);
        Step := -1;
    end;

    if ToRow < 1 then Exit;
    if FromRow < 1 then FromRow := 1;
    if ToRow >= RowCount then ToRow := RowCount - 1;
    ToRow := CalcMin(ToRow, MaxVisibleRow);
    if Step < 0 then SwapLongint(FromRow, ToRow);

    Dc := GetDC(Handle);
    try
        I := FromRow;
        while ((Step > 0) and (I <= ToRow)) or ((Step < 0) and (I >= ToRow)) do
        begin
            if ((I < FixedRows) or (I >= TopRow)) then
                if (not FSelectedRows[I]) and RowVisible[DataRownr[I]] then
                    InvertRow(I, True, Dc);
            I := I + Step;
        end;
    finally
        ReleaseDC(Handle, Dc);
    end;
end;

procedure TtsBaseGrid.DeleteRangeSelection;
begin
    SetSelectChanged(stCellSelect);
    FSelectedCells := Rect(0, 0, 0, 0);
    if FGridStatus = grCellSelect then FGridStatus := grNormal;
end;

function TtsBaseGrid.RowRangeSelected(FromRow, ToRow: Longint): Boolean;
var
    I: integer;
    TempResult: Boolean;
begin
    if FromRow > ToRow then SwapLongint(FromRow, ToRow);

    TempResult := True;

    for I := FromRow to ToRow do
    begin
        if (not FSelectedRows[I]) and IsRowVisible(GetDataRow(I)) then
        begin
            TempResult := False;
            Break;
        end;
    end;

    Result := TempResult;
end;

function TtsBaseGrid.ColRangeSelected(FromCol, ToCol: Longint): Boolean;
var
    I: integer;
    TempResult: Boolean;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);

    TempResult := True;

    for I := FromCol to ToCol do
    begin
        if (not FSelectedCols[I]) and GridCols[GetDataCol(I)].Visible then
        begin
            TempResult := False;
            Break;
        end;
    end;

    Result := TempResult;
end;

function TtsBaseGrid.RowRangeUnselected(FromRow, ToRow: Longint): Boolean;
var
    I: integer;
    TempResult: Boolean;
begin
    if FromRow > ToRow then SwapLongint(FromRow, ToRow);

    TempResult := True;

    for I := FromRow to ToRow do
    begin
        if FSelectedRows[I] then
        begin
            TempResult := False;
            Break;
        end;
    end;

    Result := TempResult;
end;

function TtsBaseGrid.ColRangeUnselected(FromCol, ToCol: Longint): Boolean;
var
    I: integer;
    TempResult: Boolean;
begin
    if FromCol > ToCol then SwapLongint(FromCol, ToCol);

    TempResult := True;

    for I := FromCol to ToCol do
    begin
        if FSelectedCols[I] then
        begin
            TempResult := False;
            Break;
        end;
    end;

    Result := TempResult;
end;

procedure TtsBaseGrid.AddRangeInversion(DisplayLeft, DisplayTop,
                                        DisplayRight, DisplayBottom: Longint);
begin
    InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom, FNullRect, True, 0);
end;

procedure TtsBaseGrid.DeleteRangeInversion(DisplayLeft, DisplayTop,
                                           DisplayRight, DisplayBottom: Longint);
begin
    InvertRange(DisplayLeft, DisplayTop, DisplayRight, DisplayBottom, FNullRect, False, 0);
end;

procedure TtsBaseGrid.ModifyRangeInversion(NewLeft, NewTop,
                                           NewRight, NewBottom: Longint);
begin
    with FSelectedCells do
    begin
        InvertRange(Left, Top, Right, NewTop - 1, FNullRect, False, 0);
        InvertRange(Left, CalcMax(Top, NewTop), NewLeft - 1, CalcMin(Bottom, NewBottom), FNullRect, False, 0);
        InvertRange(NewRight + 1, CalcMax(Top, NewTop), Right, CalcMin(Bottom, NewBottom), FNullRect, False, 0);
        InvertRange(Left, NewBottom + 1, Right, Bottom, FNullRect, False, 0);

        InvertRange(NewLeft, NewTop, NewRight, Top - 1, FNullRect, True, 0);
        InvertRange(NewLeft, CalcMax(Top, NewTop), Left - 1, CalcMin(Bottom, NewBottom), FNullRect, True, 0);
        InvertRange(Right + 1, CalcMax(Top, NewTop), NewRight, CalcMin(Bottom, NewBottom), FNullRect, True, 0);
        InvertRange(NewLeft, Bottom + 1, NewRight, NewBottom, FNullRect, True, 0);
    end;
end;

procedure TtsBaseGrid.SelectRangeLargerRowsLargerCols(DisplayCol, DisplayRow: Longint);
begin
    with FSelectedCells do
    begin
        if Left < FBaseSelectedCells.Left then
        begin
            DeleteRangeInversion(Left, Top, FBaseSelectedCells.Left - 1, Bottom);
            Left := FBaseSelectedCells.Left;
        end;

        if Top < FBaseSelectedCells.Top then
        begin
            DeleteRangeInversion(Left, Top, Right, FBaseSelectedCells.Top - 1);
            Top := FBaseSelectedCells.Top;
        end;

        if DisplayCol > Right then
        begin
            AddRangeInversion(Right + 1, Top, DisplayCol, Bottom);
            Right := DisplayCol;
        end
        else if DisplayCol < Right then
        begin
            DeleteRangeInversion(DisplayCol + 1, Top, Right, Bottom);
            Right := DisplayCol;
        end;

        if DisplayRow > Bottom then
        begin
            AddRangeInversion(Left, Bottom + 1, Right, DisplayRow);
            Bottom := DisplayRow;
        end
        else if DisplayRow < Bottom then
        begin
            DeleteRangeInversion(Left, DisplayRow + 1, Right, Bottom);
            Bottom := DisplayRow;
        end
    end;
end;

procedure TtsBaseGrid.SelectRangeLargerRowsSmallerCols(DisplayCol, DisplayRow: Longint);
begin
    with FSelectedCells do
    begin
        if Right > FBaseSelectedCells.Right then
        begin
            DeleteRangeInversion(FBaseSelectedCells.Right + 1, Top, Right, Bottom);
            Right := FBaseSelectedCells.Right;
        end;

        if Top < FBaseSelectedCells.Top then
        begin
            DeleteRangeInversion(Left, Top, Right, FBaseSelectedCells.Top - 1);
            Top := FBaseSelectedCells.Top;
        end;

        if DisplayCol < Left then
        begin
            AddRangeInversion(DisplayCol, Top, Left - 1, Bottom);
            Left := DisplayCol;
        end
        else if DisplayCol > Left then
        begin
            DeleteRangeInversion(Left, Top, DisplayCol - 1, Bottom);
            Left := DisplayCol;
        end;

        if DisplayRow > Bottom then
        begin
            AddRangeInversion(Left, Bottom + 1, Right, DisplayRow);
            Bottom := DisplayRow;
        end
        else if DisplayRow < Bottom then
        begin
            DeleteRangeInversion(Left, DisplayRow + 1, Right, Bottom);
            Bottom := DisplayRow;
        end
    end;
end;

procedure TtsBaseGrid.SelectRangeSmallerRowsLargerCols(DisplayCol, DisplayRow: Longint);
begin
    with FSelectedCells do
    begin
        if Left < FBaseSelectedCells.Left then
        begin
            DeleteRangeInversion(Left, Top, FBaseSelectedCells.Left - 1, Bottom);
            Left := FBaseSelectedCells.Left;
        end;

        if Bottom > FBaseSelectedCells.Bottom then
        begin
            DeleteRangeInversion(Left, FBaseSelectedCells.Bottom + 1, Right, Bottom);
            Bottom := FBaseSelectedCells.Bottom;
        end;

        if DisplayCol > Right then
        begin
            AddRangeInversion(Right + 1, Top, DisplayCol, Bottom);
            Right := DisplayCol;
        end
        else if DisplayCol < Right then
        begin
            DeleteRangeInversion(DisplayCol + 1, Top, Right, Bottom);
            Right := DisplayCol;
        end;

        if DisplayRow < Top then
        begin
            AddRangeInversion(Left, DisplayRow, Right, Top - 1);
            Top := DisplayRow;
        end
        else if DisplayRow > Top then
        begin
            DeleteRangeInversion(Left, Top, Right, DisplayRow - 1);
            Top := DisplayRow;
        end
    end;
end;

procedure TtsBaseGrid.SelectRangeSmallerRowsSmallerCols(DisplayCol, DisplayRow: Longint);
begin
    with FSelectedCells do
    begin
        if Right > FBaseSelectedCells.Right then
        begin
            DeleteRangeInversion(FBaseSelectedCells.Right + 1, Top, Right, Bottom);
            Right := FBaseSelectedCells.Right;
        end;

        if Bottom > FBaseSelectedCells.Bottom then
        begin
            DeleteRangeInversion(Left, FBaseSelectedCells.Bottom + 1, Right, Bottom);
            Bottom := FBaseSelectedCells.Bottom;
        end;

        if DisplayCol < Left then
        begin
            AddRangeInversion(DisplayCol, Top, Left - 1, Bottom);
            Left := DisplayCol;
        end
        else if DisplayCol > Left then
        begin
            DeleteRangeInversion(Left, Top, DisplayCol - 1, Bottom);
            Left := DisplayCol;
        end;

        if DisplayRow < Top then
        begin
            AddRangeInversion(Left, DisplayRow,  Right, Top - 1);
            Top := DisplayRow;
        end
        else if DisplayRow > Top then
        begin
            DeleteRangeInversion(Left, Top, Right, DisplayRow - 1);
            Top := DisplayRow;
        end
    end;
end;

procedure TtsBaseGrid.DeleteSelectedCellsCol(DisplayCol: Longint);
begin
    if DisplayCol > FSelectedCells.Right then Exit;

    SetSelectChanged(stCellSelect);
    if FSelectedCells.Left > DisplayCol then Dec(FSelectedCells.Left);
    if FSelectedCells.Right >= DisplayCol then Dec(FSelectedCells.Right);
    if FSelectedCells.Right < FSelectedCells.Left then DeleteRangeSelection;
end;

procedure TtsBaseGrid.CheckSelectedCellsCol(DisplayCol: Longint);
var
    I: Longint;
begin
    if EqualRect(FSelectedCells, FNullRect) then Exit;

    if DisplayCol = FSelectedCells.Left then
    begin
        SetSelectChanged(stCellSelect);
        Inc(FSelectedCells.Left);
        for I := FSelectedCells.Left to FSelectedCells.Right do
        begin
            if not GridCols[I].Visible then Inc(FSelectedCells.Left);
        end;
    end
    else if DisplayCol = FSelectedCells.Right then
    begin
        SetSelectChanged(stCellSelect);
        Dec(FSelectedCells.Right);
        for I := FSelectedCells.Right downto FSelectedCells.Left do
        begin
            if not GridCols[I].Visible then Dec(FSelectedCells.Right);
        end;
    end;

    if FSelectedCells.Right < FSelectedCells.Left then DeleteRangeSelection;
end;

procedure TtsBaseGrid.DeleteSelectedCellsRow(DisplayRow: Longint);
begin
    if DisplayRow > FSelectedCells.Bottom then Exit;

    SetSelectChanged(stCellSelect);
    if FSelectedCells.Top > DisplayRow then Dec(FSelectedCells.Top);
    if FSelectedCells.Bottom >= DisplayRow then Dec(FSelectedCells.Bottom);
    if FSelectedCells.Bottom < FSelectedCells.Top then DeleteRangeSelection;
end;

procedure TtsBaseGrid.CheckSelectedCellsRow(DisplayRow: Longint);
var
    I: Longint;
begin
    if EqualRect(FSelectedCells, FNullRect) then Exit;

    if DisplayRow = FSelectedCells.Top then
    begin
        SetSelectChanged(stCellSelect);
        Inc(FSelectedCells.Top);
        for I := FSelectedCells.Top to FSelectedCells.Bottom do
        begin
            if not RowVisible[I] then Inc(FSelectedCells.Top);
        end;
    end
    else if DisplayRow = FSelectedCells.Bottom then
    begin
        SetSelectChanged(stCellSelect);
        Dec(FSelectedCells.Bottom);
        for I := FSelectedCells.Bottom downto FSelectedCells.Top do
        begin
            if not RowVisible[I] then Dec(FSelectedCells.Bottom);
        end;
    end;

    if FSelectedCells.Right < FSelectedCells.Left then DeleteRangeSelection;
end;

procedure TtsBaseGrid.ChangeCellSelection(DisplayCol, DisplayRow: Longint);
var
    OldSelectedCells: TRect;
begin
    OldSelectedCells := FSelectedCells;
    DisplayCol := CalcMax(DisplayCol, LeftMostCol(False, True));
    DisplayRow := CalcMax(DisplayRow, TopMostRow(False, True));

    if IsAppendRow(DisplayRow) then
        if not GetPrevRow(DisplayRow, False, True, DisplayRow) then Exit;

    if DisplayCol > FBaseSelectedCells.Right then
    begin
        if DisplayRow > FBaseSelectedCells.Bottom then
            SelectRangeLargerRowsLargerCols(DisplayCol, DisplayRow)
        else
            SelectRangeSmallerRowsLargerCols(DisplayCol, DisplayRow);
    end
    else
    begin
        if DisplayRow > FBaseSelectedCells.Bottom then
            SelectRangeLargerRowsSmallerCols(DisplayCol, DisplayRow)
        else
            SelectRangeSmallerRowsSmallerCols(DisplayCol, DisplayRow);
    end;

    if not EqualRect(OldSelectedCells, FSelectedCells) then
        SetSelectChanged(stCellSelect);

    SelectionsChanged(True);
end;

function TtsBaseGrid.CellSelected(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := False;
    if CheckIndex(itCol, DisplayCol, 1, Cols) and
       CheckIndex(itRow, DisplayRow, 1, Rows) then
    begin
        Result := IsCellSelected(DisplayCol, DisplayRow);
    end;
end;

function TtsBaseGrid.IsCellSelected(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := False;
    if (DisplayCol < 0) or (DisplayCol > Cols) then Exit;
    if (DisplayRow < 0) or (DisplayRow > RowCount - 1) then Exit;

    if (DisplayCol = FDrawSelectCell.X) and (DisplayRow = FDrawSelectCell.Y) then
        Result := FDrawCellSelected
    else if (DisplayCol >= 1) and (DisplayRow >= 1) then
    begin
        if FSelectedCols[DisplayCol] or IsRowSelected(GetDataRow(DisplayRow)) or
           ((FGridStatus = grCellSelect) and
            CellInGridSelection(DisplayCol, DisplayRow)) then
        begin
            Result := True;
        end;
    end
    else if (DisplayCol < 1) and (DisplayRow >= 1) then
        Result := IsRowSelected(GetDataRow(DisplayRow))
    else if (DisplayCol >= 1) and (DisplayRow < 1) then
        Result := FSelectedCols[DisplayCol];
end;

procedure TtsBaseGrid.SetSelectedRow(DisplayRow: Longint; Select: Boolean);
begin
    SelectedRows.SetSelected(DisplayRow, Select);
end;

function TtsBaseGrid.FixedColsSelected: Boolean;
begin
    Result := False;
    if (FixedCols > 1) and (FSelectedCols.First < FixedCols) then Result := True;
end;

function TtsBaseGrid.FixedRowsSelected: Boolean;
begin
    Result := False;
    if (FixedRows > 1) and (FSelectedRows.First < FixedRows) then
        Result := True;
end;

function TtsBaseGrid.CellInGridSelection(DisplayCol, DisplayRow: Longint): Boolean;
begin
    if (DisplayCol >= FSelectedCells.Left) and
       (DisplayCol <= FSelectedCells.Right) and
       (DisplayRow >= FSelectedCells.Top) and
       (DisplayRow <= FSelectedCells.Bottom) then
        Result := True
    else
        Result := False;
end;

function TtsBaseGrid.CompareRowPos(DisplayRow: Longint): Integer;
begin
    if DisplayRow < FCurDisplayRow then
        Result := -1
    else if DisplayRow = FCurDisplayRow then
        Result := 0
    else
        Result := 1;
end;

procedure TtsBaseGrid.SelectRowShiftMouseDown(DisplayRow: Longint; var Canceled: Boolean);
var
    StartRow: Longint;
    DisablePaint: Boolean;
    OldRow: Longint;
begin
    Canceled := False;
    if IsAppendRow(DisplayRow) then Exit;

    DisablePaint := SelectionColorEnabled;
    StartRow := SelectionStartRownr;
    if GetStartRowSelected then
    begin
        if DisablePaint then EnablePaint := False;
        try
            if CompareRowPos(DisplayRow) >= 0 then
            begin
                if StartRow > TopRow then
                    InvertSelectedRows(1, StartRow - 1, False);
                if (StartRow <> DisplayRow) then
                    InvertUnselectedRows(StartRow, DisplayRow);
                if (DisplayRow < MaxVisibleRow) and (DisplayRow > 0) then
                    InvertSelectedRows(DisplayRow + 1, MaxVisibleRow, False);
            end
            else
            begin
                if (StartRow < MaxVisibleRow) and (StartRow > 0) then
                    InvertSelectedRows(MaxVisibleRow, StartRow + 1, False);
                if (StartRow <> DisplayRow) then
                    InvertUnselectedRows(StartRow, DisplayRow);
                if DisplayRow > TopRow then
                    InvertSelectedRows(DisplayRow - 1, 1, False);
            end;

            DeleteAllRowSelection;
            AddRowSelection(StartRow, DisplayRow);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;

        CheckSetCurrentRow(DisplayRow);
    end
    else
    begin
        OldRow := FCurDisplayRow;
        if DisablePaint then EnablePaint := False;
        try
            InvertSelectedRows(1, MaxVisibleRow, False);
            DeleteAllRowSelection;
            if DisplayRow <> FCurDisplayRow then
                SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;

        if OldRow <> FCurDisplayRow then
        begin
            ClearCurrent(OldRow);
            DrawCurrent(FCurDisplayRow);
            CheckRowColChanged;
        end;
    end;

    if FSelectedRows.Count > 0 then FGridStatus := grRowSelect;
end;

procedure TtsBaseGrid.SelectRowCtrlMouseDown(DisplayRow: Longint);
var
    DataRow: Longint;
begin
    if IsAppendRow(DisplayRow) then Exit;

    SetSelectionStartRow(DisplayRow);
    DataRow := GetDataRow(DisplayRow);

    if (DisplayRow = FCurDisplayRow) and IsRowSelected(DataRow) and
       InRowSelectMode then Exit;

    if (RowSelectMode = rsSingle) and (DisplayRow <> FCurDisplayRow) then
        SelectRowMouseDown(DisplayRow)
    else
    begin
        InvertRow(DisplayRow, not IsRowSelected(DataRow), 0);
        ChangeRowSelection(DisplayRow, DisplayRow);

        if (FCurDisplayRow <> DisplayRow) then
        begin
            ClearCurrent(FCurDisplayRow);
            SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
            if IsRowSelected(DataRow) then DrawCurrentSelected(DisplayRow)
                                      else DrawCurrent(DisplayRow);
            CheckRowColChanged;
        end;
    end;
end;

procedure TtsBaseGrid.SelectRowShiftCtrlMouseDown(DisplayRow: Longint; var Canceled: Boolean);
var
    CompRes: Integer;
    StartRow: Longint;
    DisablePaint: Boolean;
    OldRow: Longint;
begin
    Canceled := False;
    if IsAppendRow(DisplayRow) then Exit;

    DisablePaint := SelectionColorEnabled;
    StartRow := SelectionStartRownr;
    if GetStartRowSelected then
    begin
        if DisablePaint then EnablePaint := False;
        try
            InvertUnselectedRows(StartRow, DisplayRow);
            AddRowSelection(StartRow, DisplayRow);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;

        if DisplayRow <> FCurDisplayRow then
        begin
            ClearCurrent(FCurDisplayRow);
            SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
            DrawCurrentSelected(DisplayRow);
        end
    end
    else
    begin
        OldRow := FCurDisplayRow;
        if DisablePaint then EnablePaint := False;
        try
            CompRes := CompareRowPos(DisplayRow);
            if CompRes > 0 then
                InvertSelectedRows(StartRow + 1, DisplayRow, False)
            else if CompRes < 0 then
            begin
                if StartRow = 0 then
                    InvertSelectedRows(0, DisplayRow, False)
                else
                    InvertSelectedRows(CalcMin(StartRow - 1, MaxVisibleRow),
                                       DisplayRow, False);
            end;

            DeleteRowSelection(StartRow, DisplayRow);
            if FCurDisplayRow <> DisplayRow then
                SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;

        if FCurDisplayRow <> OldRow then
        begin
            ClearCurrent(OldRow);
            DrawCurrent(FCurDisplayRow);
        end;
    end;

    SetSelectionStartRow(DisplayRow);
    CheckRowColChanged;
end;

procedure TtsBaseGrid.SelectSingleRow(DisplayRow: Longint; Invalidate: Boolean);
var
    OldRow: Longint;
    IsRowSelected: Boolean;
    DisablePaint: Boolean;
begin
    if RowCount <= 1 then Exit;
    if (DisplayRow < 1) or (DisplayRow > RowCount - 1) then DisplayRow := 1;

    OldRow := CurDisplayRow;
    IsRowSelected := FSelectedRows[DisplayRow];
    DisablePaint := SelectionColorEnabled;

    if DisablePaint then EnablePaint := False;
    try
        if not Invalidate then
        begin
            if DisplayRow > 1 then InvertSelectedRows(1, DisplayRow - 1, False);
            if DisplayRow < MaxVisibleRow then InvertSelectedRows(DisplayRow + 1, MaxVisibleRow, False);
        end;

        DeleteAllRowSelection;
        if IsRowSelected then NewRowSelection(DisplayRow, DisplayRow);
        SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
    finally
        if DisablePaint then
        begin
            EnablePaint := True;
            if not Invalidate then Update;
        end;
    end;

    if OldRow <> DisplayRow then
    begin
        if not Invalidate then ClearCurrent(OldRow)
                          else InvalidateCell(0, OldRow);
    end;

    if DisablePaint then EnablePaint := False;
    try
        if OldRow <> DisplayRow then
        begin
            if not Invalidate then
            begin
                if IsRowSelected then DrawCurrentSelected(DisplayRow)
                                 else DrawCurrent(DisplayRow);
            end
            else InvalidateCell(0, DisplayRow);
        end;

        if not IsRowSelected then
        begin
            NewRowSelection(DisplayRow, DisplayRow);            
            if not Invalidate then InvertSelectedRows(DisplayRow, DisplayRow, True)
                              else InvalidateRow(DisplayRow);
        end;
    finally
        if DisablePaint then
        begin
            EnablePaint := True;
            if not Invalidate then Update;
        end;
    end;

    FLastAddedCol := FCurDisplayCol;
    FLastAddedRow := FCurDisplayRow;
    CheckRowColChanged;
end;

procedure TtsBaseGrid.CheckRowSelection(Invalidate: Boolean);
begin
    if InRowSelectMode then
    begin
        if (GridStatus = grNormal) or
           ((GridStatus = grRowSelect) and not RowSelected[FCurDisplayRow]) then
            SelectSingleRow(FCurDisplayRow, Invalidate);
    end;
end;

procedure TtsBaseGrid.SetNewSelectedRow(DisplayRow: Longint);
var
    OldRow: Longint;
    DisablePaint: Boolean;
begin
    DisablePaint := SelectionColorEnabled;
    if FGridStatus = grCellSelect then
    begin
        if FCurDisplayRow <> DisplayRow then
        begin
            ClearCurrent(FCurDisplayRow);
            SetCurrentPositionAndDraw(FCurDisplayCol, DisplayRow, True, True);
        end;

        if DisablePaint then EnablePaint := False;
        try
            InvertCell(0, DisplayRow, FNullRect, True, 0);
            InvertNew(1, DisplayRow, MaxVisibleCol, DisplayRow);
            DeleteRangeSelection;
            SelectionsChanged(True);
            NewRowSelection(DisplayRow, DisplayRow);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;
    end
    else
    begin
        OldRow := FCurDisplayRow;
        if DisablePaint then EnablePaint := False;
        try
            InvertSelectedRows(1, TopRow + VisibleRowCount, False);
            DeleteAllRowSelection;
            NewRowSelection(DisplayRow, DisplayRow);
            if FCurDisplayRow <> DisplayRow then
                SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
        finally
            if DisablePaint then
            begin
                EnablePaint := True;
                Update;
            end;
        end;

        if FCurDisplayRow <> OldRow then
            ClearCurrent(OldRow);

        if DisablePaint then EnablePaint := False;
        try
            if FCurDisplayRow <> OldRow then
                DrawCurrent(FCurDisplayRow);
            InvertRow(DisplayRow, True, 0);
        finally
            if DisablePaint then
            begin
                EnablePaint := True;
                Update;
            end;
        end;
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.SelectRowMouseDown(DisplayRow: Longint);
var
    DataRow: Longint;
    Selected: Boolean;
    MaxRow: Longint;
begin
    SetSelectionStartRow(DisplayRow);
    DataRow := GetDataRow(DisplayRow);
    Selected := IsRowSelected(DataRow);

    if IsAppendRow(DisplayRow) then
    begin
        SelectNone(FCurDisplayCol, DisplayRow, -1, tsDefault)
    end
    else if Selected and (DisplayRow = FCurDisplayRow) then
    begin
        MaxRow := TopRow + VisibleRowCount + 1;
        if DisplayRow > 1 then InvertSelectedRows(1, DisplayRow - 1, False);
        if DisplayRow < MaxRow then InvertSelectedRows(DisplayRow + 1, MaxRow, False);
        NewRowSelection(DisplayRow, DisplayRow);
    end
    else if Selected then
        SelectSingleRow(DisplayRow, False)
    else
        SetNewSelectedRow(DisplayRow);
end;

procedure TtsBaseGrid.SelectColShiftMouseDown(DisplayCol: Longint);
var
    DisablePaint: Boolean;
begin
    DisablePaint := SelectionColorEnabled;
    if DisablePaint then EnablePaint := False;
    try
        if FSelectedCols[FCurDisplayCol] then
        begin
            if FCurDisplayCol <= DisplayCol then
            begin
                if FCurDisplayCol > LeftCol then
                    DeleteColInversion(1, FCurDisplayCol - 1);
                if DisplayCol < MaxVisibleCol then
                    DeleteColInversion(DisplayCol + 1, MaxVisibleCol);
            end
            else if FCurDisplayCol > DisplayCol then
            begin
                if DisplayCol > LeftCol then
                    DeleteColInversion(1, DisplayCol - 1);
                if FCurDisplayCol < MaxVisibleCol then
                    DeleteColInversion(FCurDisplayCol + 1, MaxVisibleCol);
            end;

            if (not ColRangeSelected(FCurDisplayCol, DisplayCol)) and (FCurDisplayCol <> DisplayCol) then
                InvertUnselectedCols(FCurDisplayCol, DisplayCol, ivBoth);

            DeleteAllColSelection;
            AddColSelection(FCurDisplayCol, DisplayCol);
        end
        else
        begin
            DeleteColInversion(1, MaxVisibleCol);
            DeleteAllColSelection;
            if DisplayCol <> FCurDisplayCol then
                SetCurrentPosition(DisplayCol, FCurDisplayRow, True, True);
        end;
    finally
        if DisablePaint then begin EnablePaint := True; Update; end;
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.SelectColCtrlMouseDown(DisplayCol: Longint);
begin
    InvertCol(DisplayCol, ivBoth, not FSelectedCols[DisplayCol], 0);
    ChangeColSelection(DisplayCol, DisplayCol);
    if DisplayCol <> FCurDisplayCol then
        SetCurrentPosition(DisplayCol, FCurDisplayRow, True, True);
    CheckRowColChanged;
end;

procedure TtsBaseGrid.SelectColShiftCtrlMouseDown(Column: Longint);
var
    DisablePaint: Boolean;
begin
    DisablePaint := SelectionColorEnabled;
    if DisablePaint then EnablePaint := False;
    try
        if FSelectedCols[FCurDisplayCol] then
        begin
            if not ColRangeSelected(FCurDisplayCol, Column) then
            begin
                InvertUnselectedCols(FCurDisplayCol, Column, ivBoth);
                AddColSelection(FCurDisplayCol, Column);
                SetCurrentPosition(Column, FCurDisplayRow, True, True);
            end
            else if Column <> FCurDisplayCol then
                SetCurrentPosition(Column, FCurDisplayRow, True, True);
        end
        else
        begin
            if not ColRangeUnselected(FCurDisplayCol, Column) then
            begin
                if Column > FCurDisplayCol then
                    DeleteColInversion(FCurDisplayCol + 1, Column)
                else if Column < FCurDisplayCol then
                    DeleteColInversion(CalcMin(FCurDisplayCol - 1, MaxVisibleCol), Column);

                DeleteColSelection(FCurDisplayCol, Column);
            end;

            if FCurDisplayCol <> Column then
                SetCurrentPosition(Column, FCurDisplayRow, True, True);
        end;
    finally
        if DisablePaint then begin EnablePaint := True; Update; end;
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.SelectColMouseDown(Column: Longint);
var
    DisablePaint: Boolean;
begin
    DisablePaint := SelectionColorEnabled;
    if FSelectedCols[Column] then
    begin
        if DisablePaint then EnablePaint := False;
        try
            if Column > 1 then DeleteColInversion(1, Column - 1);
            if Column < MaxVisibleCol then DeleteColInversion(Column + 1, MaxVisibleCol);

            DeleteAllColSelection;
            NewColSelection(Column, Column);
            SetCurrentPosition(Column, FCurDisplayRow, True, True);
        finally
            if DisablePaint then begin EnablePaint := True; Update; end;
        end;
    end
    else
    begin
        if FGridStatus = grCellSelect then
        begin
            if DisablePaint then EnablePaint := False;
            try
                InvertCell(Column, 0, FNullRect, True, 0);
                InvertNew(Column, 1, Column, MaxVisibleRow);
                DeleteRangeSelection;
                SelectionsChanged(True);
                NewColSelection(Column, Column);
                SetCurrentPosition(Column, FCurDisplayRow, True, True);
            finally
                if DisablePaint then begin EnablePaint := True; Update; end;
            end;
        end
        else
        begin
            if DisablePaint then EnablePaint := False;
            try
                DeleteColInversion(1, LeftCol + VisibleColCount);
                DeleteAllColSelection;
                SetCurrentPosition(Column, FCurDisplayRow, True, True);
            finally
                if DisablePaint then begin EnablePaint := True; Update; end;
            end;

            NewColSelection(Column, Column);
            InvertCol(Column, ivBoth, True, 0);
        end;
    end;

    CheckRowColChanged;
end;

procedure TtsBaseGrid.DrawRowMove;
var
    Rect, InvertRect: TRect;
    Dc : HDC;
begin
    if (FMovePos < TopRow) or (FMovePos > MaxVisibleRow) then Exit;
    if RowRangeSelected(FMoveIndex, FMovePos) then Exit;

    Rect := CellRect(LeftCol, FMovePos);

    if FMovePos <= FMoveIndex then
    begin
        InvertRect.Left := 0;
        InvertRect.Top := Rect.Top;
        if LeftCol + VisibleColCount >= ColCount then
        begin
            Rect := CellRect(ColCount - 1, FMovePos);
            InvertRect.Right := Rect.Right;
        end
        else
        begin
            InvertRect.Right := ClientWidth;
        end;
        InvertRect.Bottom := InvertRect.Top + 1;
    end
    else
    begin
        InvertRect.Left := 0;
        InvertRect.Top := Rect.Top + RowHeights[FMovePos];
        if LeftCol + VisibleColCount >= ColCount then
        begin
            Rect := CellRect(ColCount - 1, FMovePos);
            InvertRect.Right := Rect.Right;
        end
        else
        begin
            InvertRect.Right := ClientWidth;
        end;
        InvertRect.Bottom := InvertRect.Top + 1;
    end;

    if InvertRect.Bottom <= ClientHeight then
    begin
        Dc := GetDC(Handle);
        try
            PatBlt(Dc, InvertRect.Left, InvertRect.Top, InvertRect.Right - InvertRect.Left,
                   InvertRect.Bottom - InvertRect.Top + 1, cmDstInvert);
        finally
            ReleaseDC(Handle, Dc);
        end;

        FRowMoveVisible := not FRowMoveVisible;
    end;
end;

procedure TtsBaseGrid.StartRowMoving(DisplayRow: Longint);
var
    Cur: HCursor;
begin
    FRowMoveDrawnOutsideGrid := False;
    Cur := Screen.Cursors[crDrag];
    SetCursor(Cur);

    Update;

    SetMouseStatus(msRowMove);
    FMoveIndex := DisplayRow;
    FMovePos := FMoveIndex;

    FRowMoveVisible := False;
    DrawRowMove;
end;

procedure TtsBaseGrid.DrawColMove;
var
    Rect, InvertRect: TRect;
    Dc: HDC;
begin
    if (FMovePos < LeftCol) or (FMovePos > MaxVisibleCol) then Exit;
    if ColRangeSelected(FMoveIndex, FMovePos) then Exit;

    Rect := CellRect(FMovePos, TopRow);

    if FMovePos <= FMoveIndex then
    begin
        InvertRect.Left := Rect.Left;
        InvertRect.Top := 0;
        InvertRect.Right := InvertRect.Left + 2;

        if TopRow + VisibleRowCount >= RowCount then
        begin
            Rect := CellRect(FMovePos, RowCount - 1);
            InvertRect.Bottom := Rect.Bottom;
        end
        else
        begin
            InvertRect.Bottom := ClientHeight;
        end;
    end
    else
    begin
        InvertRect.Left := Rect.Left + ColWidths[FMovePos];
        InvertRect.Top := 0;
        InvertRect.Right := InvertRect.Left + 2;

        if TopRow + VisibleRowCount >= RowCount then
        begin
            Rect := CellRect(FMovePos, RowCount - 1);
            InvertRect.Bottom := Rect.Bottom;
        end
        else
        begin
            InvertRect.Bottom := ClientHeight;
        end;
    end;

    if InvertRect.Right <= ClientWidth then
    begin
        Dc := GetDC(Handle);
        try
            PatBlt(Dc, InvertRect.Left, InvertRect.Top, InvertRect.Right - InvertRect.Left,
                   InvertRect.Bottom - InvertRect.Top + 1, cmDstInvert);
        finally
            ReleaseDC(Handle, Dc);
        end;

        FColMoveVisible := not FColMoveVisible;
    end;
end;

procedure TtsBaseGrid.StartColMoving(Column: Longint);
var
    Cur: HCursor;
begin
    FColMoveDrawnOutsideGrid := False;
    Cur := Screen.Cursors[crDrag];
    SetCursor(Cur);

    Update;

    SetMouseStatus(msColMove);
    FMoveIndex := Column;
    FMovePos := FMoveIndex;

    FColMoveVisible := False;
    DrawColMove;
end;

procedure TtsBaseGrid.MouseSelectRows(Shift: TShiftState; DisplayRow: Longint; var Canceled: Boolean);
begin
    Canceled := False;
    if (((ssLeft in Shift) and ([ssShift, ssCtrl] * Shift = []) and FSelectedRows[DisplayRow]) or (RowSelectMode = rsNone)) and
       (not FixedRowsSelected) and RowMoving and
       (not IsInsertRow(DisplayRow)) then
    begin
        if CheckHideControl(True) then Update;
        ClearCurrentFocusRect(True);
        StartRowMoving(DisplayRow);
        Exit;
    end;

    if not (RowSelectMode in [rsSingle, rsMulti]) then Exit;
    if CheckHideControl(True) then Update;

    if not IsAppendRow(DisplayRow) then SetMouseStatus(msRowSelect);
    DeleteSelections([grColSelect], True);
    ClearCurrentFocusRect(True);
    SelectionsChanged(True);

    if (GridStatus = grRowSelect) and (RowSelectMode <> rsSingle) then
    begin
        if [ssLeft, ssShift, ssCtrl] - Shift = [] then
            SelectRowShiftCtrlMouseDown(DisplayRow, Canceled)
        else if [ssLeft, ssShift] - Shift = [] then
            SelectRowShiftMouseDown(DisplayRow, Canceled)
        else if [ssLeft, ssCtrl] - Shift = [] then
            SelectRowCtrlMouseDown(DisplayRow)
        else if [ssLeft] - Shift = [] then
            SelectRowMouseDown(DisplayRow);
    end
    else if (not InRowSelectMode) and ([ssLeft, ssCtrl] - Shift = []) then
        SelectRowCtrlMouseDown(DisplayRow)
    else if ([ssLeft] - Shift = []) then
        SelectRowMouseDown(DisplayRow);

    DrawCurrentFocusRect(True);
end;

procedure TtsBaseGrid.MouseSelectCols(Shift: TShiftState; DisplayCol: Longint);
begin
    if (((ssLeft in Shift) and ([ssShift, ssCtrl] * Shift = []) and FSelectedCols[DisplayCol]) or (ColSelectMode = csNone)) and
       FColMoving and (not FixedColsSelected) then
    begin
        if CheckHideControl(True) then Update;
        ClearCurrentFocusRect(True);
        StartColMoving(DisplayCol);
        Exit;
    end;

    if FColSelectMode = csNone then Exit;
    if CheckHideControl(True) then Update;

    SetMouseStatus(msColSelect);
    DeleteSelections([grRowSelect], True);
    ClearCurrentFocusRect(True);
    SelectionsChanged(True);

    if (FSelectedCols.Count > 0) then
    begin
        if [ssLeft, ssShift, ssCtrl] - Shift = [] then
            SelectColShiftCtrlMouseDown(DisplayCol)
        else if [ssLeft, ssShift] - Shift = [] then
            SelectColShiftMouseDown(DisplayCol)
        else if [ssLeft, ssCtrl] - Shift = [] then
            SelectColCtrlMouseDown(DisplayCol)
        else if [ssLeft] - Shift = [] then
            SelectColMouseDown(DisplayCol);
    end
    else if ([ssLeft] - Shift = []) then
        SelectColMouseDown(DisplayCol);

    DrawCurrentFocusRect(True);
end;

procedure TtsBaseGrid.AdjustSelection(SelectType: TtsSelectType);
begin
    if FGridStatus = grRowSelect then
    begin
        InvertUnselectedRows(1, MaxVisibleRow);
        if SelectType <> stRowSelect then DeleteAllRowSelection;
    end
    else if FGridStatus = grColSelect then
    begin
        InvertSelectedColHeadings(1, MaxVisibleCol);
        InvertUnselectedCols(1, MaxVisibleCol, ivData);
        InvertLabel(True);
        if SelectType <> stColSelect then DeleteAllColSelection;
    end
    else if FGridStatus = grCellSelect then
    begin
        InvertNew(1, 1, MaxVisibleCol, MaxVisibleRow);
        InvertLabel(True);
        if SelectType <> stCellSelect then DeleteRangeSelection;
    end;
end;

procedure TtsBaseGrid.DeleteSelections(Status: TtsGridStats; DoUpdate: Boolean);
var
    DisablePaint: Boolean;
begin
    if (Status <> []) and not (FGridStatus in Status) then Exit;

    if FGridStatus <> grNormal then
    begin
        DisablePaint := SelectionColorEnabled;
        if DisablePaint then EnablePaint := False;
        try
            if (FGridStatus = grRowSelect) then
            begin
                InvertSelectedRows(1, TopRow + VisibleRowCount, False);
                DeleteAllRowSelection;
            end
            else if FGridStatus = grColSelect then
            begin
                DeleteColInversion(1, LeftCol + VisibleColCount);
                DeleteAllColSelection;
            end
            else if FGridStatus = grCellSelect then
            begin
                InvertRange(FSelectedCells.Left, FSelectedCells.Top,
                            FSelectedCells.Right, FSelectedCells.Bottom, FNullRect, False, 0);
                DeleteRangeSelection;
            end;
        finally
            if DisablePaint then
            begin
                EnablePaint := True;
                if DoUpdate then Update;
            end;
        end;

        FGridStatus := grNormal;
    end;
end;

procedure TtsBaseGrid.SelectNone(var DisplayCol: Longint; DisplayRow, MouseCol: Longint; SelectMode: TtsTextSelectMode);
var
    OldCurrentRow: Longint;
begin
    OldCurrentRow := FCurDisplayRow;
    try
        ClearCurrentFocusRect(False);
        SetCurrentPosition(DisplayCol, DisplayRow, True, True);
        if SelectMode <> tsDefault then SetControlSelectMode(SelectMode);
        DeleteSelections([], True);
        DrawCurrent(DisplayRow);

        if (MouseCol <> -1) and (MouseCol <> DisplayCol) then
        begin
            if (not CellIsReadOnly(GetDataCol(MouseCol), GetDataRow(DisplayRow))) or
               (not GridCols[GetDataCol(MouseCol)].ReadOnly) then
            begin
                DisplayCol := MouseCol;
                SetCurrentPosition(DisplayCol, DisplayRow, True, True);
            end;
        end;
    finally
        if OldCurrentRow <> FCurDisplayRow then
        begin
            ClearCurrent(OldCurrentRow);
        end;
        CheckRowColChanged;
    end;
end;

procedure TtsBaseGrid.DeleteInversionAtNewRange(DisplayCol, DisplayRow: Longint);
begin
    if CellInGridSelection(DisplayCol, DisplayRow) then
    begin
        if FSelectedCells.Left < DisplayCol then
        begin
            with FSelectedCells do
                InvertRange(CalcMax(Left, 1), CalcMax(Top, 1),
                            DisplayCol - 1, CalcMin(Bottom, MaxVisibleRow), FNullRect, False, 0);
        end;

        if FSelectedCells.Top < DisplayRow then
        begin
            with FSelectedCells do
                InvertRange(DisplayCol, CalcMax(Top, 1), DisplayCol,
                            DisplayRow - 1, FNullRect, False, 0);
        end;

        if FSelectedCells.Bottom > DisplayRow then
        begin
            with FSelectedCells do
                InvertRange(DisplayCol, DisplayRow + 1, DisplayCol,
                            CalcMin(Bottom, MaxVisibleRow), FNullRect, False, 0);
        end;

        if FSelectedCells.Right > DisplayCol then
        begin
            with FSelectedCells do
                InvertRange(DisplayCol + 1, CalcMax(Top, 1), CalcMin(Right, MaxVisibleCol),
                            CalcMin(Bottom, MaxVisibleRow), FNullRect, False, 0);
        end;
    end
    else
    begin
        with FSelectedCells do
            InvertRange(CalcMax(Left, 1), CalcMax(Top, 1),
                        CalcMin(Right, MaxVisibleCol),
                        CalcMin(Bottom, MaxVisibleRow), FNullRect, False, 0);
    end;
end;

procedure TtsBaseGrid.StartCellSelection(DisplayCol, DisplayRow: Longint);
var
    ARect: TRect;
begin
    if FGridStatus = grCellSelect then
    begin
        if FCurDisplayRow <> DisplayRow then
        begin
            ClearCurrent(FCurDisplayRow);
            SetCurrentPositionAndDraw(DisplayCol, DisplayRow, True, True);
        end
        else
            SetCurrentPosition(DisplayCol, DisplayRow, True, True);

        DeleteInversionAtNewRange(DisplayCol, DisplayRow);
    end
    else
    begin
        HideGridControl(True);
        SelectNone(DisplayCol, DisplayRow, -1, tsDefault);
    end;

    FGridStatus := grCellSelect;
    ARect := Rect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);
    FSelectedCells := ARect;
    FBaseSelectedCells := ARect;
    InvalidateCell(DisplayCol, DisplayRow);

    CheckRowColChanged;
    SetSelectChanged(stCellSelect);
    SelectionsChanged(True);
end;

function TtsBaseGrid.RowBarSizingArea: TRect;
var
    Range, Back: Integer;
begin
    Result.Top := 0;
    Result.Bottom := RowHeights[0];
    Range := ResizeRange;
    Back := ResizeRange div 2;
    Result.Left := ColWidths[0] - Back;
    Result.Right := ColWidths[0] - Back + Range;
end;

function TtsBaseGrid.HeadingSizingArea: TRect;
var
    Range, Back: Integer;
begin
    Result.Left := 0;
    Result.Right := ColWidths[0];
    Range := ResizeRange;
    Back := ResizeRange div 2;
    Result.Top := RowHeights[0] - Back;
    Result.Bottom := RowHeights[0] - Back + Range;
end;

function TtsBaseGrid.MDSizing(X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
var
    Status: TtsMouseStatus;
begin
    Result := False;
    Status := GetSizingState(X, Y, DisplayCol, DisplayRow);
    if Status in [msColResize, msRowBarResize, msRowResize, msHeadingResize] then
    begin
        SetMouseStatus(Status);
        Result := True;
    end;
end;


procedure TtsBaseGrid.MDRangeSelecting(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    EvalRect: TRect;
begin
    if not CanSelect(DisplayCol, DisplayRow) then Exit;
    if not CheckEndEdit(-1, -1, True) then Exit;

    if IsAppendRow(DisplayRow) then
    begin
        MDSelectNone(Shift, X, Y, DisplayCol, DisplayRow);
        Exit;
    end;

    SetMouseStatus(msCellSelect);

    if (FGridStatus = grCellSelect) and
       (([ssLeft, ssShift] - Shift = []) or ([ssLeft, ssShift, ssCtrl] - Shift = [])) then
    begin
        ChangeCellSelection(DisplayCol, DisplayRow);
    end
    else
    begin
        EvalRect := Rect(DisplayCol, DisplayRow, DisplayCol, DisplayRow);

        if not ((FGridStatus = grCellSelect) and
                (EqualRect(FSelectedCells, FBaseSelectedCells)) and
                (EqualRect(FSelectedCells, EvalRect))) then
        begin
            StartCellSelection(DisplayCol, DisplayRow);
        end;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.MDRowSelect(Shift: TShiftState; X, Y: Integer;
                                  DisplayCol, DisplayRow: Longint);
var
    Canceled: Boolean;
begin
    if not CanSelect(-1, DisplayRow) then Exit;
    if not CanMoveToPos(DisplayCol, DisplayRow) then Exit;

    if RowSelectMode in [rsSingle, rsMulti] then
    begin
        if (FCurDisplayRow <> DisplayRow) or
           not IsRowSelected(GetDataRow(FCurDisplayRow)) then
        begin
            if not CheckEndEdit(-1, -1, True) then Exit;
        end;

        RowFromY(Y, DisplayRow);
        if DisplayRow > 0 then
        begin
            MouseSelectRows(Shift, DisplayRow, Canceled);
            FLastAddedCol := DisplayCol;
            if not Canceled then SetLastAddedRow(DisplayRow);
        end;
    end
    else if (FCurDisplayRow <> DisplayRow) then
    begin
        if not CheckEndEdit(-1, -1, True) then Exit;
        RowFromY(Y, DisplayRow);
        if DisplayRow > 0 then
        begin
            if CheckHideControl(True) then Update;
            InvalidateCell(FCurDisplayCol, FCurDisplayRow);
            ClearCurrentFocusRect(False);
            ClearCurrent(FCurDisplayRow);
            SetCurrentPositionAndDraw(FCurDisplayCol, DisplayRow, True, True);

            if RowMoving and (not IsInsertRow(DisplayRow)) then
            begin
                Update;
                MouseSelectRows(Shift, DisplayRow, Canceled);
            end
            else
            begin
                SetControlSelectMode(tsAll);
                ShowGridControl;
                DrawCurrentFocusRect(True);
            end;
            FLastAddedCol := FCurDisplayCol;
            SetLastAddedRow(DisplayRow);
        end;
    end
    else if RowMoving and (not IsInsertRow(DisplayRow)) then
    begin
        MouseSelectRows(Shift, DisplayRow, Canceled);
        FLastAddedCol := DisplayCol;
        if not Canceled then SetLastAddedRow(DisplayRow);
    end;

    CheckRowColChanged;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.MDColSelect(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
begin
    if not CanSelect(DisplayCol, -1) then Exit;

    if (FColSelectMode <> csNone) or FColMoving then
    begin
        if not CheckEndEdit(-1, -1, True) then Exit;
        MouseSelectCols(Shift, DisplayCol);
    end
    else
        MDSelectNone(Shift, X, Y, DisplayCol, FCurDisplayRow);

    FLastAddedCol := DisplayCol;
    FLastAddedRow := DisplayRow;
    SelectionsChanged(True);
end;

function TtsBaseGrid.CanSelect(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := True;
    if DisplayCol > 0 then
    begin
        if (DisplayCol <= FInternalFixedCols) and
           (not FSelectFixed) then Result := False;
    end;
    if DisplayRow > 0 then
    begin
        if (DisplayRow <= FInternalFixedRows) and
           (not FSelectFixed) then Result := False;
    end;
end;

procedure TtsBaseGrid.MDSelectNone(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    Ok, Hidden: Boolean;
    MouseCol: Longint;
    SelectMode: TtsTextSelectMode;
    DataCol, DataRow: Longint;
    ReadOnlyCell: Boolean;
    CanEnableControl: Boolean;
    Button: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
begin
    if not CanMoveToPos(DisplayCol, DisplayRow) then Exit;

    DataCol := GetDataCol(DisplayCol);
    DataRow := GetDataRow(DisplayRow);

    try
        if (GridMode <> gmListBox) then
        begin
            ReadOnlyCell := CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
            if (not CanSelect(-1, DisplayRow)) and ReadOnlyCell then Exit;

            if not CheckEndEdit(DataCol, DataRow, True) then Exit;
            RowFromY(Y, DisplayRow);
            if DisplayRow <= 0 then DisplayRow := FCurDisplayRow;

            SelectMode := tsNone;
            if not (ssLeft in Shift) then SelectMode := tsAll;
            MouseCol := DisplayCol;
            if GridCols[GetDataCol(DisplayCol)].ReadOnly and
               ReadOnlyCell and CanSkipReadOnly then
            begin
                if (DisplayRow <> FCurDisplayRow) then SelectMode := tsAll;
                DisplayCol := FCurDisplayCol;
            end;

            Hidden := False;
            CanEnableControl := False;
            Button := GiveCellButton(DataCol, DataRow, DropDownStyle);

            if (FGridStatus <> grNormal) or
               (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow) then
            begin
                Hidden := CheckHideControl(True) or
                          DisplayFocusRect(FCurDisplayCol, FCurDisplayRow, True);
            end
            else if not FControlEnabled then
            begin
                CanEnableControl := (MouseCol = DisplayCol) and (ssLeft in Shift);
                if CanEnableControl then
                begin
                    if (Button in [btCombo, btDateTimeDropDown, btDateTimePopup]) and
                       (DropDownStyle = ddDropDownList) then
                        CanEnableControl := False;
                end;
            end;

            try
                if (FGridStatus <> grNormal) and (MouseCol <> DisplayCol) then
                    SelectMode := tsAll;
                SetControlSelectMode(SelectMode);
                SelectNone(DisplayCol, DisplayRow, MouseCol, SelectMode);

                if not GridControlActive then
                begin
                    CanEnableControl := False;
                    SelectMode := tsAll;
                end
                else if not FControlEnabled and not CanEnableControl then
                    SelectMode := tsAll
                else if (Button in [btCombo, btDateTimeDropDown, btDateTimePopup]) and (DropDownStyle = ddDropDownList) then
                    SelectMode := tsAll
                else if (DisplayCol = MouseCol) and (ssLeft in Shift) then
                    SelectMode := tsNone;

                SetControlSelectMode(SelectMode);
                if Hidden then Update;
            finally
                Ok := True;
                if CanEnableControl then
                begin
                    if CurCellControlType = ctCheck then
                    begin
                        Ok := StartEdit;
                        if Ok then Ok := StartCellChange(FCurDataCol, True);
                    end;
                    if Ok then InternalShowEditor(tsNone, False);
                end;

                if (not FControlSet) or Hidden then ShowGridControl;
                DrawCurrentFocusRect(False);
            end;

            if (DisplayCol = MouseCol) and (ssLeft in Shift) and
               DrawButtonDown(X, Y, DisplayCol, DisplayRow) then
                MDButtonDown(Shift, X, Y, DisplayCol, DisplayRow)
            else if (ssLeft in Shift) then
            begin
                FMouseDownMessage.XPos := X;
                FMouseDownMessage.YPos := Y;
                FMouseDownToControl := (MouseCol = DisplayCol) and Ok;
                Update;

                if (not FGridControl.Visible) then FMouseDownToControl := False;
            end;
        end
        else if (RowSelectMode = rsNone) then
        begin
            if not CanSelect(-1, DisplayRow) then Exit;
            if not CheckEndEdit(DataCol, DataRow, True) then Exit;
            RowFromY(Y, DisplayRow);
            SelectNone(DisplayCol, DisplayRow, -1, tsDefault);
            DrawCurrentFocusRect(False);
        end
        else if ssLeft in Shift then
            MDRowSelect(Shift, X, Y, DisplayCol, DisplayRow)
        else
        begin
            if not CanSelect(-1, DisplayRow) then Exit;
            SelectNone(DisplayCol, DisplayRow, -1, tsDefault);
            CheckRowSelection(False);
            DrawCurrentFocusRect(True);
        end;
    finally
        CheckRowColChanged;
        SelectionsChanged(True);
    end;
end;

function TtsBaseGrid.DblClickSelectNone(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := False;
    if (not FControlEnabled) and CanSetControl and
       (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then
    begin
        Result := True;
        MDSelectNone(Shift, X, Y, DisplayCol, DisplayRow);
    end;
end;

procedure TtsBaseGrid.MDSelectAll(WithMouse: Boolean);
begin
    if RowSelectMode in [rsNone, rsSingle] then Exit;
    if not CheckEndEdit(-1, -1, True) then Exit;

    if CheckHideControl(True) then Update;
    if WithMouse then SetMouseStatus(msAllRowSelect);
    try
        DoRowSelection(1, Rows, (not WithMouse) or (FSelectedRows.Count <> FVisibleRows.Count - InsertionRow), True);
    finally
        if WithMouse then SetMouseStatus(msNormal);
    end;
end;

procedure TtsBaseGrid.SelectAll;
begin
    MDSelectAll(False);
end;

procedure TtsBaseGrid.MDButtonDown(Shift: TShiftState; X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    ARect: TRect;
    SelectMode: TtsTextSelectMode;
    DC: Hdc;
    DoButton: Boolean;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
    ReadOnlyCell: Boolean;
    Hidden: Boolean;
    SpinButton: TtsSpinButton;
begin
    if not CanMoveToPos(DisplayCol, DisplayRow) then Exit;

    if (GridMode <> gmListBox) then
    begin
        ReadOnlyCell := CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
        if (not CanSelect(-1, DisplayRow)) and ReadOnlyCell then Exit;

        if not CheckEndEdit(GetDataCol(DisplayCol), GetDataRow(DisplayRow), True) then
            Exit;

        DoButton := True;
        RowFromY(Y, DisplayRow);
        if DisplayRow < 0 then
        begin
            DoButton := False;
            DisplayRow := FCurDisplayRow;
        end;

        SelectMode := tsAll;
        if (GridCols[GetDataCol(DisplayCol)].ReadOnly) and ReadOnlyCell then
            DisplayCol := FCurDisplayCol;

        Hidden := False;
        if ((FGridStatus <> grNormal) or
            (DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow)) then
        begin
            Hidden := CheckHideControl(True) or
                      DisplayFocusRect(FCurDisplayCol, FCurDisplayRow, True);
        end;

        if IsCellSelected(DisplayCol, DisplayRow) then
        begin
            ARect := CellRect(DisplayCol, DisplayRow);
            ARect.Left := CalcMax(ARect.Left + tsRangeSelectWidth,
                                  ARect.Right - FGridButton.FullWidth);
            ARect.Bottom := CalcMin(ARect.Bottom, ARect.Top + FGridButton.FullHeight);

            DC := GetDC(Handle);
            try
                PatBlt(DC, ARect.Left, ARect.Top, ARect.Right - ARect.Left,
                       ARect.Bottom - ARect.Top, cmDstInvert);
            finally
                ReleaseDC(Handle, DC);
            end;
        end;

        SelectNone(DisplayCol, DisplayRow, -1, tsDefault);
        if Hidden then UpdateGrid(True);

        SetControlSelectMode(SelectMode);
        if (not FControlSet) or Hidden then ShowGridControl;
        DrawCurrentFocusRect(False);

        FMouseDownToControl := False;
        FButtonClicked := False;
        FSpinButtonClicked := spbNone;
        FUseSpinStartDelay := True;
        FSpinRepeatCount := 0;

        if DoButton and (DisplayCol = CurDisplayCol) and (DisplayRow = CurDisplayRow) then
        begin
            SetMouseStatus(msButtonDown);

            if MouseOverButton(X, Y, DisplayCol, DisplayRow) then
            begin
                SpinButton := GetSpinButtonXY(X, Y, DisplayCol, DisplayRow);
                DoDrawButton(DisplayCol, DisplayRow, [SpinButton], SpinButton, clBtnFace, bmDown);
                FButtonDown.X := DisplayCol;
                FButtonDown.Y := DisplayRow;
                FDownSpinButton := SpinButton;
                FButtonClicked := True;
                FSpinButtonClicked := SpinButton;
            end;

            ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
            if (ButtonType = btCombo) and
               (CanDropDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow), [btCombo])) then
                ComboButtonDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow))
            else if ButtonType in [btDateTimeDropDown, btDateTimePopup] then
            begin
                if ButtonType = btDateTimeDropDown then
                    DateTimeButtonDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow))
                else
                    ButtonDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
            end
            else
            begin
                CheckDropDownOff(False);
                try
                    if ButtonType = btNormal then
                        ButtonDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow))
                    else if IsSpinButton(ButtonType) then
                    begin
                        SpinButtonDown(GetDataCol(DisplayCol), GetDataRow(DisplayRow), FSpinButtonClicked);
                        Inc(FSpinRepeatCount);
                        SpinRepeat(GetDataCol(DisplayCol), GetDataRow(DisplayRow), FSpinRepeatCount, FSpinButtonClicked);
                        if spoAutoRepeat in GiveCellSpinOptions(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then
                            StartSpinTimer(FUseSpinStartDelay);

                        if not MouseCapture then
                        begin
                            ResetButtonDown;
                            CellInvalidate(DisplayCol, DisplayRow);
                        end;
                    end;
                except
                    ResetButtonDown;
                    CellInvalidate(DisplayCol, DisplayRow);
                    raise;
                end;
            end;
        end;
    end
    else if (RowSelectMode = rsNone) then
    begin
        if not CanSelect(-1, DisplayRow) then Exit;
        if not CheckEndEdit(GetDataCol(DisplayCol), GetDataRow(DisplayRow), True) then Exit;
        SelectNone(DisplayCol, DisplayRow, -1, tsDefault);
        DrawCurrentFocusRect(False);
    end
    else
        MDRowSelect(Shift, X, Y, DisplayCol, DisplayRow);

    CheckRowColChanged;
    SelectionsChanged(True);
end;

function TtsBaseGrid.InDragArea(DisplayCol, DisplayRow: Longint): Boolean;
begin
    Result := IsCellSelected(DisplayCol, DisplayRow) and not
              (((DisplayRow = 0) and
                (FColSelectMode = csMulti) and
                (FColMoving) and
                (FSelectedCols.First >= FixedCols)) or
               ((DisplayCol = 0) and
                (RowMoving) and
                (FSelectedRows.First >= FixedRows)));
end;

procedure TtsBaseGrid.SetMouseDownColRow(DisplayCol, DisplayRow: Longint);
begin
    FDownDisplayCol := DisplayCol;
    FDownDisplayRow := DisplayRow;
end;

procedure TtsBaseGrid.SetMouseUpColRow(DisplayCol, DisplayRow: Longint);
begin
    FUpDisplayCol := DisplayCol;
    FUpDisplayRow := DisplayRow;
end;

procedure TtsBaseGrid.MouseDown(Button: TMouseButton; Shift: TShiftState;
                                X, Y: Integer);
var
    DisplayCol, DisplayRow : Longint;
    Capture: Boolean;
    CanResize: Boolean;
    RestartTimer: Boolean;
    SetDoubleClicked: Boolean;
    LostFocus: Boolean;
begin
    if (csDesigning in ComponentState) then
    begin
        CellFromXY(X, Y, DisplayCol, DisplayRow);
        if (Button = mbLeft) and MDSizing(X, Y, DisplayCol, DisplayRow) then
            MouseDownResize
        else
            inherited MouseDown(Button, Shift, X, Y);
        Exit;
    end;

    RestartTimer := False;
    FDoubleClicked := False;
    FMouseDownToControl := False;
    LostFocus := False;
    FMouseDownOccured := True;

    if (Button in [mbLeft, mbRight]) then
    begin
        FHeadingClicked := -1;
        FHeadingButtonClicked := False;
        FDrawHeadingButtonDown := False;

        if not (csDesigning in ComponentState) and CanSetFocus and
           not FGridControl.Focused and not Focused then
        begin
            SetGridFocus;
            LostFocus := not IsFocused;
        end;

        if (not LostFocus) or (not CheckMouseFocus) then
        begin
            RestartTimer := StopTimer(FButtonTimer);
            CellFromXY(X, Y, DisplayCol, DisplayRow);

            if (Button = mbRight) then
            begin
                if (GetDataCol(DisplayCol) <> FDropDownCol) or
                   (GetDataRow(DisplayRow) <> FDropDownRow) then
                begin
                    CheckDropDownOff(False);
                end;

                if (DisplayCol >= 0) and (DisplayRow >= 0) and
                   ((DisplayCol <> FCurDisplayCol) or (DisplayRow <> FCurDisplayRow)) and
                   (not IsCellSelected(DisplayCol, DisplayRow)) then
                begin
                    if (DisplayRow = 0) and (DisplayCol > 0) then
                        MDSelectNone(Shift, X, Y, DisplayCol, FCurDisplayRow)
                    else if (DisplayRow > 0) and (DisplayCol = 0) then
                        MDSelectNone(Shift, X, Y, FCurDisplayCol, DisplayRow)
                    else if (DisplayRow > 0) and (DisplayCol > 0) then
                        MDSelectNone(Shift, X, Y, DisplayCol, DisplayRow);
                end;
                {$IFNDEF TSVER_V5}
                if FProvideGridMenu then
                   ShowGridMenu(X, Y);
                {$ENDIF}
            end
            else if (Button = mbLeft) then
            begin
                CanResize := MDSizing(X, Y, DisplayCol, DisplayRow);
                SetMouseDownColRow(DisplayCol, DisplayRow);

                if (ssDouble in Shift) and
                   not DrawButtonDown(X, Y, DisplayCol, DisplayRow) and
                   not (CanClickHeading(X, Y, DisplayCol) and not CanResize) then
                begin
                    if CanResize then
                    begin
                        MouseDownResize;
                        FResizeDoubleClicked := True;
                    end;

                    SetDoubleClicked := True;
                    if FControlSet and FGridControl.Visible and
                       (DisplayCol = FCurDisplayCol) and (DisplayRow = FCurDisplayRow) then
                        FGridControl.DblClick
                    else if not FResizeDoubleClicked then
                    begin
                        DblClick;
                        DblClickCell(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
                        if DblClickSelectNone(Shift, X, Y, DisplayCol, DisplayRow) then
                            SetDoubleClicked := False;
                    end;
                    FDoubleClicked := SetDoubleClicked;
                end
                else
                begin
                    ResetButtonDown;

                    if CanResize then
                    begin
                        CheckDropDownOff(False);
                        MouseDownResize;
                    end
                    else if (DisplayCol >= 0) and (DisplayRow >=0) then
                    begin
                        if InDragArea(DisplayCol, DisplayRow) and
                           (ssLeft in Shift) and ([ssShift, ssCtrl] * Shift = []) then
                        begin
                            CheckDropDownOff(False);
                            DoCanStartDrag;
                            if Dragging then Exit;
                        end;

                        try
                            if (X >= CellRect(DisplayCol, DisplayRow).Left) and
                               (X < CellRect(DisplayCol, DisplayRow).Left + tsRangeSelectWidth) and
                               (DisplayRow >= 1 ) and (DisplayCol >= 1) and
                               (GridMode in [gmEdit, gmEditInsert, gmBrowse]) and
                               (CellSelectMode = cmRange) then
                            begin
                                CheckDropDownOff(False);
                                MDRangeSelecting(Shift, X, Y, DisplayCol, DisplayRow);
                            end
                            else if (FGridStatus = grCellSelect) and
                                    ((Shift = [ssShift]) or (Shift = [ssShift, ssCtrl])) then
                            begin
                                CheckDropDownOff(False);
                                MDRangeSelecting(Shift, X, Y, DisplayCol, DisplayRow);
                            end
                            else if (DisplayCol < 1) and (DisplayRow >= 1) then
                            begin
                                CheckDropDownOff(False);
                                MDRowSelect(Shift, X, Y, DisplayCol, DisplayRow);
                            end
                            else if (DisplayCol >= 1) and (DisplayRow < 1) then
                            begin
                                CheckDropDownOff(False);
                                if (CanClickHeading(X, Y, DisplayCol)) and
                                    ([ssCtrl, ssShift, ssAlt] * Shift = []) then
                                        FHeadingClicked := GetDataCol(DisplayCol)
                                else if not (MouseStatus = msHeadingDown) then
                                    MDColSelect(Shift, X, Y, DisplayCol, DisplayRow);
                            end
                            else if ((DisplayCol < 1) and (DisplayRow < 1)) then
                            begin
                                CheckDropDownOff(False);
                                MDSelectAll(True);
                            end
                            else if DrawButtonDown(X, Y, DisplayCol, DisplayRow) then
                            begin
                                if (GetDataCol(DisplayCol) <> FDropDownCol) or
                                   (GetDataRow(DisplayRow) <> FDropDownRow) then
                                begin
                                    CheckDropDownOff(False);
                                end;
                                MDButtonDown(Shift, X, Y, DisplayCol, DisplayRow);
                            end
                            else
                            begin
                                if (GetDataCol(DisplayCol) <> FDropDownCol) or
                                   (GetDataRow(DisplayRow) <> FDropDownRow) then
                                begin
                                    CheckDropDownOff(False);
                                end;
                                MDSelectNone(Shift, X, Y, DisplayCol, DisplayRow);
                            end;

                            CheckRowSelection(False);
                            GridStatusChanged;
                        finally
                            if not (MouseCapture or DropDownVisible or (FHeadingClicked <> -1)) then SetMouseStatus(msNormal);
                        end;
                    end
                    else
                        CheckDropDownOff(False);
                end;

                if (FHeadingClicked <> -1) and not (MouseStatus = msHeadingDown) then
                begin
                    SetMouseStatus(msHeadingDown);
                    FHeadingButtonClicked := ((FHeadingButton = hbButton) and
                                             (GridCols[FHeadingClicked].FHeadingButton = cbGrid)) or
                                             (GridCols[FHeadingClicked].FHeadingButton = cbButton);
                    FDrawHeadingButtonDown := true;
                    InvalidateCell(DisplayCol, DisplayRow);
                    try
                        DoHeadingDown(GetDataCol(DisplayCol), Button);
                    finally
                        if not MouseCapture then
                        begin
                            FDrawHeadingButtonDown := False;
                            FHeadingButtonClicked := False;
                            InvalidateCell(DisplayCol, DisplayRow);
                        end;
                    end;

                end;
            end;
        end;
    end;

    RestartTimer := RestartTimer and not MouseCapture;
    try
        if (not (Button in [mbLeft, mbRight])) or LostFocus then
            RestartTimer := StopTimer(FButtonTimer);

        if FMouseDownToControl then
        begin
            FMouseDownOccured := False;
            Capture := MouseCapture and IsFocused;
            MouseCapture := False;
            MouseMessageToControl(Capture);
        end
        else if Assigned(OnMouseDown) then
            OnMouseDown(Self, Button, Shift, X, Y);
    finally
        if RestartTimer then StartButtonTimer;
    end;
end;

procedure TtsBaseGrid.Click;
begin
    if Assigned(OnClick) then OnClick(Self);
end;

procedure TtsBaseGrid.DblClick;
begin
    if Assigned(OnDblClick) then OnDblClick(Self);
end;

function TtsBaseGrid.ClickPos(DataCol, DataRow: Longint): TtsClickPosition;
begin
    if (DataCol < 0) or (DataRow < 0) then
        Result := cpNone
    else if (DataCol = 0) and (DataRow = 0) then
        Result := cpUpperLeft
    else if (DataCol = 0) then
        Result := cpRowBar
    else if (DataRow = 0) then
        Result := cpHeading
    else
        Result := cpCell;
end;

procedure TtsBaseGrid.ClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp: Longint);
var
    UpPos, DownPos: TtsClickPosition;
begin
    UpPos := ClickPos(DataColUp, DataRowUp);
    DownPos := ClickPos(DataColDown, DataRowDown);
    if CheckClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp, DownPos, UpPos) then Exit;

    if FAsCombo then
    begin
        if not InDesignMode then
            ParentGrid.ComboClickCell(Self, DataColDown, DataRowDown, DataColUp, DataRowUp);
    end;
end;

function TtsBaseGrid.CheckClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp: Longint;
                                    DownPos, UpPos: TtsClickPosition): Boolean;
begin
    Result := DoClickCell(DataColDown, DataRowDown, DataColUp, DataRowUp, DownPos, UpPos);
end;

procedure TtsBaseGrid.ButtonClick(DataCol, DataRow: Longint);
begin
    DoButtonClick(DataCol, DataRow);
end;

procedure TtsBaseGrid.ButtonDown(DataCol, DataRow: Longint);
begin
    DoButtonDown(DataCol, DataRow);
end;

procedure TtsBaseGrid.ButtonUp(DataCol, DataRow: Longint);
begin
    DoButtonUp(DataCol, DataRow);
end;

procedure TtsBaseGrid.SpinButtonDown(DataCol, DataRow: Longint; SpinButton: TtsSpinButton);
begin
    DoSpinButtonDown(DataCol, DataRow, SpinButton);
end;

procedure TtsBaseGrid.SpinButtonUp(DataCol, DataRow: Longint; SpinButton: TtsSpinButton);
begin
    DoSpinButtonUp(DataCol, DataRow, SpinButton);
end;

procedure TtsBaseGrid.SpinRepeat(DataCol, DataRow: Longint; Count: Integer; SpinButton: TtsSpinButton);
begin
    DoSpinRepeat(DataCol, DataRow, Count, SpinButton);
    CheckSpinIncrement(DataCol, DataRow, SpinButton);
end;

procedure TtsBaseGrid.SpinButtonClick(DataCol, DataRow: Longint; SpinButton: TtsSpinButton);
begin
    DoSpinButtonClick(DataCol, DataRow, SpinButton);
end;

procedure TtsBaseGrid.ComboButtonDown(DataCol, DataRow: Longint);
begin
    if (DataCol = FDropDownCol) and (DataRow = FDropDownRow) then
        CheckDropDownOff(False)
    else
        DisplayCombo(DataCol, DataRow);
end;

procedure TtsBaseGrid.SetComboVisible;
begin
    if not InDesignMode then
    begin
        ComboForm.Enabled := True;
        ComboForm.Visible := True;
    end
    else
        Combo.FGrid.Parent := GetParentForm(Self);
end;

function TtsBaseGrid.CheckInitComboRow: Boolean;
begin
    Result := True;
end;

procedure TtsBaseGrid.InternalShowCombo(DataCol, DataRow: Longint);
begin
    ComboForm.RecreateWnd;
    ComboForm.HandleNeeded;
    Combo.FGrid.HandleNeeded;

    if Combo.FGrid.Rows > 0 then
    begin
        //turn off drawing for combo to prevent combo events from
        //firing when TopRow and CurrentDataRow are being set.
        Combo.FGrid.EnablePaint := False;
        try
            Combo.FGrid.TopRow := 1;
            if CheckInitComboRow then
                Combo.FGrid.CurrentDataRow := 1;
        finally
            Combo.FGrid.EnablePaint := True;
        end;
    end;

    ComboInit(DataCol, DataRow);
    ComboDropDown(DataCol, DataRow);

    Combo.FGrid.SetComboGridExtents(Combo.DropDownCols, Combo.DropDownRows);
    PositionComboRow;
    Combo.FGrid.CheckRowSelection(True);
    SetComboFormExtents(Combo.FGrid);
    SetComboPoint;
    SetComboVisible;
    Update;
    Combo.FGrid.Update;
end;

procedure TtsBaseGrid.OnPreviewGridClick(Sender : TObject);
begin
  PrintPreview;
end;

procedure TtsBaseGrid.OnPrintGridClick(Sender : TObject);
begin
  Print;
end;

procedure TtsBaseGrid.OnExportGridClick(Sender : TObject);
begin
  ExportGrid;
end;

procedure TtsBaseGrid.SetGridReport(Value : TosCustomGridReport);
var i : Integer;
begin
  Self.FGridReport := Value;
  if (Value <> Nil) and (not Self.FReading) and
     (not (csReading in Self.ComponentState))  then
  begin
    if PopupMenu <> Nil then
    begin
       for i := PopupMenu.Items.Count - 1 downto 0 do
         if PopupMenu.Items[i].Tag = 999 then
            PopupMenu.Items.Delete(i);
    end
    else if Self.FGridMenu <> Nil then
    begin
       for i := FGridMenu.Items.Count - 1 downto 0 do
         if FGridMenu.Items[i].Tag = 999 then
            FGridMenu.Items.Delete(i);
    end
  end;
end;

procedure TtsBaseGrid.AddGridMenuItems(aPopupMenu : TPopupMenu);
var newMenuItem : TMenuItem;
    i : integer;

  function AddMenuItem(withText : String) : TMenuItem;
  begin
    Result := TMenuItem.Create(Self);
    Result.Tag := 999;
    Result.Caption := withText;
  	aPopupMenu.Items.Add(Result);
  end;
begin
  // Only add them if they are not already there, we
  // check by looking for a menuitem with tag 999...
  for i := 0 to aPopupMenu.Items.Count - 1 do
     if PopupMenu.Items[i].Tag = 999 then
        exit;
     
  if aPopupMenu = PopupMenu then // Add a separator...
  begin
    newMenuItem := TMenuItem.Create(Self);
		newMenuItem.Caption := '-';
    newMenuItem.Tag := 999;
		aPopupMenu.Items.Add(newMenuItem);
  end;

  // Now add menu items for Print Preview, Print, and Export...
  newMenuItem := Nil;
  if (FGridReport <> Nil) then
  begin
    if (FGridReport.FPreviewMenuText <> '') then
       newMenuItem := AddMenuItem(FGridReport.FPreviewMenuText);
  end
  else
     newMenuItem := AddMenuItem('Preview Grid...');
  if newMenuItem <> Nil then
     newMenuItem.OnClick := Self.OnPreviewGridClick;

  newMenuItem := Nil;
  if (FGridReport <> Nil) then
  begin
    if (FGridReport.FPrintMenuText <> '') then
       newMenuItem := AddMenuItem(FGridReport.FPrintMenuText);
  end
  else
     newMenuItem := AddMenuItem('Print Grid...');
  if newMenuItem <> Nil then
     newMenuItem.OnClick := Self.OnPrintGridClick;

  newMenuItem := Nil;
  if (FGridReport <> Nil) then
  begin
    if (FGridReport.FExportMenuText <> '') then
       newMenuItem := AddMenuItem(FGridReport.FExportMenuText);
  end       
  else
	   newMenuItem := AddMenuItem('Export Grid...');
  if newMenuItem <> Nil then
     newMenuItem.OnClick := Self.OnExportGridClick;
end;

procedure TtsBaseGrid.ConfigureGridMenu;
begin
  FGridMenu.Free;
  FGridMenu := TPopupMenu.Create(Self);
  FGridMenu.PopupComponent := Self;

  AddGridMenuItems(FGridMenu);
end;

procedure TtsBaseGrid.ShowGridMenu(X, Y : Longint);
var aPoint : TPoint;
begin
  // Need to create a popup menu if the Grids Popupmenu is nil...
  if (Self.PopupMenu <> Nil) then
     AddGridMenuItems(PopupMenu)
  else if (FGridMenu = Nil) then
     ConfigureGridMenu;

  aPoint.X := X;
  aPoint.Y := Y;
  aPoint := ClientToScreen(aPoint);
  if (PopupMenu <> Nil) then
     PopupMenu.Popup(aPoint.X, aPoint.Y)
  else
     FGridMenu.Popup(aPoint.X, aPoint.Y);
end;

procedure TtsBaseGrid.BeginUpdate;
begin
  EnableReDraw := False;
end;

procedure TtsBaseGrid.EndUpdate;
begin
  EnableReDraw := True;
end;

procedure TtsBaseGrid.PaintToMetaFileCanvas(aMetaFileCanvas : TMetaFileCanvas);
begin
  Self.FMetaFileCanvas := aMetaFileCanvas;
  try
    Self.Paint;
  finally
    FMetaFileCanvas := Nil;
  end;
end;

procedure TtsBaseGrid.DisplayCombo(DataCol, DataRow: Longint);
begin
    CheckComboCreated;
    CheckDropDownOff(False);
    InternalShowCombo(DataCol, DataRow);
    SetFocus;
    HookDropDownHook(Self);
    Combo.FGrid.FIgnoreScrolling := True;
end;

procedure TtsBaseGrid.ShowCombo;
begin
    if not CurrentCellInView then Exit;
    if not CanDropDown(FCurDataCol, FCurDataRow, [btCombo]) then Exit;

    if (not ComboVisible) or
       (FDropDownCol <> FCurDataCol) or (FDropDownRow <> FCurDataRow) then
    begin
        CheckDropDownOff(False);
        CurrentCell.PutInView;
        DisplayCombo(FCurDataCol, FCurDataRow);
    end;
end;

procedure TtsBaseGrid.HideCombo;
begin
    CheckDropDownOff(False);
end;

procedure TtsBaseGrid.SetComboPoint;
var
    ARect: TRect;
begin
    ARect:= Combo.FGrid.CellRect(Combo.FGrid.LeftCol, Combo.FGrid.TopRow);
    FMouseDownToCombo := not InDesignMode;
end;

function TtsBaseGrid.CanSetComboExtents: Boolean;
begin
    Result := FAsCombo and Visible and Assigned(Parent) and Parent.Visible and
              InDesignMode and SetComboExtents;
end;

procedure TtsBaseGrid.GetComboGridExtents(DropCols, DropRows: Longint; var NewWidth, NewHeight: Integer);
var
    InitWidth, InitHeight: Integer;
    VersionInfo: TOSVersionInfo;
begin
    InitWidth := ComboInitWidth(DropCols);
    InitHeight := ComboInitHeight(DropRows);

    NewHeight := InitHeight;
    NewWidth := InitWidth;
    if DropRows > 0 then
    begin
        if ShowHorzScrollBar(InitWidth) or AlwaysShowHorzScrollBar then
        begin
            NewHeight := NewHeight + HorzScrollBarHeight;
            if Win32Platform = VER_PLATFORM_WIN32_NT then
            begin
                VersionInfo.dwOSVersionInfoSize := SizeOf(VersionInfo);
                GetVersionEx(VersionInfo);
                if VersionInfo.dwMajorVersion = 3 then NewHeight := NewHeight - 1;
            end;
        end;
    end;

    if DropCols > 0 then
    begin
        if ShowVertScrollBar(InitHeight) or AlwaysShowVertScrollBar then
        begin
            NewWidth := NewWidth + VertScrollBarWidth;
            if Win32Platform = VER_PLATFORM_WIN32_NT then
            begin
                VersionInfo.dwOSVersionInfoSize := SizeOf(VersionInfo);
                GetVersionEx(VersionInfo);
                if VersionInfo.dwMajorVersion = 3 then NewWidth := NewWidth - 1;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.UpdateComboExtents(DropCols, DropRows: Longint; Redraw: Boolean);
var
    NewWidth, NewHeight: Integer;
begin
    GetComboGridExtents(DropCols, DropRows, NewWidth, NewHeight);
    if Redraw or (NewWidth <> Width) or (NewHeight <> Height) then
    begin
        if not ParentGrid.ComboVisible
            then SetBounds(Left, Top, NewWidth, NewHeight)
            else SetComboFormGridExtents(Self, NewWidth, NewHeight);
    end;
end;

procedure TtsBaseGrid.SetComboGridExtents(DropCols, DropRows: Longint);
var
    NewWidth, NewHeight: Integer;
begin
    GetComboGridExtents(DropCols, DropRows, NewWidth, NewHeight);
    if (Width <> NewWidth) or (Height <> NewHeight) then
        SetBounds(Left, Top, NewWidth, NewHeight);
    UpdateScrollRange;
end;

procedure TtsBaseGrid.SetComboFormExtents(ComboGrid: TtsBaseGrid);
begin
    SetComboFormGridExtents(ComboGrid, ComboGrid.Width, ComboGrid.Height);
end;

procedure TtsBaseGrid.SetComboFormGridExtents(ComboGrid: TtsBaseGrid; NewWidth, NewHeight: Integer);
var
    ARect: TRect;
    TopLeft, WidthHeight: TPoint;
    DisplayCol, DisplayRow: Longint;
begin
    WidthHeight.X := NewWidth;
    WidthHeight.Y := NewHeight;

    with ComboGrid.ParentGrid do
    begin
        if (FDropDownCol > 0) and (FDropDownRow > 0) and
           ((ComboForm.Visible) or (InDesignMode and (ComboGrid.Parent = GetParentForm(ComboGrid.ParentGrid)))) then
        begin
            DisplayCol := GetDisplayCol(FDropDownCol);
            DisplayRow := GetDisplayRow(FDropDownRow);
        end
        else
        begin
            DisplayCol := FCurDisplayCol;
            DisplayRow := FCurDisplayRow;
        end;

        ARect := CellRect(DisplayCol, DisplayRow);
        TopLeft.X := ARect.Left;
        TopLeft.Y := ARect.Bottom;
        TopLeft := ClientToScreen(TopLeft);

        if WidthHeight.X < ColWidths[DisplayCol] then
        begin
            TopLeft.X := TopLeft.X + ColWidths[DisplayCol] -
                         WidthHeight.X;
        end;

        if not InDesignMode then
        begin
            if ComboGrid.Left <> 0 then ComboGrid.Left := 0;
            if ComboGrid.Top <> 0 then ComboGrid.Top := 0;
            PositionDropDownForm(GetDataCol(DisplayCol), GetDataRow(DisplayRow), WidthHeight, TopLeft);
            if (ComboGrid.Width <> NewWidth) or (ComboGrid.Height <> NewHeight) then
            begin
                ComboGrid.SetBounds(0, 0, NewWidth, NewHeight);
                ComboGrid.UpdateScrollRange;
            end;
            SetWindowPos(ComboForm.Handle, HWND_TOP, TopLeft.X, TopLeft.Y,
                         WidthHeight.X, WidthHeight.Y, 0);
        end
        else
        begin
            TopLeft := GetParentForm(ComboGrid.ParentGrid).ScreenToClient(TopLeft);
            if (not ComboVisible) or ComboGrid.EnablePaint then
            begin
                ComboGrid.EnablePaint := False;
                try
                    ComboGrid.SetBounds(TopLeft.X, TopLeft.Y, NewWidth, NewHeight);
                    ComboGrid.UpdateScrollRange;
                finally
                    ComboGrid.EnablePaint := True;
                end;
            end
            else
            begin
                ComboGrid.FSetBounds := True;
                ComboGrid.FBoundsRect := Rect(TopLeft.X, TopLeft.Y, NewWidth, NewHeight);
                ComboGrid.Invalidate;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.AdjustComboGridExtents(DropCols, DropRows: Longint);
begin
    if not (FAsCombo and SetComboExtents) then Exit;
    if not (Visible and Assigned(Parent) and Parent.Visible and InDesignMode) then
    begin
        if Assigned(ParentGrid) then ParentGrid.ResetLastUsedCombo;
        Exit;
    end;

    EnablePaint := False;
    try
        UpdateComboExtents(DropCols, DropRows, False);
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.ComboInitWidth(DropCols: Longint): Integer;
var
    I: Integer;
    Sum: Integer;
    DataCol, Count: Longint;
begin
    Result := Width;
    if DropCols <= 0 then Exit;

    Sum := 0;
    Count := 0;
    for I := 1 to Cols do
    begin
        DataCol := DataColnr[I];
        if GridCols[DataCol].Visible then
        begin
            Inc(Count);
            if Count > DropDownCols then Break;
            Sum := Sum + GridCols[DataCol].Width;
        end;
    end;

    if BorderStyle = bsSingle then Sum := Sum + (2*GetSystemMetrics(SM_CXBORDER));
    if RowBarOn then Sum := Sum + RowBarWidth;
    Result := Sum;
end;

function TtsBaseGrid.ComboInitHeight(DropRows: Longint): Integer;
var
    Offset: Integer;
begin
    Result := Height;
    if DropRows <= 0 then Exit;

    Offset := 0;
    if BorderStyle = bsSingle then Offset := Offset + (2*GetSystemMetrics(SM_CYBORDER));
    if HeadingOn then Offset := Offset + HeadingHeight;
    Result := (CalcMin(DropRows, CalcMax(1, FVisibleRows.Count)) * DefaultRowHeight) + Offset;
end;

procedure TtsBaseGrid.InitComboColWidth(ColWidth: Integer);
begin
    if not FAsCombo then Exit;
    DefaultColWidth := ColWidth + 10;
end;

procedure TtsBaseGrid.InitCombo(Combo: TtsCombo);
begin
    if Combo = nil then Exit;

    if InDesignMode then
    begin
        Combo.FGrid.Rows := 4;
        Combo.DropDownRows := 4;
        Combo.FGrid.Cols := 2;
        Combo.DropDownCols := 2;
    end
    else
    begin
        Combo.FGrid.Rows := 0;
        Combo.DropDownRows := 4;
        Combo.FGrid.Cols := 1;
        Combo.DropDownCols := 1;
    end;

    Combo.ValueCol := 1;
    Combo.ComboDisplayCol := 1;
    Combo.CompareType := ctCaseInsensitive;
    Combo.Grid.StoreData := False;
end;

procedure TtsBaseGrid.InitComboData(CellHasCombo: Boolean);
begin
end;

procedure TtsBaseGrid.ComboInit(DataCol, DataRow: Longint);
var
    CurCombo: TtsCombo;
begin
    CheckComboCreated;
    FInComboInit := True;
    try
        if (not FComboInitialized) or InDesignMode then
        begin
            CurCombo := GiveCellCombo(DataCol, DataRow);
            if Assigned(CurCombo) and ((CurCombo <> FLastUsedCombo) or InDesignMode) then
            begin
                FLastUsedCombo := CurCombo;
                Combo.Assign(FLastUsedCombo);
            end
            else
            begin
                if not Assigned(CurCombo) then
                begin
                    if InDesignMode then
                        Combo.Reset
                    else if (FLastUsedCombo <> CurCombo) then
                        Combo.Reset
                    else
                        InitCombo(Combo);
                    Combo.DropDownStyle := GiveCellDropDownStyle(DataCol, DataRow);
                    Combo.FGrid.DefaultColWidth := Round(ColWidths[GetDisplayCol(DataCol)] + 10);
                    Combo.FGrid.DefaultRowHeight := CalcMax(FScaledRowHeight, Combo.FGrid.CalcTextHeight);
                    Combo.FGrid.UpdateScrollRange;
                end;
                FLastUsedCombo := CurCombo;
            end;

            InitComboData(Assigned(CurCombo));
            ActivateComboInit(DataCol, DataRow);
            FComboInitialized := True;
        end;
    finally
        FInComboInit := False;
    end;
end;

procedure TtsBaseGrid.ComboDropDown(DataCol, DataRow: Longint);
begin
    if (FDropDownCol = -1) and (FDropDownRow = -1) then
    begin
        ResetComboSearchValue;
        ActivateComboDropDown(DataCol, DataRow);
        FDropDownCol := DataCol;
        FDropDownRow := DataRow;
    end;
end;

procedure TtsBaseGrid.ComboRollUp;
begin
    if (FDropDownCol <> -1) and (FDropDownRow <> -1) then
    begin
        ResetComboSearchValue;
        ActivateComboRollUp(FDropDownCol, FDropDownRow);
        FDropDownCol := -1;
        FDropDownRow := -1;
        CheckMousePosition;
    end;
end;

procedure TtsBaseGrid.ActivateComboInit(DataCol, DataRow: Longint);
begin
    DoComboInit(DataCol, DataRow);
end;

procedure TtsBaseGrid.ActivateComboDropDown(DataCol, DataRow: Longint);
begin
    DoComboDropDown(DataCol, DataRow);
end;

procedure TtsBaseGrid.ActivateComboRollUp(DataCol, DataRow: Longint);
begin
    DoComboRollup(DataCol, DataRow);
end;

procedure TtsBaseGrid.GetComboValue(ValueCol, DataColUp, DataRowUp: Longint; var Value: Variant);
var
    ControlType: TtsControlType;
    ValueType: TtsValueType;
begin
    Value := Unassigned;
    DataColUp := 0;
    DataRowUp := Combo.FGrid.CurrentDataRow;

    if ((DataRowUp > 0) and ((DataRowUp > Combo.FGrid.FixedRows) or Combo.FGrid.FSelectFixed)) and
       (DataColUp >= 0) then
    begin
        DoComboGetValue(FCurDataCol, FCurDataRow, DataRowUp, Value);

        ControlType := CurCellControlType;
        if VarIsEmpty(Value) and (ControlType <> ctNone) and (ValueCol <> 0) then
        begin
            Value := Combo.Grid.Cell[ValueCol, DataRowUp];
            if VarIsEmpty(Value) and Combo.Grid.StoreData then
            begin
                ValueType := Combo.Grid.GridData.GetValueType(ValueCol, DataRowUp);
                if ValueType = vtpNone then Value := EmptyCellValue(ControlType);
            end;
        end
        else if ControlType = ctText then
            Value := CheckStrValue(ControlType, Value);
    end;
end;

function TtsBaseGrid.IsLookupCombo(DataCol: Integer): Boolean;
begin
    Result := False;
end;

procedure TtsBaseGrid.SetComboValue(Value: Variant);
begin
    if not VarIsEmpty(Value) then CheckVarType(CurCellControlType, Value);
    SetCurrentValue(Value, True, True);
end;

procedure TtsBaseGrid.SetCurrentValue(Value: Variant; Select: Boolean; Redraw: Boolean);
var
    Ok: Boolean;
begin
    if not VarIsEmpty(Value) then
    begin
        if not VariantEqual(CurrentCell.Value, Value) then
        begin
            Ok := True;
            try
                Ok := CurrentCell.SetEditValue(Value, True, Redraw);
            finally
                if Ok and (CurCellControlType = ctText) and Select then
                begin
                    CurrentCell.SelStart := 0;
                    CurrentCell.SelLength := Length(Value);
                end;
            end;
        end;
    end;
end;

procedure TtsBaseGrid.ComboClickCell(Sender: TObject; DataColDown, DataRowDown, DataColUp, DataRowUp: Longint);
var
    Value: Variant;
    ACol: Longint;
    RollUp: Boolean;
begin
    if DataRowDown = 0 then Exit;
    if (Combo.FGrid.Rows = 0) or (Combo.FGrid.Cols = 0) or
       (Combo.FGrid.GridStatus <> grRowSelect) then
    begin
        ShowGridControl;
        CheckDropDownOff(False);
        SetFocus;
        Exit;
    end;

    if Combo.ValueCol < 0 then ACol := 0
    else if Combo.ValueCol > Combo.FGrid.Cols then ACol := 0
    else ACol := Combo.ValueCol;

    RollUp := TurnComboOff(False, True);
    try
        GetComboValue(ACol, DataColUp, DataRowUp, Value);
        try
            SetComboValue(Value);
        finally
            ShowGridControl;
        end;
    finally
        if RollUp then ComboRollUp;
        SetFocus;
    end;
end;

procedure TtsBaseGrid.DblClickCell(DataCol, DataRow: Longint);
begin
    DoDblClickCell(DataCol, DataRow, ClickPos(DataCol, DataRow));
end;

procedure TtsBaseGrid.AddScrollingRight;
var
    LastCol: Longint;
begin
    if (MaxVisibleCol < ColCount - 1) or
       ((MaxVisibleCol = ColCount - 1) and
        (CellRect(MaxVisibleCol, TopRow).Left + ColWidths[MaxVisibleCol] > ClientWidth) ) then
    begin
        begin
            LastCol := LastVisibleCol(LeftCol + 1);

            if LastCol > FLastAddedCol then
            begin
                ChangeColSelection(FLastAddedCol + 1, LastCol);
                FLastAddedCol := LastCol;
            end;

            LeftCol := LeftCol + 1;
        end;

        Update;
        SelectionsChanged(True);
    end
end;

procedure TtsBaseGrid.DeleteScrollingRight;
var
    NextVisibleCols: Longint;
begin
    NextVisibleCols := CompVisibleCols(LeftCol + 1);

    if (LeftCol + 1 + NextVisibleCols) > FCurDisplayCol then
        SelectLargerCols(LeftCol + 1 + NextVisibleCols)
    else if (LeftCol + 1 + NextVisibleCols) < FCurDisplayCol then
        SelectSmallerCols(LeftCol + 1 + NextVisibleCols + 1)
    else if (LeftCol + 1 + NextVisibleCols) = FCurDisplayCol then
        SelectCurrentCol(LeftCol + 1 + NextVisibleCols);

    LeftCol := LeftCol + 1;
    Update;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.AddScrollingLeft(NewLeftCol: Longint);
begin
    if NewLeftCol < FLastAddedCol then
    begin
        ChangeColSelection(NewLeftCol, FLastAddedCol - 1);
        FLastAddedCol := NewLeftCol;
    end;

    LeftCol := NewLeftCol;
    Update;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.DeleteScrollingLeft(NewLeftCol: Longint);
var
    PrevCol: Longint;
begin
    ChangeColSelection(FLastAddedCol, FLastAddedCol);
    LeftCol := NewLeftCol;

    GetPrevCol(LeftCol, False, True, PrevCol);
    FLastAddedCol := PrevCol;
    Update;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.AddScrollingUp(NewTopRow: Longint);
begin
    if NewTopRow < FLastAddedRow then
    begin
        ChangeRowSelection(NewTopRow, FLastAddedRow - 1);
        FLastAddedRow := NewTopRow;
    end;

    ScrollGrid(LeftCol, NewTopRow, smWindow);
    Update;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.DeleteScrollingUp(NewTopRow: Longint);
var
    NewRow: Longint;
begin
    if RowSelectMode = rsMulti then
    begin
        ChangeRowSelection(FLastAddedRow, FLastAddedRow);
        ScrollGrid(LeftCol, NewTopRow, smWindow);
        GetPrevRow(TopRow, False, True, NewRow);
        FLastAddedRow := NewRow;
    end
    else
    begin
        NewRow := CalcMax(NewTopRow, 1);
        DeleteRowSelection(FLastAddedRow, FLastAddedRow);
        if (not FAsCombo) or FMouseOverGrid then
            AddRowSelection(NewRow, NewRow);
        FLastAddedRow := NewRow;

        SetCurrentPosition(FCurDisplayCol, NewRow, True, True);
        ScrollGrid(LeftCol, NewTopRow, smRowSelect);
    end;

    Update;
    CheckRowColChanged;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.AddScrollingDown;
var
    NewRow: Longint;
    LastRow: Longint;
    MaxRow: Longint;
begin
    if ((GridMode = gmEditInsert) and
        ((MaxVisibleRow < RowCount - 1) or ( (MaxVisibleRow = RowCount - 1) and
         (CellRect(LeftCol,MaxVisibleRow).Top + RowHeights[MaxVisibleRow] > ClientHeight) ))) OR
       ((not (GridMode = gmEditInsert)) and
        ((MaxVisibleRow < BottomMostRow(False, True)) or ((MaxVisibleRow = BottomMostRow(False, True)) and
         (CellRect(LeftCol,MaxVisibleRow).Top + RowHeights[MaxVisibleRow] > ClientHeight) ))) then
    begin
        if RowSelectMode = rsMulti then
        begin
            LastRow := LastVisibleRow(TopRow + 1);
            if IsInsertRow(LastRow) then Dec(LastRow);

            if LastRow > FLastAddedRow then
            begin
                ChangeRowSelection(FLastAddedRow + 1, LastRow);
                FLastAddedRow := LastRow;
            end;

            ScrollGrid(LeftCol, TopRow + 1, smWindow);
        end
        else
        begin
            if not GetPrevRow(Rows + 1, False, True, MaxRow) then Exit;
            NewRow := MaxVisibleRow + 1;
            if IsInsertRow(NewRow) then Dec(NewRow);

            if NewRow <= MaxRow then
            begin
                NewRow := CalcMin(MaxVisibleRow + 1, MaxRow);
                DeleteRowSelection(FLastAddedRow, FLastAddedRow);
                if (not FAsCombo) or FMouseOverGrid then
                    AddRowSelection(NewRow, NewRow);
                FLastAddedRow := NewRow;

                SetCurrentPosition(FCurDisplayCol, NewRow, True, True);
                ScrollGrid(LeftCol, TopRow + 1, smRowSelect);
            end
            else if TopRow < MaxTopRow then
            begin
                ScrollGrid(LeftCol, TopRow + 1, smRowSelect);
            end;
        end;

        Update;
        CheckRowColChanged;
        SelectionsChanged(True);
    end
end;

procedure TtsBaseGrid.DeleteScrollingDown;
var
    NextVisibleRows: Longint;
begin
    NextVisibleRows := CompVisibleRows(TopRow + 1);

    if (TopRow + 1 + NextVisibleRows) > FCurDisplayRow then
        SelectLargerRows(TopRow + 1 + NextVisibleRows)
    else if (TopRow + 1 + NextVisibleRows) < FCurDisplayRow then
        SelectSmallerRows(TopRow + 1 + NextVisibleRows + 1)
    else if (TopRow + 1 + NextVisibleRows) = FCurDisplayRow then
        SelectCurrentRow(TopRow + 1 + NextVisibleRows);

    ScrollGrid(LeftCol, TopRow + 1, smWindow);
    Update;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.RightColSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
begin
    if MaxVisibleCol > FCurDisplayCol then
        SelectLargerCols(MaxVisibleCol)
    else if MaxVisibleCol < FCurDisplayCol then
        SelectSmallerCols(MaxVisibleCol + 1)
    else
        SelectCurrentCol(MaxVisibleCol);

    while CurrentPos.X = CheckPos.X do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;
        if LeftCol >= MaxLeftCol then Break;

        if LeftCol < MaxLeftCol then
        begin
            if LeftCol + VisibleColCount > FCurDisplayCol then
            begin
                AddScrollingRight;
            end
            else if LeftCol + VisibleColCount < FCurDisplayCol then
            begin
                DeleteScrollingRight;
            end
            else if LeftCol + VisibleColCount = FCurDisplayCol then
            begin
                AddScrollingRight;
                InvalidateCol(FCurDisplayCol);
                Update;
            end;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.LeftColSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
    PrevCol: Longint;
begin
    GetPrevCol(LeftCol, False, True, PrevCol);
    if LeftCol > FCurDisplayCol then
        SelectLargerCols(PrevCol)
    else
        SelectSmallerCols(PrevCol);

    while CurrentPos.X = CheckPos.X do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;

        if (LeftCol <= FixedCols) then
        begin
            CellFromXY(ScreenToClient(CurrentPos).X, 0, DisplayCol, DisplayRow);

            if DisplayCol > FCurDisplayCol then
                SelectLargerCols(DisplayCol)
            else if DisplayCol < FCurDisplayCol then
                SelectSmallerCols(DisplayCol)
            else
                SelectCurrentCol(DisplayCol);

            Break;
        end;

        if not (LeftCol > LeftMostCol(False, True)) then Break;
        GetPrevCol(LeftCol, False, True, PrevCol);
        if PrevCol > FCurDisplayCol then
            DeleteScrollingLeft(PrevCol)
        else if PrevCol < FCurDisplayCol then
            AddScrollingLeft(PrevCol)
        else if PrevCol = FCurDisplayCol then
        begin
            LeftCol := PrevCol;
            FLastAddedCol := LeftCol;
            Update;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.UpRowSelecting(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
var
    Msg: TMsg;
    CurCol, CurRow: Longint;
    PrevRow: Longint;
begin
    GetPrevRow(TopRow, False, True, PrevRow);
    if TopRow > FCurDisplayRow then
        SelectLargerRows(PrevRow)
    else
    begin
        if RowSelectMode = rsMulti then
            SelectSmallerRows(PrevRow)
        else
            SelectSmallerRows(TopRow);
    end;

    while CurrentPos.Y = CheckPos.Y do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;

        if (TopRow <= FixedRows) then
        begin
            CellFromXY(0, ScreenToClient(CurrentPos).Y, CurCol, CurRow);

            if CurRow > FCurDisplayRow then
                SelectLargerRows(CurRow)
            else if CurRow < FCurDisplayRow then
                SelectSmallerRows(CurRow)
            else
                SelectCurrentRow(CurRow);
            Break;
        end;

        if not (TopRow > TopMostRow(False, True)) then Break;

        GetPrevRow(TopRow, False, True, PrevRow);
        if PrevRow > FCurDisplayRow then
            DeleteScrollingUp(PrevRow)
        else if PrevRow < FCurDisplayRow then
        begin
            if RowSelectMode = rsMulti then
                AddScrollingUp(PrevRow)
            else
                DeleteScrollingUp(PrevRow)
        end
        else if PrevRow = FCurDisplayRow then
        begin
            if RowSelectMode = rsMulti then
            begin
                ScrollGrid(LeftCol, PrevRow, smWindow);
                FLastAddedRow := TopRow;
                Update;
            end
            else if FCurDisplayRow = 1 then
            begin
                ScrollGrid(LeftCol, PrevRow, smRowSelect);
                FLastAddedRow := TopRow;
                Update;
            end
            else
                DeleteScrollingUp(PrevRow);
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.DownRowSelecting(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
var
    Msg: TMsg;
begin
    if MaxVisibleRow > FCurDisplayRow then
        SelectLargerRows(MaxVisibleRow)
    else if MaxVisibleRow < FCurDisplayRow then
        SelectSmallerRows(MaxVisibleRow + 1)
    else
        SelectCurrentRow(MaxVisibleRow);

    while CurrentPos.Y = CheckPos.Y do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;
        if TopRow >= MaxTopRow then Break;

        if TopRow < MaxTopRow then
        begin
            if TopRow + VisibleRowCount > FCurDisplayRow then
            begin
                AddScrollingDown;
            end
            else if TopRow + VisibleRowCount < FCurDisplayRow then
            begin
                if RowSelectMode = rsMulti then
                    DeleteScrollingDown
                else
                    AddScrollingDown;
            end
            else if TopRow + VisibleRowCount = FCurDisplayRow then
            begin
                AddScrollingDown;
                InvalidateRow(FCurDisplayRow);
                Update;
            end;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.LeftRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    if (TopRow + VisibleRowCount >= RowCount) and
       (ScreenToClient(CurrentPos).Y >= CellRect(LeftCol,RowCount - 1).Bottom) then
        DisplayRow := RowCount - 1
    else
        CellFromXY(ColWidths[0] div 2, ScreenToClient(CurrentPos).Y,
                   DisplayCol, DisplayRow);

    ChangeCellSelection(CalcMax(LeftCol - 1, 1), DisplayRow);

    while CurrentPos.X = CheckPos.X do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;

          if not (LeftCol > FixedCols) then Break;

        if (TopRow + VisibleRowCount >= RowCount) and
           (ScreenToClient(CurrentPos).Y >= CellRect(LeftCol,RowCount - 1).Bottom) then
            DisplayRow := RowCount - 1
        else
            CellFromXY(ColWidths[0] div 2, ScreenToClient(CurrentPos).Y,
                       DisplayCol, DisplayRow);

        ChangeCellSelection(LeftCol - 2, DisplayRow);

        LeftCol := LeftCol - 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.LeftUpRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                 DisplayCol, DisplayRow);
    if LeftCol > FixedCols then DisplayCol := LeftCol - 1;
    if TopRow > FixedRows then DisplayRow := TopRow - 1;

    ChangeCellSelection(DisplayCol, DisplayRow);

    while (CurrentPos.X = CheckPos.X) and (CurrentPos.Y = CheckPos.Y) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 2) then Break;

        if not ( (LeftCol > FixedCols) or (TopRow > FixedRows) ) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);
            ChangeCellSelection(DisplayCol, DisplayRow);

            Break;
        end;

        ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                     DisplayCol, DisplayRow);
        if LeftCol > FixedCols then DisplayCol := LeftCol - 2;
        if TopRow > FixedRows then DisplayRow := TopRow - 2;

        ChangeCellSelection(DisplayCol, DisplayRow);

        if LeftCol > FixedCols then LeftCol := LeftCol - 1;
        if TopRow > FixedRows then TopRow := TopRow - 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.UpRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    if (LeftCol + VisibleColCount >= ColCount) and
       (ScreenToClient(CurrentPos).X >= CellRect(ColCount - 1,TopRow).Right) then
        DisplayCol := ColCount - 1
    else
        CellFromXY(ScreenToClient(CurrentPos).X, RowHeights[0] div 2,
                   DisplayCol, DisplayRow);

    ChangeCellSelection(DisplayCol, CalcMax(TopRow - 1, 1));

    while CurrentPos.Y = CheckPos.Y do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;

        if not (TopRow > FixedRows) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);

            ChangeCellSelection(DisplayCol, DisplayRow);
            Break;
        end;

        if (LeftCol + VisibleColCount >= ColCount) and
           (ScreenToClient(CurrentPos).X >= CellRect(ColCount - 1,TopRow).Right) then
            DisplayCol := ColCount - 1
        else
            CellFromXY(ScreenToClient(CurrentPos).X, RowHeights[0] div 2,
                       DisplayCol, DisplayRow);

        ChangeCellSelection(DisplayCol, TopRow - 2);

        TopRow := TopRow - 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.RightUpRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    ChangeCellSelection(CalcMin(ColCount - 1, LeftCol + VisibleColCount + 1) , CalcMax(TopRow - 1, 1));

    while (CurrentPos.X = CheckPos.X) and (CurrentPos.Y = CheckPos.Y) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 2) then Break;

        if not ( ((LeftCol < ColCount - 1) and (LeftCol + VisibleColCount <  ColCount)) or
                 (TopRow > FixedRows) ) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);
            ChangeCellSelection(DisplayCol, DisplayRow);

            Break;
        end;

        if LeftCol + VisibleColCount <  ColCount then
            DisplayCol := LeftCol + 1 + CompVisibleCols(LeftCol + 1) + 1
        else
            DisplayCol := ColCount - 1;

        if TopRow > FixedRows then
            DisplayRow := TopRow - 1
        else
            DisplayRow := TopRow;

        ChangeCellSelection(DisplayCol, DisplayRow - 1);

        if LeftCol + VisibleColCount <  ColCount then LeftCol := LeftCol + 1;
        if TopRow > FixedRows then TopRow := TopRow - 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.RightRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    if (TopRow + VisibleRowCount >= RowCount) and
       (ScreenToClient(CurrentPos).Y >= CellRect(LeftCol,RowCount - 1).Bottom) then
        DisplayRow := RowCount - 1
    else
        CellFromXY(ColWidths[0] div 2, ScreenToClient(CurrentPos).Y,
                   DisplayCol, DisplayRow);

    ChangeCellSelection(CalcMin(ColCount - 1, LeftCol + VisibleColCount + 1),
                         DisplayRow);

    while CurrentPos.X = CheckPos.X do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;

        if not ((LeftCol < ColCount - 1) and
                (LeftCol + VisibleColCount <  ColCount)) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);

            ChangeCellSelection(DisplayCol, DisplayRow);
            Break;
        end;

        if (TopRow + VisibleRowCount >= RowCount) and
           (ScreenToClient(CurrentPos).Y >= CellRect(LeftCol,RowCount - 1).Bottom) then
            DisplayRow := RowCount - 1
        else
            CellFromXY(ColWidths[0] div 2, ScreenToClient(CurrentPos).Y,
                       DisplayCol, DisplayRow);

        ChangeCellSelection(LeftCol + 1 + CompVisibleCols(LeftCol + 1) + 1, DisplayRow);

        LeftCol := LeftCol + 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.RightDownRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    ChangeCellSelection(CalcMin(ColCount - 1, LeftCol + VisibleColCount + 1),
                         CalcMin(RowCount - 1, TopRow + VisibleRowCount + 1));

    while (CurrentPos.X = CheckPos.X) and (CurrentPos.Y = CheckPos.Y) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 2) then Break;

        if not ( ((LeftCol < ColCount - 1) and (LeftCol + VisibleColCount <  ColCount)) or
                 ((TopRow < RowCount - 1) and (TopRow + VisibleRowCount < RowCount)) ) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);

            ChangeCellSelection(DisplayCol, DisplayRow);
            Break;
        end;

        if LeftCol + VisibleColCount <  ColCount then
            DisplayCol := LeftCol + 1 + CompVisibleCols(LeftCol + 1) + 1
        else
            DisplayCol := ColCount - 1;

        if TopRow + VisibleRowCount < RowCount then
            DisplayRow := TopRow + 1 + CompVisibleRows(TopRow + 1) + 1
        else
            DisplayRow := RowCount - 1;

        ChangeCellSelection(DisplayCol, DisplayRow);

        if LeftCol + VisibleColCount <  ColCount then LeftCol := LeftCol + 1;
        if TopRow + VisibleRowCount < RowCount then TopRow := TopRow + 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.DownRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    if (LeftCol + VisibleColCount >= ColCount) and
       (ScreenToClient(CurrentPos).X >= CellRect(ColCount - 1,TopRow).Right) then
        DisplayCol := ColCount - 1
    else
        CellFromXY(ScreenToClient(CurrentPos).X, RowHeights[0] div 2,
                   DisplayCol, DisplayRow);

    ChangeCellSelection(DisplayCol, CalcMin(RowCount - 1, TopRow + VisibleRowCount + 1));

    while CurrentPos.Y = CheckPos.Y do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;

        if not ((TopRow < RowCount - 1) and (TopRow + VisibleRowCount < RowCount)) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);
                         
            ChangeCellSelection(DisplayCol, DisplayRow);
            Break;
        end;

        if (LeftCol + VisibleColCount >= ColCount) and
           (ScreenToClient(CurrentPos).X >= CellRect(ColCount - 1,TopRow).Right) then
            DisplayCol := ColCount - 1
        else
            CellFromXY(ScreenToClient(CurrentPos).X, RowHeights[0] div 2,
                       DisplayCol, DisplayRow);

        ChangeCellSelection(DisplayCol, TopRow + 1 + CompVisibleRows(TopRow + 1) + 1);

        TopRow := TopRow + 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.LeftDownRangeSelecting(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
    DisplayCol, DisplayRow: Longint;
begin
    ChangeCellSelection(CalcMax(LeftCol - 1, 1),
                        CalcMin(RowCount - 1,TopRow + VisibleRowCount + 1));

    while CurrentPos.Y = CheckPos.Y do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 2) then Break;

        if not ( ((TopRow < RowCount - 1) and (TopRow + VisibleRowCount < RowCount)) or
                  (LeftCol > FixedCols) ) then
        begin
            ColRowFromXY(ScreenToClient(CurrentPos).X, ScreenToClient(CurrentPos).Y,
                         DisplayCol, DisplayRow);
            ChangeCellSelection(DisplayCol, DisplayRow);

            Break;
        end;

        if LeftCol > FixedCols then
            DisplayCol := LeftCol - 1
        else
            DisplayCol := LeftCol;

        if TopRow + VisibleRowCount < RowCount then
            DisplayRow := TopRow + 1 + CompVisibleRows(TopRow + 1) + 1
        else
            DisplayRow := RowCount - 1;

        ChangeCellSelection(DisplayCol - 1, DisplayRow);

        if LeftCol > FixedCols then LeftCol := LeftCol - 1;
        if TopRow + VisibleRowCount < RowCount then TopRow := TopRow + 1;
        Update;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.LeftColMoving(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
begin
    if ((FMovePos >= LeftCol) and (FMovePos <= MaxVisibleCol)) and (FMovePos > FixedCols) then
    begin
        if FColMoveVisible then DrawColMove;
    end;

    while (CurrentPos.X = CheckPos.X) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;

        if LeftCol > FixedCols then
        begin
            LeftCol := LeftCol - 1;
            Update;

            if LeftCol > FixedCols then
                FMovePos := LeftCol - 1
            else
            begin
                if FMovePos <> LeftCol then FMovePos := LeftCol;
                DrawColMove;
            end;
        end
        else
        begin
            if FMovePos <> LeftCol then
            begin
                FMovePos := LeftCol;
                DrawColMove;
            end;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.RightColMoving(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
begin
    if (FMovePos >= LeftCol) and (FMovePos <= MaxVisibleCol) then
    begin
        if (FMovePos = RightMostCol(False, False)) and (FMovePos <> FMoveIndex) then
        begin
            if not FColMoveDrawnOutsideGrid then
            begin
                DrawColMove;
                FColMoveDrawnOutsideGrid := FColMoveVisible;
            end
        end;

        if FColMoveVisible then DrawColMove;
        FMovePos := CalcMin(LeftCol + VisibleColCount + 1, RightMostCol(False, False));
    end;

    while (CurrentPos.X = CheckPos.X) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 0) then Break;

        if LeftCol + VisibleColCount < ColCount then
        begin
            LeftCol := LeftCol + 1;

            if FColMoveDrawnOutsideGrid then
                FColMoveDrawnOutsideGrid := False;

            FMovePos := CalcMin(LeftCol + VisibleColCount + 1, RightMostCol(False, False));
            Update;

            if LeftCol + VisibleColCount = ColCount then
            begin
                DrawColMove;
                FColMoveDrawnOutsideGrid := FColMoveVisible;
            end;
        end
        else if not FColMoveDrawnOutsideGrid then
        begin
            DrawColMove;
            FColMoveDrawnOutsideGrid := FColMoveVisible;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.UpRowMoving(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
begin
    if ((FMovePos >= TopRow) and (FMovePos <= MaxVisibleRow)) and (FMovePos > FixedRows) then
    begin
        if FRowMoveVisible then DrawRowMove;
    end;

    while (CurrentPos.Y = CheckPos.Y) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;

        if TopRow > FixedRows then
        begin
            TopRow := TopRow - 1;
            Update;

            if TopRow > FixedRows then
                FMovePos := TopRow - 1
            else
            begin
                if FMovePos <> TopRow then FMovePos := TopRow;
                DrawRowMove;
            end;
        end
        else
        begin
            if FMovePos <> TopRow then
            begin
                FMovePos := TopRow;
                DrawRowMove;
            end;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.DownRowMoving(CurrentPos, CheckPos: TPoint);
var
    Msg: TMsg;
begin
    if (FMovePos >= TopRow) and (FMovePos <= MaxVisibleRow) then
    begin
        if (FMovePos = Rows) and (FMovePos <> FMoveIndex) then
        begin
            if not FRowMoveDrawnOutsideGrid then
            begin
                DrawRowMove;
                FRowMoveDrawnOutsideGrid := FRowMoveVisible;
            end;
        end;

        if FRowMoveVisible then DrawRowMove;
        GetPrevRow(Rows + 1, False, False, FMovePos);
        FMovePos := CalcMin(TopRow + VisibleRowCount + 1, FMovePos);
    end;

    while (CurrentPos.Y = CheckPos.Y) do
    begin
        if PeekMessage(Msg, Handle, WM_MouseFirst, WM_MouseLast, PM_NoRemove) then Break;
        if CheckEscape then Break;
        if not ScrollDelay(CurrentPos.X, CurrentPos.Y, 1) then Break;

        if TopRow + VisibleRowCount < RowCount then
        begin
            TopRow := TopRow + 1;

            if FRowMoveDrawnOutsideGrid then
                FRowMoveDrawnOutsideGrid := False;

            GetPrevRow(Rows + 1, False, False, FMovePos);
            FMovePos := CalcMin(TopRow + VisibleRowCount + 1, FMovePos);
            Update;

            if TopRow + VisibleRowCount = RowCount then
            begin
                DrawRowMove;
                FRowMoveDrawnOutsideGrid := FRowMoveVisible;;
            end;
        end
        else if not FRowMoveDrawnOutsideGrid then
        begin
            DrawRowMove;
            FRowMoveDrawnOutsideGrid := FRowMoveVisible;
        end;

        GetCursorPos(CurrentPos);
    end;
end;

procedure TtsBaseGrid.MoveViewLeft(CurrentPos, CheckPos: TPoint);
var
    Border: Integer;
begin
    if FMouseStatus = msColMove then
    begin
        if (LeftCol + VisibleColCount < ColCount) or
           ((LeftCol + VisibleColCount >= ColCount) and (FMovePos <> ColCount - 1)) then
        begin
            RightColMoving(CurrentPos, CheckPos);
        end;
        Exit;
    end;

    if FGridStatus = grColSelect then
        RightColSelecting(CurrentPos, CheckPos)
    else if FGridStatus = grCellSelect then
    begin
        if ScreenToClient(CurrentPos).Y >= (ClientHeight) then
            RightDownRangeSelecting(CurrentPos, CheckPos)
        else
        begin
            if HeadingOn then Border := RowHeights[0]
                         else Border := 0;

            if ScreenToClient(CurrentPos).Y <= Border then
                RightUpRangeSelecting(CurrentPos, CheckPos)
            else
                RightRangeSelecting(CurrentPos, CheckPos);
        end;
    end;
end;

procedure TtsBaseGrid.MoveViewRight(CurrentPos, CheckPos: TPoint);
var
    Border: Integer;
begin
    if FMouseStatus = msColMove then
    begin
        LeftColMoving(CurrentPos, CheckPos);
        Exit;
    end;

    if FGridStatus = grColSelect then
        LeftColSelecting(CurrentPos, CheckPos)
    else if FGridStatus = grCellSelect then
    begin
        if ScreenToClient(CurrentPos).Y >= (ClientHeight) then
            LeftDownRangeSelecting(CurrentPos, CheckPos)
        else
        begin
            Border := FVertFixedHeight;
            if ScreenToClient(CurrentPos).Y <= Border then
                LeftUpRangeSelecting(CurrentPos, CheckPos)
            else
                LeftRangeSelecting(CurrentPos, CheckPos);
        end;
    end;
end;

procedure TtsBaseGrid.MoveViewDown(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
var
    Border: Integer;
begin
    if FMouseStatus = msRowMove then
    begin
        UpRowMoving(CurrentPos, CheckPos);
        Exit;
    end;

    if (FGridStatus = grRowSelect) or (FMouseStatus = msRowSelect) then
    begin
        UpRowSelecting(CurrentPos, CheckPos, DisplayRow);
    end
    else if FGridStatus = grCellSelect then
    begin
        if ScreenToClient(CurrentPos).X >= (ClientWidth) then
            RightUpRangeSelecting(CurrentPos, CheckPos)
        else
        begin
            Border := FHorzFixedWidth;
            if ScreenToClient(CurrentPos).X <= Border then
                LeftUpRangeSelecting(CurrentPos, CheckPos)
            else
                UpRangeSelecting(CurrentPos, CheckPos);
        end;
    end;
end;

procedure TtsBaseGrid.MoveViewUp(CurrentPos, CheckPos: TPoint; DisplayRow: Longint);
var
    Border: Integer;
begin
    if FMouseStatus = msRowMove then
    begin
        if (TopRow + VisibleRowCount < RowCount) or
           ((TopRow + VisibleRowCount >= RowCount) and (FMovePos <> Rows)) then
        begin
            DownRowMoving(CurrentPos, CheckPos);
        end;
        Exit;
    end;

    if (FGridStatus = grRowSelect) or (FMouseStatus = msRowSelect) then
        DownRowSelecting(CurrentPos, CheckPos, DisplayRow)
    else if FGridStatus = grCellSelect then
    begin
        if ScreenToClient(CurrentPos).X >= (ClientWidth) then
            RightDownRangeSelecting(CurrentPos, CheckPos)
        else
        begin
            if RowBarOn then Border := ColWidths[0]
                        else Border := 0;

            if ScreenToClient(CurrentPos).X <= Border then
                LeftDownRangeSelecting(CurrentPos, CheckPos)
            else
                DownRangeSelecting(CurrentPos, CheckPos);
        end;
    end
end;

procedure TtsBaseGrid.MoveView(Direct: TtsMoveDirection; var LastCol, LastRow: Longint);
var
    CurrentPos, CheckPos: TPoint;
begin
    GetCursorPos(CurrentPos);
    CheckPos := CurrentPos;

    if Direct = mdLeft then
    begin
        MoveViewLeft(CurrentPos, CheckPos);
    end
    else if Direct = mdRight then
    begin
        MoveViewRight(CurrentPos, CheckPos);
    end
    else if Direct = mdDown then
    begin
        MoveViewDown(CurrentPos, CheckPos, LastRow);
    end
    else if Direct = mdUp then
    begin
        MoveViewUp(CurrentPos, CheckPos, LastRow);
    end;

    GetCursorPos(CurrentPos);
    CurrentPos := ScreenToClient(CurrentPos);

    CellFromXY(CurrentPos.X, CurrentPos.Y, LastCol, LastRow);
end;

function TtsBaseGrid.ScrollRows(X, Y: integer; var DisplayCol, DisplayRow: Longint): Boolean;
var
    OldColumn: Longint;
begin
    Result := False;
    if (Y >= ClientHeight) and (MaxVisibleRow >= FixedRows) then
    begin
        Result := True;
        if FIgnoreScrolling then Exit;

        Result := TopRow < MaxTopRow;
        if Result then
        begin
            OldColumn := DisplayCol;
            MoveView(mdUp, DisplayCol, DisplayRow);

            if (DisplayRow >= RowCount) or (DisplayRow < 0) then
            begin
                DisplayRow := RowCount - 1;
            end;

            DisplayCol := OldColumn;
        end;
    end
    else if (Y < FVertFixedHeight) and (TopRow > TopMostScrollRow) and not
            ((FGridStatus = grCellSelect) and
             (FSelectedCells.Top in [0..FixedRows - 1]) and
             (FSelectedCells.Bottom in [0..FixedRows - 1])) and not
            ((FGridStatus = grRowSelect) and
             (FSelectedRows.First in [0..FixedRows - 1]) and
             (FSelectedRows.Last in [0..FixedRows - 1])) then
    begin
        Result := True;
        if FIgnoreScrolling then Exit;

        OldColumn := DisplayCol;
        MoveView(mdDown, DisplayCol, DisplayRow);

        if (DisplayRow >= RowCount) or (DisplayRow < 0) then
        begin
            DisplayRow := 1;
        end;

        DisplayCol := OldColumn;
    end
    else if FIgnoreScrolling then
    begin
        if Y >= FVertFixedHeight then FIgnoreScrolling := False;
    end;
end;

function TtsBaseGrid.ScrollCols(X, Y: integer; var DisplayCol, DisplayRow: Longint): Boolean;
var
    OldRow: Longint;
begin
    Result := False;
    if (X >= ClientWidth) and (MaxVisibleCol >= FixedCols) then
    begin
        Result := True;
        if FIgnoreScrolling then Exit;

        Result := LeftCol < MaxLeftCol;
        if Result then
        begin
            OldRow := DisplayRow;
            MoveView(mdLeft, DisplayCol, DisplayRow);

            if (DisplayCol >= ColCount) or (DisplayCol < 0) then
            begin
                DisplayCol := ColCount - 1;
            end;

            DisplayRow := OldRow;
        end;
    end
    else if (X < FHorzFixedWidth) and (LeftCol > LeftMostScrollCol) and not
            ((FGridStatus = grCellSelect) and
             (FSelectedCells.Left in [0..FixedCols - 1]) and
             (FSelectedCells.Right in [0..FixedCols - 1])) and not
            ((FGridStatus = grColSelect) and
             (FSelectedCols.First in [0..FixedCols - 1]) and
             (FSelectedCols.Last in [0..FixedCols - 1])) then
    begin
        Result := True;
        if FIgnoreScrolling then Exit;

        OldRow := DisplayRow;
        MoveView(mdRight, DisplayCol, DisplayRow);

        if (DisplayCol >= ColCount) or (DisplayCol < 0) then
        begin
            DisplayCol := 1;
        end;

        DisplayRow := OldRow;
    end
    else if FIgnoreScrolling then
    begin
        FIgnoreScrolling := false;
    end;
end;

procedure TtsBaseGrid.SelectLargerRows(DisplayRow: Longint);
var
    MaxRow: Longint;
begin
    if IsInsertRow(DisplayRow) then Dec(DisplayRow);
    DisplayRow := CalcMax(DisplayRow, TopMostRow(False, True));

    if (MaxVisibleRow < FixedRows) and (DisplayRow > MaxVisibleRow) then
        DisplayRow := MaxVisibleRow;

    if FLastAddedRow = DisplayRow then Exit;

    if RowSelectMode = rsMulti then
    begin
        if (DisplayRow > FLastAddedRow) and (FLastAddedRow >= FCurDisplayRow) then
        begin
            ChangeRowSelection(FLastAddedRow + 1, DisplayRow);
            ChangeRowInversion(FLastAddedRow + 1, DisplayRow, True);
            FLastAddedRow := DisplayRow;
        end
        else if (DisplayRow > FLastAddedRow) and (FLastAddedRow < FCurDisplayRow) then
        begin
            ChangeRowInversion(FLastAddedRow, FCurDisplayRow - 1, False);
            ChangeRowSelection(FLastAddedRow, FCurDisplayRow - 1);
            ChangeRowSelection(FCurDisplayRow + 1, DisplayRow);
            ChangeRowInversion(FCurDisplayRow + 1, DisplayRow, True);
            FLastAddedRow := DisplayRow;
        end
        else if (DisplayRow < FLastAddedRow) then
        begin
            ChangeRowInversion(FLastAddedRow, DisplayRow + 1, False);
            ChangeRowSelection(DisplayRow + 1, FLastAddedRow);
            FLastAddedRow := DisplayRow;
        end;
    end
    else
    begin
        MaxRow := BottomMostRow(False, True);
        if (FLastAddedRow < MaxRow) then
        begin
            InvertSelectedRows(FLastAddedRow, FLastAddedRow, False);
            DeleteRowSelection(FLastAddedRow, FLastAddedRow);
            ClearCurrent(FLastAddedRow);
            DisplayRow := CalcMin(DisplayRow, MaxRow);
            SetCurrentPositionAndDraw(FCurDisplayCol, DisplayRow, True, True);
            if FMouseOverGrid or not FAsCombo then
            begin
                AddRowSelection(DisplayRow, DisplayRow);
                InvertSelectedRows(DisplayRow, DisplayRow, True);
            end;
            FLastAddedRow := DisplayRow;
        end;
    end;

    CheckRowColChanged;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.SelectSmallerRows(DisplayRow: Longint);
var
    MinRow: Longint;
begin
    MinRow := TopMostRow(False, True);
    DisplayRow := CalcMax(DisplayRow, MinRow);

    if RowSelectMode = rsMulti then
    begin
        if (DisplayRow < FLastAddedRow) and (FLastAddedRow <= FCurDisplayRow) then
        begin
            ChangeRowSelection(FLastAddedRow - 1, DisplayRow);
            ChangeRowInversion(FLastAddedRow - 1, DisplayRow, True);
            FLastAddedRow := DisplayRow;
        end
        else if (DisplayRow < FLastAddedRow) and (FLastAddedRow > FCurDisplayRow) then
        begin
            ChangeRowInversion(FLastAddedRow, FCurDisplayRow + 1, False);
            ChangeRowSelection(FLastAddedRow, FCurDisplayRow + 1);
            if FCurDisplayRow > MinRow then
            begin
                ChangeRowSelection(FCurDisplayRow - 1, DisplayRow);
                ChangeRowInversion(FCurDisplayRow - 1, DisplayRow, True);
            end;
            FLastAddedRow := DisplayRow;
        end
        else if (DisplayRow > FLastAddedRow) then
        begin
            ChangeRowInversion(FLastAddedRow, DisplayRow - 1, False);
            ChangeRowSelection(DisplayRow - 1, FLastAddedRow);
            FLastAddedRow := DisplayRow;
        end;
    end
    else
    begin
        if (FLastAddedRow > TopMostRow(False, True)) then
        begin
            if (FLastAddedRow <> TopRow) or (FLastAddedRow = FixedRows) then
            begin
                InvertSelectedRows(FLastAddedRow, FLastAddedRow, False);
                DeleteRowSelection(FLastAddedRow, FLastAddedRow);
                ClearCurrent(FLastAddedRow);
                SetCurrentPositionAndDraw(FCurDisplayCol, DisplayRow, True, True);
                if FMouseOverGrid or not FAsCombo then
                begin
                    AddRowSelection(DisplayRow, DisplayRow);
                    InvertSelectedRows(DisplayRow, DisplayRow, True);
                end;
                FLastAddedRow := DisplayRow;
            end
            else
            begin
                DeleteRowSelection(FLastAddedRow, FLastAddedRow);
                DisplayRow := CalcMax(DisplayRow, 1);
                SetCurrentPosition(FCurDisplayCol, DisplayRow, True, True);
                if FMouseOverGrid or not FAsCombo then
                    AddRowSelection(DisplayRow, DisplayRow);
                FLastAddedRow := DisplayRow;
            end;
        end
        else if (not FMouseOverGrid) and FAsCombo then
            SelectCurrentRow(FLastAddedRow);
    end;

    CheckRowColChanged;
    SelectionsChanged(True);
end;

procedure TtsBaseGrid.SelectCurrentRow(DisplayRow: Longint);
begin
    DisplayRow := CalcMax(DisplayRow, TopMostRow(False, True));

    if DisplayRow > FLastAddedRow then
    begin
        ChangeRowInversion(FLastAddedRow, DisplayRow - 1, False);
        ChangeRowSelection(DisplayRow - 1, FLastAddedRow);
        FLastAddedRow := DisplayRow;
    end
    else if DisplayRow < FLastAddedRow then
    begin
        ChangeRowInversion(FLastAddedRow, DisplayRow + 1, False);
        ChangeRowSelection(DisplayRow + 1, FLastAddedRow);
        FLastAddedRow := DisplayRow;
    end
    else if FAsCombo and (RowSelectMode = rsSingle) then
    begin
        if ((not FMouseOverGrid) and IsRowSelected(DisplayRow)) or
           (FMouseOverGrid and (not IsRowSelected(DisplayRow))) then
        begin
            ChangeRowInversion(DisplayRow, DisplayRow, False);
            ChangeRowSelection(DisplayRow, DisplayRow);
        end;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.SelectLargerCols(DisplayCol: Longint);
begin
    DisplayCol := CalcMax(DisplayCol, LeftMostCol(False, True));

    if (MaxVisibleCol < FixedCols) and (DisplayCol > MaxVisibleCol) then
        DisplayCol := MaxVisibleCol;

    if (DisplayCol > FLastAddedCol) and (FLastAddedCol >= FCurDisplayCol) then
    begin
        ChangeColSelection(FLastAddedCol + 1, DisplayCol);
        ChangeColInversion(FLastAddedCol + 1, DisplayCol, True);
        FLastAddedCol := DisplayCol;
    end
    else if (DisplayCol > FLastAddedCol) and (FLastAddedCol < FCurDisplayCol) then
    begin
        ChangeColInversion(FLastAddedCol, FCurDisplayCol - 1, False);
        ChangeColSelection(FLastAddedCol, FCurDisplayCol - 1);
        ChangeColSelection(FCurDisplayCol + 1, DisplayCol);
        ChangeColInversion(FCurDisplayCol + 1, DisplayCol, True);
        FLastAddedCol := DisplayCol;
    end
    else if (DisplayCol < FLastAddedCol) then
    begin
        ChangeColInversion(FLastAddedCol, DisplayCol + 1, False);
        ChangeColSelection(DisplayCol + 1, FLastAddedCol);
        FLastAddedCol := DisplayCol;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.SelectSmallerCols(DisplayCol: Longint);
var
    MinCol: Longint;
begin
    MinCol := LeftMostCol(False, True);
    DisplayCol := CalcMax(DisplayCol, MinCol);

    if (DisplayCol < FLastAddedCol) and (FLastAddedCol <= FCurDisplayCol) then
    begin
        ChangeColSelection(FLastAddedCol - 1, DisplayCol);
        ChangeColInversion(FLastAddedCol - 1, DisplayCol, True);
        FLastAddedCol := DisplayCol;
    end
    else if (DisplayCol < FLastAddedCol) and (FLastAddedCol > FCurDisplayCol) then
    begin
        ChangeColInversion(FLastAddedCol, FCurDisplayCol + 1, False);
        ChangeColSelection(FLastAddedCol, FCurDisplayCol + 1);
        if FCurDisplayCol > MinCol then
        begin
            ChangeColSelection(FCurDisplayCol - 1, DisplayCol);
            ChangeColInversion(FCurDisplayCol - 1, DisplayCol, True);
        end;
        FLastAddedCol := DisplayCol;
    end
    else if (DisplayCol > FLastAddedCol) then
    begin
        ChangeColInversion(FLastAddedCol, DisplayCol - 1, False);
        ChangeColSelection(DisplayCol - 1, FLastAddedCol);
        FLastAddedCol := DisplayCol;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.SelectCurrentCol(DisplayCol: Longint);
begin
    DisplayCol := CalcMax(DisplayCol, LeftMostCol(False, True));

    if DisplayCol > FLastAddedCol then
    begin
        ChangeColInversion(FLastAddedCol, DisplayCol - 1, False);
        ChangeColSelection(DisplayCol - 1, FLastAddedCol);
        FLastAddedCol := DisplayCol;
    end
    else if DisplayCol < FLastAddedCol then
    begin
        ChangeColInversion(FLastAddedCol, DisplayCol + 1, False);
        ChangeColSelection(DisplayCol + 1, FLastAddedCol);
        FLastAddedCol := DisplayCol;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.MouseMoveRangeSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
var
    ColsScrolled, RowsScrolled: Boolean;
begin
    ColsScrolled := ScrollCols(X, Y, DisplayCol, DisplayRow);
    RowsScrolled := ScrollRows(X, Y, DisplayCol, DisplayRow);

    if not (ColsScrolled or RowsScrolled) then
    begin
        ChangeCellSelection(DisplayCol, DisplayRow);
    end;
end;

procedure TtsBaseGrid.MouseMoveColSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
begin
    if not ScrollCols(X, Y, DisplayCol, DisplayRow) then
    begin
        if DisplayCol > FCurDisplayCol then
            SelectLargerCols(DisplayCol)
        else if DisplayCol < FCurDisplayCol then
            SelectSmallerCols(DisplayCol)
        else
            SelectCurrentCol(DisplayCol);
    end;
end;

function TtsBaseGrid.CheckMouseOverGrid(X, Y: Integer): Boolean;
begin
    Result := False;
    if not HandleAllocated then Exit;

    if (X < 0) or (X >= ClientWidth) then
        Result := False
    else if (Y < FVertFixedHeight) or (Y >= ClientHeight) then
        Result := False
    else
        Result := True;
end;

procedure TtsBaseGrid.MouseMoveRowSelecting(X, Y: integer; DisplayCol, DisplayRow: Longint);
var
    CompRes: Integer;
begin
    FMouseOverGrid := CheckMouseOverGrid(X, Y);
    if DisplayRow > Rows then DisplayRow := Rows;
    if (not ScrollRows(X, Y, DisplayCol, DisplayRow)) and (not FIgnoreScrolling) then
    begin
        CompRes := CompareRowPos(DisplayRow);
        if CompRes > 0 then
            SelectLargerRows(DisplayRow)
        else if CompRes < 0 then
            SelectSmallerRows(DisplayRow)
        else
            SelectCurrentRow(DisplayRow);
    end;
end;

procedure TtsBaseGrid.ChangeColMovePos(DisplayCol: Longint);
begin
    if FColMoveVisible then DrawColMove;

    FMovePos := DisplayCol;
    if not FColMoveVisible then DrawColMove;
end;

procedure TtsBaseGrid.MouseMoveColMoving(X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    APoint, Point: TPoint;
begin
    if not ScrollCols(X, Y, DisplayCol, DisplayRow) then
    begin
        if (FMovePos = ColCount - 1) and (FMovePos <> FMoveIndex) then
        begin
            Point.X := X;
            Point.Y := Y;
            APoint.X := CellRect(ColCount - 1, TopRow).Left;
            APoint.Y := Y;
            if (ClientToScreen(Point).X >= ClientToScreen(APoint).X) and not FColMoveDrawnOutsideGrid then
                FColMoveDrawnOutsideGrid := True
            else if (ClientToScreen(Point).X < ClientToScreen(APoint).X) and FColMoveDrawnOutsideGrid then
                FColMoveDrawnOutsideGrid := False;
        end;

        if (DisplayCol < LeftMostScrollCol) and (DisplayCol >= 0) then
            DisplayCol := LeftMostScrollCol
        else if DisplayCol > RightMostCol(False, False) then
            DisplayCol := RightMostCol(False, False);

        if (DisplayCol <> FMovePos) then
        begin
            if FColMoveDrawnOutsideGrid then DrawColMove;

            FColMoveDrawnOutsideGrid := False;
            ChangeColMovePos(DisplayCol);
        end
        else if not FColMoveVisible then
            DrawColMove;
    end;
end;

procedure TtsBaseGrid.ChangeRowMovePos(DisplayRow: Longint);
begin
    if FRowMoveVisible then DrawRowMove;

    FMovePos := DisplayRow;
    if not FRowMoveVisible then DrawRowMove;
end;

procedure TtsBaseGrid.MouseMoveRowMoving(X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    APoint, Point: TPoint;
begin
    if not ScrollRows(X, Y, DisplayCol, DisplayRow) then
    begin
        if (FMovePos = Rows) and (FMovePos <> FMoveIndex) then
        begin
            Point.X := X;
            Point.Y := Y;
            APoint.X := X;
            APoint.Y := CellRect(LeftCol, Rows).Top;
            if (ClientToScreen(Point).Y >= ClientToScreen(APoint).Y) and not FRowMoveDrawnOutsideGrid then
                FRowMoveDrawnOutsideGrid := True
            else if (ClientToScreen(Point).Y < ClientToScreen(APoint).Y) and FRowMoveDrawnOutsideGrid then
                FRowMoveDrawnOutsideGrid := False;
        end;

        if (DisplayRow < TopMostScrollRow) and (DisplayRow >= 0) then
            DisplayRow := TopMostScrollRow
        else if DisplayRow > BottomMostRow(False, False) then
            DisplayRow := BottomMostRow(False, False);
        if IsInsertRow(DisplayRow) then Dec(DisplayRow);

        if (DisplayRow <> FMovePos) and (DisplayRow > 0) and
           (DisplayRow <= Rows) then
        begin
            if FRowMoveDrawnOutsideGrid then
                DrawRowMove;

            FRowMoveDrawnOutsideGrid := False;
            ChangeRowMovePos(DisplayRow);
        end
        else if (DisplayRow = FMovePos) and not FRowMoveVisible then
            DrawRowMove;
    end;
end;

procedure TtsBaseGrid.MouseMoveSetPosition(X, Y: integer; var NewX, NewY: Integer;
                                             var DisplayCol, DisplayRow: Longint);
begin
    CellFromXY(X, Y, DisplayCol, DisplayRow);

    NewX := X;
    NewY := Y;

    if (X > CellRect(MaxVisibleCol, TopRow).Right) and (Y <= CellRect(LeftCol, MaxVisibleRow).Bottom) then
    begin
        DisplayCol := ColCount - 1;
        DisplayRow := MouseCoord(1,Y).Y;
        NewX := CellRect(MaxVisibleCol, TopRow).Right + FVertLineWidth;
    end
    else if (X <= CellRect(MaxVisibleCol, TopRow).Right) and (Y > CellRect(LeftCol, MaxVisibleRow).Bottom) then
    begin
        DisplayRow := RowCount - 1;
        DisplayCol := MouseCoord(X, 1).X;
        NewY := CellRect(LeftCol, MaxVisibleRow).Bottom + FHorzLineWidth;
    end
    else if (X > CellRect(MaxVisibleCol, TopRow).Right) and (Y > CellRect(LeftCol, MaxVisibleRow).Bottom) then
    begin
        DisplayCol := ColCount - 1;
        DisplayRow := RowCount - 1;
        NewX := CellRect(MaxVisibleCol, TopRow).Right + FVertLineWidth;
        NewY := CellRect(LeftCol, MaxVisibleRow).Bottom + FHorzLineWidth;
    end;
end;

procedure TtsBaseGrid.MouseMoveButtonDown(X, Y: Integer; DisplayCol, DisplayRow: Longint);
begin
    if MouseOverCombo(X, Y) then
    begin
        if (FButtonDown.X <> -1) and (FButtonDown.Y <> -1) then
        begin
            DoDrawButton(FButtonDown.X, FButtonDown.Y, [FDownSpinButton], spbNone, clBtnFace, bmUp);
            FButtonUp := FButtonDown;
            ResetButtonDown;
        end;

        MouseCapture := false;
        MouseCaptureToCombo;
    end
    else if MouseOverButton(X, Y, DisplayCol, DisplayRow) and
            (FCurDisplayCol = DisplayCol) and (FCurDisplayRow = DisplayRow) then
    begin
        if (FButtonDown.X = -1) and (FButtonDown.Y = -1) and FButtonClicked and
           ((FSpinButtonClicked = spbNone) or OverSpinButton(X, Y, DisplayCol, DisplayRow, FSpinButtonClicked)) then
        begin
            DoDrawButton(DisplayCol, DisplayRow, [FSpinButtonClicked], FSpinButtonClicked, clBtnFace, bmDown);
            FButtonDown.X := DisplayCol;
            FButtonDown.Y := DisplayRow;
            FDownSpinButton := FSpinButtonClicked;
            if spoAutoRepeat in GiveCellSpinOptions(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then
                StartSpinTimer(FUseSpinStartDelay);
        end
        else if ((FButtonDown.X <> -1) or (FButtonDown.Y <> -1)) and
                (FDownSpinButton <> spbNone) and
                not OverSpinButton(X, Y, DisplayCol, DisplayRow, FSpinButtonClicked) then
        begin
            DoDrawButton(FButtonDown.X, FButtonDown.Y, [FDownSpinButton], spbNone, clBtnFace, bmUp);
            FButtonUp := FButtonDown;
            ResetButtonDown;
        end;
    end
    else if (FButtonDown.X <> -1) and (FButtonDown.Y <> -1) then
    begin
        DoDrawButton(FButtonDown.X, FButtonDown.Y, [FDownSpinButton], spbNone, clBtnFace, bmUp);
        FButtonUp := FButtonDown;
        ResetButtonDown;
    end;
end;

procedure TtsBaseGrid.MouseMoveDrawButton(X, Y: Integer; DisplayCol, DisplayRow: Longint);
var
    ButtonType: TtsButtonType;
begin
    if not ButtonsActive then Exit;
    if MouseOverButton(X, Y, DisplayCol, DisplayRow) then
    begin
        ButtonType := GiveCellButtonType(GetDataCol(DisplayCol), GetDataRow(DisplayRow));
        if (FlatButtons) then StartButtonTimer;
        if ((FButtonUp.X <> DisplayCol) or (FButtonUp.Y <> DisplayRow)) and
            (FButtonUp.X <> -1) and (FButtonUp.Y <> -1) then
        begin
            DoDrawButton(FButtonUp.X, FButtonUp.Y, [FUpSpinButton], spbNone,
                         ButtonColor(FButtonUp.X, FButtonUp.Y), bmFlat);
            ResetButtonUp;
        end;

        if (FButtonUp.X <> DisplayCol) and (FButtonUp.Y <> DisplayRow) then
        begin
           if (GridMode = gmListBox) then exit;
           if CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) and
              not Self.FReadOnlyButton then exit;

           // if (GridMode in [gmListBox, gmBrowse]) or
           //     CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then Exit;

            if (FlatButtons and not IsSpinButton(ButtonType)) or
               (((DisplayCol <> CurDisplayCol) or (DisplayRow <> CurDisplayRow)) and
                (InactiveButtonState <> ibsBackGround)) then
            begin
                DoDrawButton(DisplayCol, DisplayRow, [spbIncrement, spbDecrement], spbNone, clBtnFace, bmUp);
                FButtonUp.X := DisplayCol;
                FButtonUp.Y := DisplayRow;
            end;
        end;
    end
    else if (FButtonUp.X <> -1) or (FButtonUp.Y <> -1) then
    begin
        DoDrawButton(FButtonUp.X, FButtonUp.Y, [FUpSpinButton], spbNone,
                     ButtonColor(FButtonUp.X, FButtonUp.Y), bmFlat);
        ResetButtonUp;
    end;
end;

procedure TtsBaseGrid.MouseMove(Shift: TShiftState; X, Y: Integer);
var
    DisplayCol, DisplayRow: Longint;
    NewX, NewY: Integer;
begin
    if (csDesigning in ComponentState) and (MouseStatus = msNormal) then
    begin
        inherited MouseMove(Shift, X, Y);
        Exit;
    end;

    FInMouseMove := True;
    ColRowFromXY(X, Y, DisplayCol, DisplayRow);

    if (ssLeft in Shift) and (not FDoubleClicked) then
    begin
        try
            case FMouseStatus of
                msColMove: MouseMoveColMoving(X, Y, DisplayCol, DisplayRow);
                msRowMove: MouseMoveRowMoving(X, Y, DisplayCol, DisplayRow);
                msRowSelect: MouseMoveRowSelecting(X, Y, DisplayCol, DisplayRow);
                msColSelect: MouseMoveColSelecting(X, Y, DisplayCol, DisplayRow);
                msButtonDown: MouseMoveButtonDown(X, Y, DisplayCol, DisplayRow);

                msCellSelect:
                    begin
                        MouseMoveSetPosition(X, Y, NewX, NewY, DisplayCol, DisplayRow);
                        MouseMoveRangeSelecting(NewX, NewY, DisplayCol, DisplayRow);
                    end;

                msColResize, msRowBarResize:
                    begin
                        DrawSizingLine;
                        FSizingPos := X + FSizingOfs;
                        DrawSizingLine;
                    end;

                msRowResize, msHeadingResize:
                    begin
                        DrawSizingLine;
                        FSizingPos := Y + FSizingOfs;
                        DrawSizingLine;
                    end;

                msHeadingDown:
                    begin
                        if ((GetDataCol(DisplayCol) <> FHeadingClicked) or (DisplayRow <> 0) or (Y <= 0))
                            and FDrawHeadingButtonDown then
                        begin
                            FDrawHeadingButtonDown := false;
                            InvalidateCell(GetDisplayCol(FHeadingClicked), 0);
                        end
                        else if ButtonInColHeading(DisplayCol) and FDrawHeadingButtonDown and
                            (not MouseOverHeadingButton(X, Y, DisplayCol)) then
                        begin
                            FDrawHeadingButtonDown := false;
                            InvalidateCell(DisplayCol, 0);
                        end
                        else if ButtonInColHeading(DisplayCol) and (GetDataCol(DisplayCol) = FHeadingClicked)
                            and (not FDrawHeadingButtonDown) and (DisplayRow = 0) and
                            (Y > 0) and MouseOverHeadingButton(X, Y, DisplayCol) then
                        begin
                            FDrawHeadingButtonDown := true;
                            InvalidateCell(DisplayCol, 0);
                        end
                        else if IsColHeadingButton(DisplayCol) and (GetDataCol(DisplayCol) = FHeadingClicked)
                            and (Y > 0) and (DisplayRow = 0) and not FDrawHeadingButtonDown then
                        begin
                            FDrawHeadingButtonDown := true;
                            InvalidateCell(DisplayCol, 0);
                        end
                    end;
            end;

        finally
            if not MouseCapture then SetMouseStatus(msNormal);
        end;
    end
    else if (ssRight in Shift) and (MouseStatus = msHeadingDown) then
    begin
        if ((GetDataCol(DisplayCol) <> FHeadingClicked) or (DisplayRow <> 0) or (Y <= 0))
            and FDrawHeadingButtonDown then
        begin
            FDrawHeadingButtonDown := false;
            InvalidateCell(GetDisplayCol(FHeadingClicked), 0);
        end
        else if ButtonInColHeading(DisplayCol) and FDrawHeadingButtonDown and
            (not MouseOverHeadingButton(X, Y, DisplayCol)) then
        begin
            FDrawHeadingButtonDown := false;
            InvalidateCell(DisplayCol, 0);
        end
        else if ButtonInColHeading(DisplayCol) and (GetDataCol(DisplayCol) = FHeadingClicked)
            and (not FDrawHeadingButtonDown) and (DisplayRow = 0) and
            (Y > 0) and MouseOverHeadingButton(X, Y, DisplayCol) then
        begin
            FDrawHeadingButtonDown := true;
            InvalidateCell(DisplayCol, 0);
        end
        else if IsColHeadingButton(DisplayCol) and (GetDataCol(DisplayCol) = FHeadingClicked)
            and (Y > 0) and (DisplayRow = 0) and not FDrawHeadingButtonDown then
        begin
            FDrawHeadingButtonDown := true;
            InvalidateCell(DisplayCol, 0);
        end
    end
    else if (not (ssMiddle in Shift)) and (not FDoubleClicked) then
    begin
        try
            CellFromXY(X, Y, DisplayCol, DisplayRow);
            MouseMoveDrawButton(X, Y, DisplayCol, DisplayRow);
        finally
            if not MouseCapture then SetMouseStatus(msNormal);
        end;
    end;

    FInMouseMove := False;
    inherited MouseMove( Shift, X, Y);
end;

function TtsBaseGrid.RowsInView(NewHeight: Integer; FixedHeight: Integer): Integer;
var
    UsableHeight: integer;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    UsableHeight := ClientHeight - FixedHeight;
    Result := (UsableHeight div CalcMax(NewHeight, 1)) + 1;

    if Result >= RowCount then
    begin
        Result := RowCount - 1;
    end;
end;

procedure TtsBaseGrid.SetNewTopRow(DisplayRow: Longint; NewHeight: Integer;
                                     OldTop: Integer);
var
    NewTopRow: Longint;
    NewInView, RealHeight: Integer;
    FixedHeight: Integer;
begin
    if not HandleAllocated then Exit;

    FixedHeight := FVertFixedHeight;
    if DisplayRow < FixedRows then Exit;
    if FixedHeight >= ClientHeight then Exit;

    NewTopRow := DisplayRow - Round((OldTop-FixedHeight) / CalcMax(NewHeight, 1));

    if NewTopRow > DisplayRow then
        NewTopRow := DisplayRow
    else
    begin
        RealHeight := ClientHeight - FixedHeight;
        while ((DisplayRow - NewTopRow + 1) * NewHeight > RealHeight) and
               (NewTopRow < DisplayRow) do NewTopRow := NewTopRow + 1;
    end;

    NewInView := RowsInView(NewHeight, FixedHeight);
    if NewTopRow + NewInView > RowCount then
    begin
        if NewInView < RowCount - 1 then Dec(NewInView);
        NewTopRow := RowCount - NewInView;
    end;

    EnablePaint := False;
    try
        NewTopRow := CalcMax(NewTopRow, FixedRows);
        if TopRow <> NewTopRow then TopRow := NewTopRow;
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.ChangeAllRowHeights(NewHeight: integer; SetNewTop: Boolean);
var
    OldTop: Integer;
begin
    OldTop := CellRect(LeftCol, FSizingIndex).Top;
    EnablePaint := False;
    try
        FInChangingAllRowHeights := True;
        try
            DefaultRowHeight := NewHeight;
            if HeadingOn then
            begin
                if ResizeRow(0, HeadingHeight) then UpdateScrollRange;
            end;
        finally
            FInChangingAllRowHeights := False;
        end;

        if SetNewTop then SetNewTopRow(FSizingIndex, NewHeight, OldTop);
    finally
        EnablePaint := True;
    end;
end;

function TtsBaseGrid.ColsInView(NewWidth: Integer): Integer;
var
    UsableWidth: integer;
begin
    Result := 0;
    if not HandleAllocated then Exit;

    UsableWidth := ClientWidth - FHorzFixedWidth;
    Result := (UsableWidth div CalcMax(NewWidth, 1)) + 1;

    if Result >= ColCount then
    begin
        Result := ColCount - 1;
    end;
end;

procedure TtsBaseGrid.SetNewLeftCol(DisplayCol: Longint; NewWidth: Integer;
                                      OldLeft: Integer);
var
    NewLeftCol: Longint;
    NewInView, RealWidth: Integer;
    FixedWidth: Integer;
begin
    if not HandleAllocated then Exit;

    FixedWidth := FHorzFixedWidth;
    if DisplayCol < FixedCols then Exit;
    if FixedWidth >= ClientWidth then Exit;

    NewLeftCol := DisplayCol - Round((OldLeft - FixedWidth) / CalcMax(NewWidth, 1));

    if NewLeftCol > DisplayCol then
        NewLeftCol := DisplayCol
    else
    begin
        RealWidth := ClientWidth - FixedWidth;
        while ((DisplayCol - NewLeftCol + 1) * NewWidth > RealWidth) and
               (NewLeftCol < DisplayCol) do NewLeftCol := NewLeftCol + 1;
    end;

    NewInView :=  ColsInView(NewWidth);
    if NewLeftCol + NewInView > ColCount then
    begin
        if NewInView < ColCount - 1 then Dec(NewInView);
        NewLeftCol := ColCount - NewInView;
    end;

    EnablePaint := False;
    try
        NewLeftCol := CalcMax(NewLeftCol, FixedCols);
        if LeftCol <> NewLeftCol then LeftCol := NewLeftCol;
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.ChangeAllColWidths(NewWidth: integer; SetNewLeft: Boolean);
var
    OldLeft: Integer;
begin
    OldLeft := CellRect(FSizingIndex, TopRow).Left;
    EnablePaint := False;
    try
        FInChangingAllColWidths := True;
        try
            DefaultColWidth := NewWidth;
            if RowBarOn then
            begin
                if ResizeCol(0, RowBarWidth) then UpdateScrollRange;
            end;
        finally
            FInChangingAllColWidths := False;
        end;

        if SetNewLeft then SetNewLeftCol(FSizingIndex, NewWidth, OldLeft);
    finally
        EnablePaint := True;
    end;
end;

procedure TtsBaseGrid.EndColMoving(Move: Boolean);
begin
    try
        if FColMoveVisible then DrawColMove;

        if not Move then
            MouseCapture := False
        else
        begin
            if not ColRangeSelected(FMoveIndex, FMovePos) then
            begin
                MoveColRange(FMoveIndex, FMovePos);
                SetCurrentPosition(FMovePos, FCurDisplayRow, True, True);
                ShowGridControl;
                DrawCurrentFocusRect(False);
                Update;
                CheckRowColChanged;
            end;
        end;
    finally
        if FSelectedCols.Count <> 0 then FGridStatus := grColSelect;
    end;
end;

procedure TtsBaseGrid.EndRowMoving(Move: Boolean);
var
    DataRow: Longint;
begin
    try
        if FRowMoveVisible then DrawRowMove;

        if not Move then
            MouseCapture := False
        else
        begin
            if not RowRangeSelected(FMoveIndex, FMovePos) then
            begin
                DataRow := GetDataRow(FCurDisplayRow);
                MoveRowRange(FMoveIndex, FMovePos);
                SetCurrentPosition(FCurDisplayCol, GetDisplayRow(DataRow), True, True);
                Update;
                CheckRowColChanged;
            end;
        end;
    finally
        if FSelectedRows.Count <> 0 then FGridStatus := grRowSelect;
    end;
end;

procedure TtsBaseGrid.EndColSelecting(Select: Boolean);
begin
    if not Select then
    begin
        ChangeColSelection(FCurDisplayCol, FLastAddedCol);
        ChangeColInversion(FCurDisplayCol, FLastAddedCol, True);
        MouseCapture := False;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.EndRowSelecting(Select: Boolean);
begin
    if (not Select) then
    begin
        if not InRowSelectMode then
        begin
            ChangeRowSelection(FCurDisplayRow, FLastAddedRow);
            ChangeRowInversion(FCurDisplayRow, FLastAddedRow, True);
        end;

        MouseCapture := False;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.EndCellSelecting(Select: Boolean);
begin
    if not Select then
    begin
        DeleteSelections([grCellSelect], True);
        MouseCapture := False;
    end;

    SelectionsChanged(True);
end;

procedure TtsBaseGrid.MUResizedCol(X, Y: Integer; Resize: Boolean);
var
    ARect: TRect;
    NewWidth: Integer;
    Hide: Boolean;
begin
    ARect := CellRect(FSizingIndex, TopRow);
    DrawSizingLine;
    if not Resize then Exit;

    if ((FSizingPos + 1) = (ARect.Left + ColWidths[FSizingIndex])) and FResizeDoubleClicked then
    begin
        if FSizingIndex = 0 then
            FSizingPos := ARect.Left + FOldRowBarWidth - 1
        else if FResizeCols = rcAll then
            FSizingPos := ARect.Left + FOldDefaultColWidth - 1
        else
            FSizingPos := ARect.Left + GridCols[GetDataCol(FSizingIndex)].FOldWidth - 1;
    end
    else
    begin
        FSizingPos := X + FSizingOfs;
        if (FSizingPos > ClientWidth) and not (FAsCombo and InDesignMode) then
            FSizingPos := ClientWidth;
    end;
    if (FSizingPos > ARect.Left) then
    begin
        Hide := False;
        if (FControlSet) and ((FSizingIndex = FCurDisplayCol) or (FResizeCols = rcAll)) then
        begin
            Hide := True;
        end;

        NewWidth := FSizingPos - ARect.Left + 1;
        if (FSizingIndex = 0) then
        begin
            if Hide then HideGridControl(False);
            FInResizingRowBar := True;
            RowBarWidth := NewWidth;
            FInResizingRowBar := False;
        end
        else if (NewWidth <> ColWidths[FSizingIndex]) and (FResizeCols = rcAll) then
        begin
            if Hide then HideGridControl(False);
            ChangeAllColWidths(NewWidth, True);
            CheckTopLeft(False);
        end
        else if (NewWidth <> ColWidths[FSizingIndex]) then
        begin
            if Hide then HideGridControl(False);
            GridCols[GetDataCol(FSizingIndex)].CopyWidth(NewWidth);
            CheckTopLeft(False);
        end;

        if not FControlSet then ShowGridControl;
    end;

    FResizeDoubleClicked := False;
end;

procedure TtsBaseGrid.MUResizedRow(X, Y: Integer; Resize: Boolean);
var
    ARect: TRect;
    NewHeight: Integer;
    Hide: Boolean;
begin
    ARect := CellRect(LeftCol, FSizingIndex);
    if EqualRect(ARect, FNullRect) then ARect := CellRect(MaxVisibleCol, FSizingIndex);

    DrawSizingLine;
    if not Resize then Exit;

    if ((FSizingPos + 1) = (ARect.Top + RowHeights[FSizingIndex])) and FResizeDoubleClicked then
    begin
        if FSizingIndex = 0 then
            FSizingPos := ARect.Top + FOldHeadingHeight - 1
        else if FResizeRows = rrAll then
            FSizingPos := ARect.Top + FOldDefaultRowHeight - 1
        else
            FSizingPos := ARect.Top + GridRows.OldRowHeight[GetDataRow(FSizingIndex)] - 1;
    end
    else
    begin
        FSizingPos := Y + FSizingOfs;
        if (FSizingPos > ClientHeight) and not (FAsCombo and InDesignMode) then
            FSizingPos := ClientHeight;
    end;

    if (FSizingPos > ARect.Top) then
    begin
        Hide := False;
        if (FControlSet) and ((FSizingIndex = FCurDisplayRow) or (FResizeRows = rrAll)) then
        begin
            Hide := True;
        end;

        NewHeight := FSizingPos - ARect.Top + 1;
        if (FSizingIndex = 0) then
        begin
            if Hide then HideGridControl(False);
            FInResizingHeading := True;
            HeadingHeight := NewHeight;
            FInResizingHeading := False;
        end
        else if (NewHeight <> RowHeights[FSizingIndex]) and (FResizeRows = rrAll) then
        begin
            if Hide then HideGridControl(False);
            ChangeAllRowHeights(NewHeight, True);
            CheckTopLeft(False);
        end
        else if (NewHeight <> RowHeights[FSizingIndex]) then
        begin
            if Hide then HideGridControl(False);
            GridRows.CopyRowHeight(GetDataRow(FSizingIndex), NewHeight);
            CheckTopLeft(False);
        end;

        if not FControlSet then ShowGridControl;
        Update;
    end;

    FResizeDoubleClicked := False;
end;

procedure TtsBaseGrid.MUButtonUp(X, Y: Integer);
var
    DisplayCol, DisplayRow: Longint;
begin
    CellFromXY(X, Y, DisplayCol, DisplayRow);

    if (FButtonDown.X <> -1) and (FButtonDown.Y <> -1) then
    begin
        DoDrawButton(FDownDisplayCol, FDownDisplayRow, [FDownSpinButton], spbNone,
                     ButtonColor(FDownDisplayCol, FDownDisplayRow), bmFlat);
        ResetButtonDown;
    end;

    if (FButtonUp.X <> -1) and (FButtonUp.Y <> -1) and
       ((FButtonUp.X <> DisplayCol) or (FButtonUp.Y <> DisplayRow)) then
    begin
        DoDrawButton(FButtonUp.X, FButtonUp.Y, [FUpSpinButton], spbNone,
                     ButtonColor(FButtonUp.X, FButtonUp.Y), bmFlat);
        ResetButtonUp;
    end;

    if MouseOverButton(X, Y, DisplayCol, DisplayRow) then
    begin
        if (GridMode in [gmListBox, gmBrowse]) or
           CellIsReadOnly(GetDataCol(DisplayCol), GetDataRow(DisplayRow)) then Exit;

        DoDrawButton(DisplayCol, DisplayRow, [spbNone], spbNone, clBtnFace, bmUp);
        FButtonUp.X := DisplayCol;
        FButtonUp.Y := DisplayRow;
    end;
end;

procedure TtsBaseGrid.MUHeadingUp(Button:TMouseButton; X, Y: Integer);
var
    DisplayCol: Longint;
    OldDraw: Boolean;
begin
    DisplayCol := GetDisplayCol(FHeadingClicked);
    FHeadingClicked := -1;
    FHeadingButtonClicked := false;
    OldDraw := FDrawHeadingButtonDown;
    if FDrawHeadingButtonDown then
    begin
        FDrawHeadingButtonDown := false;
        InvalidateCell(DisplayCol, 0);
    end;
    DoHeadingUp(GetDataCol(DisplayCol), Button);
    if OldDraw then DoHeadingClick(GetDataCol(DisplayCol));
end;

procedure TtsBaseGrid.CancelMouseAction;
var
    OldStatus: TtsMouseStatus;
begin
    OldStatus := FMouseStatus;

    try
        case FMouseStatus of
            msColResize, msRowBarResize: MUResizedCol(0, 0, False);
            msRowResize, msHeadingResize: MUResizedRow(0, 0, False);
            msColMove: EndColMoving(False);
            msRowMove: EndRowMoving(False);
            msRowSelect: EndRowSelecting(False);
            msColSelect: EndColSelecting(False);
            msCellSelect: EndCellSelecting(False);
            msHeadingDown: MUHeadingUp(mbLeft, 0, 0);
        end;

    finally
        SetMouseStatus(msNormal);
    end;

    if OldStatus in [msRowResize, msColResize, msRowBarResize, msHeadingResize] then
        Update;

    GridStatusChanged;
end;

procedure TtsBaseGrid.MouseUp(Button: TMouseButton; Shift: TShiftState;
                              X, Y: Integer);
var
    OldStatus: TtsMouseStatus;
    SpinButton: TtsSpinButton;
    DisplayCol, DisplayRow: Longint;
    ButtonType: TtsButtonType;
    DropDownStyle: TtsDropDownStyle;
    MousePos: TPoint;
begin
    if (csDesigning in ComponentState) and (MouseStatus = msNormal) then
    begin
        inherited MouseUp(Button, Shift, X, Y);
        Exit;
    end;

    if Dragging then
    begin
        inherited MouseUp(Button, Shift, X, Y);
        Exit;
    end;

    StopTimer(FButtonTimer);
    if (Button = mbLeft) then
    begin
        CellFromXY(X, Y, DisplayCol, DisplayRow);
        SetMouseUpColRow(DisplayCol, DisplayRow);
        OldStatus := FMouseStatus;
        SpinButton := FDownSpinButton;

        try
            case FMouseStatus of
                msColResize, msRowBarResize: MUResizedCol(X, Y, True);
                msRowResize, msHeadingResize: MUResizedRow(X, Y, True);
                msColMove: EndColMoving(True);
                msRowMove: EndRowMoving(True);
                msRowSelect: EndRowSelecting(True);
                msColSelect: EndColSelecting(True);
                msCellSelect: EndCellSelecting(True);
                msButtonDown: MUButtonUp(X, Y);
                msHeadingDown: MUHeadingUp(Button, X, Y);
            end;

        finally
            SetMouseStatus(msNormal);
        end;

        if OldStatus in [msRowResize, msColResize, msRowBarResize, msHeadingResize] then
            Update;

        GridStatusChanged;
        if not FControlSet then ShowGridControl;

        if not FDoubleClicked then
        begin
            if OldStatus = msButtonDown then
            begin
                ButtonType := GiveCellButton(GetDataCol(DisplayCol), GetDataRow(DisplayRow), DropDownStyle);
                if MouseOverButton(X, Y, FDownDisplayCol, FDownDisplayRow) or
                   (ButtonType in [btCombo, btDateTimeDropDown, btDateTimePopup]) then
                begin
                    if (ButtonType in [btCombo, btDateTimeDropDown, btDateTimePopup, btNormal]) then
                    begin
                        ButtonClick(GetDataCol(FDownDisplayCol), GetDataRow(FDownDisplayRow));
                        if ButtonType = btDateTimePopup then
                        begin
                            ResetButton;
                            DateTimeButtonDown(GetDataCol(FDownDisplayCol), GetDataRow(FDownDisplayRow));
                        end;
                    end
                    else if SpinButton <> spbNone then
                        SpinButtonClick(GetDataCol(FDownDisplayCol), GetDataRow(FDownDisplayRow), SpinButton)
                end;

                if (ButtonType in [btCombo, btDateTimeDropDown, btDateTimePopup, btNormal]) then
                    ButtonUp(GetDataCol(FCurDisplayCol), GetDataRow(FCurDisplayRow))
                else if SpinButton <> spbNone then
                    SpinButtonUp(GetDataCol(FCurDisplayCol), GetDataRow(FCurDisplayRow), SpinButton)
            end
            else if not (OldStatus in [msRowResize, msColResize, msRowBarResize,
                                       msHeadingResize, msColMove, msRowMove]) then
            begin
                if FMouseDownOccured or Focused then
                begin
                    FMouseDownOccured := False;
                    Click;
                    ClickCell(GetDataCol(FDownDisplayCol), GetDataRow(FDownDisplayRow),
                              GetDataCol(FUpDisplayCol), GetDataRow(FUpDisplayRow));
                end;
            end;
        end;

        FDoubleClicked := False;
    end;

    FMouseDownOccured := False;
    
    try
        inherited MouseUp(Button,Shift,X,Y);
    except //capture exception from CustomGrid and continue
        on E: EInvalidGridOperation do
            if E.Message <> ResourceStr(SIndexOutOfRange) then raise;
    end;

    GetCursorPos(MousePos);
    MousePos := ScreenToClient(MousePos);
    CellFromXY(MousePos.X, MousePos.Y, DisplayCol, DisplayRow);
    MouseMoveDrawButton(MousePos.X, MousePos.Y, DisplayCol, DisplayRow);
end;

procedure TtsBaseGrid.DoEnter;
begin
    if InDoExit then Exit;
    if FInHidingGridControl then Exit;
    if Assigned(FGridControl) and FGridControl.Visible then FGridControl.Invalidate;

    if Assigned(OnEnter) then OnEnter(Self);
end;

procedure TtsBaseGrid.DoExit;
begin
    if FInHidingGridControl then Exit;

    Inc(FInDoExit);
    try
        try
            if not CanEndCellEdit(True) then
            begin
                SetFocus;
                Exit;
            end;
        except
            on Exception do begin SetFocus; raise; end;
        end;
    finally
        Dec(FInDoExit);
    end;

    if not InDesignMode then CheckDropDownOff(False);
    ResetComboSearchValue;
    if Assigned(FGridControl) and FGridControl.Visible then FGridControl.Invalidate;
    if Assigned(OnExit) then OnExit(Self);
end;

{End TtsBaseGrid}

{TtsCustomGrid}

procedure TtsCustomGrid.Paint;
begin
    FLastRowLoaded := -1;
    inherited;
end;

procedure TtsCustomGrid.GetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo);
begin
    DoGetDrawInfo(DataCol, DataRow, DrawInfo);
end;

procedure TtsCustomGrid.CellLoadedEvent(DataCol, DataRow: Longint; ControlType: TtsControlType; var Value: Variant);
begin
    if DataRow <> FLastRowLoaded then
    begin
        FLastRowLoaded := DataRow;
        DoRowLoaded(DataRow);
    end;

    FInDoCellLoaded := True;
    try
        DoCellLoaded(DataCol, DataRow, Value);
        if FAsCombo then
            TtsCustomGrid(ParentGrid).DoComboCellLoaded(DataCol, DataRow, Value);
    finally
        FInDoCellLoaded := False;
    end;

    if not VarIsEmpty(Value) then
    begin
        CheckVarType(ControlType, Value);
        if (ControlType = ctText) and (VarType(Value) <> varString) then
            Value := CheckStrValue(ControlType, Value);
    end;
end;

function TtsCustomGrid.PaintCell(var DrawData: TtsDrawData; ARect: TRect; DrawSelected: Boolean): Boolean;
var
    State: TtsPaintCellState;
    AColor: TColor;
begin
    Result := False;
    if (DrawData.DisplayCol >= 1) and (DrawData.DisplayRow >= 0) then
    begin
        with DrawData do
        begin
            GetPaintCellPars(DisplayCol, DisplayRow, State);
            if DrawRect.Right > DrawRect.Left then
            begin
                if DisplayRow = 0 then
                begin
                    AColor := GiveCellColor(DataCol, 0, False);
                    if Canvas.Brush.Color <> AColor then Canvas.Brush.Color := AColor;
                    Canvas.Font := HeadingFont;
                end
                else
                begin
                    if Canvas.Brush.Color <> Self.Color then Canvas.Brush.Color := Self.Color;
                    Canvas.Font := Self.Font;
                end;

                DoPaintCell(DataCol, DataRow, DrawRect, State, Result);
            end;

            if Result then
            begin
                UpdateDrawData(DrawData, False);
                if DisplayRow > 0 then
                begin
                    FillButtonPart(DrawData, DrawSelected);
                    DrawCellFocusRect(DisplayCol, DisplayRow);
                    DrawButtonInCell(DrawData, DrawSelected);
                end;

                if DisplayRow = 0 then
                    DrawHeadingButton(Canvas, DisplayCol, DrawData);
            end;
        end;
    end;
end;

function TtsCustomGrid.ActivateDoGetDrawInfo: Boolean;
begin
    Result := Assigned(OnGetDrawInfo);
end;

procedure TtsCustomGrid.TopLeftChangedEvent(OldCol, OldRow, NewCol, NewRow: Longint; ByUser: Boolean);
begin
    if ((OldCol <> NewCol) or (OldRow <> NewRow)) then
        DoTopLeftChanged(OldCol, OldRow, NewCol, NewRow, ByUser);
end;

procedure TtsCustomGrid.Print;
begin
  if GridReport = Nil then
     raise Exception.Create('TopGrid requires a GridReport component to be associated to this grid to support printing !');

  GridReport.Print(Self);
end;

procedure TtsCustomGrid.PrintPreview;
begin
  if GridReport = Nil then
     raise Exception.Create('TopGrid requires a GridReport component to be associated to this grid to support printing !');

  GridReport.PrintPreview(Self);
end;

procedure TtsCustomGrid.ExportGrid;
var expDialog : TSaveDialog;
    sExt : String;
begin
  expDialog := TSaveDialog.Create(Self);
  try
    expDialog.Filter := 'CSV File (*.csv)|*.csv|XML File (*.xml)|*.xml';
    expDialog.FilterIndex := 0;
    expDialog.DefaultExt := 'csv';
    expDialog.Title := 'Grid Export';
    if expDialog.Execute and
       (Length(expDialog.FileName) > 3) then
    begin
      sExt := Lowercase(Copy(expDialog.FileName, Length(expDialog.FileName) - 2, 3));
      if (sExt = 'xml') then
         ExportXML(expDialog.FileName)
      else 
         ExportCSV(expDialog.FileName);
    end;
  finally
    expDialog.Free;
  end;
end;

function TtsCustomGrid.GetCSVRowData(forRow : Longint) : String;
var i : Integer;
begin
  Result := '';
  for i := 1 to Cols do
    if (Col[DataColnr[i]].ControlType <> ctPicture) and
       (Col[DataColnr[i]].Visible) then
    begin
      Result := Result + AnsiQuotedStr(GetCellValue(DataColnr[i], forRow), '"');
      if FExportDelimiter = '#9' then
        Result := Result + #9
      else if FExportDelimiter = '#10' then
        Result := Result + #10
      else if FExportDelimiter = '#13' then
        Result := Result + #13
      else
        Result := Result + FExportDelimiter;
    end;
end;

procedure TtsCustomGrid.ExportCSV(toFile : String);
var exportFile : TStringList;
    iRow, i : Integer;
    sRowText : String;
begin
  EnableRedraw := False;
  exportFile := TStringList.Create;
  try
    sRowText := '';
    for i := 1 to Cols do
      if (Col[DataColnr[i]].Visible) and
         (Col[DataColnr[i]].ControlType <> ctPicture) then
      begin
        sRowText := sRowText + AnsiQuotedStr(Col[DataColnr[i]].Heading, '"');
        if FExportDelimiter = '#9' then
          sRowText := sRowText + #9
        else if FExportDelimiter = '#10' then
          sRowText := sRowText + #10
        else if FExportDelimiter = '#13' then
          sRowText := sRowText + #13
        else
          sRowText := sRowText + FExportDelimiter;
      end;
    exportFile.Add(sRowText);
    iRow := 1;
    while (iRow <= Rows) do
    begin
      exportFile.Add(GetCSVRowData(iRow));
      Inc(iRow);
    end;
    exportFile.SaveToFile(toFile);
  finally
    exportFile.Free;
    EnableRedraw := True;
  end;
end;

procedure TtsCustomGrid.ExportXML(toFile : String);
var exportFile : TStringList;
begin
  exportFile := TStringList.Create;
  try
    exportFile.Text := GetXMLData;
    exportFile.SaveToFile(toFile);
  finally
    exportFile.Free;
  end;
end;

function TtsCustomGrid.GetXMLMetaData : String;
var i : Integer;
begin
  Result := '<METADATA><FIELDS>';
  for i := 1 to Cols do
  begin
    if Col[i].ControlType = ctPicture then
       Continue
    else
    begin
      Result := Result + '<FIELD attrname=' + AnsiQuotedStr(Col[i].XMLHeading, '"') + ' fieldtype=';
      Result := Result + '"string"';
      Result := Result + ' />';
    end;
  end;
  Result := Result + '</FIELDS><PARAMS LCID="1033"/></METADATA>';
end;

function TtsCustomGrid.GetXMLRowData(forRow : Variant) : String;
var i : Integer;

  function XMLValue(iCol : Integer) : String;
  begin
    if CellControlType[iCol, forRow] = ctPicture then
       Result := ''
    else
       Result := CheckForWhiteSpace(GetCellValue(iCol, forRow));
  end;
begin
  Result := '<ROW ';
  for i := 1 to Cols do
    if Col[i].ControlType <> ctPicture then
       Result := Result + Col[i].XMLHeading + '=' + AnsiQuotedStr(XMLValue(i), '"') + ' ';
  Result := Result + '/>';
end;

function TtsCustomGrid.GetXMLData : String;
var iRow : Integer;

  function xmlEncoding : String;
  begin
    if FXMLExport.Encoding = '' then
       Result := ''
    else
       Result := 'encoding="' + FXMLExport.Encoding + '"';
  end;
  function xmlStandAlone : String;
  begin
    if FXMLExport.StandAlone then
       Result := 'yes'
    else
       Result := 'no';
  end;
  function xmlDataPacket : String;
  begin
    if FXMLExport.DataPacketVersion = '' then
       Result := ''
    else
       Result := '<DATAPACKET Version="' + FXMLExport.DataPacketVersion + '">';
  end;
begin
  Result := Format('<?xml version="%s" %s standalone="%s"?> %s', [FXMLExport.Version, xmlEncoding, xmlStandAlone, xmlDataPacket]);
  Result := Result + XMLMetaData;
  Result := Result + ' <ROWDATA> ';
  EnableRedraw := False;
  try
    iRow := 1;
    while (iRow <= Rows) do
    begin
      Result := Result + #10#13 + GetXMLRowData(iRow);
      inc(iRow);
    end;
  finally
    EnableRedraw := True;
  end;
  Result := Result + '</ROWDATA></DATAPACKET>';
end;


procedure TtsCustomGrid.RowDeleted(DataRow: Longint; ByUser: Boolean);
begin
    DoDeleteRow(DataRow, ByUser);
end;

procedure TtsCustomGrid.RowInserted(DataRow: Longint; ByUser: Boolean);
begin
    DoInsertRow(DataRow, ByUser);
end;

function TtsCustomGrid.CreateCombo: TtsCombo;
begin
    Result := TtsCombo.Create(Self);
end;

function TtsCustomGrid.CreateComboGrid;
begin
    Result := TtsComboGrid.Create(ComboForm);
end;

procedure TtsCustomGrid.DoRowLoaded(DataRow: Variant);
begin
    if Assigned(FOnRowLoaded) then FOnRowLoaded(Self, DataRow);
end;

procedure TtsCustomGrid.DoStartCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnStartCellEdit) then FOnStartCellEdit(Self, DataCol, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoStartRowEdit(DataRow: Variant; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnStartRowEdit) then FOnStartRowEdit(Self, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoEndCellEdit(DataCol: Longint; DataRow: Variant; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnEndCellEdit) then FOnEndCellEdit(Self, DataCol, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoEndRowEdit(DataRow: Variant; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnEndRowEdit) then FOnEndRowEdit(Self, FCurDataRow, Cancel);
end;

procedure TtsCustomGrid.DoShowEditor(DataCol: Longint; DataRow: Variant; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnShowEditor) then FOnShowEditor(Self, DataCol, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoInvalidMaskValue(DataCol: Longint; DataRow: Variant; var Accept: Boolean);
begin
    Accept := False;
    if Assigned(FOnInvalidMaskValue) then FOnInvalidMaskValue(Self, DataCol, DataRow, Accept);
end;

procedure TtsCustomGrid.DoInvalidMaskEdit(Keys: string; DataCol: Longint; DataRow: Variant; var Accept: Boolean);
begin
    Accept := False;
    if Assigned(FOnInvalidMaskEdit) then FOnInvalidMaskEdit(Self, Keys, DataCol, DataRow, Accept);
end;

procedure TtsCustomGrid.DoUndoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnUndoCellEdit) then FOnUndoCellEdit(Self, DataCol, DataRow, ByUser, Cancel);
end;

procedure TtsCustomGrid.DoUndoRowEdit(DataRow: Variant; ByUser: Boolean; var Cancel: Boolean);
begin
    Cancel := False;
    if Assigned(FOnUndoRowEdit) then FOnUndoRowEdit(Self, DataRow, ByUser, Cancel);
end;

procedure TtsCustomGrid.DoCellEdit(DataCol: Longint; DataRow: Variant; ByUser: Boolean);
begin
    if Assigned(FOnCellEdit) then FOnCellEdit(Self, DataCol, DataRow, ByUser);
end;

procedure TtsCustomGrid.DoCellChanged(OldDataCol, NewDataCol: Longint; OldDataRow, NewDataRow: Variant);
begin
    if Assigned(FOnCellChanged) and CanActivateEvent then FOnCellChanged(Self, OldDataCol, NewDataCol, OldDataRow, NewDataRow);
end;

procedure TtsCustomGrid.DoRowChanged(OldDataRow, NewDataRow: Variant);
begin
    if Assigned(FOnRowChanged) and CanActivateEvent then FOnRowChanged(Self, OldDataRow, NewDataRow);
end;

procedure TtsCustomGrid.DoPrintRow(DataRow: Longint; var Cancel : Boolean);
begin
    if Assigned(FOnPrintRow) and CanActivateEvent then FOnPrintRow(Self, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoPrintCell(DataCol, DataRow: Longint; var Cancel : Boolean);
begin
    if Assigned(FOnPrintCell) and CanActivateEvent then FOnPrintCell(Self, DataCol, DataRow, Cancel);
end;

procedure TtsCustomGrid.DoButtonClick(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnButtonClick) then FOnButtonClick(Self, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoButtonDown(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnButtonDown) then FOnButtonDown(Self, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoButtonUp(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnButtonUp) then FOnButtonUp(Self, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoSpinButtonClick(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton);
begin
    if Assigned(FOnSpinButtonClick) then FOnSpinButtonClick(Self, DataCol, DataRow, SpinButton);
end;

procedure TtsCustomGrid.DoSpinButtonDown(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton);
begin
    if Assigned(FOnSpinButtonDown) then FOnSpinButtonDown(Self, DataCol, DataRow, SpinButton);
end;

procedure TtsCustomGrid.DoSpinButtonUp(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton);
begin
    if Assigned(FOnSpinButtonUp) then FOnSpinButtonUp(Self, DataCol, DataRow, SpinButton);
end;

procedure TtsCustomGrid.DoSpinRepeat(DataCol: Longint; DataRow: Variant; Count: Integer; SpinButton: TtsSpinButton);
begin
    if Assigned(FOnSpinRepeat) then FOnSpinRepeat(Self, DataCol, DataRow, Count, SpinButton);
end;

procedure TtsCustomGrid.DoSpinIncrement(DataCol: Longint; DataRow: Variant; SpinButton: TtsSpinButton; var Value: Variant; var Pos, Len: Integer; var Accept: Boolean);
begin
    if Assigned(FOnSpinIncrement) then FOnSpinIncrement(Self, DataCol, DataRow, SpinButton, Value, Pos, Len, Accept);
end;

function TtsCustomGrid.DoClickCell(DataColDown: Longint; DataRowDown: Variant;
                                   DataColUp: Longint; DataRowUp: Variant;
                                   DownPos, UpPos: TtsClickPosition): Boolean;
begin
    Result := Assigned(FOnClickCell);
    if Assigned(FOnClickCell) then
        FOnClickCell(Self, DataColDown, DataRowDown, DataColUp, DataRowUp, DownPos, UpPos)
end;

procedure TtsCustomGrid.DoDblClickCell(DataCol: Longint; DataRow: Variant; Pos: TtsClickPosition);
begin
    if Assigned(FOnDblClickCell) then FOnDblClickCell(Self, DataCol, DataRow, Pos);
end;

procedure TtsCustomGrid.DoComboInit(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnComboInit) then FOnComboInit(Self, Combo.Grid, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoComboDropDown(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnComboDropDown) then FOnComboDropDown(Self, Combo.Grid, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoComboRollUp(DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnComboRollUp) then FOnComboRollUp(Self, Combo.Grid, FDropDownCol, FDropDownRow);
end;

procedure TtsCustomGrid.DoComboGetValue(GridDataCol: Longint; GridDataRow,
                                        ComboDataRow: Variant; var Value: Variant);
begin
    if Assigned(FOnComboGetValue) then
        FOnComboGetValue(Self, Combo.Grid, GridDataCol, GridDataRow, ComboDataRow, Value);
end;

procedure TtsCustomGrid.DoDateTimeInit(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnDateTimeInit) then
        FOnDateTimeInit(Self, DateTimeDef, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoDateTimeDropDown(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnDateTimeDropDown) then
        FOnDateTimeDropDown(Self, DateTimeDef, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoDateTimeRollUp(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant);
begin
    if Assigned(FOnDateTimeRollUp) then
        FOnDateTimeRollUp(Self, DateTimeDef, DataCol, DataRow);
end;

procedure TtsCustomGrid.DoDateTimeGetValue(DateTimeDef: TtsDateTimeDefComponent; DataCol: Longint; DataRow: Variant; var Value: Variant);
begin
    if Assigned(FOnDateTimeGetValue) then
        FOnDateTimeGetValue(Self, DateTimeDef, DataCol, DataRow, Value);
end;

procedure TtsCustomGrid.DoGetDrawInfo(DataCol, DataRow: Longint; var DrawInfo: TtsDrawInfo);
begin
    if Assigned(FOnGetDrawInfo) then FOnGetDrawInfo(Self, DataCol, DataRow, DrawInfo);
end;

procedure TtsCustomGrid.DoComboCellLoaded(DataCol, DataRow: Longint; var Value: Variant);
begin
    if Assigned(FOnComboCellLoaded) then
        FOnComboCellLoaded(Self, Combo.Grid, DataCol, DataRow, Value);
end;

procedure TtsCustomGrid.DoTopLeftChanged(OldCol, OldRow, NewCol, NewRow: Longint; ByUser: Boolean);
begin
    if Assigned(FOnTopLeftChanged) and CanActivateEvent then
        FOnTopLeftChanged(Self, OldCol, OldRow, NewCol, NewRow, ByUser);
end;

procedure TtsCustomGrid.DoPaintCell(DataCol, DataRow: Longint; DrawRect:TRect;
                                    State: TtsPaintCellState; var Cancel: Boolean);
begin
    if Assigned(FOnPaintCell) then
        FOnPaintCell(Self, DataCol, DataRow, DrawRect, State, Cancel);
end;

procedure TtsCustomGrid.DoCellLoaded(DataCol, DataRow: Longint; var Value: Variant);
begin
    if Assigned(FOnCellLoaded) then FOnCellLoaded(Self, DataCol, DataRow, Value);
end;

procedure TtsCustomGrid.DoDeleteRow(DataRow: Longint; ByUser: Boolean);
begin
    if Assigned(FOnDeleteRow) and CanActivateEvent then FOnDeleteRow(Self, DataRow, ByUser);
end;

procedure TtsCustomGrid.DoInsertRow(DataRow: Longint; ByUser: Boolean);
begin
    if Assigned(FOnInsertRow) and CanActivateEvent then FOnInsertRow(Self, DataRow, ByUser);
end;

{End TtsCustomGrid}

 { TosCustomGridReport }

constructor TosCustomGridReport.Create(Owner : TComponent);
begin
  inherited Create(Owner);
  FDateTimeLabel := 'DateTime:';
  FPageLabel := 'Page:';
  FEndOfReportLabel := '*** END OF REPORT ***';
  FRecordCountLabel := 'Records';
  FMenuOptionsText := 'Preview...|Print...|Export...';
  FShowDateTime := True;
  FShowPageCount := True;
  FShowEndOfReport := True;
  FShowRecordCount := True;
  FProvideGridMenu := False;
  FTitleFont := TFont.Create;
  FTitleImage := TPicture.Create;
  FPaperSize := psLetter;
  FColumnSpacing := 2;
  FShowTitleSection := True;
  FMargins := TosReportPageMargins.Create;
  FMargins.LeftMargin := 7;
  FMargins.RightMargin := 7;
  FMargins.TopMargin := 7;
  FMargins.BottomMargin := 15;
  FPrintLineMode := lmNone;
  FPrintBandColor := clNone;
end;

destructor TosCustomGridReport.Destroy;
begin
  FTitleImage.Free;
  FTitleFont.Free;
  FMargins.Free;
  inherited Destroy;
end;

procedure TosCustomGridReport.Print(forGrid : TtsBaseGrid);
begin
end;

procedure TosCustomGridReport.PrintPreview(forGrid : TtsBaseGrid); 
begin
end;

procedure TosCustomGridReport.SetMargins(Value : TosReportPageMargins);
begin
  FMargins.Assign(Value);
end;

procedure TosCustomGridReport.SetTitleFont(Value : TFont);
begin
  FTitleFont.Assign(Value);
end;

procedure TosCustomGridReport.SetTitleImage(Value : TPicture);
begin
  FTitleImage.Assign(Value);
end;

procedure TosCustomGridReport.SetProvideGridMenu(Value : Boolean);
begin
  FProvideGridMenu := Value;
end;

procedure TosCustomGridReport.SetMenuOptionsText(Value : String);
var i : Integer;
    s : String;
begin
  FMenuOptionsText := Value;
  if Value = '' then
  begin
    FPreviewMenuText := '';
    FPrintMenuText   := '';
    FExportMenuText  := '';
  end
  else
  begin
    i := Pos('|', Value);
    if i > 0 then
    begin
      FPreviewMenuText := Copy(Value, 1, i-1);
      s := Copy(Value, i+1, Length(Value));
      i := Pos('|', s);
      if i > 0 then
      begin
        FPrintMenuText := Copy(s, 1, i-1);
        FExportMenuText := Copy(s, i+1, Length(s));
      end
      else FPrintMenuText := s;
    end
    else FPreviewMenuText := Value;
  end;
end;

procedure InitPictureMonoMask(var BmpMask: TBitmap);
var
    I, J: Integer;
begin
    BmpMask := TBitmap.Create;
    BmpMask.Width := 8;
    BmpMask.Height := BmpMask.Width;

    for I := 0 to BmpMask.Width - 1 do
        for J := 0 to BmpMask.Height - 1 do
        begin
            if (I + J) mod 2 = 0
                then BmpMask.Canvas.Pixels[I,J] := clBlack
                else BmpMask.Canvas.Pixels[I,J] := clWhite;
    end;
end;

constructor TosXMLExport.Create;
begin
  inherited Create;
  FVersion := '1.0';
  FDataPacketVersion := '2.0';
  FStandAlone := True;
end;

procedure TosXMLExport.Assign(Source : TPersistent);
begin
  Self.FEncoding   := TosXMLExport(Source).Encoding;
  Self.FVersion    := TosXMLExport(Source).Version;
  Self.FDataPacketVersion := TosXMLExport(Source).DataPacketVersion;
  Self.FStandAlone := TosXMLExport(Source).StandAlone;
end;

initialization
begin
    CursorArrowRev := LoadCursor(HInstance,'TSARROWREV');
    CursorHorArrowRight := LoadCursor(HInstance,'TSHORARROWRIGHT');
    CursorVertArrowDown := LoadCursor(HInstance,'TSVERTARROWDOWN');

    BitMapArrowRight := TBitMap.Create;
    BitMapInsertRow := TBitMap.Create;
    BitMapChangedRow := TBitMap.Create;
    BitMapCombo := TBitmap.Create;
    BitMapButtonDetail := TBitmap.Create;
    BitMapSortUp := TBitmap.Create;
    BitMapSortDown := TBitmap.Create;
    BitMapSortBullet := TBitmap.Create;
    BitmapSpinUp := TBitmap.Create;
    BitmapSpinDown := TBitmap.Create;
    BitmapSpinLeft := TBitmap.Create;
    BitmapSpinRight := TBitmap.Create;

    BitMapArrowRight.LoadFromResourceName(HInstance,'TSDOTARROWRIGHT');
    BitMapInsertRow.LoadFromResourceName(HInstance,'TSINSERTROW');
    BitMapChangedRow.LoadFromResourceName(HInstance,'TSCHANGEDROW');
    BitMapCombo.LoadFromResourceName(HInstance,'TSARROWCOMBO');
    BitMapButtonDetail.LoadFromResourceName(HInstance,'TSBUTDETAIL');
    BitMapSortUp.LoadFromResourceName(HInstance,'TSSORTUP');
    BitMapSortDown.LoadFromResourceName(HInstance,'TSSORTDOWN');
    BitMapSortBullet.LoadFromResourceName(HInstance,'TSSORTBULLET');
    BitmapSpinUp.LoadFromResourceName(HInstance,'TSSPINUP');
    BitmapSpinDown.LoadFromResourceName(HInstance,'TSSPINDOWN');
    BitmapSpinLeft.LoadFromResourceName(HInstance,'TSSPINLEFT');
    BitmapSpinRight.LoadFromResourceName(HInstance,'TSSPINRIGHT');

    FGridMemoryCanvas := TtsMemoryCanvas.Create;
    FControlMemoryCanvas := TtsMemoryCanvas.Create;
    InitPictureMonoMask(FPictureMonoMask);

    HookedGrids := TList.Create;
end;

finalization
begin
    HookedGrids.Free;
    FCheckBoxBitmaps.Free;
    BitMapArrowRight.Free;
    BitMapInsertRow.Free;
    BitMapChangedRow.Free;
    BitMapCombo.Free;
    BitMapButtonDetail.Free;
    BitMapSortUp.Free;
    BitMapSortDown.Free;
    BitMapSortBullet.Free;
    BitmapSpinUp.Free;
    BitmapSpinDown.Free;
    BitmapSpinLeft.Free;
    BitmapSpinRight.Free;

    FGridMemoryCanvas.Free;
    FControlMemoryCanvas.Free;
    FPictureMonoMask.Free;
end;

end.
